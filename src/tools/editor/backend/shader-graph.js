const defaultShaderGraph = {
  nodes: [{
    id: "N0",
    type: "FragmentOutput",
    x: 347,
    y: 321,
    inputs: {
      color: {
        default: "vec4f(1.0)"
      }
    }
  }],
  connections: []
};

export let DEFAULT_SHADER_GRAPH_JS = `export let shaderGraphsProdc = [
  {
    "name": "fragShaderGraph",
    "content": ${JSON.stringify(JSON.stringify(defaultShaderGraph))}
  },
  {
    "name": "ScrollTex",
    "content": ${JSON.stringify("{\"nodes\":[{\"id\":\"N3\",\"type\":\"Time\",\"x\":-573,\"y\":481,\"inputs\":{}},{\"id\":\"N4\",\"type\":\"Float\",\"x\":-576,\"y\":308,\"value\":0.01,\"inputs\":{}},{\"id\":\"N5\",\"type\":\"Multiply\",\"x\":-320,\"y\":419,\"inputs\":{\"a\":{\"default\":\"1.0\"},\"b\":{\"default\":\"1.0\"}}},{\"id\":\"N7\",\"type\":\"MultiplyVec2\",\"x\":-153,\"y\":519,\"inputs\":{\"a\":{\"default\":\"vec2f(1.0)\"},\"b\":{\"default\":\"1.0\"}}},{\"id\":\"N12\",\"type\":\"TextureSampler\",\"x\":351,\"y\":604,\"name\":\"tex0\",\"inputs\":{\"uv\":{\"default\":\"input.uv\"}}},{\"id\":\"N17\",\"type\":\"Vec2\",\"x\":-492,\"y\":627,\"inputs\":{},\"valueX\":0,\"valueY\":1},{\"id\":\"N18\",\"type\":\"AddVec2\",\"x\":75,\"y\":516,\"inputs\":{\"a\":{\"default\":\"vec2f(0.0)\"},\"b\":{\"default\":\"vec2f(0.0)\"}}},{\"id\":\"N11\",\"type\":\"UV\",\"x\":-159,\"y\":711,\"inputs\":{}},{\"id\":\"N30\",\"type\":\"LightShadowNode\",\"x\":194,\"y\":269,\"inputs\":{\"intensity\":{\"default\":\"1\"}}},{\"id\":\"N32\",\"type\":\"LightToColor\",\"x\":384,\"y\":268,\"inputs\":{\"light\":{\"default\":\"vec3f(1.0)\"}}},{\"id\":\"N34\",\"type\":\"FragmentOutput\",\"x\":722,\"y\":539,\"inputs\":{\"color\":{\"default\":\"vec4f(1.0)\"}}},{\"id\":\"N35\",\"type\":\"MultiplyColor\",\"x\":524,\"y\":427,\"inputs\":{\"a\":{\"default\":\"vec4(1.0)\"},\"b\":{\"default\":\"vec4(1.0)\"}}}],\"connections\":[{\"from\":\"N4\",\"fromPin\":\"out\",\"to\":\"N5\",\"toPin\":\"a\"},{\"from\":\"N3\",\"fromPin\":\"out\",\"to\":\"N5\",\"toPin\":\"b\"},{\"from\":\"N5\",\"fromPin\":\"out\",\"to\":\"N7\",\"toPin\":\"a\"},{\"from\":\"N17\",\"fromPin\":\"out\",\"to\":\"N7\",\"toPin\":\"b\"},{\"from\":\"N7\",\"fromPin\":\"out\",\"to\":\"N18\",\"toPin\":\"a\"},{\"from\":\"N18\",\"fromPin\":\"out\",\"to\":\"N12\",\"toPin\":\"uv\"},{\"from\":\"N11\",\"fromPin\":\"out\",\"to\":\"N18\",\"toPin\":\"b\"},{\"from\":\"N30\",\"fromPin\":\"out\",\"to\":\"N32\",\"toPin\":\"light\"},{\"from\":\"N32\",\"fromPin\":\"out\",\"to\":\"N35\",\"toPin\":\"a\"},{\"from\":\"N12\",\"fromPin\":\"out\",\"to\":\"N35\",\"toPin\":\"b\"},{\"from\":\"N35\",\"fromPin\":\"out\",\"to\":\"N34\",\"toPin\":\"color\"}],\"final\":\"\\n/* === Engine uniforms === */\\n\\n// DINAMIC GLOBALS\\nconst PI: f32 = 3.141592653589793;\\noverride shadowDepthTextureSize: f32 = 1024.0;\\n\\n// DINAMIC STRUCTS\\n\\n\\n// PREDEFINED\\nstruct Scene {\\n    lightViewProjMatrix  : mat4x4f,\\n    cameraViewProjMatrix : mat4x4f,\\n    cameraPos            : vec3f,\\n    padding2             : f32,\\n    lightPos             : vec3f,\\n    padding              : f32,\\n    globalAmbient        : vec3f,\\n    padding3             : f32,\\n    time                 : f32,\\n    deltaTime            : f32,\\n    padding4             : vec2f,\\n};\\n\\n// PREDEFINED\\nstruct SpotLight {\\n    position      : vec3f,\\n    _pad1         : f32,\\n    direction     : vec3f,\\n    _pad2         : f32,\\n    innerCutoff   : f32,\\n    outerCutoff   : f32,\\n    intensity     : f32,\\n    _pad3         : f32,\\n    color         : vec3f,\\n    _pad4         : f32,\\n    range         : f32,\\n    ambientFactor : f32,\\n    shadowBias    : f32,\\n    _pad5         : f32,\\n    lightViewProj : mat4x4<f32>,\\n};\\n\\n// PREDEFINED\\nstruct MaterialPBR {\\n    baseColorFactor : vec4f,\\n    metallicFactor  : f32,\\n    roughnessFactor : f32,\\n    _pad1           : f32,\\n    _pad2           : f32,\\n};\\n\\n// PREDEFINED\\nstruct PBRMaterialData {\\n    baseColor : vec3f,\\n    metallic  : f32,\\n    roughness : f32,\\n    alpha     : f32\\n};\\n\\n// PREDEFINED\\nconst MAX_SPOTLIGHTS = 20u;\\n\\n// PREDEFINED\\n@group(0) @binding(0) var<uniform> scene : Scene;\\n@group(0) @binding(1) var shadowMapArray: texture_depth_2d_array;\\n@group(0) @binding(2) var shadowSampler: sampler_comparison;\\n@group(0) @binding(3) var meshTexture: texture_2d<f32>;\\n@group(0) @binding(4) var meshSampler: sampler;\\n@group(0) @binding(5) var<uniform> spotlights: array<SpotLight, MAX_SPOTLIGHTS>;\\n@group(0) @binding(6) var metallicRoughnessTex: texture_2d<f32>;\\n@group(0) @binding(7) var metallicRoughnessSampler: sampler;\\n@group(0) @binding(8) var<uniform> material: MaterialPBR;\\n\\n// ✅ Graph custom uniforms\\n\\n\\n// ✅ Graph custom functions\\n\\nfn computeSpotLight(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, material: PBRMaterialData) -> vec3f {\\n    let L = normalize(light.position - fragPos);\\n    let NdotL = max(dot(N, L), 0.0);\\n\\n    let theta = dot(L, normalize(-light.direction));\\n    let epsilon = light.innerCutoff - light.outerCutoff;\\n    var coneAtten = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);\\n\\n    // coneAtten = 1.0;\\n    if (coneAtten <= 0.0 || NdotL <= 0.0) {\\n        return vec3f(0.0);\\n    }\\n\\n    let F0 = mix(vec3f(0.04), material.baseColor.rgb, vec3f(material.metallic));\\n    let H = normalize(L + V);\\n    let F = F0 + (1.0 - F0) * pow(1.0 - max(dot(H, V), 0.0), 5.0);\\n\\n    let alpha = material.roughness * material.roughness;\\n    let NdotH = max(dot(N, H), 0.0);\\n    let alpha2 = alpha * alpha;\\n    let denom = (NdotH * NdotH * (alpha2 - 1.0) + 1.0);\\n    let D = alpha2 / (PI * denom * denom + 1e-5);\\n\\n    let k = (alpha + 1.0) * (alpha + 1.0) / 8.0;\\n    let NdotV = max(dot(N, V), 0.0);\\n    let Gv = NdotV / (NdotV * (1.0 - k) + k);\\n    let Gl = NdotL / (NdotL * (1.0 - k) + k);\\n    let G = Gv * Gl;\\n\\n    let numerator = D * G * F;\\n    let denominator = 4.0 * NdotV * NdotL + 1e-5;\\n    let specular = numerator / denominator;\\n\\n    let kS = F;\\n    let kD = (vec3f(1.0) - kS) * (1.0 - material.metallic);\\n    let diffuse = kD * material.baseColor.rgb / PI;\\n\\n    let radiance = light.color * light.intensity;\\n    // return (diffuse + specular) * radiance * NdotL * coneAtten;\\n    return material.baseColor * light.color * light.intensity * NdotL * coneAtten;\\n}\\n\\nfn sampleShadow(shadowUV: vec2f, layer: i32, depthRef: f32, normal: vec3f, lightDir: vec3f) -> f32 {\\n    var visibility: f32 = 0.0;\\n    let biasConstant: f32 = 0.001;\\n    let slopeBias = max(0.002 * (1.0 - dot(normal, lightDir)), 0.0);\\n    let bias = biasConstant + slopeBias;\\n    let oneOverSize = 1.0 / (shadowDepthTextureSize * 0.5);\\n    let offsets: array<vec2f, 9> = array<vec2f, 9>(\\n        vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),\\n        vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),\\n        vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0)\\n    );\\n    for(var i: u32 = 0u; i < 9u; i = i + 1u) {\\n        visibility += textureSampleCompare(\\n            shadowMapArray, shadowSampler,\\n            shadowUV + offsets[i] * oneOverSize,\\n            layer, depthRef - bias\\n        );\\n    }\\n    return visibility / 9.0;\\n}\\n\\n\\n// PREDEFINED Fragment input\\nstruct FragmentInput {\\n    @location(0) shadowPos : vec4f,\\n    @location(1) fragPos   : vec3f,\\n    @location(2) fragNorm  : vec3f,\\n    @location(3) uv        : vec2f,\\n};\\n\\n// PREDEFINED PBR helpers\\nfn getPBRMaterial(uv: vec2f) -> PBRMaterialData {\\n    let texColor = textureSample(meshTexture, meshSampler, uv);\\n    let baseColor = texColor.rgb * material.baseColorFactor.rgb;\\n    let mrTex = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);\\n    let metallic = mrTex.b * material.metallicFactor;\\n    let roughness = mrTex.g * material.roughnessFactor;\\n    \\n    // ✅ Get alpha from texture and material factor\\n    // let alpha = texColor.a * material.baseColorFactor.a;\\n    let alpha = material.baseColorFactor.a;\\n    \\n    return PBRMaterialData(baseColor, metallic, roughness, alpha);\\n}\\n\\n@fragment\\nfn main(input: FragmentInput) -> @location(0) vec4f {\\n  // Locals\\n  \\n    let norm = normalize(input.fragNorm);\\n    let viewDir = normalize(scene.cameraPos - input.fragPos);\\n    let materialData = getPBRMaterial(input.uv);\\n    var lightContribution = vec3f(0.0);\\n    for (var i: u32 = 0u; i < MAX_SPOTLIGHTS; i = i + 1u) {\\n        let sc = spotlights[i].lightViewProj * vec4<f32>(input.fragPos, 1.0);\\n        let p  = sc.xyz / sc.w;\\n        let uv = clamp(p.xy * 0.5 + vec2<f32>(0.5), vec2<f32>(0.0), vec2<f32>(1.0));\\n        let depthRef = p.z * 0.5 + 0.5;\\n        let lightDir = normalize(spotlights[i].position - input.fragPos);\\n        let bias = spotlights[i].shadowBias;\\n        let visibility = sampleShadow(uv, i32(i), depthRef - bias, norm, lightDir);\\n        let contrib = computeSpotLight(spotlights[i], norm, input.fragPos, viewDir, materialData);\\n        lightContribution += contrib * visibility;\\n    }\\n  let t0: vec4f = vec4f(lightContribution, 1.0);\\n  let t1: f32 = 0.01 * scene.time;\\n  let t2: vec2f = t1 * vec2f(0, 1);\\n  let t3: vec2f = t2 + input.uv;\\n  let t4: vec4f = textureSample(meshTexture, meshSampler, t3);\\n  let t5: vec4f = t0 * t4;\\n  \\n  return t5;\\n}\\n\"}")}
  },
   {
    "name": "Pulsing",
    "content": ${JSON.stringify("{\"nodes\":[{\"id\":\"N1\",\"type\":\"Time\",\"x\":-400,\"y\":100,\"inputs\":{}},{\"id\":\"N2\",\"type\":\"Sin\",\"x\":-200,\"y\":100,\"inputs\":{\"value\":{\"default\":\"0.0\"}}},{\"id\":\"N3\",\"type\":\"Float\",\"x\":-200,\"y\":200,\"value\":0.3,\"inputs\":{}},{\"id\":\"N4\",\"type\":\"Multiply\",\"x\":0,\"y\":150,\"inputs\":{\"a\":{\"default\":\"1.0\"},\"b\":{\"default\":\"1.0\"}}},{\"id\":\"N5\",\"type\":\"Float\",\"x\":0,\"y\":250,\"value\":0.8,\"inputs\":{}},{\"id\":\"N6\",\"type\":\"Add\",\"x\":200,\"y\":200,\"inputs\":{\"a\":{\"default\":\"0.0\"},\"b\":{\"default\":\"0.0\"}}},{\"id\":\"N7\",\"type\":\"CombineVec4\",\"x\":400,\"y\":200,\"inputs\":{\"x\":{\"default\":\"0.0\"},\"y\":{\"default\":\"0.0\"},\"z\":{\"default\":\"0.0\"},\"w\":{\"default\":\"1.0\"}}},{\"id\":\"N8\",\"type\":\"UV\",\"x\":0,\"y\":450,\"inputs\":{}},{\"id\":\"N9\",\"type\":\"TextureSampler\",\"x\":200,\"y\":450,\"name\":\"tex0\",\"inputs\":{\"uv\":{\"default\":\"input.uv\"}}},{\"id\":\"N10\",\"type\":\"LightShadowNode\",\"x\":200,\"y\":-100,\"inputs\":{\"intensity\":{\"default\":\"1\"}}},{\"id\":\"N11\",\"type\":\"LightToColor\",\"x\":400,\"y\":-100,\"inputs\":{\"light\":{\"default\":\"vec3f(1.0)\"}}},{\"id\":\"N12\",\"type\":\"MultiplyColor\",\"x\":600,\"y\":50,\"inputs\":{\"a\":{\"default\":\"vec4(1.0)\"},\"b\":{\"default\":\"vec4(1.0)\"}}},{\"id\":\"N13\",\"type\":\"MultiplyColor\",\"x\":800,\"y\":250,\"inputs\":{\"a\":{\"default\":\"vec4(1.0)\"},\"b\":{\"default\":\"vec4(1.0)\"}}},{\"id\":\"N14\",\"type\":\"FragmentOutput\",\"x\":1000,\"y\":250,\"inputs\":{\"color\":{\"default\":\"vec4f(1.0)\"}}}],\"connections\":[{\"from\":\"N1\",\"fromPin\":\"out\",\"to\":\"N2\",\"toPin\":\"value\"},{\"from\":\"N2\",\"fromPin\":\"out\",\"to\":\"N4\",\"toPin\":\"a\"},{\"from\":\"N3\",\"fromPin\":\"out\",\"to\":\"N4\",\"toPin\":\"b\"},{\"from\":\"N5\",\"fromPin\":\"out\",\"to\":\"N6\",\"toPin\":\"a\"},{\"from\":\"N4\",\"fromPin\":\"out\",\"to\":\"N6\",\"toPin\":\"b\"},{\"from\":\"N6\",\"fromPin\":\"out\",\"to\":\"N7\",\"toPin\":\"x\"},{\"from\":\"N6\",\"fromPin\":\"out\",\"to\":\"N7\",\"toPin\":\"y\"},{\"from\":\"N6\",\"fromPin\":\"out\",\"to\":\"N7\",\"toPin\":\"z\"},{\"from\":\"N8\",\"fromPin\":\"out\",\"to\":\"N9\",\"toPin\":\"uv\"},{\"from\":\"N10\",\"fromPin\":\"out\",\"to\":\"N11\",\"toPin\":\"light\"},{\"from\":\"N11\",\"fromPin\":\"out\",\"to\":\"N12\",\"toPin\":\"a\"},{\"from\":\"N7\",\"fromPin\":\"out\",\"to\":\"N12\",\"toPin\":\"b\"},{\"from\":\"N12\",\"fromPin\":\"out\",\"to\":\"N13\",\"toPin\":\"a\"},{\"from\":\"N9\",\"fromPin\":\"out\",\"to\":\"N13\",\"toPin\":\"b\"},{\"from\":\"N13\",\"fromPin\":\"out\",\"to\":\"N14\",\"toPin\":\"color\"}],\"final\":\"\\n/* === Engine uniforms === */\\n\\n// DINAMIC GLOBALS\\nconst PI: f32 = 3.141592653589793;\\noverride shadowDepthTextureSize: f32 = 1024.0;\\n\\n// DINAMIC STRUCTS\\n\\n\\n// PREDEFINED\\nstruct Scene {\\n    lightViewProjMatrix  : mat4x4f,\\n    cameraViewProjMatrix : mat4x4f,\\n    cameraPos            : vec3f,\\n    padding2             : f32,\\n    lightPos             : vec3f,\\n    padding              : f32,\\n    globalAmbient        : vec3f,\\n    padding3             : f32,\\n    time                 : f32,\\n    deltaTime            : f32,\\n    padding4             : vec2f,\\n};\\n\\n// PREDEFINED\\nstruct SpotLight {\\n    position      : vec3f,\\n    _pad1         : f32,\\n    direction     : vec3f,\\n    _pad2         : f32,\\n    innerCutoff   : f32,\\n    outerCutoff   : f32,\\n    intensity     : f32,\\n    _pad3         : f32,\\n    color         : vec3f,\\n    _pad4         : f32,\\n    range         : f32,\\n    ambientFactor : f32,\\n    shadowBias    : f32,\\n    _pad5         : f32,\\n    lightViewProj : mat4x4<f32>,\\n};\\n\\n// PREDEFINED\\nstruct MaterialPBR {\\n    baseColorFactor : vec4f,\\n    metallicFactor  : f32,\\n    roughnessFactor : f32,\\n    _pad1           : f32,\\n    _pad2           : f32,\\n};\\n\\n// PREDEFINED\\nstruct PBRMaterialData {\\n    baseColor : vec3f,\\n    metallic  : f32,\\n    roughness : f32,\\n    alpha     : f32\\n};\\n\\n// PREDEFINED\\nconst MAX_SPOTLIGHTS = 20u;\\n\\n// PREDEFINED\\n@group(0) @binding(0) var<uniform> scene : Scene;\\n@group(0) @binding(1) var shadowMapArray: texture_depth_2d_array;\\n@group(0) @binding(2) var shadowSampler: sampler_comparison;\\n@group(0) @binding(3) var meshTexture: texture_2d<f32>;\\n@group(0) @binding(4) var meshSampler: sampler;\\n@group(0) @binding(5) var<uniform> spotlights: array<SpotLight, MAX_SPOTLIGHTS>;\\n@group(0) @binding(6) var metallicRoughnessTex: texture_2d<f32>;\\n@group(0) @binding(7) var metallicRoughnessSampler: sampler;\\n@group(0) @binding(8) var<uniform> material: MaterialPBR;\\n\\n// ✅ Graph custom uniforms\\n\\n\\n// ✅ Graph custom functions\\n\\nfn computeSpotLight(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, material: PBRMaterialData) -> vec3f {\\n    let L = normalize(light.position - fragPos);\\n    let NdotL = max(dot(N, L), 0.0);\\n\\n    let theta = dot(L, normalize(-light.direction));\\n    let epsilon = light.innerCutoff - light.outerCutoff;\\n    var coneAtten = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);\\n\\n    // coneAtten = 1.0;\\n    if (coneAtten <= 0.0 || NdotL <= 0.0) {\\n        return vec3f(0.0);\\n    }\\n\\n    let F0 = mix(vec3f(0.04), material.baseColor.rgb, vec3f(material.metallic));\\n    let H = normalize(L + V);\\n    let F = F0 + (1.0 - F0) * pow(1.0 - max(dot(H, V), 0.0), 5.0);\\n\\n    let alpha = material.roughness * material.roughness;\\n    let NdotH = max(dot(N, H), 0.0);\\n    let alpha2 = alpha * alpha;\\n    let denom = (NdotH * NdotH * (alpha2 - 1.0) + 1.0);\\n    let D = alpha2 / (PI * denom * denom + 1e-5);\\n\\n    let k = (alpha + 1.0) * (alpha + 1.0) / 8.0;\\n    let NdotV = max(dot(N, V), 0.0);\\n    let Gv = NdotV / (NdotV * (1.0 - k) + k);\\n    let Gl = NdotL / (NdotL * (1.0 - k) + k);\\n    let G = Gv * Gl;\\n\\n    let numerator = D * G * F;\\n    let denominator = 4.0 * NdotV * NdotL + 1e-5;\\n    let specular = numerator / denominator;\\n\\n    let kS = F;\\n    let kD = (vec3f(1.0) - kS) * (1.0 - material.metallic);\\n    let diffuse = kD * material.baseColor.rgb / PI;\\n\\n    let radiance = light.color * light.intensity;\\n    // return (diffuse + specular) * radiance * NdotL * coneAtten;\\n    return material.baseColor * light.color * light.intensity * NdotL * coneAtten;\\n}\\n\\nfn sampleShadow(shadowUV: vec2f, layer: i32, depthRef: f32, normal: vec3f, lightDir: vec3f) -> f32 {\\n    var visibility: f32 = 0.0;\\n    let biasConstant: f32 = 0.001;\\n    let slopeBias = max(0.002 * (1.0 - dot(normal, lightDir)), 0.0);\\n    let bias = biasConstant + slopeBias;\\n    let oneOverSize = 1.0 / (shadowDepthTextureSize * 0.5);\\n    let offsets: array<vec2f, 9> = array<vec2f, 9>(\\n        vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),\\n        vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),\\n        vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0)\\n    );\\n    for(var i: u32 = 0u; i < 9u; i = i + 1u) {\\n        visibility += textureSampleCompare(\\n            shadowMapArray, shadowSampler,\\n            shadowUV + offsets[i] * oneOverSize,\\n            layer, depthRef - bias\\n        );\\n    }\\n    return visibility / 9.0;\\n}\\n\\n\\n// PREDEFINED Fragment input\\nstruct FragmentInput {\\n    @location(0) shadowPos : vec4f,\\n    @location(1) fragPos   : vec3f,\\n    @location(2) fragNorm  : vec3f,\\n    @location(3) uv        : vec2f,\\n};\\n\\n// PREDEFINED PBR helpers\\nfn getPBRMaterial(uv: vec2f) -> PBRMaterialData {\\n    let texColor = textureSample(meshTexture, meshSampler, uv);\\n    let baseColor = texColor.rgb * material.baseColorFactor.rgb;\\n    let mrTex = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);\\n    let metallic = mrTex.b * material.metallicFactor;\\n    let roughness = mrTex.g * material.roughnessFactor;\\n    \\n    // ✅ Get alpha from texture and material factor\\n    // let alpha = texColor.a * material.baseColorFactor.a;\\n    let alpha = material.baseColorFactor.a;\\n    \\n    return PBRMaterialData(baseColor, metallic, roughness, alpha);\\n}\\n\\n@fragment\\nfn main(input: FragmentInput) -> @location(0) vec4f {\\n  // Locals\\n  \\n    let norm = normalize(input.fragNorm);\\n    let viewDir = normalize(scene.cameraPos - input.fragPos);\\n    let materialData = getPBRMaterial(input.uv);\\n    var lightContribution = vec3f(0.0);\\n    for (var i: u32 = 0u; i < MAX_SPOTLIGHTS; i = i + 1u) {\\n        let sc = spotlights[i].lightViewProj * vec4<f32>(input.fragPos, 1.0);\\n        let p  = sc.xyz / sc.w;\\n        let uv = clamp(p.xy * 0.5 + vec2<f32>(0.5), vec2<f32>(0.0), vec2<f32>(1.0));\\n        let depthRef = p.z * 0.5 + 0.5;\\n        let lightDir = normalize(spotlights[i].position - input.fragPos);\\n        let bias = spotlights[i].shadowBias;\\n        let visibility = sampleShadow(uv, i32(i), depthRef - bias, norm, lightDir);\\n        let contrib = computeSpotLight(spotlights[i], norm, input.fragPos, viewDir, materialData);\\n        lightContribution += contrib * visibility;\\n    }\\n  let t0: vec4f = vec4f(lightContribution, 1.0);\\n  let t1: f32 = sin(scene.time);\\n  let t2: f32 = t1 * 0.3;\\n  let t3: f32 = 0.8 + t2;\\n  let t4: vec4f = vec4f(t3, t3, t3, 1.0);\\n  let t5: vec4f = t0 * t4;\\n  let t6: vec4f = textureSample(meshTexture, meshSampler, input.uv);\\n  let t7: vec4f = t5 * t6;\\n  \\n  return t7;\\n}\\n\"}")}
  },
    {
    "name": "leftRightUV",
    "content": ${JSON.stringify("{\"nodes\":[{\"id\":\"N1\",\"type\":\"UV\",\"x\":152,\"y\":236,\"inputs\":{}},{\"id\":\"N2\",\"type\":\"Time\",\"x\":152,\"y\":436,\"inputs\":{}},{\"id\":\"N3\",\"type\":\"Float\",\"x\":152,\"y\":536,\"value\":0.05,\"inputs\":{}},{\"id\":\"N4\",\"type\":\"Multiply\",\"x\":352,\"y\":486,\"inputs\":{\"a\":{\"default\":\"1.0\"},\"b\":{\"default\":\"1.0\"}}},{\"id\":\"N5\",\"type\":\"Sin\",\"x\":552,\"y\":486,\"inputs\":{\"value\":{\"default\":\"0.0\"}}},{\"id\":\"N6\",\"type\":\"Float\",\"x\":552,\"y\":586,\"value\":0.08,\"inputs\":{}},{\"id\":\"N7\",\"type\":\"Multiply\",\"x\":752,\"y\":536,\"inputs\":{\"a\":{\"default\":\"1.0\"},\"b\":{\"default\":\"1.0\"}}},{\"id\":\"N8\",\"type\":\"Vec2\",\"x\":752,\"y\":636,\"inputs\":{},\"valueX\":1,\"valueY\":0},{\"id\":\"N9\",\"type\":\"MultiplyVec2\",\"x\":952,\"y\":586,\"inputs\":{\"a\":{\"default\":\"vec2f(1.0)\"},\"b\":{\"default\":\"1.0\"}}},{\"id\":\"N10\",\"type\":\"AddVec2\",\"x\":1079,\"y\":350,\"inputs\":{\"a\":{\"default\":\"vec2f(0.0)\"},\"b\":{\"default\":\"vec2f(0.0)\"}}},{\"id\":\"N11\",\"type\":\"TextureSampler\",\"x\":1352,\"y\":411,\"name\":\"tex0\",\"inputs\":{\"uv\":{\"default\":\"input.uv\"}}},{\"id\":\"N12\",\"type\":\"LightShadowNode\",\"x\":1152,\"y\":86,\"inputs\":{\"intensity\":{\"default\":\"1\"}}},{\"id\":\"N13\",\"type\":\"LightToColor\",\"x\":1352,\"y\":86,\"inputs\":{\"light\":{\"default\":\"vec3f(1.0)\"}}},{\"id\":\"N14\",\"type\":\"MultiplyColor\",\"x\":1552,\"y\":248,\"inputs\":{\"a\":{\"default\":\"vec4(1.0)\"},\"b\":{\"default\":\"vec4(1.0)\"}}},{\"id\":\"N15\",\"type\":\"FragmentOutput\",\"x\":1752,\"y\":248,\"inputs\":{\"color\":{\"default\":\"vec4f(1.0)\"}}}],\"connections\":[{\"from\":\"N2\",\"fromPin\":\"out\",\"to\":\"N4\",\"toPin\":\"a\"},{\"from\":\"N3\",\"fromPin\":\"out\",\"to\":\"N4\",\"toPin\":\"b\"},{\"from\":\"N4\",\"fromPin\":\"out\",\"to\":\"N5\",\"toPin\":\"value\"},{\"from\":\"N5\",\"fromPin\":\"out\",\"to\":\"N7\",\"toPin\":\"a\"},{\"from\":\"N6\",\"fromPin\":\"out\",\"to\":\"N7\",\"toPin\":\"b\"},{\"from\":\"N7\",\"fromPin\":\"out\",\"to\":\"N9\",\"toPin\":\"a\"},{\"from\":\"N8\",\"fromPin\":\"out\",\"to\":\"N9\",\"toPin\":\"b\"},{\"from\":\"N1\",\"fromPin\":\"out\",\"to\":\"N10\",\"toPin\":\"a\"},{\"from\":\"N9\",\"fromPin\":\"out\",\"to\":\"N10\",\"toPin\":\"b\"},{\"from\":\"N10\",\"fromPin\":\"out\",\"to\":\"N11\",\"toPin\":\"uv\"},{\"from\":\"N12\",\"fromPin\":\"out\",\"to\":\"N13\",\"toPin\":\"light\"},{\"from\":\"N13\",\"fromPin\":\"out\",\"to\":\"N14\",\"toPin\":\"a\"},{\"from\":\"N11\",\"fromPin\":\"out\",\"to\":\"N14\",\"toPin\":\"b\"},{\"from\":\"N14\",\"fromPin\":\"out\",\"to\":\"N15\",\"toPin\":\"color\"}],\"final\":\"\\n/* === Engine uniforms === */\\n\\n// DINAMIC GLOBALS\\nconst PI: f32 = 3.141592653589793;\\noverride shadowDepthTextureSize: f32 = 1024.0;\\n\\n// DINAMIC STRUCTS\\n\\n\\n// PREDEFINED\\nstruct Scene {\\n    lightViewProjMatrix  : mat4x4f,\\n    cameraViewProjMatrix : mat4x4f,\\n    cameraPos            : vec3f,\\n    padding2             : f32,\\n    lightPos             : vec3f,\\n    padding              : f32,\\n    globalAmbient        : vec3f,\\n    padding3             : f32,\\n    time                 : f32,\\n    deltaTime            : f32,\\n    padding4             : vec2f,\\n};\\n\\n// PREDEFINED\\nstruct SpotLight {\\n    position      : vec3f,\\n    _pad1         : f32,\\n    direction     : vec3f,\\n    _pad2         : f32,\\n    innerCutoff   : f32,\\n    outerCutoff   : f32,\\n    intensity     : f32,\\n    _pad3         : f32,\\n    color         : vec3f,\\n    _pad4         : f32,\\n    range         : f32,\\n    ambientFactor : f32,\\n    shadowBias    : f32,\\n    _pad5         : f32,\\n    lightViewProj : mat4x4<f32>,\\n};\\n\\n// PREDEFINED\\nstruct MaterialPBR {\\n    baseColorFactor : vec4f,\\n    metallicFactor  : f32,\\n    roughnessFactor : f32,\\n    _pad1           : f32,\\n    _pad2           : f32,\\n};\\n\\n// PREDEFINED\\nstruct PBRMaterialData {\\n    baseColor : vec3f,\\n    metallic  : f32,\\n    roughness : f32,\\n    alpha     : f32\\n};\\n\\n// PREDEFINED\\nconst MAX_SPOTLIGHTS = 20u;\\n\\n// PREDEFINED\\n@group(0) @binding(0) var<uniform> scene : Scene;\\n@group(0) @binding(1) var shadowMapArray: texture_depth_2d_array;\\n@group(0) @binding(2) var shadowSampler: sampler_comparison;\\n@group(0) @binding(3) var meshTexture: texture_2d<f32>;\\n@group(0) @binding(4) var meshSampler: sampler;\\n@group(0) @binding(5) var<uniform> spotlights: array<SpotLight, MAX_SPOTLIGHTS>;\\n@group(0) @binding(6) var metallicRoughnessTex: texture_2d<f32>;\\n@group(0) @binding(7) var metallicRoughnessSampler: sampler;\\n@group(0) @binding(8) var<uniform> material: MaterialPBR;\\n\\n// ✅ Graph custom uniforms\\n\\n\\n// ✅ Graph custom functions\\n\\nfn computeSpotLight(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, material: PBRMaterialData) -> vec3f {\\n    let L = normalize(light.position - fragPos);\\n    let NdotL = max(dot(N, L), 0.0);\\n\\n    let theta = dot(L, normalize(-light.direction));\\n    let epsilon = light.innerCutoff - light.outerCutoff;\\n    var coneAtten = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);\\n\\n    // coneAtten = 1.0;\\n    if (coneAtten <= 0.0 || NdotL <= 0.0) {\\n        return vec3f(0.0);\\n    }\\n\\n    let F0 = mix(vec3f(0.04), material.baseColor.rgb, vec3f(material.metallic));\\n    let H = normalize(L + V);\\n    let F = F0 + (1.0 - F0) * pow(1.0 - max(dot(H, V), 0.0), 5.0);\\n\\n    let alpha = material.roughness * material.roughness;\\n    let NdotH = max(dot(N, H), 0.0);\\n    let alpha2 = alpha * alpha;\\n    let denom = (NdotH * NdotH * (alpha2 - 1.0) + 1.0);\\n    let D = alpha2 / (PI * denom * denom + 1e-5);\\n\\n    let k = (alpha + 1.0) * (alpha + 1.0) / 8.0;\\n    let NdotV = max(dot(N, V), 0.0);\\n    let Gv = NdotV / (NdotV * (1.0 - k) + k);\\n    let Gl = NdotL / (NdotL * (1.0 - k) + k);\\n    let G = Gv * Gl;\\n\\n    let numerator = D * G * F;\\n    let denominator = 4.0 * NdotV * NdotL + 1e-5;\\n    let specular = numerator / denominator;\\n\\n    let kS = F;\\n    let kD = (vec3f(1.0) - kS) * (1.0 - material.metallic);\\n    let diffuse = kD * material.baseColor.rgb / PI;\\n\\n    let radiance = light.color * light.intensity;\\n    // return (diffuse + specular) * radiance * NdotL * coneAtten;\\n    return material.baseColor * light.color * light.intensity * NdotL * coneAtten;\\n}\\n\\nfn sampleShadow(shadowUV: vec2f, layer: i32, depthRef: f32, normal: vec3f, lightDir: vec3f) -> f32 {\\n    var visibility: f32 = 0.0;\\n    let biasConstant: f32 = 0.001;\\n    let slopeBias = max(0.002 * (1.0 - dot(normal, lightDir)), 0.0);\\n    let bias = biasConstant + slopeBias;\\n    let oneOverSize = 1.0 / (shadowDepthTextureSize * 0.5);\\n    let offsets: array<vec2f, 9> = array<vec2f, 9>(\\n        vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),\\n        vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),\\n        vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0)\\n    );\\n    for(var i: u32 = 0u; i < 9u; i = i + 1u) {\\n        visibility += textureSampleCompare(\\n            shadowMapArray, shadowSampler,\\n            shadowUV + offsets[i] * oneOverSize,\\n            layer, depthRef - bias\\n        );\\n    }\\n    return visibility / 9.0;\\n}\\n\\n\\n// PREDEFINED Fragment input\\nstruct FragmentInput {\\n    @location(0) shadowPos : vec4f,\\n    @location(1) fragPos   : vec3f,\\n    @location(2) fragNorm  : vec3f,\\n    @location(3) uv        : vec2f,\\n};\\n\\n// PREDEFINED PBR helpers\\nfn getPBRMaterial(uv: vec2f) -> PBRMaterialData {\\n    let texColor = textureSample(meshTexture, meshSampler, uv);\\n    let baseColor = texColor.rgb * material.baseColorFactor.rgb;\\n    let mrTex = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);\\n    let metallic = mrTex.b * material.metallicFactor;\\n    let roughness = mrTex.g * material.roughnessFactor;\\n    \\n    // ✅ Get alpha from texture and material factor\\n    // let alpha = texColor.a * material.baseColorFactor.a;\\n    let alpha = material.baseColorFactor.a;\\n    \\n    return PBRMaterialData(baseColor, metallic, roughness, alpha);\\n}\\n\\n@fragment\\nfn main(input: FragmentInput) -> @location(0) vec4f {\\n  // Locals\\n  \\n    let norm = normalize(input.fragNorm);\\n    let viewDir = normalize(scene.cameraPos - input.fragPos);\\n    let materialData = getPBRMaterial(input.uv);\\n    var lightContribution = vec3f(0.0);\\n    for (var i: u32 = 0u; i < MAX_SPOTLIGHTS; i = i + 1u) {\\n        let sc = spotlights[i].lightViewProj * vec4<f32>(input.fragPos, 1.0);\\n        let p  = sc.xyz / sc.w;\\n        let uv = clamp(p.xy * 0.5 + vec2<f32>(0.5), vec2<f32>(0.0), vec2<f32>(1.0));\\n        let depthRef = p.z * 0.5 + 0.5;\\n        let lightDir = normalize(spotlights[i].position - input.fragPos);\\n        let bias = spotlights[i].shadowBias;\\n        let visibility = sampleShadow(uv, i32(i), depthRef - bias, norm, lightDir);\\n        let contrib = computeSpotLight(spotlights[i], norm, input.fragPos, viewDir, materialData);\\n        lightContribution += contrib * visibility;\\n    }\\n  let t0: vec4f = vec4f(lightContribution, 1.0);\\n  let t1: f32 = scene.time * 0.05;\\n  let t2: f32 = sin(t1);\\n  let t3: f32 = t2 * 0.08;\\n  let t4: vec2f = t3 * vec2f(1, 0);\\n  let t5: vec2f = input.uv + t4;\\n  let t6: vec4f = textureSample(meshTexture, meshSampler, t5);\\n  let t7: vec4f = t0 * t6;\\n  \\n  return t7;\\n}\\n\"}")}
  },
];
`;