export default [
  {
    "name": "getResultAngle",
    "code": "function getResultAngle(input) {\n   return input * 30;\n}",
    "type": "return",
    "intervalId": null
  },
  {
    "name": "neonTextEffect",
    "code": "function neonTextEffect(ctx, canvas, arg) {\n\n  const state = arg;\n  state.fontSize ??= 14;\n  state.flicker   ??= 22;\n  state.text     ??= \"nidza.js\";\n  state.glow       ??= 25;\n  state.hue        ??= 200;\n\n  function helper() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    const flickerOffset =\n      Math.random() < state.flicker ? Math.random() * 50 : 0;\n\n    ctx.shadowColor = `hsl(${state.hue}, 100%, 50%)`;\n    ctx.shadowBlur = state.glow + flickerOffset;\n\n    ctx.font = `${state.fontSize}px 'Arial Black', sans-serif`;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n\n    const lines = String(state.text).split(\"\\n\");\n    const lineHeight = state.lineHeight ?? state.fontSize * 1.2;\n\n    const totalHeight = lines.length * lineHeight;\n    let y = canvas.height / 2 - totalHeight / 2 + lineHeight / 2;\n\n    const gradient = ctx.createLinearGradient(\n      canvas.width / 2 - 150, 0,\n      canvas.width / 2 + 150, 0\n    );\n\n    gradient.addColorStop(0, `hsl(${state.hue}, 100%, 60%)`);\n    gradient.addColorStop(0.5, `hsl(${state.hue + 50}, 100%, 70%)`);\n    gradient.addColorStop(1, `hsl(${state.hue}, 100%, 60%)`);\n\n    ctx.fillStyle = gradient;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = `hsl(${state.hue}, 100%, 90%)`;\n\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], canvas.width / 2, y);\n      ctx.strokeText(lines[i], canvas.width / 2, y);\n      y += lineHeight;\n    }\n\n    state.hue += 0.5;\n    if (state.hue > 360) state.hue = 0;\n  }\n\n  helper();\n}",
    "type": "void",
    "intervalId": null
  },
  {
    "name": "teslaLightning",
    "code": "function teslaLightning(ctx, canvas, arg) {\n\n  const state = arg;\n\n  // defaults (safe for node graphs)\n  state.leftX  ??= canvas.width * 0.25;\n  state.leftY  ??= canvas.height * 0.5;\n  state.rightX ??= canvas.width * 0.75;\n  state.rightY ??= canvas.height * 0.5;\n\n  state.ballRadius ??= 14;\n  state.segments   ??= 22;\n  state.jitter     ??= 18;\n  state.glow       ??= 25;\n  state.hue        ??= 200;\n  state.thickness  ??= 20;\n  state.time       ??= 0;\n\n  function helper() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // === DRAW BALLS ===\n    ctx.shadowBlur = state.glow;\n    ctx.shadowColor = `hsl(${state.hue},100%,60%)`;\n\n    ctx.fillStyle = `hsl(${state.hue},100%,70%)`;\n\n    ctx.beginPath();\n    ctx.arc(state.leftX, state.leftY, state.ballRadius, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.arc(state.rightX, state.rightY, state.ballRadius, 0, Math.PI * 2);\n    ctx.fill();\n\n    // === LIGHTNING PATH ===\n    ctx.beginPath();\n\n    let x1 = state.leftX;\n    let y1 = state.leftY;\n    let x2 = state.rightX;\n    let y2 = state.rightY;\n\n    const dx = (x2 - x1) / state.segments;\n    const dy = (y2 - y1) / state.segments;\n\n    ctx.moveTo(x1, y1);\n\n    for (let i = 1; i < state.segments; i++) {\n      const offset =\n        (Math.random() - 0.5) * state.jitter *\n        Math.sin(i * 0.5 + state.time);\n\n      const nx = x1 + dx * i + offset;\n      const ny = y1 + dy * i + offset;\n\n      ctx.lineTo(nx, ny);\n    }\n\n    ctx.lineTo(x2, y2);\n\n    // === LIGHTNING STYLE ===\n    ctx.strokeStyle = `hsla(${state.hue},100%,70%,0.9)`;\n    ctx.lineWidth = state.thickness;\n    ctx.shadowBlur = state.glow;\n    ctx.stroke();\n\n    // === CORE (HOT CENTER LINE) ===\n    ctx.strokeStyle = \"rgba(255,255,255,0.9)\";\n    ctx.lineWidth = 1;\n    ctx.shadowBlur = state.glow * 0.5;\n    ctx.stroke();\n\n    // animate\n    state.time += 0.15;\n    state.hue += 0.3;\n    if (state.hue > 360) state.hue = 0;\n  }\n\n  helper();\n}",
    "type": "void",
    "intervalId": null
  },
  {
    "name": "teslaNetwork",
    "code": "function teslaNetwork(ctx, canvas, arg) {\n\n  const state = arg;\n\n  state.mode      ??= \"star\";   // star | quad | ring | text\n  state.segments  ??= 20;\n  state.jitter    ??= 18;\n  state.glow      ??= 25;\n  state.hue       ??= 200;\n  state.thickness ??= 2;\n  state.ballRadius ??= 12;\n  state.time      ??= 0;\n\n  function drawBall(x, y) {\n    ctx.beginPath();\n    ctx.arc(x, y, state.ballRadius, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawLightning(x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n\n    const dx = (x2 - x1) / state.segments;\n    const dy = (y2 - y1) / state.segments;\n\n    for (let i = 1; i < state.segments; i++) {\n      const offset =\n        (Math.random() - 0.5) *\n        state.jitter *\n        Math.sin(i * 0.6 + state.time);\n\n      ctx.lineTo(\n        x1 + dx * i + offset,\n        y1 + dy * i + offset\n      );\n    }\n\n    ctx.lineTo(x2, y2);\n\n    ctx.strokeStyle = `hsla(${state.hue},100%,70%,0.9)`;\n    ctx.lineWidth = state.thickness;\n    ctx.shadowBlur = state.glow;\n    ctx.stroke();\n\n    ctx.strokeStyle = \"rgba(255,255,255,0.9)\";\n    ctx.lineWidth = 1;\n    ctx.shadowBlur = state.glow * 0.5;\n    ctx.stroke();\n  }\n\n  function generatePoints() {\n    const pts = [];\n\n    const cx = canvas.width / 2;\n    const cy = canvas.height / 2;\n\n    if (state.mode === \"star\") {\n      const r = 120;\n      for (let i = 0; i < 5; i++) {\n        const a = (i / 5) * Math.PI * 2;\n        pts.push([cx + Math.cos(a) * r, cy + Math.sin(a) * r]);\n      }\n    }\n\n    if (state.mode === \"quad\") {\n      const s = 140;\n      pts.push(\n        [cx - s, cy - s],\n        [cx + s, cy - s],\n        [cx + s, cy + s],\n        [cx - s, cy + s]\n      );\n    }\n\n    if (state.mode === \"ring\") {\n      const r = 160;\n      const count = 8;\n      for (let i = 0; i < count; i++) {\n        const a = (i / count) * Math.PI * 2;\n        pts.push([cx + Math.cos(a) * r, cy + Math.sin(a) * r]);\n      }\n    }\n\n    if (state.mode === \"text\") {\n      // simple letter points (example: A)\n      const size = 120;\n      pts.push(\n        [cx, cy - size],\n        [cx - size, cy + size],\n        [cx + size, cy + size],\n        [cx - size * 0.5, cy],\n        [cx + size * 0.5, cy]\n      );\n    }\n\n    return pts;\n  }\n\n  function helper() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    ctx.fillStyle = `hsl(${state.hue},100%,70%)`;\n    ctx.shadowColor = `hsl(${state.hue},100%,60%)`;\n\n    const points = generatePoints();\n\n    // draw balls\n    for (const p of points) drawBall(p[0], p[1]);\n\n    // connect them\n    for (let i = 0; i < points.length; i++) {\n      const a = points[i];\n      const b = points[(i + 1) % points.length];\n      drawLightning(a[0], a[1], b[0], b[1]);\n    }\n\n    state.time += 0.15;\n    state.hue += 0.4;\n    if (state.hue > 360) state.hue = 0;\n  }\n\n  helper();\n}",
    "type": "return",
    "intervalId": null
  },
  {
    "name": "teslaLetter",
    "code": "function teslaLetter(ctx, canvas, arg) {\n\n  const state = arg;\n\n  state.char       ??= \"A\";\n  state.fontSize   ??= 180;\n  state.sampleStep ??= 16;\n  state.segments   ??= 13;\n  state.jitter     ??= 7;\n  state.glow       ??= 20;\n  state.hue        ??= 200;\n  state.ballRadius ??= 5;\n  state.time       ??= 0;\n\n  // offscreen buffer (local, safe)\n  const buffer = document.createElement(\"canvas\");\n  buffer.width = canvas.width;\n  buffer.height = canvas.height;\n  const bctx = buffer.getContext(\"2d\");\n\n  function getLetterPoints() {\n    bctx.clearRect(0, 0, buffer.width, buffer.height);\n\n    bctx.fillStyle = \"#fff\";\n    bctx.font = `${state.fontSize}px Arial Black`;\n    bctx.textAlign = \"center\";\n    bctx.textBaseline = \"middle\";\n    bctx.fillText(state.char, buffer.width / 2, buffer.height / 2);\n\n    const img = bctx.getImageData(0, 0, buffer.width, buffer.height).data;\n    const pts = [];\n\n    for (let y = 0; y < buffer.height; y += state.sampleStep) {\n      for (let x = 0; x < buffer.width; x += state.sampleStep) {\n        if (img[(y * buffer.width + x) * 4 + 3] > 20) {\n          pts.push([x, y]);\n        }\n      }\n    }\n    return pts;\n  }\n\n  function drawBall(x, y) {\n    ctx.beginPath();\n    ctx.arc(x, y, state.ballRadius, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawLightning(a, b) {\n    ctx.beginPath();\n    ctx.moveTo(a[0], a[1]);\n\n    const dx = (b[0] - a[0]) / state.segments;\n    const dy = (b[1] - a[1]) / state.segments;\n\n    for (let i = 1; i < state.segments; i++) {\n      const o =\n        (Math.random() - 0.5) *\n        state.jitter *\n        Math.sin(i + state.time);\n\n      ctx.lineTo(\n        a[0] + dx * i + o,\n        a[1] + dy * i + o\n      );\n    }\n\n    ctx.lineTo(b[0], b[1]);\n\n    ctx.strokeStyle = `hsla(${state.hue},100%,70%,0.9)`;\n    ctx.lineWidth = 1.5;\n    ctx.shadowBlur = state.glow;\n    ctx.stroke();\n  }\n\n  function helper() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    ctx.fillStyle = `hsl(${state.hue},100%,70%)`;\n    ctx.shadowColor = `hsl(${state.hue},100%,60%)`;\n\n    const pts = getLetterPoints();\n\n    // draw balls\n    for (const p of pts) drawBall(p[0], p[1]);\n\n    // lightning between near points\n    for (let i = 0; i < pts.length - 1; i += 2) {\n      drawLightning(pts[i], pts[i + 1]);\n    }\n\n    state.time += 0.2;\n    state.hue += 0.4;\n    if (state.hue > 360) state.hue = 0;\n  }\n\n  helper();\n}",
    "type": "return",
    "intervalId": null
  }
];
