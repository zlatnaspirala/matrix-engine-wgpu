<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Visual Blueprint Editor (Fixed)</title>
  <style>
    :root {
      --bg: #101217;
      --text: #dfe7f0;
      --grad-event: linear-gradient(135deg, #4ef6a8, #2bd28f);
      --grad-action: linear-gradient(135deg, #6ec6ff, #3a8fc1);
      --grad-control: linear-gradient(135deg, #f6d64e, #d4aa2b);
      --grad-math: linear-gradient(135deg, #ff6ec6, #d23aa1);
      --grad-value: linear-gradient(135deg, #6ef4c0, #3aa88f);
      --grad-timer: linear-gradient(135deg, #ff8c6e, #d23a2b);
    }

    html,
    body {
      margin: 0;
      height: 100%;
      font-family: Inter, sans-serif;
      background: var(--bg);
      user-select: none;
      overflow: hidden;
    }

    #app {
      display: flex;
      height: 100%;
      gap: 8px;
    }

    #leftBar {
      width: 220px;
      background: linear-gradient(180deg, #0b1320, #081018);
      padding: 12px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      z-index: 10;
    }

    #leftBar h3 {
      margin: 8px 0;
      font-size: 14px;
      color: #9fb4d8;
    }

    .btn {
      display: block;
      padding: 8px 10px;
      margin: 6px 0;
      background: #1b2632;
      border-radius: 8px;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.04);
      color: var(--text);
      font-size: 13px;
      text-align: left;
      transition: background 0.2s;
    }

    .btn:hover {
      background: #2a3642;
    }

    #boardWrap {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: #081018;
      cursor: grab;
    }

    #board {
      position: absolute;
      inset: 0;
      transform-origin: 0 0;
    }

    svg.connections {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: visible;
    }

    /* --- UPDATED NODE STYLE --- */
    .node {
      position: absolute;
      min-width: 180px;
      border-radius: 10px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.05);
      /* Transparency restored with blur for readability */
      background: rgba(15, 23, 32, 0.85);
      backdrop-filter: blur(4px);
    }

    .node .header {
      padding: 6px 10px;
      font-weight: 700;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px 10px 0 0;
      color: #fff;
    }

    .node.event .header {
      background: var(--grad-event);
    }

    .node.action .header {
      background: var(--grad-action);
    }

    .node.control .header {
      background: var(--grad-control);
    }

    .node.math .header {
      background: var(--grad-math);
    }

    .node.value .header {
      background: var(--grad-value);
    }

    .node.timer .header {
      background: var(--grad-timer);
    }

    .node .body {
      padding: 8px 10px;
      font-size: 13px;
      border-radius: 0 0 10px 10px;
    }

    .pin-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin: 6px 0;
    }

    .pins-left,
    .pins-right {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .pin {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 12px;
      position: relative;
    }

    .pin:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .pin .dot {
      width: 12px;
      height: 12px;
      display: block;
    }

    .pin.value .dot {
      border-radius: 50%;
      background: #f6d64e;
    }

    .pin.action .dot {
      width: 0;
      height: 0;
      border-left: 6px solid #4ef6a8;
      border-top: 6px solid transparent;
      border-bottom: 6px solid transparent;
    }

    .link {
      stroke: #9fc9ff;
      stroke-width: 3;
      fill: none;
      stroke-linecap: round;
    }

    .link.value {
      stroke: #6ef4c0;
    }

    .node.selected {
      outline: 3px solid rgba(255, 255, 255, 0.1);
    }

    .node .value-display {
      font-size: 12px;
      color: #9fb4d8;
      margin-top: 4px;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 4px;
      border-radius: 4px;
    }

    #log {
      font-family: monospace;
      font-size: 12px;
      margin-top: 10px;
      color: #cfe;
      white-space: pre-wrap;
      word-break: break-all;
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="leftBar">
      <h3>Blueprint Nodes</h3>
      <button class="btn" onclick="addNode('event')">Event: onLoad</button>
      <button class="btn" onclick="addNode('function')">Function</button>
      <button class="btn" onclick="addNode('if')">If Branch</button>
      <button class="btn" onclick="addNode('genrand')">GenRandInt</button>
      <button class="btn" onclick="addNode('print')">Print</button>
      <button class="btn" onclick="addNode('timeout')">SetTimeout</button>
      <hr style="border:none; height:1px; background:rgba(255,255,255,0.03); margin:10px 0;">
      <button class="btn" onclick="addNode('add')">Add (+)</button>
      <button class="btn" onclick="addNode('sub')">Sub (-)</button>
      <button class="btn" onclick="addNode('mul')">Mul (*)</button>
      <button class="btn" onclick="addNode('div')">Div (/)</button>
      <button class="btn" onclick="addNode('sin')">Sin</button>
      <button class="btn" onclick="addNode('cos')">Cos</button>
      <button class="btn" onclick="addNode('pi')">Pi</button>
      <hr style="border:none; height:1px; background:rgba(255,255,255,0.03); margin:10px 0;">
      <button class="btn" onclick="compileGraph()">Save to LocalStorage</button>
      <button class="btn" onclick="clearStorage()">Clear Save</button>
      <button class="btn" onclick="runGraph()">Run</button>
      <pre id="log" aria-live="polite"></pre>
    </div>
    <div id="boardWrap">
      <div id="board">
        <svg class="connections"></svg>
      </div>
    </div>
  </div>

  <script>
    const board = document.getElementById('board');
    const boardWrap = document.getElementById('boardWrap');
    let svg = board.querySelector('svg.connections');
    const logEl = document.getElementById('log');

    let nodes = {}, links = [], nodeCounter = 1, linkCounter = 1;
    let state = {
      draggingNode: null, dragOffset: [0, 0], connecting: null,
      selectedNode: null, pan: [0, 0], panning: false, panStart: [0, 0]
    };

    function log(...args) {logEl.textContent = args.join(' ');}

    function selectNode(id) {
      if(state.selectedNode) document.querySelector(`.node[data-id="${state.selectedNode}"]`)?.classList.remove('selected');
      state.selectedNode = id;
      document.querySelector(`.node[data-id="${id}"]`)?.classList.add('selected');
    }

    function createNodeDOM(spec) {
      const el = document.createElement('div');
      el.className = 'node ' + (spec.category || '');
      el.style.left = spec.x + 'px';
      el.style.top = spec.y + 'px';
      el.dataset.id = spec.id;

      const header = document.createElement('div'); header.className = 'header'; header.textContent = spec.title;
      el.appendChild(header);

      const body = document.createElement('div'); body.className = 'body';
      const row = document.createElement('div'); row.className = 'pin-row';
      const left = document.createElement('div'); left.className = 'pins-left';
      const right = document.createElement('div'); right.className = 'pins-right';

      (spec.inputs || []).forEach(pin => left.appendChild(pinElement(pin, false, spec.id)));
      (spec.outputs || []).forEach(pin => right.appendChild(pinElement(pin, true, spec.id)));

      row.appendChild(left); row.appendChild(right); body.appendChild(row);

      // Allows Print (action node) and value/math nodes to have displays
      // Around line 108: This block previously only supported Value and Math nodes.
      if((spec.category === 'value' && spec.title !== 'GenRandInt') || spec.category === 'math' || spec.title === 'Print') {
        const display = document.createElement('div');
        display.className = 'value-display';

        if(spec.title === 'Print' && spec.fields) {
          // Display the static label for the Print node
          const labelField = spec.fields.find(f => f.key === 'label');
          display.textContent = labelField ? `Label: "${labelField.value}"` : '?';
          // ADDED: Give the Print node a display element reference
          spec.displayEl = display;
        } else {
          // Display the dynamic result for value/math nodes
          display.textContent = '?';
          spec.displayEl = display; // Keep reference for dynamic updates
        }

        el.appendChild(display); // Append to the main node element
      }

      // --- NEW INPUT FIELD CREATION BLOCK ---
      if(spec.fields && spec.fields.length > 0 && spec.title === 'GenRandInt') {
        const fieldsContainer = document.createElement('div');
        fieldsContainer.style.flexDirection = 'column';
        fieldsContainer.style.marginTop = '8px';
        fieldsContainer.style.marginTop = '8px';
        fieldsContainer.style.fontSize = '12px';
        fieldsContainer.style.display = 'flex';
        fieldsContainer.style.gap = '8px';
        fieldsContainer.style.justifyContent = 'space-between';

        spec.fields.forEach(field => {
          const fieldWrap = document.createElement('div');
          fieldWrap.style.display = 'flex';
          fieldWrap.style.alignItems = 'center';
          fieldWrap.style.gap = '4px';

          const label = document.createElement('span');
          label.textContent = field.key.toUpperCase() + ':';
          label.style.color = '#a8b9cf';
          fieldWrap.appendChild(label);

          const input = document.createElement('input');
          input.type = 'number';
          input.value = field.value;
          input.dataset.key = field.key;
          input.style.width = '40px';
          input.style.padding = '2px';
          input.style.border = '1px solid #3a475a';
          input.style.borderRadius = '4px';
          input.style.backgroundColor = '#1a2430';
          input.style.color = 'var(--text)';

          // Update the spec's field value when the input changes
          input.addEventListener('change', () => {
            field.value = input.value;
            updateValueDisplays();
          });

          fieldWrap.appendChild(input);
          fieldsContainer.appendChild(fieldWrap);
        });
        body.appendChild(fieldsContainer);
      }
      // --- END NEW INPUT FIELD CREATION BLOCK ---

      el.appendChild(body);

      header.addEventListener('mousedown', e => {
        e.preventDefault(); state.draggingNode = el;
        const rect = el.getBoundingClientRect();
        const bx = board.getBoundingClientRect();
        state.dragOffset = [e.clientX - rect.left + bx.left, e.clientY - rect.top + bx.top];
        document.body.style.cursor = 'grabbing';
      });
      el.addEventListener('click', e => {e.stopPropagation(); selectNode(spec.id);});
      return el;
    }

    function pinElement(pinSpec, isOutput, nodeId) {
      const pin = document.createElement('div'); pin.className = 'pin ' + pinSpec.type;
      pin.dataset.pin = pinSpec.name; pin.dataset.type = pinSpec.type; pin.dataset.io = isOutput ? 'out' : 'in';
      const dot = document.createElement('div'); dot.className = 'dot'; pin.appendChild(dot);
      pin.addEventListener('mousedown', e => {startConnect(nodeId, pinSpec.name, pinSpec.type, isOutput);});
      pin.addEventListener('mouseup', e => {finishConnect(nodeId, pinSpec.name, pinSpec.type, isOutput);});
      return pin;
    }

    function addNode(type) {
      const id = 'node_' + (nodeCounter++);
      const x = Math.abs(state.pan[0]) + 100 + Math.random() * 200;
      const y = Math.abs(state.pan[1]) + 100 + Math.random() * 200;

      let spec = null;
      if(type === 'event') {spec = {id, title: 'onLoad', x, y, category: 'event', inputs: [], outputs: [{name: 'exec', type: 'action'}]};}
      else if(type === 'function') {spec = {id, title: 'Function', x, y, category: 'action', inputs: [{name: 'exec', type: 'action'}], outputs: [{name: 'execOut', type: 'action'}]};}
      else if(type === 'if') {spec = {id, title: 'If', x, y, category: 'control', inputs: [{name: 'exec', type: 'action'}, {name: 'condition', type: 'value'}], outputs: [{name: 'true', type: 'action'}, {name: 'false', type: 'action'}]};}
      else if(type === 'genrand') {spec = {id, title: 'GenRandInt', x, y, category: 'value', inputs: [], outputs: [{name: 'result', type: 'value'}], fields: [{key: 'min', value: '0'}, {key: 'max', value: '10'}]};}

      // New Print definition with a static label field
      else if(type === 'print') {
        spec = {
          id, title: 'Print', x, y, category: 'action',
          inputs: [{name: 'exec', type: 'action'}, {name: 'value', type: 'value'}],
          outputs: [{name: 'execOut', type: 'action'}],
          fields: [{key: 'label', value: ''}] // <-- NEW STATIC FIELD
        };
      }

      else if(type === 'timeout') {spec = {id, title: 'SetTimeout', x, y, category: 'timer', inputs: [{name: 'exec', type: 'action'}, {name: 'delay', type: 'value'}], outputs: [{name: 'execOut', type: 'action'}], fields: [{key: 'delay', value: '1000'}]};}
      else if(type === 'add') {spec = {id, title: 'Add', x, y, category: 'math', inputs: [{name: 'a', type: 'value'}, {name: 'b', type: 'value'}], outputs: [{name: 'result', type: 'value'}]};}
      else if(type === 'sub') {spec = {id, title: 'Sub', x, y, category: 'math', inputs: [{name: 'a', type: 'value'}, {name: 'b', type: 'value'}], outputs: [{name: 'result', type: 'value'}]};}
      else if(type === 'mul') {spec = {id, title: 'Mul', x, y, category: 'math', inputs: [{name: 'a', type: 'value'}, {name: 'b', type: 'value'}], outputs: [{name: 'result', type: 'value'}]};}
      else if(type === 'div') {spec = {id, title: 'Div', x, y, category: 'math', inputs: [{name: 'a', type: 'value'}, {name: 'b', type: 'value'}], outputs: [{name: 'result', type: 'value'}]};}
      else if(type === 'sin') {spec = {id, title: 'Sin', x, y, category: 'math', inputs: [{name: 'a', type: 'value'}], outputs: [{name: 'result', type: 'value'}]};}
      else if(type === 'cos') {spec = {id, title: 'Cos', x, y, category: 'math', inputs: [{name: 'a', type: 'value'}], outputs: [{name: 'result', type: 'value'}]};}
      else if(type === 'pi') {spec = {id, title: 'Pi', x, y, category: 'math', inputs: [], outputs: [{name: 'result', type: 'value'}]};}

      const dom = createNodeDOM(spec); board.appendChild(dom); nodes[id] = spec;
      return id;
    }

    document.addEventListener('mousemove', e => {
      if(state.draggingNode) {
        const el = state.draggingNode;
        el.style.left = (e.clientX - state.dragOffset[0]) + 'px';
        el.style.top = (e.clientY - state.dragOffset[1]) + 'px';
        const id = el.dataset.id;
        if(nodes[id]) {nodes[id].x = parseFloat(el.style.left); nodes[id].y = parseFloat(el.style.top);}

        // ðŸš¨ CRITICAL CHANGE: Only update links, NOT values (it's too slow and recursive)
        updateLinks();
      } else if(state.panning) {
        const dx = e.clientX - state.panStart[0];
        const dy = e.clientY - state.panStart[1];
        state.pan[0] += dx; state.pan[1] += dy;
        board.style.transform = `translate(${state.pan[0]}px,${state.pan[1]}px)`;
        state.panStart = [e.clientX, e.clientY];
      }
    });
    document.addEventListener('mouseup', e => {state.draggingNode = null; state.panning = false; document.body.style.cursor = 'default';});
    boardWrap.addEventListener('mousedown', e => {
      if(!e.target.closest('.node')) {state.panning = true; state.panStart = [e.clientX, e.clientY]; document.body.style.cursor = 'grabbing';}
    });

    function startConnect(nodeId, pinName, type, isOut) {state.connecting = {node: nodeId, pin: pinName, type: type, out: isOut};}
    function finishConnect(nodeId, pinName, type, isOut) {
      if(state.connecting && state.connecting.node !== nodeId) {
        if(state.connecting.out !== isOut && state.connecting.type === type) {
          const from = isOut ? {node: nodeId, pin: pinName} : {...state.connecting};
          const to = isOut ? {...state.connecting} : {node: nodeId, pin: pinName};
          const exists = links.find(l => l.from.node === from.node && l.from.pin === from.pin && l.to.node === to.node && l.to.pin === to.pin);
          if(!exists) {
            links.push({id: 'link_' + (linkCounter++), from, to, type});
            updateLinks();

            // ðŸš¨ CRITICAL CHANGE: Delay the heavy, recursive calculation slightly
            // This allows the browser to clear the connection handler from the stack
            // before starting the deep getValue() recursion.
            setTimeout(updateValueDisplays, 0);
          }
        }
      }
      state.connecting = null;
    }

    function updateLinks() {
      while(svg.firstChild) svg.removeChild(svg.firstChild);
      links.forEach(l => {
        const fromNode = document.querySelector(`.node[data-id="${l.from.node}"]`);
        const toNode = document.querySelector(`.node[data-id="${l.to.node}"]`);
        if(!fromNode || !toNode) return;
        const fromDot = fromNode.querySelector(`.pin[data-pin="${l.from.pin}"] .dot`);
        const toDot = toNode.querySelector(`.pin[data-pin="${l.to.pin}"] .dot`);
        if(!fromDot || !toDot) return;
        const fRect = fromDot.getBoundingClientRect();
        const tRect = toDot.getBoundingClientRect();
        const bRect = board.getBoundingClientRect();
        const x1 = (fRect.left - bRect.left) + 6;
        const y1 = (fRect.top - bRect.top) + 6;
        const x2 = (tRect.left - bRect.left) + 6;
        const y2 = (tRect.top - bRect.top) + 6;
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('class', 'link ' + (l.type === 'value' ? 'value' : ''));
        path.setAttribute('d', `M${x1},${y1} C${x1 + 50},${y1} ${x2 - 50},${y2} ${x2},${y2}`);
        svg.appendChild(path);
      });
    }

    // REPLACE your ENTIRE getValue function with this one:

    // REPLACE your ENTIRE getValue function with this one:

    function getValue(nodeId, pinName, visited = new Set()) {
      const n = nodes[nodeId];
      if(!n) return 0;

      let l = null;

      // --- 1. Find the Link using an explicit loop (Avoiding Array.find optimization issues) ---
      // The debugger highlights this area because the stack overflows while waiting for the result of the function call.
      // The recursion happens in step 2.
      for(const link of links) {
        if(link.to.node === nodeId && link.to.pin === pinName && link.type === 'value') {
          l = link;
          break;
        }
      }

      // --- 2. Cycle Protection and Link Traversal ---
      if(l) {
        const sourceNodeId = l.from.node;

        // CRITICAL CHECK: If the source node is already in our current calculation path, stop the loop.
        if(visited.has(sourceNodeId)) {
          console.warn(`Circular dependency detected at node ${nodeId} linked to ${sourceNodeId}. Returning 0.`);
          return 0;
        }

        // Prepare the visited set for the next recursive call:
        // Add the current node (nodeId) to the set before continuing the chain.
        const newVisited = new Set(visited);
        newVisited.add(nodeId);

        // Recursively call getValue on the source node, passing the updated visited set.
        return getValue(sourceNodeId, l.from.pin, newVisited);
      }

      // --- 3. Node internal logic (Base cases and calculations) ---

      if(n.title === 'GenRandInt') {

        // ðŸš¨ FIX: Find the values within the fields array
        const minField = n.fields?.find(f => f.key === 'min');
        const maxField = n.fields?.find(f => f.key === 'max');

        // Use the found value or default to 0/10, converting to number with '+'
        const min = +(minField?.value) || 0;
        const max = +(maxField?.value) || 10;

        return Math.floor(Math.random() * (max - min + 1) + min);

      }
      if(n.title === 'String') {
        const field = n.fields?.find(f => f.key === 'value');
        return field ? field.value : '';
      }
      if(n.title === 'Pi') return Math.PI;

      // Retrieve inputs recursively, passing the current visited set (as we are still in the same node evaluation).
      const vA = +getValue(nodeId, 'a') || 0;
      const vB = +getValue(nodeId, 'b') || 0;

      if(n.title === 'Add') return vA + vB;
      if(n.title === 'Sub') return vA - vB;
      if(n.title === 'Mul') return vA * vB;
      if(n.title === 'Div') return vB ? vA / vB : 0;
      if(n.title === 'Sin') return Math.sin(vA);
      if(n.title === 'Cos') return Math.cos(vA);

      return 0;
    }

    function updateValueDisplays() {
      Object.values(nodes).forEach(n => {
        if(n.displayEl) n.displayEl.textContent = getValue(n.id, 'result').toFixed(3);
      });
    }

    function triggerNode(id) {
      const n = nodes[id]; if(!n) return;
      const el = document.querySelector(`.node[data-id="${id}"] .header`);
      if(el) {el.style.filter = 'brightness(1.5)'; setTimeout(() => el.style.filter = 'none', 200);}
      if(n.category === 'event') enqueueOutputs(n, 'exec');
      if(n.category === 'action') {
        if(n.title === 'Print') {
          const valueToPrint = getValue(id, 'value'); // 1. Get Value
          const labelField = n.fields?.find(f => f.key === 'label');
          const label = labelField ? labelField.value : 'Print:';

          // 2. GUI Preview: Update the Print node's display
          if(n.displayEl) {
            n.displayEl.textContent = valueToPrint;
          }

          // 3. Console Log (for developer debugger)
          console.log(`[Blueprint] ${label}`, valueToPrint);

          // 4. Internal Log (for GUI box)
          log(`> ${label}`, valueToPrint);
        }
        if(n.title === 'SetTimeout') {setTimeout(() => enqueueOutputs(n, 'execOut'), +n.fields?.delay || 1000); return;}
        enqueueOutputs(n, 'execOut');
      }
      if(n.category === 'control') {
        if(n.title === 'If') {enqueueOutputs(n, getValue(id, 'condition') ? 'true' : 'false');}
      }
    }

    function enqueueOutputs(n, pinName) {
      links.filter(l => l.from.node === n.id && l.from.pin === pinName && l.type === 'action')
        .forEach(l => setTimeout(() => triggerNode(l.to.node), 10));
    }

    function runGraph() {log('--- Run ---'); Object.values(nodes).filter(n => n.category === 'event' && n.title === 'onLoad').forEach(n => triggerNode(n.id));}

    const SAVE_KEY = 'vbe_graph_data';
    function compileGraph() {
      const bundle = {nodes, links, nodeCounter, linkCounter, pan: state.pan};
      localStorage.setItem(SAVE_KEY, JSON.stringify(bundle));
      log('Graph saved to LocalStorage!');
    }
    function clearStorage() {localStorage.removeItem(SAVE_KEY); log('Save cleared. Refresh to reset.');}
    function init() {
      const saved = localStorage.getItem(SAVE_KEY);
      if(saved) {
        try {
          const data = JSON.parse(saved);
          nodes = data.nodes || {}; links = data.links || [];
          nodeCounter = data.nodeCounter || 1; linkCounter = data.linkCounter || 1;
          state.pan = data.pan || [0, 0];
          board.style.transform = `translate(${state.pan[0]}px,${state.pan[1]}px)`;
          Object.values(nodes).forEach(spec => board.appendChild(createNodeDOM(spec)));
          updateLinks(); updateValueDisplays();
          log('Restored graph.');
          return;
        } catch(e) {console.error(e);}
      }
      addNode('event');
    }
    init();
  </script>
</body>

</html>