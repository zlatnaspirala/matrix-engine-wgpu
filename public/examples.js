(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _cameraTexture = require("./examples/camera-texture.js");
var _glbLoader = require("./examples/glb-loader.js");
var _loadObjFile = require("./examples/load-obj-file.js");
var _loadObjsSequence = require("./examples/load-objs-sequence.js");
var _physicsPlayground = require("./examples/physics-playground.js");
var _videoTexture = require("./examples/video-texture.js");
var _utils = require("./src/engine/utils.js");
/**
 * @examples
 * MATRIX_ENGINE_WGPU EXAMPLE WORKSPACE
 */

// import {loadJamb} from "./examples/load-jamb.js";

window.urlQ = _utils.urlQuery;

// A helper function to change the demo without breaking the URL
const switchDemo = id => {
  const url = new URL(window.location.href);
  url.searchParams.set('demo', id);
  window.location.href = url.toString();
  // Setting href automatically triggers the reload with the new param
};

// Demo 1
(0, _utils.byId)('loadObjFile').addEventListener("click", () => switchDemo('1'));

// Demo 2
(0, _utils.byId)('physicsPlayground').addEventListener("click", () => switchDemo('2'));

// Demo 3
(0, _utils.byId)('camera-texture').addEventListener("click", () => switchDemo('3'));

// Demo 4
(0, _utils.byId)('video-texture').addEventListener("click", () => switchDemo('4'));

// Demo 5 - Fixed ID
(0, _utils.byId)('objs-anim').addEventListener("click", () => switchDemo('5'));

// Demo 6 - Fixed ID
(0, _utils.byId)('glb-loader').addEventListener("click", () => switchDemo('6'));
if (urlQ['demo'] === '1') {
  (0, _loadObjFile.loadObjFile)();
} else if (urlQ['demo'] === '2') {
  (0, _physicsPlayground.physicsPlayground)();
} else if (urlQ['demo'] === '3') {
  (0, _cameraTexture.loadCameraTexture)();
} else if (urlQ['demo'] === '4') {
  (0, _videoTexture.loadVideoTexture)();
} else if (urlQ['demo'] === '5') {
  (0, _loadObjsSequence.loadObjsSequence)();
} else if (urlQ['demo'] === '6') {
  (0, _glbLoader.loadGLBLoader)();
}

},{"./examples/camera-texture.js":2,"./examples/glb-loader.js":3,"./examples/load-obj-file.js":4,"./examples/load-objs-sequence.js":5,"./examples/physics-playground.js":6,"./examples/video-texture.js":7,"./src/engine/utils.js":56}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadCameraTexture = void 0;
var _world = _interopRequireDefault(require("../src/world.js"));
var _loaderObj = require("../src/engine/loader-obj.js");
var _utils = require("../src/engine/utils.js");
var _raycast = require("../src/engine/raycast.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var loadCameraTexture = function () {
  let cameraTexture = new _world.default({
    useSingleRenderPass: true,
    canvasSize: 'fullscreen',
    mainCameraParams: {
      type: 'WASD',
      responseCoef: 1000
    },
    clearColor: {
      r: 0,
      b: 0.122,
      g: 0.122,
      a: 1
    }
  }, () => {
    cameraTexture.addLight();
    addEventListener('AmmoReady', () => {
      (0, _loaderObj.downloadMeshes)({
        welcomeText: "./res/meshes/blender/piramyd.obj",
        armor: "./res/meshes/obj/armor.obj",
        sphere: "./res/meshes/blender/sphere.obj",
        cube: "./res/meshes/blender/cube.obj"
      }, onLoadObj, {
        scale: [1, 1, 1]
      });
    });
    function onLoadObj(m) {
      cameraTexture.myLoadedMeshes = m;
      for (var key in m) {
        console.log(`%c Loaded objs: ${key} `, _utils.LOG_MATRIX);
      }
      cameraTexture.addMeshObj({
        position: {
          x: 0,
          y: 2,
          z: -10
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        },
        rotationSpeed: {
          x: 0,
          y: 0,
          z: 0
        },
        texturesPaths: ['./res/meshes/blender/cube.png'],
        name: 'MyVideoTex',
        mesh: m.cube,
        physics: {
          enabled: true,
          geometry: "Cube"
        }
        // raycast: { enabled: true , radius: 2 }
      });
      var TEST = cameraTexture.getSceneObjectByName('MyVideoTex');
      setTimeout(() => {
        console.log(`%c Test video-texture...`, _utils.LOG_MATRIX);
        TEST.loadVideoTexture({
          type: 'camera'
        });
      }, 4000);
    }
  });
  window.app = cameraTexture;
};
exports.loadCameraTexture = loadCameraTexture;

},{"../src/engine/loader-obj.js":44,"../src/engine/raycast.js":55,"../src/engine/utils.js":56,"../src/world.js":96}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadGLBLoader = loadGLBLoader;
var _world = _interopRequireDefault(require("../src/world.js"));
var _loaderObj = require("../src/engine/loader-obj.js");
var _webgpuGltf = require("../src/engine/loaders/webgpu-gltf.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// import {LOG_FUNNY, LOG_INFO, LOG_MATRIX} from "../src/engine/utils.js";
// import {loadBVH} from "../src/engine/loaders/bvh.js";

/**
 * @Note
 * “Character and animation assets from Mixamo,
 * used under Adobe’s royalty‑free license. 
 * Redistribution of raw assets is not permitted.”
 **/
function loadGLBLoader() {
  let TEST_ANIM = new _world.default({
    useSingleRenderPass: true,
    canvasSize: 'fullscreen',
    mainCameraParams: {
      type: 'WASD',
      responseCoef: 1000
    },
    clearColor: {
      r: 0,
      b: 0.122,
      g: 0.122,
      a: 1
    }
  }, () => {
    addEventListener('AmmoReady', async () => {
      setTimeout(() => {
        app.cameras.WASD.yaw = -0.03;
        app.cameras.WASD.pitch = -0.49;
        app.cameras.WASD.position[2] = 0;
        app.cameras.WASD.position[1] = 35;
      }, 2000);
      (0, _loaderObj.downloadMeshes)({
        cube: "./res/meshes/blender/cube.obj"
      }, onGround, {
        scale: [120, 0.5, 120]
      });

      // // Monster1
      var glbFile01 = await fetch("res/meshes/glb/monster.glb").then(res => res.arrayBuffer().then(buf => (0, _webgpuGltf.uploadGLBModel)(buf, TEST_ANIM.device)));
      TEST_ANIM.addGlbObj({
        material: {
          type: 'standard',
          useTextureFromGlb: true
        },
        useScale: true,
        scale: [20, 20, 20],
        position: {
          x: 0,
          y: -4,
          z: -70
        },
        name: 'firstGlb',
        texturesPaths: ['./res/meshes/glb/textures/mutant_origin.png']
      }, null, glbFile01);

      // var glbFile02 = await fetch("res/meshes/glb/monster.glb").then(res => res.arrayBuffer().then(buf => uploadGLBModel(buf, TEST_ANIM.device)));
      TEST_ANIM.addGlbObj({
        material: {
          type: 'power',
          useTextureFromGlb: true
        },
        useScale: true,
        scale: [20, 20, 20],
        position: {
          x: -40,
          y: -4,
          z: -70
        },
        name: 'firstGlb',
        texturesPaths: ['./res/meshes/glb/textures/mutant_origin.png']
      }, null, glbFile01);

      // var glbFile03 = await fetch("res/meshes/glb/monster.glb").then(res => res.arrayBuffer().then(buf => uploadGLBModel(buf, TEST_ANIM.device)));
      TEST_ANIM.addGlbObj({
        material: {
          type: 'pong',
          useTextureFromGlb: true
        },
        useScale: true,
        scale: [20, 20, 20],
        position: {
          x: 40,
          y: -4,
          z: -70
        },
        name: 'firstGlb',
        texturesPaths: ['./res/meshes/glb/textures/mutant_origin.png']
      }, null, glbFile01);

      // woman
      var glbFile11 = await fetch("res/meshes/glb/woman1.glb").then(res => res.arrayBuffer().then(buf => (0, _webgpuGltf.uploadGLBModel)(buf, TEST_ANIM.device)));
      TEST_ANIM.addGlbObjInctance({
        material: {
          type: 'mirror',
          useTextureFromGlb: true
        },
        envMapParams: {
          baseColorMix: 0.75,
          mirrorTint: [0.9, 0.5, 1.0],
          // Slight cool tint
          reflectivity: 0.5,
          // 25% reflection blend
          illuminateColor: [0.3, 0.7, 1.0],
          // Soft cyan
          illuminateStrength: 0.1,
          // Gentle rim
          illuminatePulse: 0.001,
          // No pulse (static)
          fresnelPower: 5.0,
          // Medium-sharp edge
          envLodBias: 2.5,
          usePlanarReflection: false // ✅ Env map mode
        },
        useScale: true,
        scale: [20, 20, 20],
        position: {
          x: 0,
          y: -4,
          z: -20
        },
        name: 'woman1',
        texturesPaths: ['./res/meshes/glb/textures/mutant_origin.png', './res/textures/env-maps/sky1.webp']
      }, null, glbFile11);

      // var glbFile02 = await fetch("res/meshes/glb/woman1.glb").then(res => res.arrayBuffer().then(buf => uploadGLBModel(buf, TEST_ANIM.device)));
      TEST_ANIM.addGlbObj({
        material: {
          type: 'power',
          useTextureFromGlb: true
        },
        useScale: true,
        scale: [20, 20, 20],
        position: {
          x: -40,
          y: -4,
          z: -20
        },
        name: 'woman1',
        texturesPaths: ['./res/meshes/glb/textures/mutant_origin.png']
      }, null, glbFile11);

      // var glbFile03 = await fetch("res/meshes/glb/woman1.glb").then(res => res.arrayBuffer().then(buf => uploadGLBModel(buf, TEST_ANIM.device)));
      TEST_ANIM.addGlbObj({
        material: {
          type: 'pong',
          useTextureFromGlb: true
        },
        useScale: true,
        scale: [20, 20, 20],
        position: {
          x: 40,
          y: -4,
          z: -20
        },
        name: 'woman1',
        texturesPaths: ['./res/meshes/glb/textures/mutant_origin.png']
      }, null, glbFile11);

      // var glbFileWhouse = await fetch("res/meshes/glb/wood-house-1.glb").then(res => res.arrayBuffer().then(buf => uploadGLBModel(buf, TEST_ANIM.device)));
      // TEST_ANIM.addGlbObj({
      //   material: {type: 'pong', useTextureFromGlb: true},
      //   useScale: true,
      //   scale: [20, 20, 20],
      //   position: {x: 40, y: -4, z: -20},
      //   name: 'glbFileWhouse',
      //   texturesPaths: ['./res/meshes/glb/textures/mutant_origin.png'],
      // }, null, glbFileWhouse);

      // this is future load and replace skeletal anim.
      // const path = 'https://raw.githubusercontent.com/zlatnaspirala/Matrix-Engine-BVH-test/main/javascript-bvh/example.bvh';
      // const path = 'res/meshes/glb/glb-test1.bvh';
      // loadBVH(path).then(async (BVHANIM) => {
      //   var glbFile = await fetch(
      //     "res/meshes/glb/test.glb")
      //     .then(res => res.arrayBuffer().then(buf => uploadGLBModel(buf, TEST_ANIM.device)));
      //   TEST_ANIM.addGlbObj({
      //     // scale: [1,1,1],
      //     scale: [10, 10, 10],
      //     name: 'firstGlb',
      //     texturesPaths: ['./res/textures/rust.jpg'],
      //   }, BVHANIM, glbFile);
      // });
    });
    function onGround(m) {
      TEST_ANIM.addLight();
      TEST_ANIM.addMeshObj({
        material: {
          type: 'mirror'
        },
        envMapParams: {
          baseColorMix: 0.55,
          mirrorTint: [0.9, 0.95, 1.0],
          // Slight cool tint
          reflectivity: 0.95,
          // 25% reflection blend
          illuminateColor: [0.3, 0.7, 1.0],
          // Soft cyan
          illuminateStrength: 0.1,
          // Gentle rim
          illuminatePulse: 0.001,
          // No pulse (static)
          fresnelPower: 5.0,
          // Medium-sharp edge
          envLodBias: 2.5,
          usePlanarReflection: false // ✅ Env map mode
        },
        position: {
          x: 0,
          y: -5,
          z: -10
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        },
        rotationSpeed: {
          x: 0,
          y: 0,
          z: 0
        },
        texturesPaths: ['./res/textures/floor1.jpg', './res/textures/env-maps/sky1.webp'],
        name: 'ground',
        mesh: m.cube,
        physics: {
          enabled: false,
          mass: 0,
          geometry: "Cube"
        }
      });
      app.lightContainer[0].position[1] = 35;
      app.lightContainer[0].intensity = 6;
      app.activateBloomEffect();
      // app.activateVolumetricEffect();
      app.bloomPass.setIntensity(0.25);
    }
  });
  // just for dev
  window.app = TEST_ANIM;
}

// loadGLBLoader()

},{"../src/engine/loader-obj.js":44,"../src/engine/loaders/webgpu-gltf.js":47,"../src/world.js":96}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadObjFile = void 0;
var _world = _interopRequireDefault(require("../src/world.js"));
var _loaderObj = require("../src/engine/loader-obj.js");
var _utils = require("../src/engine/utils.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// import {addRaycastsAABBListener} from "../src/engine/raycast.js";

var loadObjFile = function () {
  let loadObjFile = new _world.default({
    useSingleRenderPass: true,
    canvasSize: 'fullscreen',
    mainCameraParams: {
      type: 'WASD',
      responseCoef: 1000
    },
    clearColor: {
      r: 0,
      b: 0.122,
      g: 0.122,
      a: 1
    }
  }, () => {
    addEventListener('AmmoReady', () => {
      (0, _loaderObj.downloadMeshes)({
        ball: "./res/meshes/blender/sphere.obj",
        cube: "./res/meshes/blender/cube.obj"
      }, onLoadObj, {
        scale: [2, 2, 2]
      });
      (0, _loaderObj.downloadMeshes)({
        cube: "./res/meshes/blender/cube.obj"
      }, onGround, {
        scale: [20, 1, 20]
      });
    });
    function onGround(m) {
      loadObjFile.addMeshObj({
        material: {
          type: 'mirror'
        },
        position: {
          x: 0,
          y: -5,
          z: -10
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        },
        rotationSpeed: {
          x: 0,
          y: 0,
          z: 0
        },
        texturesPaths: ['./res/textures/floor1.jpg', './res/textures/env-maps/sky1.webp'],
        envMapParams: {
          baseColorMix: 0.95,
          mirrorTint: [0.9, 0.95, 1.0],
          // Slight cool tint
          reflectivity: 0.25,
          // 25% reflection blend
          illuminateColor: [0.3, 0.7, 1.0],
          // Soft cyan
          illuminateStrength: 0.1,
          // Gentle rim
          illuminatePulse: 0.001,
          // No pulse (static)
          fresnelPower: 5.0,
          // Medium-sharp edge
          envLodBias: 2.5,
          usePlanarReflection: false // ✅ Env map mode
        },
        name: 'ground',
        mesh: m.cube,
        physics: {
          enabled: false,
          mass: 0,
          geometry: "Cube"
        }
      });
    }
    function onLoadObj(m) {
      loadObjFile.myLoadedMeshes = m;
      loadObjFile.addMeshObj({
        material: {
          type: 'mirror'
        },
        position: {
          x: 0,
          y: 3,
          z: -20
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        },
        rotationSpeed: {
          x: 0,
          y: 0,
          z: 0
        },
        texturesPaths: ['./res/textures/cube-g1.png', './res/textures/env-maps/sky1.webp'],
        name: 'cube1',
        mesh: m.cube,
        envMapParams: {
          baseColorMix: 0.2,
          // normal mix
          mirrorTint: [0.9, 0.95, 1.0],
          // Slight cool tint
          reflectivity: 0.95,
          // 25% reflection blend
          illuminateColor: [0.3, 0.7, 1.0],
          // Soft cyan
          illuminateStrength: 0.4,
          // Gentle rim
          illuminatePulse: 0.001,
          // No pulse (static)
          fresnelPower: 5.0,
          // Medium-sharp edge
          envLodBias: 2.5,
          usePlanarReflection: false // ✅ Env map mode
        },
        physics: {
          enabled: false,
          geometry: "Cube"
        },
        // pointerEffect: {
        //   // enabled: true,
        //   // flameEffect: true,
        //   // flameEmitter: true,
        // },
        raycast: {
          enabled: true,
          radius: 2
        }
      });
      loadObjFile.addMeshObj({
        material: {
          type: 'mirror'
        },
        position: {
          x: 0,
          y: -1,
          z: -20
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        },
        scale: [100, 100, 100],
        rotationSpeed: {
          x: 0,
          y: 0,
          z: 0
        },
        texturesPaths: ['./res/textures/cube-g1.png', './res/textures/env-maps/sky1.webp'],
        envMapParams: {
          baseColorMix: 0.0,
          // CLEAR SKY
          mirrorTint: [0.9, 0.95, 1.0],
          // Slight cool tint
          reflectivity: 0.25,
          // 25% reflection blend
          illuminateColor: [0.3, 0.7, 1.0],
          // Soft cyan
          illuminateStrength: 0.1,
          // Gentle rim
          illuminatePulse: 0.01,
          // No pulse (static)
          fresnelPower: 2.0,
          // Medium-sharp edge
          envLodBias: 1.5,
          usePlanarReflection: false // ✅ Env map mode
        },
        name: 'ball1',
        mesh: m.ball,
        physics: {
          enabled: false,
          geometry: "Sphere"
        }
      });
      console.log(`%c Test access scene ${TEST} object.`, _utils.LOG_MATRIX);
      loadObjFile.addLight();
      loadObjFile.lightContainer[0].behavior.setOsc0(-1, 1, 0.001);
      loadObjFile.lightContainer[0].behavior.value_ = -1;
      loadObjFile.lightContainer[0].updater.push(light => {
        light.position[0] = light.behavior.setPath0();
      });
      loadObjFile.lightContainer[0].position[1] = 11;
      var TEST = loadObjFile.getSceneObjectByName('cube2');
      setTimeout(() => {
        // app.activateBloomEffect();
        let cube1 = app.getSceneObjectByName('cube1');
        // cube1.effects.flameEffect.intensity = 100;
        // cube1.effects.flameEffect.morphTo("pyramid", 8)
        app.cameras.WASD.yaw = -0.03;
        app.cameras.WASD.pitch = -0.49;
        app.cameras.WASD.position[2] = 0;
        app.cameras.WASD.position[1] = 3.76;
      }, 800);
    }
  });
  window.app = loadObjFile;
};
exports.loadObjFile = loadObjFile;

},{"../src/engine/loader-obj.js":44,"../src/engine/utils.js":56,"../src/world.js":96}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadObjsSequence = void 0;
var _world = _interopRequireDefault(require("../src/world.js"));
var _loaderObj = require("../src/engine/loader-obj.js");
var _utils = require("../src/engine/utils.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var loadObjsSequence = function () {
  let loadObjFile = new _world.default({
    useSingleRenderPass: true,
    canvasSize: 'fullscreen',
    mainCameraParams: {
      type: 'WASD',
      responseCoef: 1000
    }
  }, () => {
    addEventListener('AmmoReady', () => {
      // Requied now
      loadObjFile.addLight();
      // Light
      app.lightContainer[0].position[2] = -20;
      app.lightContainer[0].position[1] = 25;
      app.lightContainer[0].intensity = 3;
      app.activateBloomEffect();
      app.bloomPass.setIntensity(0.25);
      (0, _loaderObj.downloadMeshes)({
        cube: "./res/meshes/blender/cube.obj"
      }, onGround, {
        scale: [20, 1, 20]
      });
      (0, _loaderObj.downloadMeshes)((0, _loaderObj.makeObjSeqArg)({
        id: "swat-walk-pistol",
        path: "res/meshes/objs-sequence/swat-walk-pistol",
        from: 1,
        to: 20
      }), onLoadObj, {
        scale: [0.1, 0.1, 0.1]
      });
    });
    function onLoadObj(m) {
      console.log(`%c Loaded objs: ${m} `, _utils.LOG_MATRIX);
      var objAnim = {
        id: "swat-walk-pistol",
        meshList: m,
        currentAni: 1,
        animations: {
          active: 'walk',
          walk: {
            from: 1,
            to: 20,
            speed: 3
          },
          walkPistol: {
            from: 36,
            to: 60,
            speed: 3
          }
        }
      };
      loadObjFile.addMeshObj({
        position: {
          x: 0,
          y: 0,
          z: -20
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        },
        rotationSpeed: {
          x: 0,
          y: 0,
          z: 0
        },
        useScale: true,
        scale: [100, 100, 100],
        texturesPaths: ['./res/meshes/blender/swat.png'],
        name: 'swat',
        mesh: m['swat-walk-pistol'],
        physics: {
          enabled: false,
          geometry: "Cube"
        },
        objAnim: objAnim
      });
      setTimeout(() => {
        app.cameras.WASD.pitch = -0.2605728267949113;
        app.cameras.WASD.yaw = -0.0580;
        app.cameras.WASD.position[1] = 15;
        app.cameras.WASD.position[2] = 11;
        app.getSceneObjectByName('swat').objAnim.play('walk');
      }, 200);
    }
    function onGround(m) {
      loadObjFile.addMeshObj({
        position: {
          x: 0,
          y: -1,
          z: -10
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        },
        rotationSpeed: {
          x: 0,
          y: 0,
          z: 0
        },
        texturesPaths: ['./res/meshes/blender/cube.png'],
        name: 'ground',
        mesh: m.cube,
        physics: {
          enabled: false,
          mass: 0,
          geometry: "Cube"
        }
      });
    }
  });
  window.app = loadObjFile;
};
exports.loadObjsSequence = loadObjsSequence;

},{"../src/engine/loader-obj.js":44,"../src/engine/utils.js":56,"../src/world.js":96}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.physicsPlayground = void 0;
var _world = _interopRequireDefault(require("../src/world.js"));
var _loaderObj = require("../src/engine/loader-obj.js");
var _utils = require("../src/engine/utils.js");
var _raycast = require("../src/engine/raycast.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var physicsPlayground = function () {
  let physicsPlayground = new _world.default({
    useSingleRenderPass: true,
    canvasSize: 'fullscreen',
    mainCameraParams: {
      type: 'WASD',
      responseCoef: 1000
    },
    clearColor: {
      r: 0,
      b: 0.122,
      g: 0.122,
      a: 1
    }
  }, () => {
    (0, _raycast.addRaycastsListener)();
    addEventListener('AmmoReady', () => {
      // downloadMeshes({
      //   ball: "./res/meshes/blender/sphere.obj",
      //   cube: "./res/meshes/blender/cube.obj",
      // }, onLoadObj,
      //   {scale: [1, 1, 1]})
      (0, _loaderObj.downloadMeshes)({
        cube: "./res/meshes/blender/cube.obj"
      }, onGround, {
        scale: [20, 0.01, 20]
      });

      // physicsPlayground.physicsBodiesGenerator(
      //   "standard",
      //   {x: 0, y: 0, z: -20},
      //   {x: 0, y: 0, z: 0},
      //   "res/textures/star1.png",
      //   "testGen",
      //   "Cube",
      //   false,
      //   [1, 1, 1],
      //   100
      // );

      // physicsPlayground.physicsBodiesGeneratorWall(
      //   "standard",
      //   {x: -10, y: 1, z: -20},
      //   {x: 0, y: 0, z: 0},
      //   "res/textures/star1.png",
      //   "cube",
      //   "10x3",
      //   true,
      //   [1, 1, 1],
      //   2,
      //   100
      // );

      // physicsPlayground.physicsBodiesGeneratorPyramid(
      //   "standard",
      //   {x: 0, y: 1, z: -20},
      //   {x: 0, y: 0, z: 0},
      //   "./res/meshes/blender/cube.png",
      //   "pyr",
      //   6,
      //   true,
      //   [1, 1, 1],
      //   2
      // );

      // 
      app.physicsBodiesGeneratorWall("mirror", {
        x: -4.5,
        y: 0,
        z: -10
      }, {
        x: 0,
        y: 0,
        z: 0
      }, ["./res/textures/rust.jpg", "./res/textures/env-maps/sky1.webp"], 'my_set_walls', "5x5", true, [1, 1, 1], 2, 70);
      let strength = 10;
      app.canvas.addEventListener("ray.hit.event", e => {
        console.log('ray.hit.event detected');
        let b = app.matrixAmmo.getBodyByName(e.detail.hitObject.name);
        const i = new Ammo.btVector3(e.detail.rayDirection[0] * strength, e.detail.rayDirection[1] * strength, e.detail.rayDirection[2] * strength);
        b.applyCentralImpulse(i);
      });

      // physicsPlayground.physicsBodiesGeneratorTower(
      //   "standard",
      //   {x: 0, y: 0, z: -20},
      //   {x: 0, y: 0, z: 0},
      //   "./res/meshes/blender/cube.png",
      //   "tower",
      //   10,
      //   true,
      //   [1, 1, 1],
      //   2
      // );
    });
    function onGround(m) {
      setTimeout(() => {
        app.cameras.WASD.yaw = -0.03;
        app.cameras.WASD.pitch = -0.49;
        app.cameras.WASD.position[2] = 0;
        app.cameras.WASD.position[1] = 3.76;
      }, 1000);
      physicsPlayground.addMeshObj({
        position: {
          x: 0,
          y: -3.5,
          z: -10
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        },
        rotationSpeed: {
          x: 0,
          y: 0,
          z: 0
        },
        texturesPaths: ['res/icons/editor/chatgpt-gen-bg-inv.png'],
        name: 'ground',
        mesh: m.cube,
        physics: {
          enabled: false,
          mass: 0,
          geometry: "Cube"
        }
        // raycast: { enabled: true , radius: 2 }
      });
      physicsPlayground.addLight();
      physicsPlayground.lightContainer[0].behavior.setOsc0(-1, 1, 0.001);
      physicsPlayground.lightContainer[0].behavior.value_ = -1;
      physicsPlayground.lightContainer[0].updater.push(light => {
        light.position[0] = light.behavior.setPath0();
      });
      physicsPlayground.lightContainer[0].position[1] = 14;
    }
    function onLoadObj(m) {
      physicsPlayground.myLoadedMeshes = m;
      physicsPlayground.addMeshObj({
        material: {
          type: 'standard'
        },
        position: {
          x: 0,
          y: 2,
          z: -20
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        },
        rotationSpeed: {
          x: 0,
          y: 0,
          z: 0
        },
        texturesPaths: ['./res/meshes/blender/cube.png'],
        name: 'cube1',
        mesh: m.cube,
        physics: {
          enabled: true,
          geometry: "Cube"
        },
        raycast: {
          enabled: true,
          radius: 1
        }
      });
      physicsPlayground.addMeshObj({
        material: {
          type: 'standard'
        },
        position: {
          x: 0,
          y: 2,
          z: -20
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        },
        rotationSpeed: {
          x: 0,
          y: 0,
          z: 0
        },
        texturesPaths: ['./res/meshes/blender/cube.png'],
        name: 'cube2',
        mesh: m.cube,
        physics: {
          enabled: false,
          geometry: "Cube"
        },
        raycast: {
          enabled: true,
          radius: 1
        }
      });
      physicsPlayground.addMeshObj({
        material: {
          type: 'standard'
        },
        position: {
          x: 0,
          y: -1,
          z: -20
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        },
        rotationSpeed: {
          x: 0,
          y: 111,
          z: 0
        },
        texturesPaths: ['./res/meshes/blender/cube.png'],
        name: 'ball1',
        mesh: m.ball,
        physics: {
          enabled: true,
          geometry: "Sphere"
        },
        raycast: {
          enabled: true,
          radius: 1
        }
      });
      var TEST = physicsPlayground.getSceneObjectByName('cube1');
      console.log(`%c Test access scene ${TEST} object.`, _utils.LOG_MATRIX);
      let mybodycube = app.matrixAmmo.getBodyByName('cube1');
      let mybodycube2 = app.matrixAmmo.getBodyByName('cube2');

      // const pivotA = new Ammo.btVector3(0, 0, 0); // door local pivot
      // const pivotB = new Ammo.btVector3(0, 0, 0); // frame local pivot

      // const axisA = new Ammo.btVector3(0, 1, 0); // Y axis
      // const axisB = new Ammo.btVector3(0, 1, 0);

      // const hinge = new Ammo.btHingeConstraint(
      //   mybodycube,
      //   mybodycube2,
      //   pivotA,
      //   pivotB,
      //   axisA,
      //   axisB,
      //   true
      // );

      // hinge.setLimit(-Math.PI / 2, Math.PI / 2); // 90° open
      // physicsPlayground.matrixAmmo.dynamicsWorld.addConstraint(hinge, true);
      //  app.matrixAmmo.getBodyByName(`CubePhysics${x}`).setAngularVelocity(new Ammo.btVector3(
      //      randomFloatFromTo(3, 12), 9, 9
      // ))

      physicsPlayground.canvas.addEventListener("ray.hit.event", e => {
        console.log('ray.hit.event detected', e.detail);
        const body = app.matrixAmmo.getBodyByName(e.detail.hitObject.name);

        // ------------------------------------------------------
        // body.setAngularVelocity(new Ammo.btVector3(0, 9, 9));
        // ------------------------------------------------------

        // ------------------------------------------------------
        const impulse = new Ammo.btVector3(0, 5, 0);
        body.applyCentralImpulse(impulse);
        // ------------------------------------------------------

        // ------------------------------------------------------
        // const torque = new Ammo.btVector3(0, 10, 0);
        // body.applyTorqueImpulse(torque);
        // ------------------------------------------------------

        // ------------------------------------------------------
        // const dir = e.detail.rayDirection;
        // const strength = 20;

        // const impulse = new Ammo.btVector3(
        //   dir[0] * strength,
        //   dir[1] * strength,
        //   dir[2] * strength
        // );

        // body.applyCentralImpulse(impulse);
        // // ------------------------------------------------------

        // // ------------------------------------------------------
        // body.activate(true);
        // ------------------------------------------------------

        //
        // PhysicsMaterials = {
        //   metal: {friction: 0.4, restitution: 0.1},
        //   rubber: {friction: 1.0, restitution: 0.9},
        //   ice: {friction: 0.01, restitution: 0.0}
        // };
        // body.setFriction(mat.friction);
        // body.setRestitution(mat.restitution);

        // explode(position, radius, strength) {
        //   for(const body of this.bodies) {
        //     const p = body.getWorldTransform().getOrigin();
        //     const dx = p.x() - position[0];
        //     const dy = p.y() - position[1];
        //     const dz = p.z() - position[2];

        //     const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
        //     if(dist > radius) continue;

        //     const force = strength / (dist + 0.1);
        //     body.activate(true);
        //     body.applyCentralImpulse(
        //       new Ammo.btVector3(dx * force, dy * force, dz * force)
        //     );
        //   }
        // }
      });
    }
  });
  // just for dev
  window.app = physicsPlayground;
};
exports.physicsPlayground = physicsPlayground;

},{"../src/engine/loader-obj.js":44,"../src/engine/raycast.js":55,"../src/engine/utils.js":56,"../src/world.js":96}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadVideoTexture = void 0;
var _world = _interopRequireDefault(require("../src/world.js"));
var _loaderObj = require("../src/engine/loader-obj.js");
var _utils = require("../src/engine/utils.js");
var _raycast = require("../src/engine/raycast.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// @group(0) @binding(5) var<uniform> postFXMode: u32;
var loadVideoTexture = function () {
  let videoTexture = new _world.default({
    useSingleRenderPass: true,
    canvasSize: 'fullscreen',
    mainCameraParams: {
      type: 'WASD',
      responseCoef: 1000
    },
    clearColor: {
      r: 0,
      b: 0.122,
      g: 0.122,
      a: 1
    }
  }, () => {
    // For now one light perscene must be added.
    // if you dont wanna light just use intesity = 0
    // videoTexture is app main instance
    videoTexture.addLight();
    (0, _raycast.addRaycastsAABBListener)();
    videoTexture.canvas.addEventListener("ray.hit.event", e => {
      console.log('test ray after shadows merge');
    });
    addEventListener('AmmoReady', () => {
      (0, _loaderObj.downloadMeshes)({
        welcomeText: "./res/meshes/blender/piramyd.obj",
        armor: "./res/meshes/obj/armor.obj",
        sphere: "./res/meshes/blender/sphere.obj",
        cube: "./res/meshes/blender/cube.obj"
      }, onLoadObj, {
        scale: [1, 1, 1]
      });
    });
    function onLoadObj(m) {
      videoTexture.myLoadedMeshes = m;
      for (var key in m) {
        console.log(`%c Loaded objs: ${key} `, _utils.LOG_MATRIX);
      }
      videoTexture.addMeshObj({
        position: {
          x: 0,
          y: 2,
          z: -10
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        },
        rotationSpeed: {
          x: 0,
          y: 0,
          z: 0
        },
        texturesPaths: ['./res/meshes/blender/cube.png'],
        name: 'MyVideoTex',
        mesh: m.cube,
        physics: {
          enabled: true,
          geometry: "Cube"
        },
        raycast: {
          enabled: true,
          radius: 12
        }
      });
      var TEST = videoTexture.getSceneObjectByName('MyVideoTex');
      console.log(`%c Test video-texture...`, _utils.LOG_MATRIX);
      TEST.loadVideoTexture({
        type: 'video',
        src: 'res/videos/tunel.mp4'
      });
    }
  });
  window.app = videoTexture;
};
exports.loadVideoTexture = loadVideoTexture;

},{"../src/engine/loader-obj.js":44,"../src/engine/raycast.js":55,"../src/engine/utils.js":56,"../src/world.js":96}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _bvhLoader = require("./module/bvh-loader");
var _default = exports.default = _bvhLoader.MEBvh;

},{"./module/bvh-loader":9}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MEBvhJoint = exports.MEBvh = void 0;
exports.degToRad = degToRad;
exports.dot3vs1 = dot3vs1;
exports.euler2mat = euler2mat;
exports.mat2euler = mat2euler;
exports.multiply = multiply;
var _webgpuMatrix = require("webgpu-matrix");
/**
 * @description Manual convert python script BVH
 * from https://github.com/dabeschte/npybvh to the JS.
 * @author Nikola Lukic
 * @license GPL-V3
 */

function degToRad(degrees) {
  return degrees * Math.PI / 180;
}
;
function arraySum3(a, b) {
  var rez1 = a[0] + b[0];
  var rez2 = a[1] + b[1];
  var rez3 = a[2] + b[2];
  return [rez1, rez2, rez3];
}
function deg2rad(degrees) {
  return degrees * (Math.PI / 180);
}
function npdeg2rad(degrees) {
  return [degrees[0] * (Math.PI / 180), degrees[1] * (Math.PI / 180), degrees[2] * (Math.PI / 180)];
}
function rad2deg(radians) {
  return radians * (180 / Math.PI);
}
function byId(id) {
  return document.getElementById(id);
}

// fix for .dot N-dim vs 1D-dim Array
function dot3vs1(a, b) {
  var aNumRows = a.length,
    aNumCols = a[0].length,
    bNumRows = b.length;
  var REZ1 = 0,
    REZ2 = 0,
    REZ3 = 0;
  if (aNumRows == 3 && aNumCols == 3 && bNumRows == 3) {
    for (var j = 0; j < a.length; j++) {
      // First root of 3x3 a.
      REZ1 += a[0][j] * b[j];
      REZ2 += a[1][j] * b[j];
      REZ3 += a[2][j] * b[j];
    }
    var finalRez = [REZ1, REZ2, REZ3];
    return finalRez;
  } else {
    console.error("Bad arguments for dot3vs1");
  }
}
function multiply(a, b) {
  var aNumRows = a.length,
    aNumCols = a[0].length,
    bNumRows = b.length,
    bNumCols = b[0].length,
    m = new Array(aNumRows);
  for (var r = 0; r < aNumRows; ++r) {
    m[r] = new Array(bNumCols);
    for (var c = 0; c < bNumCols; ++c) {
      m[r][c] = 0;
      for (var i = 0; i < aNumCols; ++i) {
        m[r][c] += a[r][i] * b[i][c];
      }
    }
  }
  return m;
}

/**
 * @description
 * Euler's rotation theorem tells us that any rotation in 3D can be described by 3
 * angles.  Let's call the 3 angles the *Euler angle vector* and call the angles
 * in the vector :Math:`alpha`, :Math:`beta` and :Math:`gamma`.  The vector is [
 * :Math:`alpha`, :Math:`beta`. :Math:`gamma` ] and, in this description, the
 * order of the parameters specifies the order in which the rotations occur (so
 * the rotation corresponding to :Math:`alpha` is applied first).
 * @source https://github.com/matthew-brett/transforms3d/blob/master/transforms3d/euler.py
 */

// map axes strings to/from tuples of inner axis, parity, repetition, frame
var _AXES2TUPLE = {
  'sxyz': [0, 0, 0, 0],
  'sxyx': [0, 0, 1, 0],
  'sxzy': [0, 1, 0, 0],
  'sxzx': [0, 1, 1, 0],
  'syzx': [1, 0, 0, 0],
  'syzy': [1, 0, 1, 0],
  'syxz': [1, 1, 0, 0],
  'syxy': [1, 1, 1, 0],
  'szxy': [2, 0, 0, 0],
  'szxz': [2, 0, 1, 0],
  'szyx': [2, 1, 0, 0],
  'szyz': [2, 1, 1, 0],
  'rzyx': [0, 0, 0, 1],
  'rxyx': [0, 0, 1, 1],
  'ryzx': [0, 1, 0, 1],
  'rxzx': [0, 1, 1, 1],
  'rxzy': [1, 0, 0, 1],
  'ryzy': [1, 0, 1, 1],
  'rzxy': [1, 1, 0, 1],
  'ryxy': [1, 1, 1, 1],
  'ryxz': [2, 0, 0, 1],
  'rzxz': [2, 0, 1, 1],
  'rxyz': [2, 1, 0, 1],
  'rzyz': [2, 1, 1, 1]
};

// axis sequences for Euler angles
var _NEXT_AXIS = [1, 2, 0, 1];
function euler2mat(ai, aj, ak, axes) {
  if (typeof axes === 'undefined') var axes = 'sxyz';
  // Return rotation matrix from Euler angles and axis sequence.
  // Parameters
  /*
  ai : float
      First rotation angle (according to `axes`).
  aj : float
      Second rotation angle (according to `axes`).
  ak : float
      Third rotation angle (according to `axes`).
  axes : str, optional
      Axis specification; one of 24 axis sequences as string or encoded
      tuple - e.g. ``sxyz`` (the default).
  Returns
  -------
  mat : array (3, 3)
      Rotation matrix or affine.
  Examples
  --------
  >>> R = euler2mat(1, 2, 3, 'syxz')
  >>> np.allclose(np.sum(R[0]), -1.34786452)
  True
  >>> R = euler2mat(1, 2, 3, (0, 1, 0, 1))
  >>> np.allclose(np.sum(R[0]), -0.383436184)
  True */
  try {
    var firstaxis = _AXES2TUPLE[axes][0],
      parity = _AXES2TUPLE[axes][1],
      repetition = _AXES2TUPLE[axes][2],
      frame = _AXES2TUPLE[axes][3];
  } catch (AttributeError) {
    // _TUPLE2AXES[axes]  # validation
    // firstaxis, parity, repetition, frame = axes
    console.error("AttributeError: ", AttributeError);
  }
  var i = firstaxis;
  var j = _NEXT_AXIS[i + parity];
  var k = _NEXT_AXIS[i - parity + 1];
  if (frame) {
    ai = ak;
    ak = ai;
  }
  if (parity) {
    ai = -ai;
    aj = -aj;
    ak = -ak;
  }
  var si = Math.sin(ai);
  var sj = Math.sin(aj);
  var sk = Math.sin(ak);
  var ci = Math.cos(ai);
  var cj = Math.cos(aj);
  var ck = Math.cos(ak);
  var cc = ci * ck;
  var cs = ci * sk;
  var sc = si * ck;
  var ss = si * sk;

  // M = np.eye(3)
  var M = [[1., 0., 0], [0., 1., 0], [0., 0., 1]];
  if (repetition) {
    M[i][i] = cj;
    M[i][j] = sj * si;
    M[i][k] = sj * ci;
    M[j][i] = sj * sk;
    M[j][j] = -cj * ss + cc;
    M[j][k] = -cj * cs - sc;
    M[k][i] = -sj * ck;
    M[k][j] = cj * sc + cs;
    M[k][k] = cj * cc - ss;
  } else {
    M[i][i] = cj * ck;
    M[i][j] = sj * sc - cs;
    M[i][k] = sj * cc + ss;
    M[j][i] = cj * sk;
    M[j][j] = sj * ss + cc;
    M[j][k] = sj * cs - sc;
    M[k][i] = -sj;
    M[k][j] = cj * si;
    M[k][k] = cj * ci;
  }
  return M;
}

/**
 * @description
 * How to calculate the angle from rotation matrix.
 */
function mat2euler(M, rad2deg_flag) {
  var pitch_1, pitch_2, roll_1, roll_2, yaw_1, yaw_2, pitch, roll, yaw;
  if (M[2][0] != 1 & M[2][0] != -1) {
    pitch_1 = -1 * Math.asin(M[2][0]);
    pitch_2 = Math.PI - pitch_1;
    roll_1 = Math.atan2(M[2][1] / Math.cos(pitch_1), M[2][2] / Math.cos(pitch_1));
    roll_2 = Math.atan2(M[2][1] / Math.cos(pitch_2), M[2][2] / Math.cos(pitch_2));
    yaw_1 = Math.atan2(M[1][0] / Math.cos(pitch_1), M[0][0] / Math.cos(pitch_1));
    yaw_2 = Math.atan2(M[1][0] / Math.cos(pitch_2), M[0][0] / Math.cos(pitch_2));
    pitch = pitch_1;
    roll = roll_1;
    yaw = yaw_1;
  } else {
    yaw = 0;
    if (M[2][0] == -1) {
      pitch = Math.PI / 2;
      roll = yaw + Math.atan2(M[0][1], M[0][2]);
    } else {
      pitch = -Math.PI / 2;
      roll = -1 * yaw + Math.atan2(-1 * M[0][1], -1 * M[0][2]);
    }
  }
  if (typeof rad2deg_flag !== "undefined") {
    // convert from radians to degrees
    roll = roll * 180 / Math.PI;
    pitch = pitch * 180 / Math.PI;
    yaw = yaw * 180 / Math.PI;
  }
  return [roll, pitch, yaw];
}
class MEBvhJoint {
  constructor(name, parent) {
    this.name = name;
    this.parent = parent;
    this.offset = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    this.channels = [];
    this.children = [];

    // New: where in the frame array this joint’s channels start ???
    this.channelOffset = 0;
  }
  add_child(child) {
    this.children.push(child);
  }
  __repr__() {
    return this.name;
  }
  position_animated() {
    var detFlag = false;
    for (const item in this.channels) {
      if (this.channels[item].endsWith("position") == true) {
        detFlag = true;
      }
    }
    return detFlag;
  }
  rotation_animated() {
    var detFlag = false;
    for (const item in this.channels) {
      if (this.channels[item].endsWith("rotation") == true) {
        detFlag = true;
      }
    }
    return detFlag;
  }
  createIdentityMatrix() {
    // Returns a flat Float32Array of length 16 (column-major)
    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  matrixFromKeyframe(frameData) {
    const m = this.createIdentityMatrix();
    let t = [0, 0, 0];
    let r = [0, 0, 0];
    for (let i = 0; i < this.channels.length; i++) {
      const channel = this.channels[i];
      const value = frameData[this.channelOffset + i];
      // channelOffset = index into frameData where this joint’s values start

      switch (channel) {
        case 'Xposition':
          t[0] = value;
          break;
        case 'Yposition':
          t[1] = value;
          break;
        case 'Zposition':
          t[2] = value;
          break;
        case 'Xrotation':
          r[0] = degToRad(value);
          break;
        case 'Yrotation':
          r[1] = degToRad(value);
          break;
        case 'Zrotation':
          r[2] = degToRad(value);
          break;
      }
    }

    // Apply translation
    _webgpuMatrix.mat4.translate(m, t, m);
    // Apply rotations in BVH order (important!)
    _webgpuMatrix.mat4.rotateX(m, r[0], m);
    _webgpuMatrix.mat4.rotateY(m, r[1], m);
    _webgpuMatrix.mat4.rotateZ(m, r[2], m);
    return m;
  }
}
exports.MEBvhJoint = MEBvhJoint;
class MEBvh {
  constructor() {
    this.joints = {};
    this.root = null;
    this.keyframes = null;
    this.frames = 0;
    this.fps = 0;
    this.myName = "MATRIX-ENGINE-BVH";
    // new
    this.jointOrder = []; // array to store joints in order
  }
  computeJointOrder() {
    this.jointOrder = [];
    const traverse = joint => {
      this.jointOrder.push(joint.name);
      for (const child of joint.children) {
        traverse(child);
      }
    };
    traverse(this.root); // root is your MEBvhJoint
  }
  computeChannelOffsets() {
    let offset = 0;
    const walk = joint => {
      joint.channelOffset = offset; // assign
      offset += joint.channels.length; // advance
      for (const child of joint.children) {
        walk(child);
      }
    };
    if (this.root) walk(this.root);
    this.totalChannels = offset; // store total for frame allocation
  }
  async parse_file(link) {
    return new Promise((resolve, reject) => {
      fetch(link).then(event => {
        event.text().then(text => {
          var hierarchy = text.split("MOTION")[0];
          var motion = text.split("MOTION")[1];
          var newLog = document.createElement("div");
          newLog.innerHTML += '<h2>Hierarchy</h2>';
          newLog.innerHTML += '<p>' + hierarchy + '</p>';
          var newLog2 = document.createElement("span");
          newLog2.innerHTML += '<h2>Motion</h2>';
          newLog2.innerHTML += '<p class="paragraf fixHeight" >' + motion + '</p>';
          if (byId && byId('log') !== null) {
            byId('log').appendChild(newLog2);
            byId('log').appendChild(newLog);
          }
          this._parse_hierarchy(hierarchy);
          this.computeJointOrder();
          this.computeChannelOffsets(); // <— must do this here NEW
          this.parse_motion(motion);
          resolve();
        });
      });
    });
  }
  _parse_hierarchy(text) {
    var lines = text.split(/\s*\n+\s*/);
    var joint_stack = [];
    for (var key in lines) {
      var line = lines[key];
      var words = line.split(/\s+/);
      var instruction = words[0];
      var parent = null;
      if (instruction == "JOINT" || instruction == "ROOT") {
        if (instruction == "JOINT") {
          // -1 py -> last item
          parent = joint_stack[joint_stack.length - 1];
        } else {
          parent = null;
        }
        var joint = new MEBvhJoint(words[1], parent);
        this.joints[joint.name] = joint;
        if (parent != null) {
          parent.add_child(joint);
        }
        joint_stack.push(joint);
        if (instruction == "ROOT") {
          this.root = joint;
        }
      } else if (instruction == "CHANNELS") {
        for (var j = 2; j < words.length; j++) {
          joint_stack[joint_stack.length - 1].channels.push(words[j]);
        }
      } else if (instruction == "OFFSET") {
        for (var j = 1; j < words.length; j++) {
          joint_stack[joint_stack.length - 1].offset[j - 1] = parseFloat(words[j]);
        }
      } else if (instruction == "End") {
        var joint = new MEBvhJoint(joint_stack[joint_stack.length - 1].name + "_end", joint_stack[joint_stack.length - 1]);
        joint_stack[joint_stack.length - 1].add_child(joint);
        joint_stack.push(joint);
        this.joints[joint.name] = joint;
      } else if (instruction == "}") {
        joint_stack.pop();
      }
    }
  }
  _add_pose_recursive(joint, offset, poses) {
    var newLog1 = document.createElement("span");
    newLog1.innerHTML += '<h2>add_pose_recursive</h2>';
    newLog1.innerHTML += '<p class="paragraf" >Joint Name: ' + joint.name + '</p>';
    newLog1.innerHTML += '<p>joint.parent    : ' + (joint.parent != null ? joint.parent.name : 'null') + '</p>';
    newLog1.innerHTML += '<p>joint.offset    : ' + joint.offset + '</p>';
    newLog1.innerHTML += '<p>joint.children.length  : ' + joint.children.length + '</p>';
    joint.children.length != 0 ? newLog1.innerHTML += '<p> Childrens: ' : newLog1.innerHTML += 'No Childrens ';
    joint.children.forEach(iJoint => {
      newLog1.innerHTML += ' ' + iJoint['name'] + ' , ';
    });
    newLog1.innerHTML += '</p>';
    newLog1.innerHTML += '<p>Argument offset : ' + offset + '</p>';
    byId('log').appendChild(newLog1);
    var pose = arraySum3(joint.offset, offset);
    poses.push(pose);
    for (var c in joint.children) {
      this._add_pose_recursive(joint.children[c], pose, poses);
    }
  }
  plot_hierarchy() {
    // import matplotlib.pyplot as plt
    // from mpl_toolkits.mplot3d import axes3d, Axes3D

    var poses = [];
    this._add_pose_recursive(this.root, [0, 0, 0], poses);

    // pos = np.array(poses);

    /* Draw staff DISABLED
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')
        ax.scatter(pos[:, 0], pos[:, 2], pos[:, 1])
        ax.set_xlim(-30, 30)
        ax.set_ylim(-30, 30)
        ax.set_zlim(-30, 30)
        plt.show() */
  }
  parse_motion(text) {
    var lines = text.split(/\s*\n+\s*/);
    var frame = 0;
    for (var key in lines) {
      var line = lines[key];
      if (line == "") {
        continue;
      }
      var words = line.split(/\s+/);
      if (line.startsWith("Frame Time:")) {
        this.fps = Math.round(1 / parseFloat(words[2]));
        continue;
      }
      if (line.startsWith("Frames:")) {
        this.frames = parseInt(words[1]);
        continue;
      }
      if (this.keyframes == null) {
        // OK this is just costruction (define) with random values.
        var localArr = Array.from(Array(this.frames), () => new Array(words.length));
        this.keyframes = localArr;
      }
      for (var angle_index = 0; angle_index < words.length; angle_index++) {
        this.keyframes[frame][angle_index] = parseFloat(words[angle_index]);
      }
      frame += 1;
    }
  }
  _extract_rotation(frame_pose, index_offset, joint) {
    var local_rotation = [0, 0, 0],
      M_rotation;
    for (var key in joint.channels) {
      var channel = joint.channels[key];
      if (channel.endsWith("position")) {
        continue;
      }
      if (channel == "Xrotation") {
        local_rotation[0] = frame_pose[index_offset];
      } else if (channel == "Yrotation") {
        local_rotation[1] = frame_pose[index_offset];
      } else if (channel == "Zrotation") {
        local_rotation[2] = frame_pose[index_offset];
      } else {
        console.warn("Unknown channel {channel}");
        // raise Exception(f"Unknown channel {channel}");
      }
      index_offset += 1;
    }
    local_rotation = npdeg2rad(local_rotation);
    M_rotation = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
    for (key in joint.channels) {
      var channel = joint.channels[key];
      if (channel.endsWith("position")) {
        continue;
      }
      var euler_rot;
      if (channel == "Xrotation") {
        // console.warn("local_rotation " + local_rotation);
        euler_rot = [local_rotation[0], 0., 0.];
      } else if (channel == "Yrotation") {
        euler_rot = [0., local_rotation[1], 0.];
      } else if (channel == "Zrotation") {
        euler_rot = [0., 0., local_rotation[2]];
      } else {
        console.warn("Unknown channel {channel}");
      }
      var M_channel = euler2mat(euler_rot[0], euler_rot[1], euler_rot[2], euler_rot[3]);
      var M_rotation = multiply(M_rotation, M_channel);
    }
    return [M_rotation, index_offset];
  }
  _extract_position(joint, frame_pose, index_offset) {
    var offset_position = [0, 0, 0];
    for (var key in joint.channels) {
      var channel = joint.channels[key];
      if (channel.endsWith("rotation")) {
        continue;
      }
      if (channel == "Xposition") {
        offset_position[0] = frame_pose[index_offset];
      } else if (channel == "Yposition") {
        offset_position[1] = frame_pose[index_offset];
      } else if (channel == "Zposition") {
        offset_position[2] = frame_pose[index_offset];
      } else {
        console.warn("Unknown channel {channel}");
        // raise Exception(f"Unknown channel {channel}")
      }
      index_offset += 1;
    }
    return [offset_position, index_offset];
  }
  _recursive_apply_frame(joint, frame_pose, index_offset, p, r, M_parent, p_parent) {
    var joint_index;
    if (joint.position_animated()) {
      var local = this._extract_position(joint, frame_pose, index_offset);
      var offset_position = local[0],
        index_offset = local[1];
    } else {
      var offset_position = [0, 0, 0];
    }
    if (joint.channels.length == 0) {
      var local2 = 0;
      for (var item in this.joints) {
        if (joint.name == item) {
          joint_index = local2;
        }
        local2++;
      }
      p[joint_index] = arraySum3(p_parent, dot3vs1(M_parent, joint.offset));
      r[joint_index] = mat2euler(M_parent);
      return index_offset;
    }
    if (joint.rotation_animated()) {
      var local2 = this._extract_rotation(frame_pose, index_offset, joint);
      var M_rotation = local2[0];
      index_offset = local2[1];
    } else {
      var M_rotation = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
    }
    var M = multiply(M_parent, M_rotation);
    // https://www.khanacademy.org/math/precalculus/x9e81a4f98389efdf:matrices/x9e81a4f98389efdf:adding-and-subtracting-matrices/e/matrix_addition_and_subtraction

    var position = arraySum3(p_parent, dot3vs1(M_parent, joint.offset));
    position = arraySum3(position, offset_position);
    var rotation = mat2euler(M, "rad2deg");

    // just find by id
    var local = 0;
    for (const item in this.joints) {
      if (joint.name == item) {
        joint_index = local;
      }
      local++;
    }
    p[joint_index] = position;
    r[joint_index] = rotation;
    for (var c in joint.children) {
      index_offset = this._recursive_apply_frame(joint.children[c], frame_pose, index_offset, p, r, M, position);
    }
    return index_offset;
  }
  frame_pose(frame) {
    var jointLength = 0;
    for (var x in this.joints) {
      jointLength++;
    }
    var p = Array.from(Array(jointLength), () => [0, 0, 0]);
    var r = Array.from(Array(jointLength), () => [0, 0, 0]);
    var frame_pose = this.keyframes[frame];
    var M_parent = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    M_parent[0][0] = 1;
    M_parent[1][1] = 1;
    M_parent[2][2] = 1;
    this._recursive_apply_frame(this.root, frame_pose, 0, p, r, M_parent, [0, 0, 0]);
    return [p, r];
  }
  all_frame_poses() {
    var jointLength = 0;
    for (var x in this.joints) {
      jointLength++;
    }
    var p = Array.from({
      length: this.frames
    }, () => Array.from({
      length: jointLength
    }, () => [0, 0, 0]));
    var r = Array.from({
      length: this.frames
    }, () => Array.from({
      length: jointLength
    }, () => [0, 0, 0]));
    for (var frame = 0; frame < this.keyframes.length; frame++) {
      var local3 = this.frame_pose(frame);
      p[frame] = local3[0];
      r[frame] = local3[1];
    }
    return [p, r];
  }
  _plot_pose(p, r, fig, ax) {
    /* 
      _plot_pose(p, r, fig=None, ax=None) {
        import matplotlib.pyplot as plt
        from mpl_toolkits.mplot3d import axes3d, Axes3D
      if fig is None:
          fig = plt.figure()
      if ax is None:
          ax = fig.add_subplot(111, projection='3d')
      ax.cla()
      ax.scatter(p[:, 0], p[:, 2], p[:, 1])
      ax.set_xlim(-30, 30)
      ax.set_ylim(-30, 30)
      ax.set_zlim(-1, 59)
      plt.draw()
      plt.pause(0.001)
    */
  }

  // Meybe helps for draw
  // plot_frame(frame, fig=None, ax=None) {
  plot_frame(frame, fig, ax) {
    // ????
    // p, (r = this.frame_pose(frame));
    // this._plot_pose(p, r, fig, ax);
  }
  joint_names() {
    var keys = [];
    for (var key in this.joints) {
      keys.push(key);
    }
    return keys;
  }
  plot_all_frames() {
    /*
      import matplotlib.pyplot as plt
      from mpl_toolkits.mplot3d import axes3d, Axes3D
      fig = plt.figure()
      ax = fig.add_subplot(111, projection='3d')
      for i in range(self.frames) {
          self.plot_frame(i, fig, ax);
      } 
    */
  }
  __repr__() {
    return `BVH.JS ${this.joints.keys().length} joints, ${this.frames} frames`;
  }
}
exports.MEBvh = MEBvh;

},{"webgpu-matrix":21}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RANDOM = exports.EPSILON = exports.ARRAY_TYPE = exports.ANGLE_ORDER = void 0;
exports.equals = equals;
exports.round = round;
exports.setMatrixArrayType = setMatrixArrayType;
exports.toDegree = toDegree;
exports.toRadian = toRadian;
/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
var EPSILON = exports.EPSILON = 0.000001;
var ARRAY_TYPE = exports.ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = exports.RANDOM = Math.random;
var ANGLE_ORDER = exports.ANGLE_ORDER = "zyx";

/**
 * Symmetric round
 * see https://www.npmjs.com/package/round-half-up-symmetric#user-content-detailed-background
 *
 * @param {Number} a value to round
 */
function round(a) {
  if (a >= 0) return Math.round(a);
  return a % 0.5 === 0 ? Math.floor(a) : Math.round(a);
}

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
var radian = 180 / Math.PI;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Convert Radian To Degree
 *
 * @param {Number} a Angle in Radians
 */
function toDegree(a) {
  return a * radian;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a          The first number to test.
 * @param {Number} b          The second number to test.
 * @param {Number} tolerance  Absolute or relative tolerance (default glMatrix.EPSILON)
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSILON;
  return Math.abs(a - b) <= tolerance * Math.max(1, Math.abs(a), Math.abs(b));
}

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec4 = exports.vec3 = exports.vec2 = exports.quat2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = void 0;
var glMatrix = _interopRequireWildcard(require("./common.js"));
exports.glMatrix = glMatrix;
var mat2 = _interopRequireWildcard(require("./mat2.js"));
exports.mat2 = mat2;
var mat2d = _interopRequireWildcard(require("./mat2d.js"));
exports.mat2d = mat2d;
var mat3 = _interopRequireWildcard(require("./mat3.js"));
exports.mat3 = mat3;
var mat4 = _interopRequireWildcard(require("./mat4.js"));
exports.mat4 = mat4;
var quat = _interopRequireWildcard(require("./quat.js"));
exports.quat = quat;
var quat2 = _interopRequireWildcard(require("./quat2.js"));
exports.quat2 = quat2;
var vec2 = _interopRequireWildcard(require("./vec2.js"));
exports.vec2 = vec2;
var vec3 = _interopRequireWildcard(require("./vec3.js"));
exports.vec3 = vec3;
var vec4 = _interopRequireWildcard(require("./vec4.js"));
exports.vec4 = vec4;
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }

},{"./common.js":10,"./mat2.js":12,"./mat2d.js":13,"./mat3.js":14,"./mat4.js":15,"./quat.js":16,"./quat2.js":17,"./vec2.js":18,"./vec3.js":19,"./vec4.js":20}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LDU = LDU;
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromValues = fromValues;
exports.identity = identity;
exports.invert = invert;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.rotate = rotate;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transpose = transpose;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }
  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2 | null} out, or null if source matrix is not invertible
 */
function invert(out, a) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];

  // Calculate the determinant
  var det = a0 * a3 - a2 * a1;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is necessary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function scale(out, a, v) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var v0 = v[0],
    v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3]);
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
var sub = exports.sub = subtract;

},{"./common.js":10}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.identity = identity;
exports.invert = invert;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.rotate = rotate;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.translate = translate;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(6);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
function fromValues(a, b, c, d, tx, ty) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d | null} out, or null if source matrix is not invertible
 */
function invert(out, a) {
  var aa = a[0],
    ab = a[1],
    ac = a[2],
    ad = a[3];
  var atx = a[4],
    aty = a[5];
  var det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply(out, a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function rotate(out, a, rad) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
function scale(out, a, v) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5];
  var v0 = v[0],
    v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
function translate(out, a, v) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5];
  var v0 = v[0],
    v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[4] * a[4] + a[5] * a[5] + 1);
}

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
var sub = exports.sub = subtract;

},{"./common.js":10}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromMat2d = fromMat2d;
exports.fromMat4 = fromMat4;
exports.fromQuat = fromQuat;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.identity = identity;
exports.invert = invert;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.rotate = rotate;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.translate = translate;
exports.transpose = transpose;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
      a02 = a[2],
      a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3 | null} out, or null if source matrix is not invertible
 */
function invert(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  var b00 = b[0],
    b01 = b[1],
    b02 = b[2];
  var b10 = b[3],
    b11 = b[4],
    b12 = b[5];
  var b20 = b[6],
    b21 = b[7],
    b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a10 = a[3],
    a11 = a[4],
    a12 = a[5],
    a20 = a[6],
    a21 = a[7],
    a22 = a[8],
    x = v[0],
    y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a10 = a[3],
    a11 = a[4],
    a12 = a[5],
    a20 = a[6],
    a21 = a[7],
    a22 = a[8],
    s = Math.sin(rad),
    c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  var x = v[0],
    y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */
function fromQuat(out, q) {
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}

/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */
function normalFromMat4(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[4] * a[4] + a[5] * a[5] + a[6] * a[6] + a[7] * a[7] + a[8] * a[8]);
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5],
    a6 = a[6],
    a7 = a[7],
    a8 = a[8];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
var sub = exports.sub = subtract;

},{"./common.js":10}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.decompose = decompose;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromQuat = fromQuat;
exports.fromQuat2 = fromQuat2;
exports.fromRotation = fromRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.frustum = frustum;
exports.getRotation = getRotation;
exports.getScaling = getScaling;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.invert = invert;
exports.lookAt = lookAt;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.ortho = void 0;
exports.orthoNO = orthoNO;
exports.orthoZO = orthoZO;
exports.perspective = void 0;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.perspectiveNO = perspectiveNO;
exports.perspectiveZO = perspectiveZO;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.targetTo = targetTo;
exports.translate = translate;
exports.transpose = transpose;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(16);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
      a02 = a[2],
      a03 = a[3];
    var a12 = a[6],
      a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4 | null} out, or null if source matrix is not invertible
 */
function invert(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  out[0] = a11 * b11 - a12 * b10 + a13 * b09;
  out[1] = a02 * b10 - a01 * b11 - a03 * b09;
  out[2] = a31 * b05 - a32 * b04 + a33 * b03;
  out[3] = a22 * b04 - a21 * b05 - a23 * b03;
  out[4] = a12 * b08 - a10 * b11 - a13 * b07;
  out[5] = a00 * b11 - a02 * b08 + a03 * b07;
  out[6] = a32 * b02 - a30 * b05 - a33 * b01;
  out[7] = a20 * b05 - a22 * b02 + a23 * b01;
  out[8] = a10 * b10 - a11 * b08 + a13 * b06;
  out[9] = a01 * b08 - a00 * b10 - a03 * b06;
  out[10] = a30 * b04 - a31 * b02 + a33 * b00;
  out[11] = a21 * b02 - a20 * b04 - a23 * b00;
  out[12] = a11 * b07 - a10 * b09 - a12 * b06;
  out[13] = a00 * b09 - a01 * b07 + a02 * b06;
  out[14] = a31 * b01 - a30 * b03 - a32 * b00;
  out[15] = a20 * b03 - a21 * b01 + a22 * b00;
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b0 = a00 * a11 - a01 * a10;
  var b1 = a00 * a12 - a02 * a10;
  var b2 = a01 * a12 - a02 * a11;
  var b3 = a20 * a31 - a21 * a30;
  var b4 = a20 * a32 - a22 * a30;
  var b5 = a21 * a32 - a22 * a31;
  var b6 = a00 * b5 - a01 * b4 + a02 * b3;
  var b7 = a10 * b5 - a11 * b4 + a12 * b3;
  var b8 = a20 * b2 - a21 * b1 + a22 * b0;
  var b9 = a30 * b2 - a31 * b1 + a32 * b0;

  // Calculate the determinant
  return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];

  // Cache only the current line of the second matrix
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  var x = v[0],
    y = v[1],
    z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
  var x = v[0],
    y = v[1],
    z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  var x = axis[0],
    y = axis[1],
    z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len < glMatrix.EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var x = axis[0],
    y = axis[1],
    z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s, c, t;
  if (len < glMatrix.EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *     let quatMat = mat4.create();
 *     mat4.fromQuat(quatMat, quat);
 *     mat4.multiply(dest, dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */
function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3],
    ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  //Only scale if it makes sense
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion parameter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}

/**
 * Decomposes a transformation matrix into its rotation, translation
 * and scale components. Returns only the rotation component
 * @param  {quat} out_r Quaternion to receive the rotation component
 * @param  {vec3} out_t Vector to receive the translation vector
 * @param  {vec3} out_s Vector to receive the scaling factor
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @returns {quat} out_r
 */
function decompose(out_r, out_t, out_s, mat) {
  out_t[0] = mat[12];
  out_t[1] = mat[13];
  out_t[2] = mat[14];
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  var is1 = 1 / out_s[0];
  var is2 = 1 / out_s[1];
  var is3 = 1 / out_s[2];
  var sm11 = m11 * is1;
  var sm12 = m12 * is2;
  var sm13 = m13 * is3;
  var sm21 = m21 * is1;
  var sm22 = m22 * is2;
  var sm23 = m23 * is3;
  var sm31 = m31 * is1;
  var sm32 = m32 * is2;
  var sm33 = m33 * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out_r[3] = 0.25 * S;
    out_r[0] = (sm23 - sm32) / S;
    out_r[1] = (sm31 - sm13) / S;
    out_r[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out_r[3] = (sm23 - sm32) / S;
    out_r[0] = 0.25 * S;
    out_r[1] = (sm12 + sm21) / S;
    out_r[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out_r[3] = (sm31 - sm13) / S;
    out_r[0] = (sm12 + sm21) / S;
    out_r[1] = 0.25 * S;
    out_r[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out_r[3] = (sm12 - sm21) / S;
    out_r[0] = (sm31 + sm13) / S;
    out_r[1] = (sm23 + sm32) / S;
    out_r[2] = 0.25 * S;
  }
  return out_r;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *     let quatMat = mat4.create();
 *     mat4.fromQuat(quatMat, quat);
 *     mat4.multiply(dest, dest, quatMat);
 *     mat4.scale(dest, dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *     mat4.translate(dest, dest, origin);
 *     let quatMat = mat4.create();
 *     mat4.fromQuat(quatMat, quat);
 *     mat4.multiply(dest, dest, quatMat);
 *     mat4.scale(dest, dest, scale)
 *     mat4.translate(dest, dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    var nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}

/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */
var perspective = exports.perspective = perspectiveNO;

/**
 * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    var nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Alias for {@link mat4.orthoNO}
 * @function
 */
var ortho = exports.ortho = orthoNO;

/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} target Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  var eyex = eye[0],
    eyey = eye[1],
    eyez = eye[2],
    upx = up[0],
    upy = up[1],
    upz = up[2];
  var z0 = eyex - target[0],
    z1 = eyey - target[1],
    z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }
  var x0 = upy * z2 - upz * z1,
    x1 = upz * z0 - upx * z2,
    x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}

/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[4] * a[4] + a[5] * a[5] + a[6] * a[6] + a[7] * a[7] + a[8] * a[8] + a[9] * a[9] + a[10] * a[10] + a[11] * a[11] + a[12] * a[12] + a[13] * a[13] + a[14] * a[14] + a[15] * a[15]);
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var a4 = a[4],
    a5 = a[5],
    a6 = a[6],
    a7 = a[7];
  var a8 = a[8],
    a9 = a[9],
    a10 = a[10],
    a11 = a[11];
  var a12 = a[12],
    a13 = a[13],
    a14 = a[14],
    a15 = a[15];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  var b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7];
  var b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11];
  var b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
var sub = exports.sub = subtract;

},{"./common.js":10}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = void 0;
exports.calculateW = calculateW;
exports.clone = void 0;
exports.conjugate = conjugate;
exports.copy = void 0;
exports.create = create;
exports.dot = void 0;
exports.equals = equals;
exports.exactEquals = void 0;
exports.exp = exp;
exports.fromEuler = fromEuler;
exports.fromMat3 = fromMat3;
exports.fromValues = void 0;
exports.getAngle = getAngle;
exports.getAxisAngle = getAxisAngle;
exports.identity = identity;
exports.invert = invert;
exports.lerp = exports.length = exports.len = void 0;
exports.ln = ln;
exports.mul = void 0;
exports.multiply = multiply;
exports.normalize = void 0;
exports.pow = pow;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.setAxes = exports.set = exports.scale = exports.rotationTo = void 0;
exports.setAxisAngle = setAxisAngle;
exports.slerp = slerp;
exports.squaredLength = exports.sqrLen = exports.sqlerp = void 0;
exports.str = str;
var glMatrix = _interopRequireWildcard(require("./common.js"));
var mat3 = _interopRequireWildcard(require("./mat3.js"));
var vec3 = _interopRequireWildcard(require("./vec3.js"));
var vec4 = _interopRequireWildcard(require("./vec4.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Quaternion in the format XYZW
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);
  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */
function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */
function multiply(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = b[0],
    by = b[1],
    bz = b[2],
    bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var by = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bz = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */
function exp(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}

/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */
function ln(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}

/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */
function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = b[0],
    by = b[1],
    bz = b[2],
    bw = b[3];
  var omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  // calculate coefficients
  if (1.0 - cosom > glMatrix.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}

/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert(out, a) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x Angle to rotate around X axis in degrees.
 * @param {Number} y Angle to rotate around Y axis in degrees.
 * @param {Number} z Angle to rotate around Z axis in degrees.
 * @param {'xyz'|'xzy'|'yxz'|'yzx'|'zxy'|'zyx'} order Intrinsic order for conversion, default is zyx.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
  var order = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : glMatrix.ANGLE_ORDER;
  var halfToRad = Math.PI / 360;
  x *= halfToRad;
  z *= halfToRad;
  y *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  switch (order) {
    case "xyz":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "xzy":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    case "yxz":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    case "yzx":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "zxy":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "zyx":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    default:
      throw new Error('Unknown angle order ' + order);
  }
  return out;
}

/**
 * Returns a string representation of a quaternion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
var clone = exports.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
var fromValues = exports.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */
var copy = exports.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
var set = exports.set = vec4.set;

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */
var add = exports.add = vec4.add;

/**
 * Alias for {@link quat.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
var scale = exports.scale = vec4.scale;

/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
var dot = exports.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */
var lerp = exports.lerp = vec4.lerp;

/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */
var length = exports.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
var len = exports.len = length;

/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
var squaredLength = exports.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
var sqrLen = exports.sqrLen = squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
var normalize = exports.normalize = vec4.normalize;

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
var exactEquals = exports.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions point approximately to the same direction.
 *
 * Both quaternions are assumed to be unit length.
 *
 * @param {ReadonlyQuat} a The first unit quaternion.
 * @param {ReadonlyQuat} b The second unit quaternion.
 * @returns {Boolean} True if the quaternions are equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(vec4.dot(a, b)) >= 1 - glMatrix.EPSILON;
}

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */
var rotationTo = exports.rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);
    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
var sqlerp = exports.sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
var setAxes = exports.setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

},{"./common.js":10,"./mat3.js":14,"./vec3.js":19,"./vec4.js":20}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.clone = clone;
exports.conjugate = conjugate;
exports.copy = copy;
exports.create = create;
exports.dot = void 0;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.fromMat4 = fromMat4;
exports.fromRotation = fromRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromRotationTranslationValues = fromRotationTranslationValues;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.getDual = getDual;
exports.getReal = void 0;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.invert = invert;
exports.length = exports.len = void 0;
exports.lerp = lerp;
exports.mul = void 0;
exports.multiply = multiply;
exports.normalize = normalize;
exports.rotateAroundAxis = rotateAroundAxis;
exports.rotateByQuatAppend = rotateByQuatAppend;
exports.rotateByQuatPrepend = rotateByQuatPrepend;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.scale = scale;
exports.set = set;
exports.setDual = setDual;
exports.squaredLength = exports.sqrLen = exports.setReal = void 0;
exports.str = str;
exports.translate = translate;
var glMatrix = _interopRequireWildcard(require("./common.js"));
var quat = _interopRequireWildcard(require("./quat.js"));
var mat4 = _interopRequireWildcard(require("./mat4.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */
function create() {
  var dq = new glMatrix.ARRAY_TYPE(8);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }
  dq[3] = 1;
  return dq;
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */
function clone(a) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}

/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */
function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}

/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */
function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
    ay = y2 * 0.5,
    az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}

/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */
function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
    ay = t[1] * 0.5,
    az = t[2] * 0.5,
    bx = q[0],
    by = q[1],
    bz = q[2],
    bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */
function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}

/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */
function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}

/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */
function fromMat4(out, a) {
  //TODO Optimize this
  var outer = quat.create();
  mat4.getRotation(outer, a);
  var t = new glMatrix.ARRAY_TYPE(3);
  mat4.getTranslation(t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}

/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}

/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}

/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */
function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}

/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */
var getReal = exports.getReal = quat.copy;

/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */
function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}

/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */
var setReal = exports.setReal = quat.copy;

/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */
function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}

/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */
function getTranslation(out, a) {
  var ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7],
    bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}

/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */
function translate(out, a, v) {
  var ax1 = a[0],
    ay1 = a[1],
    az1 = a[2],
    aw1 = a[3],
    bx1 = v[0] * 0.5,
    by1 = v[1] * 0.5,
    bz1 = v[2] * 0.5,
    ax2 = a[4],
    ay2 = a[5],
    az2 = a[6],
    aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}

/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */
function rotateX(out, a, rad) {
  var bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3],
    ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7],
    ax1 = ax * bw + aw * bx + ay * bz - az * by,
    ay1 = ay * bw + aw * by + az * bx - ax * bz,
    az1 = az * bw + aw * bz + ax * by - ay * bx,
    aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateX(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}

/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */
function rotateY(out, a, rad) {
  var bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3],
    ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7],
    ax1 = ax * bw + aw * bx + ay * bz - az * by,
    ay1 = ay * bw + aw * by + az * bx - ax * bz,
    az1 = az * bw + aw * bz + ax * by - ay * bx,
    aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateY(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}

/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */
function rotateZ(out, a, rad) {
  var bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3],
    ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7],
    ax1 = ax * bw + aw * bx + ay * bz - az * by,
    ay1 = ay * bw + aw * by + az * bx - ax * bz,
    az1 = az * bw + aw * bz + ax * by - ay * bx,
    aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateZ(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}

/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */
function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3],
    ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}

/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */
function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3],
    bx = a[0],
    by = a[1],
    bz = a[2],
    bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}

/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */
function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < glMatrix.EPSILON) {
    return copy(out, a);
  }
  var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
    ay1 = a[1],
    az1 = a[2],
    aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}

/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */
function multiply(out, a, b) {
  var ax0 = a[0],
    ay0 = a[1],
    az0 = a[2],
    aw0 = a[3],
    bx1 = b[4],
    by1 = b[5],
    bz1 = b[6],
    bw1 = b[7],
    ax1 = a[4],
    ay1 = a[5],
    az1 = a[6],
    aw1 = a[7],
    bx0 = b[0],
    by0 = b[1],
    bz0 = b[2],
    bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}

/**
 * Alias for {@link quat2.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}

/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
var dot = exports.dot = quat.dot;

/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */
function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}

/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */
function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}

/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}

/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */
var length = exports.length = quat.length;

/**
 * Alias for {@link quat2.length}
 * @function
 */
var len = exports.len = length;

/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
var squaredLength = exports.squaredLength = quat.squaredLength;

/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */
var sqrLen = exports.sqrLen = squaredLength;

/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */
function normalize(out, a) {
  var magnitude = squaredLength(a);
  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }
  return out;
}

/**
 * Returns a string representation of a dual quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */
function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}

/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}

/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5],
    a6 = a[6],
    a7 = a[7];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

},{"./common.js":10,"./mat4.js":15,"./quat.js":16}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotate = rotate;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.signedAngle = signedAngle;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/**
 * symmetric round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */
function round(out, a) {
  out[0] = glMatrix.round(a[0]);
  out[1] = glMatrix.round(a[1]);
  return out;
}

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x * x + y * y;
}

/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
    y = a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0],
    y = a[1];
  return x * x + y * y;
}

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}

/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale === undefined ? 1.0 : scale;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */
function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
    p1 = a[1] - b[1],
    sinC = Math.sin(rad),
    cosC = Math.cos(rad);

  //perform rotation and translate to correct position
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}

/**
 * Get the smallest angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var ax = a[0],
    ay = a[1],
    bx = b[0],
    by = b[1];
  return Math.abs(Math.atan2(ay * bx - ax * by, ax * bx + ay * by));
}

/**
 * Get the signed angle in the interval [-pi,pi] between two 2D vectors (positive if `a` is to the right of `b`)
 * 
 * @param {ReadonlyVec2} a The first vector
 * @param {ReadonlyVec2} b The second vector
 * @returns {number} The signed angle in radians
 */
function signedAngle(a, b) {
  var ax = a[0],
    ay = a[1],
    bx = b[0],
    by = b[1];
  return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
}

/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */
function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
    a1 = a[1];
  var b0 = b[0],
    b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
var len = exports.len = length;

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link vec2.divide}
 * @function
 */
var div = exports.div = divide;

/**
 * Alias for {@link vec2.distance}
 * @function
 */
var dist = exports.dist = distance;

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
var sqrDist = exports.sqrDist = squaredDistance;

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
var sqrLen = exports.sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = exports.forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

},{"./common.js":10}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.bezier = bezier;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.hermite = hermite;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.slerp = slerp;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * symmetric round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = glMatrix.round(a[0]);
  out[1] = glMatrix.round(a[1]);
  out[2] = glMatrix.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2];
  var bx = b[0],
    by = b[1],
    bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a spherical linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function slerp(out, a, b, t) {
  var angle = Math.acos(Math.min(Math.max(dot(a, b), -1), 1));
  var sinTotal = Math.sin(angle);
  var ratioA = Math.sin((1 - t) * angle) / sinTotal;
  var ratioB = Math.sin(t * angle) / sinTotal;
  out[0] = ratioA * a[0] + ratioB * b[0];
  out[1] = ratioA * a[1] + ratioB * b[1];
  out[2] = ratioA * a[2] + ratioB * b[2];
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale === undefined ? 1.0 : scale;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q normalized quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // Fast Vector Rotation using Quaternions by Robert Eisele
  // https://raw.org/proof/vector-rotation-using-quaternions/

  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3];
  var vx = a[0],
    vy = a[1],
    vz = a[2];

  // t = q x v
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;

  // t = 2t
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;

  // v + w t + q x t
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */
function rotateX(out, a, b, rad) {
  var p = [],
    r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */
function rotateY(out, a, b, rad) {
  var p = [],
    r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */
function rotateZ(out, a, b, rad) {
  var p = [],
    r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    bx = b[0],
    by = b[1],
    bz = b[2],
    mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)),
    cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}

/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */
function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link vec3.divide}
 * @function
 */
var div = exports.div = divide;

/**
 * Alias for {@link vec3.distance}
 * @function
 */
var dist = exports.dist = distance;

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
var sqrDist = exports.sqrDist = squaredDistance;

/**
 * Alias for {@link vec3.length}
 * @function
 */
var len = exports.len = length;

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
var sqrLen = exports.sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = exports.forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

},{"./common.js":10}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * symmetric round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */
function round(out, a) {
  out[0] = glMatrix.round(a[0]);
  out[1] = glMatrix.round(a[1]);
  out[2] = glMatrix.round(a[2]);
  out[3] = glMatrix.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} out the receiving vector
 * @param {ReadonlyVec4} u the first vector
 * @param {ReadonlyVec4} v the second vector
 * @param {ReadonlyVec4} w the third vector
 * @returns {vec4} result
 */
function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
    B = v[0] * w[2] - v[2] * w[0],
    C = v[0] * w[3] - v[3] * w[0],
    D = v[1] * w[2] - v[2] * w[1],
    E = v[1] * w[3] - v[3] * w[1],
    F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random(out, scale) {
  scale = scale === undefined ? 1.0 : scale;

  // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;
  var v1, v2, v3, v4;
  var s1, s2;
  var rand;
  rand = glMatrix.RANDOM();
  v1 = rand * 2 - 1;
  v2 = (4 * glMatrix.RANDOM() - 2) * Math.sqrt(rand * -rand + rand);
  s1 = v1 * v1 + v2 * v2;
  rand = glMatrix.RANDOM();
  v3 = rand * 2 - 1;
  v4 = (4 * glMatrix.RANDOM() - 2) * Math.sqrt(rand * -rand + rand);
  s2 = v3 * v3 + v4 * v4;
  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q normalized quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat(out, a, q) {
  // Fast Vector Rotation using Quaternions by Robert Eisele
  // https://raw.org/proof/vector-rotation-using-quaternions/

  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3];
  var vx = a[0],
    vy = a[1],
    vz = a[2];

  // t = q x v
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;

  // t = 2t
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;

  // v + w t + q x t
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */
function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link vec4.divide}
 * @function
 */
var div = exports.div = divide;

/**
 * Alias for {@link vec4.distance}
 * @function
 */
var dist = exports.dist = distance;

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
var sqrDist = exports.sqrDist = squaredDistance;

/**
 * Alias for {@link vec4.length}
 * @function
 */
var len = exports.len = length;

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
var sqrLen = exports.sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = exports.forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

},{"./common.js":10}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mat4 = exports.mat3 = void 0;
exports.setDefaultType = setDefaultType;
exports.vec4 = exports.vec3 = exports.vec2 = exports.utils = exports.types = void 0;
/* wgpu-matrix@1.0.0, license MIT */
var arrayLike = exports.types = /*#__PURE__*/Object.freeze({
  __proto__: null
});

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
let EPSILON = 0.000001;
/**
 * Set the value for EPSILON for various checks
 * @param v - Value to use for EPSILON.
 * @returns previous value of EPSILON;
 */
function setEpsilon(v) {
  const old = EPSILON;
  EPSILON = v;
  return old;
}
/**
 * Convert degrees to radians
 * @param degrees - Angle in degrees
 * @returns angle converted to radians
 */
function degToRad(degrees) {
  return degrees * Math.PI / 180;
}
/**
 * Convert radians to degrees
 * @param radians - Angle in radians
 * @returns angle converted to degrees
 */
function radToDeg(radians) {
  return radians * 180 / Math.PI;
}
/**
 * Lerps between a and b via t
 * @param a - starting value
 * @param b - ending value
 * @param t - value where 0 = a and 1 = b
 * @returns a + (b - a) * t
 */
function lerp$3(a, b, t) {
  return a + (b - a) * t;
}
/**
 * Compute the opposite of lerp. Given a and b and a value between
 * a and b returns a value between 0 and 1. 0 if a, 1 if b.
 * Note: no clamping is done.
 * @param a - start value
 * @param b - end value
 * @param v - value between a and b
 * @returns (v - a) / (b - a)
 */
function inverseLerp(a, b, v) {
  const d = b - a;
  return Math.abs(b - a) < EPSILON ? a : (v - a) / d;
}
/**
 * Compute the euclidean modulo
 *
 * ```
 * // table for n / 3
 * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n
 * ------------------------------------
 * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3
 *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)
 * ```
 *
 * @param n - dividend
 * @param m - divisor
 * @returns the euclidean modulo of n / m
 */
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
var utils = exports.utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get EPSILON() {
    return EPSILON;
  },
  setEpsilon: setEpsilon,
  degToRad: degToRad,
  radToDeg: radToDeg,
  lerp: lerp$3,
  inverseLerp: inverseLerp,
  euclideanModulo: euclideanModulo
});

/**
 *
 * Vec2 math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new Vec2. In other words you can do this
 *
 *     const v = vec2.cross(v1, v2);  // Creates a new Vec2 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = vec2.create();
 *     vec2.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     vec2.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
let VecType$2 = Float32Array;
/**
 * Sets the type this library creates for a Vec2
 * @param ctor - the constructor for the type. Either `Float32Array`, 'Float64Array', or `Array`
 * @returns previous constructor for Vec2
 */
function setDefaultType$5(ctor) {
  const oldType = VecType$2;
  VecType$2 = ctor;
  return oldType;
}
/**
 * Creates a Vec2; may be called with x, y, z to set initial values.
 *
 * Note: Since passing in a raw JavaScript array
 * is valid in all circumstances, if you want to
 * force a JavaScript array into a Vec2's specified type
 * it would be faster to use
 *
 * ```
 * const v = vec2.clone(someJSArray);
 * ```
 *
 * Note: a consequence of the implementation is if your Vec2Type = `Array`
 * instead of `Float32Array` or `Float64Array` then any values you
 * don't pass in will be undefined. Usually this is not an issue since
 * (a) using `Array` is rare and (b) using `vec2.create` is usually used
 * to create a Vec2 to be filled out as in
 *
 * ```
 * const sum = vec2.create();
 * vec2.add(v1, v2, sum);
 * ```
 *
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @returns the created vector
 */
function create$4(x = 0, y = 0) {
  const dst = new VecType$2(2);
  if (x !== undefined) {
    dst[0] = x;
    if (y !== undefined) {
      dst[1] = y;
    }
  }
  return dst;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @returns the created vector
 */
const fromValues$2 = create$4;
/**
 * Applies Math.ceil to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the ceil of each element of v.
 */
function ceil$2(v, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = Math.ceil(v[0]);
  dst[1] = Math.ceil(v[1]);
  return dst;
}
/**
 * Applies Math.floor to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the floor of each element of v.
 */
function floor$2(v, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = Math.floor(v[0]);
  dst[1] = Math.floor(v[1]);
  return dst;
}
/**
 * Applies Math.round to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the round of each element of v.
 */
function round$2(v, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = Math.round(v[0]);
  dst[1] = Math.round(v[1]);
  return dst;
}
/**
 * Clamp each element of vector between min and max
 * @param v - Operand vector.
 * @param max - Min value, default 0
 * @param min - Max value, default 1
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that the clamped value of each element of v.
 */
function clamp$2(v, min = 0, max = 1, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = Math.min(max, Math.max(min, v[0]));
  dst[1] = Math.min(max, Math.max(min, v[1]));
  return dst;
}
/**
 * Adds two vectors; assumes a and b have the same dimension.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the sum of a and b.
 */
function add$2(a, b, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  return dst;
}
/**
 * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param scale - Amount to scale b
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the sum of a + b * scale.
 */
function addScaled$2(a, b, scale, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] + b[0] * scale;
  dst[1] = a[1] + b[1] * scale;
  return dst;
}
/**
 * Returns the angle in radians between two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns The angle in radians between the 2 vectors.
 */
function angle$1(a, b) {
  const ax = a[0];
  const ay = a[1];
  const bx = a[0];
  const by = a[1];
  const mag1 = Math.sqrt(ax * ax + ay * ay);
  const mag2 = Math.sqrt(bx * bx + by * by);
  const mag = mag1 * mag2;
  const cosine = mag && dot$2(a, b) / mag;
  return Math.acos(cosine);
}
/**
 * Subtracts two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the difference of a and b.
 */
function subtract$2(a, b, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  return dst;
}
/**
 * Subtracts two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the difference of a and b.
 */
const sub$2 = subtract$2;
/**
 * Check if 2 vectors are approximately equal
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns true if vectors are approximately equal
 */
function equalsApproximately$4(a, b) {
  return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON;
}
/**
 * Check if 2 vectors are exactly equal
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns true if vectors are exactly equal
 */
function equals$4(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient t, returns
 * a + t * (b - a).
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param t - Interpolation coefficient.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The linear interpolated result.
 */
function lerp$2(a, b, t, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] + t * (b[0] - a[0]);
  dst[1] = a[1] + t * (b[1] - a[1]);
  return dst;
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient vector t, returns
 * a + t * (b - a).
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param t - Interpolation coefficients vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns the linear interpolated result.
 */
function lerpV$2(a, b, t, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] + t[0] * (b[0] - a[0]);
  dst[1] = a[1] + t[1] * (b[1] - a[1]);
  return dst;
}
/**
 * Return max values of two vectors.
 * Given vectors a and b returns
 * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The max components vector.
 */
function max$2(a, b, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = Math.max(a[0], b[0]);
  dst[1] = Math.max(a[1], b[1]);
  return dst;
}
/**
 * Return min values of two vectors.
 * Given vectors a and b returns
 * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The min components vector.
 */
function min$2(a, b, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = Math.min(a[0], b[0]);
  dst[1] = Math.min(a[1], b[1]);
  return dst;
}
/**
 * Multiplies a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The scaled vector.
 */
function mulScalar$2(v, k, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  return dst;
}
/**
 * Multiplies a vector by a scalar. (same as mulScalar)
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The scaled vector.
 */
const scale$4 = mulScalar$2;
/**
 * Divides a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The scaled vector.
 */
function divScalar$2(v, k, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  return dst;
}
/**
 * Inverse a vector.
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The inverted vector.
 */
function inverse$4(v, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = 1 / v[0];
  dst[1] = 1 / v[1];
  return dst;
}
/**
 * Invert a vector. (same as inverse)
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The inverted vector.
 */
const invert$4 = inverse$4;
/**
 * Computes the cross product of two vectors; assumes both vectors have
 * three entries.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of a cross b.
 */
function cross$1(a, b, dst) {
  dst = dst || new VecType$2(3);
  const z = a[0] * b[1] - a[1] * b[0];
  dst[0] = 0;
  dst[1] = 0;
  dst[2] = z;
  return dst;
}
/**
 * Computes the dot product of two vectors; assumes both vectors have
 * three entries.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns dot product
 */
function dot$2(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the length of vector
 * @param v - vector.
 * @returns length of vector.
 */
function length$2(v) {
  const v0 = v[0];
  const v1 = v[1];
  return Math.sqrt(v0 * v0 + v1 * v1);
}
/**
 * Computes the length of vector (same as length)
 * @param v - vector.
 * @returns length of vector.
 */
const len$2 = length$2;
/**
 * Computes the square of the length of vector
 * @param v - vector.
 * @returns square of the length of vector.
 */
function lengthSq$2(v) {
  const v0 = v[0];
  const v1 = v[1];
  return v0 * v0 + v1 * v1;
}
/**
 * Computes the square of the length of vector (same as lengthSq)
 * @param v - vector.
 * @returns square of the length of vector.
 */
const lenSq$2 = lengthSq$2;
/**
 * Computes the distance between 2 points
 * @param a - vector.
 * @param b - vector.
 * @returns distance between a and b
 */
function distance$2(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  return Math.sqrt(dx * dx + dy * dy);
}
/**
 * Computes the distance between 2 points (same as distance)
 * @param a - vector.
 * @param b - vector.
 * @returns distance between a and b
 */
const dist$2 = distance$2;
/**
 * Computes the square of the distance between 2 points
 * @param a - vector.
 * @param b - vector.
 * @returns square of the distance between a and b
 */
function distanceSq$2(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  return dx * dx + dy * dy;
}
/**
 * Computes the square of the distance between 2 points (same as distanceSq)
 * @param a - vector.
 * @param b - vector.
 * @returns square of the distance between a and b
 */
const distSq$2 = distanceSq$2;
/**
 * Divides a vector by its Euclidean length and returns the quotient.
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The normalized vector.
 */
function normalize$2(v, dst) {
  dst = dst || new VecType$2(2);
  const v0 = v[0];
  const v1 = v[1];
  const len = Math.sqrt(v0 * v0 + v1 * v1);
  if (len > 0.00001) {
    dst[0] = v0 / len;
    dst[1] = v1 / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
  }
  return dst;
}
/**
 * Negates a vector.
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns -v.
 */
function negate$4(v, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = -v[0];
  dst[1] = -v[1];
  return dst;
}
/**
 * Copies a vector. (same as clone)
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A copy of v.
 */
function copy$4(v, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = v[0];
  dst[1] = v[1];
  return dst;
}
/**
 * Clones a vector. (same as copy)
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A copy of v.
 */
const clone$4 = copy$4;
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of products of entries of a and b.
 */
function multiply$4(a, b, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] * b[0];
  dst[1] = a[1] * b[1];
  return dst;
}
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length. (same as mul)
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of products of entries of a and b.
 */
const mul$4 = multiply$4;
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of quotients of entries of a and b.
 */
function divide$2(a, b, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] / b[0];
  dst[1] = a[1] / b[1];
  return dst;
}
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length. (same as divide)
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of quotients of entries of a and b.
 */
const div$2 = divide$2;
/**
 * Creates a random unit vector * scale
 * @param scale - Default 1
 * @param dst - vector to hold result. If not new one is created.
 * @returns The random vector.
 */
function random$1(scale = 1, dst) {
  dst = dst || new VecType$2(2);
  const angle = Math.random() * 2 * Math.PI;
  dst[0] = Math.cos(angle) * scale;
  dst[1] = Math.sin(angle) * scale;
  return dst;
}
/**
 * Zero's a vector
 * @param dst - vector to hold result. If not new one is created.
 * @returns The zeroed vector.
 */
function zero$2(dst) {
  dst = dst || new VecType$2(2);
  dst[0] = 0;
  dst[1] = 0;
  return dst;
}
/**
 * transform Vec2 by 4x4 matrix
 * @param v - the vector
 * @param m - The matrix.
 * @param dst - optional Vec2 to store result. If not passed a new one is created.
 * @returns the transformed vector
 */
function transformMat4$2(v, m, dst) {
  dst = dst || new VecType$2(2);
  const x = v[0];
  const y = v[1];
  dst[0] = x * m[0] + y * m[4] + m[12];
  dst[1] = x * m[1] + y * m[5] + m[13];
  return dst;
}
/**
 * Transforms vec4 by 3x3 matrix
 *
 * @param v - the vector
 * @param m - The matrix.
 * @param dst - optional Vec2 to store result. If not passed a new one is created.
 * @returns the transformed vector
 */
function transformMat3$1(v, m, dst) {
  dst = dst || new VecType$2(2);
  const x = v[0];
  const y = v[1];
  dst[0] = m[0] * x + m[4] * y + m[8];
  dst[1] = m[1] * x + m[5] * y + m[9];
  return dst;
}
var vec2Impl = exports.vec2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create: create$4,
  setDefaultType: setDefaultType$5,
  fromValues: fromValues$2,
  ceil: ceil$2,
  floor: floor$2,
  round: round$2,
  clamp: clamp$2,
  add: add$2,
  addScaled: addScaled$2,
  angle: angle$1,
  subtract: subtract$2,
  sub: sub$2,
  equalsApproximately: equalsApproximately$4,
  equals: equals$4,
  lerp: lerp$2,
  lerpV: lerpV$2,
  max: max$2,
  min: min$2,
  mulScalar: mulScalar$2,
  scale: scale$4,
  divScalar: divScalar$2,
  inverse: inverse$4,
  invert: invert$4,
  cross: cross$1,
  dot: dot$2,
  length: length$2,
  len: len$2,
  lengthSq: lengthSq$2,
  lenSq: lenSq$2,
  distance: distance$2,
  dist: dist$2,
  distanceSq: distanceSq$2,
  distSq: distSq$2,
  normalize: normalize$2,
  negate: negate$4,
  copy: copy$4,
  clone: clone$4,
  multiply: multiply$4,
  mul: mul$4,
  divide: divide$2,
  div: div$2,
  random: random$1,
  zero: zero$2,
  transformMat4: transformMat4$2,
  transformMat3: transformMat3$1
});

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * 3x3 Matrix math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new matrix. In other words you can do this
 *
 *     const mat = mat3.translation([1, 2, 3]);  // Creates a new translation matrix
 *
 * or
 *
 *     const mat = mat3.create();
 *     mat3.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any matrix as the destination. So for example
 *
 *     const mat = mat3.identity();
 *     const trans = mat3.translation([1, 2, 3]);
 *     mat3.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
 *
 */
let MatType$1 = Float32Array;
// This mess is because with Mat3 we have 3 unused elements.
// For Float32Array and Float64Array that's not an issue
// but for Array it's troublesome
const ctorMap = new Map([[Float32Array, () => new Float32Array(12)], [Float64Array, () => new Float64Array(12)], [Array, () => new Array(12).fill(0)]]);
let newMat3 = ctorMap.get(Float32Array);
/**
 * Sets the type this library creates for a Mat3
 * @param ctor - the constructor for the type. Either `Float32Array`, 'Float64Array', or `Array`
 * @returns previous constructor for Mat3
 */
function setDefaultType$4(ctor) {
  const oldType = MatType$1;
  MatType$1 = ctor;
  newMat3 = ctorMap.get(ctor);
  return oldType;
}
/**
 * Create a Mat3 from values
 *
 * Note: Since passing in a raw JavaScript array
 * is valid in all circumstances, if you want to
 * force a JavaScript array into a Mat3's specified type
 * it would be faster to use
 *
 * ```
 * const m = mat3.clone(someJSArray);
 * ```
 *
 * Note: a consequence of the implementation is if your Mat3Type = `Array`
 * instead of `Float32Array` or `Float64Array` then any values you
 * don't pass in will be undefined. Usually this is not an issue since
 * (a) using `Array` is rare and (b) using `mat3.create` is usually used
 * to create a Mat3 to be filled out as in
 *
 * ```
 * const m = mat3.create();
 * mat3.perspective(fov, aspect, near, far, m);
 * ```
 *
 * @param v0 - value for element 0
 * @param v1 - value for element 1
 * @param v2 - value for element 2
 * @param v3 - value for element 3
 * @param v4 - value for element 4
 * @param v5 - value for element 5
 * @param v6 - value for element 6
 * @param v7 - value for element 7
 * @param v8 - value for element 8
 * @returns matrix created from values.
 */
function create$3(v0, v1, v2, v3, v4, v5, v6, v7, v8) {
  const dst = newMat3();
  // to make the array homogenous
  dst[3] = 0;
  dst[7] = 0;
  dst[11] = 0;
  if (v0 !== undefined) {
    dst[0] = v0;
    if (v1 !== undefined) {
      dst[1] = v1;
      if (v2 !== undefined) {
        dst[2] = v2;
        if (v3 !== undefined) {
          dst[4] = v3;
          if (v4 !== undefined) {
            dst[5] = v4;
            if (v5 !== undefined) {
              dst[6] = v5;
              if (v6 !== undefined) {
                dst[8] = v6;
                if (v7 !== undefined) {
                  dst[9] = v7;
                  if (v8 !== undefined) {
                    dst[10] = v8;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return dst;
}
/**
 * Negates a matrix.
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns -m.
 */
function negate$3(m, dst) {
  dst = dst || newMat3();
  dst[0] = -m[0];
  dst[1] = -m[1];
  dst[2] = -m[2];
  dst[4] = -m[4];
  dst[5] = -m[5];
  dst[6] = -m[6];
  dst[8] = -m[8];
  dst[9] = -m[9];
  dst[10] = -m[10];
  return dst;
}
/**
 * Copies a matrix.
 * @param m - The matrix.
 * @param dst - The matrix. If not passed a new one is created.
 * @returns A copy of m.
 */
function copy$3(m, dst) {
  dst = dst || newMat3();
  dst[0] = m[0];
  dst[1] = m[1];
  dst[2] = m[2];
  dst[4] = m[4];
  dst[5] = m[5];
  dst[6] = m[6];
  dst[8] = m[8];
  dst[9] = m[9];
  dst[10] = m[10];
  return dst;
}
/**
 * Copies a matrix (same as copy)
 * @param m - The matrix.
 * @param dst - The matrix. If not passed a new one is created.
 * @returns A copy of m.
 */
const clone$3 = copy$3;
/**
 * Check if 2 matrices are approximately equal
 * @param a Operand matrix.
 * @param b Operand matrix.
 * @returns true if matrices are approximately equal
 */
function equalsApproximately$3(a, b) {
  return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON && Math.abs(a[4] - b[4]) < EPSILON && Math.abs(a[5] - b[5]) < EPSILON && Math.abs(a[6] - b[6]) < EPSILON && Math.abs(a[8] - b[8]) < EPSILON && Math.abs(a[9] - b[9]) < EPSILON && Math.abs(a[10] - b[10]) < EPSILON;
}
/**
 * Check if 2 matrices are exactly equal
 * @param a Operand matrix.
 * @param b Operand matrix.
 * @returns true if matrices are exactly equal
 */
function equals$3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10];
}
/**
 * Creates a 3-by-3 identity matrix.
 *
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns A 3-by-3 identity matrix.
 */
function identity$1(dst) {
  dst = dst || newMat3();
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  return dst;
}
/**
 * Takes the transpose of a matrix.
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The transpose of m.
 */
function transpose$1(m, dst) {
  dst = dst || newMat3();
  if (dst === m) {
    let t;
    // 0 1 2
    // 4 5 6
    // 8 9 10
    t = m[1];
    m[1] = m[4];
    m[4] = t;
    t = m[2];
    m[2] = m[8];
    m[8] = t;
    t = m[6];
    m[6] = m[9];
    m[9] = t;
    return dst;
  }
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  dst[0] = m00;
  dst[1] = m10;
  dst[2] = m20;
  dst[4] = m01;
  dst[5] = m11;
  dst[6] = m21;
  dst[8] = m02;
  dst[9] = m12;
  dst[10] = m22;
  return dst;
}
/**
 * Computes the inverse of a 3-by-3 matrix.
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The inverse of m.
 */
function inverse$3(m, dst) {
  dst = dst || newMat3();
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m11_x_m22 = m11 * m22;
  const m21_x_m12 = m21 * m12;
  const m01_x_m22 = m01 * m22;
  const m21_x_m02 = m21 * m02;
  const m01_x_m12 = m01 * m12;
  const m11_x_m02 = m11 * m02;
  const invDet = 1 / (m00 * (m11_x_m22 - m21_x_m12) - m10 * (m01_x_m22 - m21_x_m02) + m20 * (m01_x_m12 - m11_x_m02));
  dst[0] = +(m11_x_m22 - m21_x_m12) * invDet;
  dst[1] = -(m10 * m22 - m20 * m12) * invDet;
  dst[2] = +(m10 * m21 - m20 * m11) * invDet;
  dst[4] = -(m01_x_m22 - m21_x_m02) * invDet;
  dst[5] = +(m00 * m22 - m20 * m02) * invDet;
  dst[6] = -(m00 * m21 - m20 * m01) * invDet;
  dst[8] = +(m01_x_m12 - m11_x_m02) * invDet;
  dst[9] = -(m00 * m12 - m10 * m02) * invDet;
  dst[10] = +(m00 * m11 - m10 * m01) * invDet;
  return dst;
}
/**
 * Compute the determinant of a matrix
 * @param m - the matrix
 * @returns the determinant
 */
function determinant$1(m) {
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  return m00 * (m11 * m22 - m21 * m12) - m10 * (m01 * m22 - m21 * m02) + m20 * (m01 * m12 - m11 * m02);
}
/**
 * Computes the inverse of a 3-by-3 matrix. (same as inverse)
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The inverse of m.
 */
const invert$3 = inverse$3;
/**
 * Multiplies two 3-by-3 matrices with a on the left and b on the right
 * @param a - The matrix on the left.
 * @param b - The matrix on the right.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The matrix product of a and b.
 */
function multiply$3(a, b, dst) {
  dst = dst || newMat3();
  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a10 = a[4 + 0];
  const a11 = a[4 + 1];
  const a12 = a[4 + 2];
  const a20 = a[8 + 0];
  const a21 = a[8 + 1];
  const a22 = a[8 + 2];
  const b00 = b[0];
  const b01 = b[1];
  const b02 = b[2];
  const b10 = b[4 + 0];
  const b11 = b[4 + 1];
  const b12 = b[4 + 2];
  const b20 = b[8 + 0];
  const b21 = b[8 + 1];
  const b22 = b[8 + 2];
  dst[0] = a00 * b00 + a10 * b01 + a20 * b02;
  dst[1] = a01 * b00 + a11 * b01 + a21 * b02;
  dst[2] = a02 * b00 + a12 * b01 + a22 * b02;
  dst[4] = a00 * b10 + a10 * b11 + a20 * b12;
  dst[5] = a01 * b10 + a11 * b11 + a21 * b12;
  dst[6] = a02 * b10 + a12 * b11 + a22 * b12;
  dst[8] = a00 * b20 + a10 * b21 + a20 * b22;
  dst[9] = a01 * b20 + a11 * b21 + a21 * b22;
  dst[10] = a02 * b20 + a12 * b21 + a22 * b22;
  return dst;
}
/**
 * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)
 * @param a - The matrix on the left.
 * @param b - The matrix on the right.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The matrix product of a and b.
 */
const mul$3 = multiply$3;
/**
 * Sets the translation component of a 3-by-3 matrix to the given
 * vector.
 * @param a - The matrix.
 * @param v - The vector.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The matrix with translation set.
 */
function setTranslation$1(a, v, dst) {
  dst = dst || identity$1();
  if (a !== dst) {
    dst[0] = a[0];
    dst[1] = a[1];
    dst[2] = a[2];
    dst[4] = a[4];
    dst[5] = a[5];
    dst[6] = a[6];
  }
  dst[8] = v[0];
  dst[9] = v[1];
  dst[10] = 1;
  return dst;
}
/**
 * Returns the translation component of a 3-by-3 matrix as a vector with 3
 * entries.
 * @param m - The matrix.
 * @param dst - vector to hold result. If not passed a new one is created.
 * @returns The translation component of m.
 */
function getTranslation$1(m, dst) {
  dst = dst || create$4();
  dst[0] = m[8];
  dst[1] = m[9];
  return dst;
}
/**
 * Returns an axis of a 3x3 matrix as a vector with 2 entries
 * @param m - The matrix.
 * @param axis - The axis 0 = x, 1 = y,
 * @returns The axis component of m.
 */
function getAxis$1(m, axis, dst) {
  dst = dst || create$4();
  const off = axis * 4;
  dst[0] = m[off + 0];
  dst[1] = m[off + 1];
  return dst;
}
/**
 * Sets an axis of a 3x3 matrix as a vector with 2 entries
 * @param m - The matrix.
 * @param v - the axis vector
 * @param axis - The axis  0 = x, 1 = y;
 * @param dst - The matrix to set. If not passed a new one is created.
 * @returns The matrix with axis set.
 */
function setAxis$1(m, v, axis, dst) {
  if (dst !== m) {
    dst = copy$3(m, dst);
  }
  const off = axis * 4;
  dst[off + 0] = v[0];
  dst[off + 1] = v[1];
  return dst;
}
/**
 * Returns the scaling component of the matrix
 * @param m - The Matrix
 * @param dst - The vector to set. If not passed a new one is created.
 */
function getScaling$1(m, dst) {
  dst = dst || create$4();
  const xx = m[0];
  const xy = m[1];
  const yx = m[4];
  const yy = m[5];
  dst[0] = Math.sqrt(xx * xx + xy * xy);
  dst[1] = Math.sqrt(yx * yx + yy * yy);
  return dst;
}
/**
 * Creates a 3-by-3 matrix which translates by the given vector v.
 * @param v - The vector by which to translate.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The translation matrix.
 */
function translation$1(v, dst) {
  dst = dst || newMat3();
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[8] = v[0];
  dst[9] = v[1];
  dst[10] = 1;
  return dst;
}
/**
 * Translates the given 3-by-3 matrix by the given vector v.
 * @param m - The matrix.
 * @param v - The vector by which to translate.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The translated matrix.
 */
function translate$1(m, v, dst) {
  dst = dst || newMat3();
  const v0 = v[0];
  const v1 = v[1];
  const m00 = m[0];
  const m01 = m[1];
  const m02 = m[2];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  if (m !== dst) {
    dst[0] = m00;
    dst[1] = m01;
    dst[2] = m02;
    dst[4] = m10;
    dst[5] = m11;
    dst[6] = m12;
  }
  dst[8] = m00 * v0 + m10 * v1 + m20;
  dst[9] = m01 * v0 + m11 * v1 + m21;
  dst[10] = m02 * v0 + m12 * v1 + m22;
  return dst;
}
/**
 * Creates a 3-by-3 matrix which rotates  by the given angle.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotation matrix.
 */
function rotation$1(angleInRadians, dst) {
  dst = dst || newMat3();
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = s;
  dst[2] = 0;
  dst[4] = -s;
  dst[5] = c;
  dst[6] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  return dst;
}
/**
 * Rotates the given 3-by-3 matrix  by the given angle.
 * @param m - The matrix.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotated matrix.
 */
function rotate$1(m, angleInRadians, dst) {
  dst = dst || newMat3();
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c * m00 + s * m10;
  dst[1] = c * m01 + s * m11;
  dst[2] = c * m02 + s * m12;
  dst[4] = c * m10 - s * m00;
  dst[5] = c * m11 - s * m01;
  dst[6] = c * m12 - s * m02;
  if (m !== dst) {
    dst[8] = m[8];
    dst[9] = m[9];
    dst[10] = m[10];
  }
  return dst;
}
/**
 * Creates a 3-by-3 matrix which scales in each dimension by an amount given by
 * the corresponding entry in the given vector; assumes the vector has three
 * entries.
 * @param v - A vector of
 *     2 entries specifying the factor by which to scale in each dimension.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The scaling matrix.
 */
function scaling$1(v, dst) {
  dst = dst || newMat3();
  dst[0] = v[0];
  dst[1] = 0;
  dst[2] = 0;
  dst[4] = 0;
  dst[5] = v[1];
  dst[6] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  return dst;
}
/**
 * Scales the given 3-by-3 matrix in each dimension by an amount
 * given by the corresponding entry in the given vector; assumes the vector has
 * three entries.
 * @param m - The matrix to be modified.
 * @param v - A vector of 2 entries specifying the
 *     factor by which to scale in each dimension.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The scaled matrix.
 */
function scale$3(m, v, dst) {
  dst = dst || newMat3();
  const v0 = v[0];
  const v1 = v[1];
  dst[0] = v0 * m[0 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2];
  dst[4] = v1 * m[1 * 4 + 0];
  dst[5] = v1 * m[1 * 4 + 1];
  dst[6] = v1 * m[1 * 4 + 2];
  if (m !== dst) {
    dst[8] = m[8];
    dst[9] = m[9];
    dst[10] = m[10];
  }
  return dst;
}
var mat3Impl = exports.mat3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setDefaultType: setDefaultType$4,
  create: create$3,
  negate: negate$3,
  copy: copy$3,
  clone: clone$3,
  equalsApproximately: equalsApproximately$3,
  equals: equals$3,
  identity: identity$1,
  transpose: transpose$1,
  inverse: inverse$3,
  determinant: determinant$1,
  invert: invert$3,
  multiply: multiply$3,
  mul: mul$3,
  setTranslation: setTranslation$1,
  getTranslation: getTranslation$1,
  getAxis: getAxis$1,
  setAxis: setAxis$1,
  getScaling: getScaling$1,
  translation: translation$1,
  translate: translate$1,
  rotation: rotation$1,
  rotate: rotate$1,
  scaling: scaling$1,
  scale: scale$3
});

/**
 *
 * Vec3 math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new `Vec3`. In other words you can do this
 *
 *     const v = vec3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = vec3.create();
 *     vec3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     vec3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
let VecType$1 = Float32Array;
/**
 * Sets the type this library creates for a Vec3
 * @param ctor - the constructor for the type. Either `Float32Array`, 'Float64Array', or `Array`
 * @returns previous constructor for Vec3
 */
function setDefaultType$3(ctor) {
  const oldType = VecType$1;
  VecType$1 = ctor;
  return oldType;
}
/**
 * Creates a vec3; may be called with x, y, z to set initial values.
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @param z - Initial z value.
 * @returns the created vector
 */
function create$2(x, y, z) {
  const dst = new VecType$1(3);
  if (x !== undefined) {
    dst[0] = x;
    if (y !== undefined) {
      dst[1] = y;
      if (z !== undefined) {
        dst[2] = z;
      }
    }
  }
  return dst;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Creates a vec3; may be called with x, y, z to set initial values. (same as create)
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @param z - Initial z value.
 * @returns the created vector
 */
const fromValues$1 = create$2;
/**
 * Applies Math.ceil to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the ceil of each element of v.
 */
function ceil$1(v, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = Math.ceil(v[0]);
  dst[1] = Math.ceil(v[1]);
  dst[2] = Math.ceil(v[2]);
  return dst;
}
/**
 * Applies Math.floor to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the floor of each element of v.
 */
function floor$1(v, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = Math.floor(v[0]);
  dst[1] = Math.floor(v[1]);
  dst[2] = Math.floor(v[2]);
  return dst;
}
/**
 * Applies Math.round to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the round of each element of v.
 */
function round$1(v, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = Math.round(v[0]);
  dst[1] = Math.round(v[1]);
  dst[2] = Math.round(v[2]);
  return dst;
}
/**
 * Clamp each element of vector between min and max
 * @param v - Operand vector.
 * @param max - Min value, default 0
 * @param min - Max value, default 1
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that the clamped value of each element of v.
 */
function clamp$1(v, min = 0, max = 1, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = Math.min(max, Math.max(min, v[0]));
  dst[1] = Math.min(max, Math.max(min, v[1]));
  dst[2] = Math.min(max, Math.max(min, v[2]));
  return dst;
}
/**
 * Adds two vectors; assumes a and b have the same dimension.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the sum of a and b.
 */
function add$1(a, b, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  dst[2] = a[2] + b[2];
  return dst;
}
/**
 * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param scale - Amount to scale b
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the sum of a + b * scale.
 */
function addScaled$1(a, b, scale, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] + b[0] * scale;
  dst[1] = a[1] + b[1] * scale;
  dst[2] = a[2] + b[2] * scale;
  return dst;
}
/**
 * Returns the angle in radians between two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns The angle in radians between the 2 vectors.
 */
function angle(a, b) {
  const ax = a[0];
  const ay = a[1];
  const az = a[2];
  const bx = a[0];
  const by = a[1];
  const bz = a[2];
  const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);
  const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);
  const mag = mag1 * mag2;
  const cosine = mag && dot$1(a, b) / mag;
  return Math.acos(cosine);
}
/**
 * Subtracts two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the difference of a and b.
 */
function subtract$1(a, b, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  dst[2] = a[2] - b[2];
  return dst;
}
/**
 * Subtracts two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the difference of a and b.
 */
const sub$1 = subtract$1;
/**
 * Check if 2 vectors are approximately equal
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns true if vectors are approximately equal
 */
function equalsApproximately$2(a, b) {
  return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON;
}
/**
 * Check if 2 vectors are exactly equal
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns true if vectors are exactly equal
 */
function equals$2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient t, returns
 * a + t * (b - a).
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param t - Interpolation coefficient.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The linear interpolated result.
 */
function lerp$1(a, b, t, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] + t * (b[0] - a[0]);
  dst[1] = a[1] + t * (b[1] - a[1]);
  dst[2] = a[2] + t * (b[2] - a[2]);
  return dst;
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient vector t, returns
 * a + t * (b - a).
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param t - Interpolation coefficients vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns the linear interpolated result.
 */
function lerpV$1(a, b, t, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] + t[0] * (b[0] - a[0]);
  dst[1] = a[1] + t[1] * (b[1] - a[1]);
  dst[2] = a[2] + t[2] * (b[2] - a[2]);
  return dst;
}
/**
 * Return max values of two vectors.
 * Given vectors a and b returns
 * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The max components vector.
 */
function max$1(a, b, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = Math.max(a[0], b[0]);
  dst[1] = Math.max(a[1], b[1]);
  dst[2] = Math.max(a[2], b[2]);
  return dst;
}
/**
 * Return min values of two vectors.
 * Given vectors a and b returns
 * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The min components vector.
 */
function min$1(a, b, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = Math.min(a[0], b[0]);
  dst[1] = Math.min(a[1], b[1]);
  dst[2] = Math.min(a[2], b[2]);
  return dst;
}
/**
 * Multiplies a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The scaled vector.
 */
function mulScalar$1(v, k, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  dst[2] = v[2] * k;
  return dst;
}
/**
 * Multiplies a vector by a scalar. (same as mulScalar)
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The scaled vector.
 */
const scale$2 = mulScalar$1;
/**
 * Divides a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The scaled vector.
 */
function divScalar$1(v, k, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  dst[2] = v[2] / k;
  return dst;
}
/**
 * Inverse a vector.
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The inverted vector.
 */
function inverse$2(v, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = 1 / v[0];
  dst[1] = 1 / v[1];
  dst[2] = 1 / v[2];
  return dst;
}
/**
 * Invert a vector. (same as inverse)
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The inverted vector.
 */
const invert$2 = inverse$2;
/**
 * Computes the cross product of two vectors; assumes both vectors have
 * three entries.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of a cross b.
 */
function cross(a, b, dst) {
  dst = dst || new VecType$1(3);
  const t1 = a[2] * b[0] - a[0] * b[2];
  const t2 = a[0] * b[1] - a[1] * b[0];
  dst[0] = a[1] * b[2] - a[2] * b[1];
  dst[1] = t1;
  dst[2] = t2;
  return dst;
}
/**
 * Computes the dot product of two vectors; assumes both vectors have
 * three entries.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns dot product
 */
function dot$1(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the length of vector
 * @param v - vector.
 * @returns length of vector.
 */
function length$1(v) {
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);
}
/**
 * Computes the length of vector (same as length)
 * @param v - vector.
 * @returns length of vector.
 */
const len$1 = length$1;
/**
 * Computes the square of the length of vector
 * @param v - vector.
 * @returns square of the length of vector.
 */
function lengthSq$1(v) {
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  return v0 * v0 + v1 * v1 + v2 * v2;
}
/**
 * Computes the square of the length of vector (same as lengthSq)
 * @param v - vector.
 * @returns square of the length of vector.
 */
const lenSq$1 = lengthSq$1;
/**
 * Computes the distance between 2 points
 * @param a - vector.
 * @param b - vector.
 * @returns distance between a and b
 */
function distance$1(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}
/**
 * Computes the distance between 2 points (same as distance)
 * @param a - vector.
 * @param b - vector.
 * @returns distance between a and b
 */
const dist$1 = distance$1;
/**
 * Computes the square of the distance between 2 points
 * @param a - vector.
 * @param b - vector.
 * @returns square of the distance between a and b
 */
function distanceSq$1(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  return dx * dx + dy * dy + dz * dz;
}
/**
 * Computes the square of the distance between 2 points (same as distanceSq)
 * @param a - vector.
 * @param b - vector.
 * @returns square of the distance between a and b
 */
const distSq$1 = distanceSq$1;
/**
 * Divides a vector by its Euclidean length and returns the quotient.
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The normalized vector.
 */
function normalize$1(v, dst) {
  dst = dst || new VecType$1(3);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);
  if (len > 0.00001) {
    dst[0] = v0 / len;
    dst[1] = v1 / len;
    dst[2] = v2 / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
    dst[2] = 0;
  }
  return dst;
}
/**
 * Negates a vector.
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns -v.
 */
function negate$2(v, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = -v[0];
  dst[1] = -v[1];
  dst[2] = -v[2];
  return dst;
}
/**
 * Copies a vector. (same as clone)
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A copy of v.
 */
function copy$2(v, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = v[0];
  dst[1] = v[1];
  dst[2] = v[2];
  return dst;
}
/**
 * Clones a vector. (same as copy)
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A copy of v.
 */
const clone$2 = copy$2;
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of products of entries of a and b.
 */
function multiply$2(a, b, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] * b[0];
  dst[1] = a[1] * b[1];
  dst[2] = a[2] * b[2];
  return dst;
}
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length. (same as mul)
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of products of entries of a and b.
 */
const mul$2 = multiply$2;
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of quotients of entries of a and b.
 */
function divide$1(a, b, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] / b[0];
  dst[1] = a[1] / b[1];
  dst[2] = a[2] / b[2];
  return dst;
}
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length. (same as divide)
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of quotients of entries of a and b.
 */
const div$1 = divide$1;
/**
 * Creates a random vector
 * @param scale - Default 1
 * @param dst - vector to hold result. If not new one is created.
 * @returns The random vector.
 */
function random(scale = 1, dst) {
  dst = dst || new VecType$1(3);
  const angle = Math.random() * 2 * Math.PI;
  const z = Math.random() * 2 - 1;
  const zScale = Math.sqrt(1 - z * z) * scale;
  dst[0] = Math.cos(angle) * zScale;
  dst[1] = Math.sin(angle) * zScale;
  dst[2] = z * scale;
  return dst;
}
/**
 * Zero's a vector
 * @param dst - vector to hold result. If not new one is created.
 * @returns The zeroed vector.
 */
function zero$1(dst) {
  dst = dst || new VecType$1(3);
  dst[0] = 0;
  dst[1] = 0;
  dst[2] = 0;
  return dst;
}
/**
 * transform vec3 by 4x4 matrix
 * @param v - the vector
 * @param m - The matrix.
 * @param dst - optional vec3 to store result. If not passed a new one is created.
 * @returns the transformed vector
 */
function transformMat4$1(v, m, dst) {
  dst = dst || new VecType$1(3);
  const x = v[0];
  const y = v[1];
  const z = v[2];
  const w = m[3] * x + m[7] * y + m[11] * z + m[15] || 1;
  dst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  dst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  dst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return dst;
}
/**
 * Transform vec4 by upper 3x3 matrix inside 4x4 matrix.
 * @param v - The direction.
 * @param m - The matrix.
 * @param dst - optional Vec3 to store result. If not passed a new one is created.
 * @returns The transformed vector.
 */
function transformMat4Upper3x3(v, m, dst) {
  dst = dst || new VecType$1(3);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];
  return dst;
}
/**
 * Transforms vec4 by 3x3 matrix
 *
 * @param v - the vector
 * @param m - The matrix.
 * @param dst - optional vec3 to store result. If not passed a new one is created.
 * @returns the transformed vector
 */
function transformMat3(v, m, dst) {
  dst = dst || new VecType$1(3);
  const x = v[0];
  const y = v[1];
  const z = v[2];
  dst[0] = x * m[0] + y * m[4] + z * m[8];
  dst[1] = x * m[1] + y * m[5] + z * m[9];
  dst[2] = x * m[2] + y * m[6] + z * m[10];
  return dst;
}
var vec3Impl = exports.vec3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create: create$2,
  setDefaultType: setDefaultType$3,
  fromValues: fromValues$1,
  ceil: ceil$1,
  floor: floor$1,
  round: round$1,
  clamp: clamp$1,
  add: add$1,
  addScaled: addScaled$1,
  angle: angle,
  subtract: subtract$1,
  sub: sub$1,
  equalsApproximately: equalsApproximately$2,
  equals: equals$2,
  lerp: lerp$1,
  lerpV: lerpV$1,
  max: max$1,
  min: min$1,
  mulScalar: mulScalar$1,
  scale: scale$2,
  divScalar: divScalar$1,
  inverse: inverse$2,
  invert: invert$2,
  cross: cross,
  dot: dot$1,
  length: length$1,
  len: len$1,
  lengthSq: lengthSq$1,
  lenSq: lenSq$1,
  distance: distance$1,
  dist: dist$1,
  distanceSq: distanceSq$1,
  distSq: distSq$1,
  normalize: normalize$1,
  negate: negate$2,
  copy: copy$2,
  clone: clone$2,
  multiply: multiply$2,
  mul: mul$2,
  divide: divide$1,
  div: div$1,
  random: random,
  zero: zero$1,
  transformMat4: transformMat4$1,
  transformMat4Upper3x3: transformMat4Upper3x3,
  transformMat3: transformMat3
});

/**
 * 4x4 Matrix math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new matrix. In other words you can do this
 *
 *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix
 *
 * or
 *
 *     const mat = mat4.create();
 *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any matrix as the destination. So for example
 *
 *     const mat = mat4.identity();
 *     const trans = mat4.translation([1, 2, 3]);
 *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
 *
 */
let MatType = Float32Array;
/**
 * Sets the type this library creates for a Mat4
 * @param ctor - the constructor for the type. Either `Float32Array`, 'Float64Array', or `Array`
 * @returns previous constructor for Mat4
 */
function setDefaultType$2(ctor) {
  const oldType = MatType;
  MatType = ctor;
  return oldType;
}
/**
 * Create a Mat4 from values
 *
 * Note: Since passing in a raw JavaScript array
 * is valid in all circumstances, if you want to
 * force a JavaScript array into a Mat4's specified type
 * it would be faster to use
 *
 * ```
 * const m = mat4.clone(someJSArray);
 * ```
 *
 * Note: a consequence of the implementation is if your Mat4Type = `Array`
 * instead of `Float32Array` or `Float64Array` then any values you
 * don't pass in will be undefined. Usually this is not an issue since
 * (a) using `Array` is rare and (b) using `mat4.create` is usually used
 * to create a Mat4 to be filled out as in
 *
 * ```
 * const m = mat4.create();
 * mat4.perspective(fov, aspect, near, far, m);
 * ```
 *
 * @param v0 - value for element 0
 * @param v1 - value for element 1
 * @param v2 - value for element 2
 * @param v3 - value for element 3
 * @param v4 - value for element 4
 * @param v5 - value for element 5
 * @param v6 - value for element 6
 * @param v7 - value for element 7
 * @param v8 - value for element 8
 * @param v9 - value for element 9
 * @param v10 - value for element 10
 * @param v11 - value for element 11
 * @param v12 - value for element 12
 * @param v13 - value for element 13
 * @param v14 - value for element 14
 * @param v15 - value for element 15
 * @returns created from values.
 */
function create$1(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
  const dst = new MatType(16);
  if (v0 !== undefined) {
    dst[0] = v0;
    if (v1 !== undefined) {
      dst[1] = v1;
      if (v2 !== undefined) {
        dst[2] = v2;
        if (v3 !== undefined) {
          dst[3] = v3;
          if (v4 !== undefined) {
            dst[4] = v4;
            if (v5 !== undefined) {
              dst[5] = v5;
              if (v6 !== undefined) {
                dst[6] = v6;
                if (v7 !== undefined) {
                  dst[7] = v7;
                  if (v8 !== undefined) {
                    dst[8] = v8;
                    if (v9 !== undefined) {
                      dst[9] = v9;
                      if (v10 !== undefined) {
                        dst[10] = v10;
                        if (v11 !== undefined) {
                          dst[11] = v11;
                          if (v12 !== undefined) {
                            dst[12] = v12;
                            if (v13 !== undefined) {
                              dst[13] = v13;
                              if (v14 !== undefined) {
                                dst[14] = v14;
                                if (v15 !== undefined) {
                                  dst[15] = v15;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return dst;
}
/**
 * Negates a matrix.
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns -m.
 */
function negate$1(m, dst) {
  dst = dst || new MatType(16);
  dst[0] = -m[0];
  dst[1] = -m[1];
  dst[2] = -m[2];
  dst[3] = -m[3];
  dst[4] = -m[4];
  dst[5] = -m[5];
  dst[6] = -m[6];
  dst[7] = -m[7];
  dst[8] = -m[8];
  dst[9] = -m[9];
  dst[10] = -m[10];
  dst[11] = -m[11];
  dst[12] = -m[12];
  dst[13] = -m[13];
  dst[14] = -m[14];
  dst[15] = -m[15];
  return dst;
}
/**
 * Copies a matrix.
 * @param m - The matrix.
 * @param dst - The matrix. If not passed a new one is created.
 * @returns A copy of m.
 */
function copy$1(m, dst) {
  dst = dst || new MatType(16);
  dst[0] = m[0];
  dst[1] = m[1];
  dst[2] = m[2];
  dst[3] = m[3];
  dst[4] = m[4];
  dst[5] = m[5];
  dst[6] = m[6];
  dst[7] = m[7];
  dst[8] = m[8];
  dst[9] = m[9];
  dst[10] = m[10];
  dst[11] = m[11];
  dst[12] = m[12];
  dst[13] = m[13];
  dst[14] = m[14];
  dst[15] = m[15];
  return dst;
}
/**
 * Copies a matrix (same as copy)
 * @param m - The matrix.
 * @param dst - The matrix. If not passed a new one is created.
 * @returns A copy of m.
 */
const clone$1 = copy$1;
/**
 * Check if 2 matrices are approximately equal
 * @param a - Operand matrix.
 * @param b - Operand matrix.
 * @returns true if matrices are approximately equal
 */
function equalsApproximately$1(a, b) {
  return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON && Math.abs(a[3] - b[3]) < EPSILON && Math.abs(a[4] - b[4]) < EPSILON && Math.abs(a[5] - b[5]) < EPSILON && Math.abs(a[6] - b[6]) < EPSILON && Math.abs(a[7] - b[7]) < EPSILON && Math.abs(a[8] - b[8]) < EPSILON && Math.abs(a[9] - b[9]) < EPSILON && Math.abs(a[10] - b[10]) < EPSILON && Math.abs(a[11] - b[11]) < EPSILON && Math.abs(a[12] - b[12]) < EPSILON && Math.abs(a[13] - b[13]) < EPSILON && Math.abs(a[14] - b[14]) < EPSILON && Math.abs(a[15] - b[15]) < EPSILON;
}
/**
 * Check if 2 matrices are exactly equal
 * @param a - Operand matrix.
 * @param b - Operand matrix.
 * @returns true if matrices are exactly equal
 */
function equals$1(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Creates a 4-by-4 identity matrix.
 *
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns A 4-by-4 identity matrix.
 */
function identity(dst) {
  dst = dst || new MatType(16);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Takes the transpose of a matrix.
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The transpose of m.
 */
function transpose(m, dst) {
  dst = dst || new MatType(16);
  if (dst === m) {
    let t;
    t = m[1];
    m[1] = m[4];
    m[4] = t;
    t = m[2];
    m[2] = m[8];
    m[8] = t;
    t = m[3];
    m[3] = m[12];
    m[12] = t;
    t = m[6];
    m[6] = m[9];
    m[9] = t;
    t = m[7];
    m[7] = m[13];
    m[13] = t;
    t = m[11];
    m[11] = m[14];
    m[14] = t;
    return dst;
  }
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  dst[0] = m00;
  dst[1] = m10;
  dst[2] = m20;
  dst[3] = m30;
  dst[4] = m01;
  dst[5] = m11;
  dst[6] = m21;
  dst[7] = m31;
  dst[8] = m02;
  dst[9] = m12;
  dst[10] = m22;
  dst[11] = m32;
  dst[12] = m03;
  dst[13] = m13;
  dst[14] = m23;
  dst[15] = m33;
  return dst;
}
/**
 * Computes the inverse of a 4-by-4 matrix.
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The inverse of m.
 */
function inverse$1(m, dst) {
  dst = dst || new MatType(16);
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  const tmp0 = m22 * m33;
  const tmp1 = m32 * m23;
  const tmp2 = m12 * m33;
  const tmp3 = m32 * m13;
  const tmp4 = m12 * m23;
  const tmp5 = m22 * m13;
  const tmp6 = m02 * m33;
  const tmp7 = m32 * m03;
  const tmp8 = m02 * m23;
  const tmp9 = m22 * m03;
  const tmp10 = m02 * m13;
  const tmp11 = m12 * m03;
  const tmp12 = m20 * m31;
  const tmp13 = m30 * m21;
  const tmp14 = m10 * m31;
  const tmp15 = m30 * m11;
  const tmp16 = m10 * m21;
  const tmp17 = m20 * m11;
  const tmp18 = m00 * m31;
  const tmp19 = m30 * m01;
  const tmp20 = m00 * m21;
  const tmp21 = m20 * m01;
  const tmp22 = m00 * m11;
  const tmp23 = m10 * m01;
  const t0 = tmp0 * m11 + tmp3 * m21 + tmp4 * m31 - (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
  const t1 = tmp1 * m01 + tmp6 * m21 + tmp9 * m31 - (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
  const t2 = tmp2 * m01 + tmp7 * m11 + tmp10 * m31 - (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
  const t3 = tmp5 * m01 + tmp8 * m11 + tmp11 * m21 - (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
  const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
  dst[0] = d * t0;
  dst[1] = d * t1;
  dst[2] = d * t2;
  dst[3] = d * t3;
  dst[4] = d * (tmp1 * m10 + tmp2 * m20 + tmp5 * m30 - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));
  dst[5] = d * (tmp0 * m00 + tmp7 * m20 + tmp8 * m30 - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));
  dst[6] = d * (tmp3 * m00 + tmp6 * m10 + tmp11 * m30 - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));
  dst[7] = d * (tmp4 * m00 + tmp9 * m10 + tmp10 * m20 - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));
  dst[8] = d * (tmp12 * m13 + tmp15 * m23 + tmp16 * m33 - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));
  dst[9] = d * (tmp13 * m03 + tmp18 * m23 + tmp21 * m33 - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));
  dst[10] = d * (tmp14 * m03 + tmp19 * m13 + tmp22 * m33 - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));
  dst[11] = d * (tmp17 * m03 + tmp20 * m13 + tmp23 * m23 - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));
  dst[12] = d * (tmp14 * m22 + tmp17 * m32 + tmp13 * m12 - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));
  dst[13] = d * (tmp20 * m32 + tmp12 * m02 + tmp19 * m22 - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));
  dst[14] = d * (tmp18 * m12 + tmp23 * m32 + tmp15 * m02 - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));
  dst[15] = d * (tmp22 * m22 + tmp16 * m02 + tmp21 * m12 - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));
  return dst;
}
/**
 * Compute the determinant of a matrix
 * @param m - the matrix
 * @returns the determinant
 */
function determinant(m) {
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  const tmp0 = m22 * m33;
  const tmp1 = m32 * m23;
  const tmp2 = m12 * m33;
  const tmp3 = m32 * m13;
  const tmp4 = m12 * m23;
  const tmp5 = m22 * m13;
  const tmp6 = m02 * m33;
  const tmp7 = m32 * m03;
  const tmp8 = m02 * m23;
  const tmp9 = m22 * m03;
  const tmp10 = m02 * m13;
  const tmp11 = m12 * m03;
  const t0 = tmp0 * m11 + tmp3 * m21 + tmp4 * m31 - (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
  const t1 = tmp1 * m01 + tmp6 * m21 + tmp9 * m31 - (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
  const t2 = tmp2 * m01 + tmp7 * m11 + tmp10 * m31 - (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
  const t3 = tmp5 * m01 + tmp8 * m11 + tmp11 * m21 - (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
  return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;
}
/**
 * Computes the inverse of a 4-by-4 matrix. (same as inverse)
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The inverse of m.
 */
const invert$1 = inverse$1;
/**
 * Multiplies two 4-by-4 matrices with a on the left and b on the right
 * @param a - The matrix on the left.
 * @param b - The matrix on the right.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The matrix product of a and b.
 */
function multiply$1(a, b, dst) {
  dst = dst || new MatType(16);
  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a03 = a[3];
  const a10 = a[4 + 0];
  const a11 = a[4 + 1];
  const a12 = a[4 + 2];
  const a13 = a[4 + 3];
  const a20 = a[8 + 0];
  const a21 = a[8 + 1];
  const a22 = a[8 + 2];
  const a23 = a[8 + 3];
  const a30 = a[12 + 0];
  const a31 = a[12 + 1];
  const a32 = a[12 + 2];
  const a33 = a[12 + 3];
  const b00 = b[0];
  const b01 = b[1];
  const b02 = b[2];
  const b03 = b[3];
  const b10 = b[4 + 0];
  const b11 = b[4 + 1];
  const b12 = b[4 + 2];
  const b13 = b[4 + 3];
  const b20 = b[8 + 0];
  const b21 = b[8 + 1];
  const b22 = b[8 + 2];
  const b23 = b[8 + 3];
  const b30 = b[12 + 0];
  const b31 = b[12 + 1];
  const b32 = b[12 + 2];
  const b33 = b[12 + 3];
  dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
  dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
  dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
  dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
  dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
  dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
  dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
  dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
  dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
  dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
  dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
  dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
  dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
  dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
  dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
  dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
  return dst;
}
/**
 * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)
 * @param a - The matrix on the left.
 * @param b - The matrix on the right.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The matrix product of a and b.
 */
const mul$1 = multiply$1;
/**
 * Sets the translation component of a 4-by-4 matrix to the given
 * vector.
 * @param a - The matrix.
 * @param v - The vector.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The matrix with translation set.
 */
function setTranslation(a, v, dst) {
  dst = dst || identity();
  if (a !== dst) {
    dst[0] = a[0];
    dst[1] = a[1];
    dst[2] = a[2];
    dst[3] = a[3];
    dst[4] = a[4];
    dst[5] = a[5];
    dst[6] = a[6];
    dst[7] = a[7];
    dst[8] = a[8];
    dst[9] = a[9];
    dst[10] = a[10];
    dst[11] = a[11];
  }
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}
/**
 * Returns the translation component of a 4-by-4 matrix as a vector with 3
 * entries.
 * @param m - The matrix.
 * @param dst - vector to hold result. If not passed a new one is created.
 * @returns The translation component of m.
 */
function getTranslation(m, dst) {
  dst = dst || create$2();
  dst[0] = m[12];
  dst[1] = m[13];
  dst[2] = m[14];
  return dst;
}
/**
 * Returns an axis of a 4x4 matrix as a vector with 3 entries
 * @param m - The matrix.
 * @param axis - The axis 0 = x, 1 = y, 2 = z;
 * @returns The axis component of m.
 */
function getAxis(m, axis, dst) {
  dst = dst || create$2();
  const off = axis * 4;
  dst[0] = m[off + 0];
  dst[1] = m[off + 1];
  dst[2] = m[off + 2];
  return dst;
}
/**
 * Sets an axis of a 4x4 matrix as a vector with 3 entries
 * @param m - The matrix.
 * @param v - the axis vector
 * @param axis - The axis  0 = x, 1 = y, 2 = z;
 * @param dst - The matrix to set. If not passed a new one is created.
 * @returns The matrix with axis set.
 */
function setAxis(a, v, axis, dst) {
  if (dst !== a) {
    dst = copy$1(a, dst);
  }
  const off = axis * 4;
  dst[off + 0] = v[0];
  dst[off + 1] = v[1];
  dst[off + 2] = v[2];
  return dst;
}
/**
 * Returns the scaling component of the matrix
 * @param m - The Matrix
 * @param dst - The vector to set. If not passed a new one is created.
 */
function getScaling(m, dst) {
  dst = dst || create$2();
  const xx = m[0];
  const xy = m[1];
  const xz = m[2];
  const yx = m[4];
  const yy = m[5];
  const yz = m[6];
  const zx = m[8];
  const zy = m[9];
  const zz = m[10];
  dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);
  dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);
  dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);
  return dst;
}
/**
 * Computes a 4-by-4 perspective transformation matrix given the angular height
 * of the frustum, the aspect ratio, and the near and far clipping planes.  The
 * arguments define a frustum extending in the negative z direction.  The given
 * angle is the vertical angle of the frustum, and the horizontal angle is
 * determined to produce the given aspect ratio.  The arguments near and far are
 * the distances to the near and far clipping planes.  Note that near and far
 * are not z coordinates, but rather they are distances along the negative
 * z-axis.  The matrix generated sends the viewing frustum to the unit box.
 * We assume a unit box extending from -1 to 1 in the x and y dimensions and
 * from 0 to 1 in the z dimension.
 * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).
 * @param aspect - The aspect ratio width / height.
 * @param zNear - The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param zFar - The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The perspective matrix.
 */
function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
  dst = dst || new MatType(16);
  const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
  const rangeInv = 1 / (zNear - zFar);
  dst[0] = f / aspect;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = f;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = zFar * rangeInv;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = zNear * zFar * rangeInv;
  dst[15] = 0;
  return dst;
}
/**
 * Computes a 4-by-4 orthogonal transformation matrix that transforms from
 * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y
 * and 0 to +1 in z.
 * @param left - Left side of the near clipping plane viewport.
 * @param right - Right side of the near clipping plane viewport.
 * @param bottom - Bottom of the near clipping plane viewport.
 * @param top - Top of the near clipping plane viewport.
 * @param near - The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param far - The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param dst - Output matrix. If not passed a new one is created.
 * @returns The perspective matrix.
 */
function ortho(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);
  dst[0] = 2 / (right - left);
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 2 / (top - bottom);
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1 / (near - far);
  dst[11] = 0;
  dst[12] = (right + left) / (left - right);
  dst[13] = (top + bottom) / (bottom - top);
  dst[14] = near / (near - far);
  dst[15] = 1;
  return dst;
}
/**
 * Computes a 4-by-4 perspective transformation matrix given the left, right,
 * top, bottom, near and far clipping planes. The arguments define a frustum
 * extending in the negative z direction. The arguments near and far are the
 * distances to the near and far clipping planes. Note that near and far are not
 * z coordinates, but rather they are distances along the negative z-axis. The
 * matrix generated sends the viewing frustum to the unit box. We assume a unit
 * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z
 * dimension.
 * @param left - The x coordinate of the left plane of the box.
 * @param right - The x coordinate of the right plane of the box.
 * @param bottom - The y coordinate of the bottom plane of the box.
 * @param top - The y coordinate of the right plane of the box.
 * @param near - The negative z coordinate of the near plane of the box.
 * @param far - The negative z coordinate of the far plane of the box.
 * @param dst - Output matrix. If not passed a new one is created.
 * @returns The perspective projection matrix.
 */
function frustum(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);
  const dx = right - left;
  const dy = top - bottom;
  const dz = near - far;
  dst[0] = 2 * near / dx;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 2 * near / dy;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = (left + right) / dx;
  dst[9] = (top + bottom) / dy;
  dst[10] = far / dz;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = near * far / dz;
  dst[15] = 0;
  return dst;
}
let xAxis;
let yAxis;
let zAxis;
/**
 * Computes a 4-by-4 look-at transformation.
 *
 * This is a matrix which positions the camera itself. If you want
 * a view matrix (a matrix which moves things in front of the camera)
 * take the inverse of this.
 *
 * @param eye - The position of the eye.
 * @param target - The position meant to be viewed.
 * @param up - A vector pointing up.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The look-at matrix.
 */
function lookAt(eye, target, up, dst) {
  dst = dst || new MatType(16);
  xAxis = xAxis || create$2();
  yAxis = yAxis || create$2();
  zAxis = zAxis || create$2();
  normalize$1(subtract$1(eye, target, zAxis), zAxis);
  normalize$1(cross(up, zAxis, xAxis), xAxis);
  normalize$1(cross(zAxis, xAxis, yAxis), yAxis);
  dst[0] = xAxis[0];
  dst[1] = xAxis[1];
  dst[2] = xAxis[2];
  dst[3] = 0;
  dst[4] = yAxis[0];
  dst[5] = yAxis[1];
  dst[6] = yAxis[2];
  dst[7] = 0;
  dst[8] = zAxis[0];
  dst[9] = zAxis[1];
  dst[10] = zAxis[2];
  dst[11] = 0;
  dst[12] = eye[0];
  dst[13] = eye[1];
  dst[14] = eye[2];
  dst[15] = 1;
  return dst;
}
/**
 * Creates a 4-by-4 matrix which translates by the given vector v.
 * @param v - The vector by
 *     which to translate.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The translation matrix.
 */
function translation(v, dst) {
  dst = dst || new MatType(16);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}
/**
 * Translates the given 4-by-4 matrix by the given vector v.
 * @param m - The matrix.
 * @param v - The vector by
 *     which to translate.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The translated matrix.
 */
function translate(m, v, dst) {
  dst = dst || new MatType(16);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const m00 = m[0];
  const m01 = m[1];
  const m02 = m[2];
  const m03 = m[3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  if (m !== dst) {
    dst[0] = m00;
    dst[1] = m01;
    dst[2] = m02;
    dst[3] = m03;
    dst[4] = m10;
    dst[5] = m11;
    dst[6] = m12;
    dst[7] = m13;
    dst[8] = m20;
    dst[9] = m21;
    dst[10] = m22;
    dst[11] = m23;
  }
  dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;
  dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;
  dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;
  dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotation matrix.
 */
function rotationX(angleInRadians, dst) {
  dst = dst || new MatType(16);
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = c;
  dst[6] = s;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = -s;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the x-axis by the given
 * angle.
 * @param m - The matrix.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotated matrix.
 */
function rotateX(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  const m10 = m[4];
  const m11 = m[5];
  const m12 = m[6];
  const m13 = m[7];
  const m20 = m[8];
  const m21 = m[9];
  const m22 = m[10];
  const m23 = m[11];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[4] = c * m10 + s * m20;
  dst[5] = c * m11 + s * m21;
  dst[6] = c * m12 + s * m22;
  dst[7] = c * m13 + s * m23;
  dst[8] = c * m20 - s * m10;
  dst[9] = c * m21 - s * m11;
  dst[10] = c * m22 - s * m12;
  dst[11] = c * m23 - s * m13;
  if (m !== dst) {
    dst[0] = m[0];
    dst[1] = m[1];
    dst[2] = m[2];
    dst[3] = m[3];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotation matrix.
 */
function rotationY(angleInRadians, dst) {
  dst = dst || new MatType(16);
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = 0;
  dst[2] = -s;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = s;
  dst[9] = 0;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the y-axis by the given
 * angle.
 * @param m - The matrix.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotated matrix.
 */
function rotateY(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c * m00 - s * m20;
  dst[1] = c * m01 - s * m21;
  dst[2] = c * m02 - s * m22;
  dst[3] = c * m03 - s * m23;
  dst[8] = c * m20 + s * m00;
  dst[9] = c * m21 + s * m01;
  dst[10] = c * m22 + s * m02;
  dst[11] = c * m23 + s * m03;
  if (m !== dst) {
    dst[4] = m[4];
    dst[5] = m[5];
    dst[6] = m[6];
    dst[7] = m[7];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotation matrix.
 */
function rotationZ(angleInRadians, dst) {
  dst = dst || new MatType(16);
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = s;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = -s;
  dst[5] = c;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the z-axis by the given
 * angle.
 * @param m - The matrix.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotated matrix.
 */
function rotateZ(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c * m00 + s * m10;
  dst[1] = c * m01 + s * m11;
  dst[2] = c * m02 + s * m12;
  dst[3] = c * m03 + s * m13;
  dst[4] = c * m10 - s * m00;
  dst[5] = c * m11 - s * m01;
  dst[6] = c * m12 - s * m02;
  dst[7] = c * m13 - s * m03;
  if (m !== dst) {
    dst[8] = m[8];
    dst[9] = m[9];
    dst[10] = m[10];
    dst[11] = m[11];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the given axis by the given
 * angle.
 * @param axis - The axis
 *     about which to rotate.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns A matrix which rotates angle radians
 *     around the axis.
 */
function axisRotation(axis, angleInRadians, dst) {
  dst = dst || new MatType(16);
  let x = axis[0];
  let y = axis[1];
  let z = axis[2];
  const n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  const xx = x * x;
  const yy = y * y;
  const zz = z * z;
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  const oneMinusCosine = 1 - c;
  dst[0] = xx + (1 - xx) * c;
  dst[1] = x * y * oneMinusCosine + z * s;
  dst[2] = x * z * oneMinusCosine - y * s;
  dst[3] = 0;
  dst[4] = x * y * oneMinusCosine - z * s;
  dst[5] = yy + (1 - yy) * c;
  dst[6] = y * z * oneMinusCosine + x * s;
  dst[7] = 0;
  dst[8] = x * z * oneMinusCosine + y * s;
  dst[9] = y * z * oneMinusCosine - x * s;
  dst[10] = zz + (1 - zz) * c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the given axis by the given
 * angle. (same as axisRotation)
 * @param axis - The axis
 *     about which to rotate.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns A matrix which rotates angle radians
 *     around the axis.
 */
const rotation = axisRotation;
/**
 * Rotates the given 4-by-4 matrix around the given axis by the
 * given angle.
 * @param m - The matrix.
 * @param axis - The axis
 *     about which to rotate.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotated matrix.
 */
function axisRotate(m, axis, angleInRadians, dst) {
  dst = dst || new MatType(16);
  let x = axis[0];
  let y = axis[1];
  let z = axis[2];
  const n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  const xx = x * x;
  const yy = y * y;
  const zz = z * z;
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  const oneMinusCosine = 1 - c;
  const r00 = xx + (1 - xx) * c;
  const r01 = x * y * oneMinusCosine + z * s;
  const r02 = x * z * oneMinusCosine - y * s;
  const r10 = x * y * oneMinusCosine - z * s;
  const r11 = yy + (1 - yy) * c;
  const r12 = y * z * oneMinusCosine + x * s;
  const r20 = x * z * oneMinusCosine + y * s;
  const r21 = y * z * oneMinusCosine - x * s;
  const r22 = zz + (1 - zz) * c;
  const m00 = m[0];
  const m01 = m[1];
  const m02 = m[2];
  const m03 = m[3];
  const m10 = m[4];
  const m11 = m[5];
  const m12 = m[6];
  const m13 = m[7];
  const m20 = m[8];
  const m21 = m[9];
  const m22 = m[10];
  const m23 = m[11];
  dst[0] = r00 * m00 + r01 * m10 + r02 * m20;
  dst[1] = r00 * m01 + r01 * m11 + r02 * m21;
  dst[2] = r00 * m02 + r01 * m12 + r02 * m22;
  dst[3] = r00 * m03 + r01 * m13 + r02 * m23;
  dst[4] = r10 * m00 + r11 * m10 + r12 * m20;
  dst[5] = r10 * m01 + r11 * m11 + r12 * m21;
  dst[6] = r10 * m02 + r11 * m12 + r12 * m22;
  dst[7] = r10 * m03 + r11 * m13 + r12 * m23;
  dst[8] = r20 * m00 + r21 * m10 + r22 * m20;
  dst[9] = r20 * m01 + r21 * m11 + r22 * m21;
  dst[10] = r20 * m02 + r21 * m12 + r22 * m22;
  dst[11] = r20 * m03 + r21 * m13 + r22 * m23;
  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the given axis by the
 * given angle. (same as rotate)
 * @param m - The matrix.
 * @param axis - The axis
 *     about which to rotate.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotated matrix.
 */
const rotate = axisRotate;
/**
 * Creates a 4-by-4 matrix which scales in each dimension by an amount given by
 * the corresponding entry in the given vector; assumes the vector has three
 * entries.
 * @param v - A vector of
 *     three entries specifying the factor by which to scale in each dimension.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The scaling matrix.
 */
function scaling(v, dst) {
  dst = dst || new MatType(16);
  dst[0] = v[0];
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = v[1];
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = v[2];
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Scales the given 4-by-4 matrix in each dimension by an amount
 * given by the corresponding entry in the given vector; assumes the vector has
 * three entries.
 * @param m - The matrix to be modified.
 * @param v - A vector of three entries specifying the
 *     factor by which to scale in each dimension.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The scaled matrix.
 */
function scale$1(m, v, dst) {
  dst = dst || new MatType(16);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  dst[0] = v0 * m[0 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2];
  dst[3] = v0 * m[0 * 4 + 3];
  dst[4] = v1 * m[1 * 4 + 0];
  dst[5] = v1 * m[1 * 4 + 1];
  dst[6] = v1 * m[1 * 4 + 2];
  dst[7] = v1 * m[1 * 4 + 3];
  dst[8] = v2 * m[2 * 4 + 0];
  dst[9] = v2 * m[2 * 4 + 1];
  dst[10] = v2 * m[2 * 4 + 2];
  dst[11] = v2 * m[2 * 4 + 3];
  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}
var mat4Impl = exports.mat4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setDefaultType: setDefaultType$2,
  create: create$1,
  negate: negate$1,
  copy: copy$1,
  clone: clone$1,
  equalsApproximately: equalsApproximately$1,
  equals: equals$1,
  identity: identity,
  transpose: transpose,
  inverse: inverse$1,
  determinant: determinant,
  invert: invert$1,
  multiply: multiply$1,
  mul: mul$1,
  setTranslation: setTranslation,
  getTranslation: getTranslation,
  getAxis: getAxis,
  setAxis: setAxis,
  getScaling: getScaling,
  perspective: perspective,
  ortho: ortho,
  frustum: frustum,
  lookAt: lookAt,
  translation: translation,
  translate: translate,
  rotationX: rotationX,
  rotateX: rotateX,
  rotationY: rotationY,
  rotateY: rotateY,
  rotationZ: rotationZ,
  rotateZ: rotateZ,
  axisRotation: axisRotation,
  rotation: rotation,
  axisRotate: axisRotate,
  rotate: rotate,
  scaling: scaling,
  scale: scale$1
});

/**
 *
 * Vec4 math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new `Vec4`. In other words you can do this
 *
 *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = vec4.create();
 *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
let VecType = Float32Array;
/**
 * Sets the type this library creates for a Vec4
 * @param ctor - the constructor for the type. Either `Float32Array`, 'Float64Array', or `Array`
 * @returns previous constructor for Vec4
 */
function setDefaultType$1(ctor) {
  const oldType = VecType;
  VecType = ctor;
  return oldType;
}
/**
 * Creates a vec4; may be called with x, y, z to set initial values.
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @param z - Initial z value.
 * @param w - Initial w value.
 * @returns the created vector
 */
function create(x, y, z, w) {
  const dst = new VecType(4);
  if (x !== undefined) {
    dst[0] = x;
    if (y !== undefined) {
      dst[1] = y;
      if (z !== undefined) {
        dst[2] = z;
        if (w !== undefined) {
          dst[3] = w;
        }
      }
    }
  }
  return dst;
}
/**
 * Creates a vec4; may be called with x, y, z to set initial values. (same as create)
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @param z - Initial z value.
 * @param z - Initial w value.
 * @returns the created vector
 */
const fromValues = create;
/**
 * Applies Math.ceil to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the ceil of each element of v.
 */
function ceil(v, dst) {
  dst = dst || new VecType(4);
  dst[0] = Math.ceil(v[0]);
  dst[1] = Math.ceil(v[1]);
  dst[2] = Math.ceil(v[2]);
  dst[3] = Math.ceil(v[3]);
  return dst;
}
/**
 * Applies Math.floor to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the floor of each element of v.
 */
function floor(v, dst) {
  dst = dst || new VecType(4);
  dst[0] = Math.floor(v[0]);
  dst[1] = Math.floor(v[1]);
  dst[2] = Math.floor(v[2]);
  dst[3] = Math.floor(v[3]);
  return dst;
}
/**
 * Applies Math.round to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the round of each element of v.
 */
function round(v, dst) {
  dst = dst || new VecType(4);
  dst[0] = Math.round(v[0]);
  dst[1] = Math.round(v[1]);
  dst[2] = Math.round(v[2]);
  dst[3] = Math.round(v[3]);
  return dst;
}
/**
 * Clamp each element of vector between min and max
 * @param v - Operand vector.
 * @param max - Min value, default 0
 * @param min - Max value, default 1
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that the clamped value of each element of v.
 */
function clamp(v, min = 0, max = 1, dst) {
  dst = dst || new VecType(4);
  dst[0] = Math.min(max, Math.max(min, v[0]));
  dst[1] = Math.min(max, Math.max(min, v[1]));
  dst[2] = Math.min(max, Math.max(min, v[2]));
  dst[3] = Math.min(max, Math.max(min, v[3]));
  return dst;
}
/**
 * Adds two vectors; assumes a and b have the same dimension.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the sum of a and b.
 */
function add(a, b, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  dst[2] = a[2] + b[2];
  dst[3] = a[3] + b[3];
  return dst;
}
/**
 * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param scale - Amount to scale b
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the sum of a + b * scale.
 */
function addScaled(a, b, scale, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] + b[0] * scale;
  dst[1] = a[1] + b[1] * scale;
  dst[2] = a[2] + b[2] * scale;
  dst[3] = a[3] + b[3] * scale;
  return dst;
}
/**
 * Subtracts two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the difference of a and b.
 */
function subtract(a, b, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  dst[2] = a[2] - b[2];
  dst[3] = a[3] - b[3];
  return dst;
}
/**
 * Subtracts two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A vector that is the difference of a and b.
 */
const sub = subtract;
/**
 * Check if 2 vectors are approximately equal
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns true if vectors are approximately equal
 */
function equalsApproximately(a, b) {
  return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON && Math.abs(a[3] - b[3]) < EPSILON;
}
/**
 * Check if 2 vectors are exactly equal
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns true if vectors are exactly equal
 */
function equals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient t, returns
 * a + t * (b - a).
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param t - Interpolation coefficient.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The linear interpolated result.
 */
function lerp(a, b, t, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] + t * (b[0] - a[0]);
  dst[1] = a[1] + t * (b[1] - a[1]);
  dst[2] = a[2] + t * (b[2] - a[2]);
  dst[3] = a[3] + t * (b[3] - a[3]);
  return dst;
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient vector t, returns
 * a + t * (b - a).
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param t - Interpolation coefficients vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns the linear interpolated result.
 */
function lerpV(a, b, t, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] + t[0] * (b[0] - a[0]);
  dst[1] = a[1] + t[1] * (b[1] - a[1]);
  dst[2] = a[2] + t[2] * (b[2] - a[2]);
  dst[3] = a[3] + t[3] * (b[3] - a[3]);
  return dst;
}
/**
 * Return max values of two vectors.
 * Given vectors a and b returns
 * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The max components vector.
 */
function max(a, b, dst) {
  dst = dst || new VecType(4);
  dst[0] = Math.max(a[0], b[0]);
  dst[1] = Math.max(a[1], b[1]);
  dst[2] = Math.max(a[2], b[2]);
  dst[3] = Math.max(a[3], b[3]);
  return dst;
}
/**
 * Return min values of two vectors.
 * Given vectors a and b returns
 * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The min components vector.
 */
function min(a, b, dst) {
  dst = dst || new VecType(4);
  dst[0] = Math.min(a[0], b[0]);
  dst[1] = Math.min(a[1], b[1]);
  dst[2] = Math.min(a[2], b[2]);
  dst[3] = Math.min(a[3], b[3]);
  return dst;
}
/**
 * Multiplies a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The scaled vector.
 */
function mulScalar(v, k, dst) {
  dst = dst || new VecType(4);
  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  dst[2] = v[2] * k;
  dst[3] = v[3] * k;
  return dst;
}
/**
 * Multiplies a vector by a scalar. (same as mulScalar)
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The scaled vector.
 */
const scale = mulScalar;
/**
 * Divides a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The scaled vector.
 */
function divScalar(v, k, dst) {
  dst = dst || new VecType(4);
  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  dst[2] = v[2] / k;
  dst[3] = v[3] / k;
  return dst;
}
/**
 * Inverse a vector.
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The inverted vector.
 */
function inverse(v, dst) {
  dst = dst || new VecType(4);
  dst[0] = 1 / v[0];
  dst[1] = 1 / v[1];
  dst[2] = 1 / v[2];
  dst[3] = 1 / v[3];
  return dst;
}
/**
 * Invert a vector. (same as inverse)
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The inverted vector.
 */
const invert = inverse;
/**
 * Computes the dot product of two vectors; assumes both vectors have
 * three entries.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns dot product
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Computes the length of vector
 * @param v - vector.
 * @returns length of vector.
 */
function length(v) {
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const v3 = v[3];
  return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
}
/**
 * Computes the length of vector (same as length)
 * @param v - vector.
 * @returns length of vector.
 */
const len = length;
/**
 * Computes the square of the length of vector
 * @param v - vector.
 * @returns square of the length of vector.
 */
function lengthSq(v) {
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const v3 = v[3];
  return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;
}
/**
 * Computes the square of the length of vector (same as lengthSq)
 * @param v - vector.
 * @returns square of the length of vector.
 */
const lenSq = lengthSq;
/**
 * Computes the distance between 2 points
 * @param a - vector.
 * @param b - vector.
 * @returns distance between a and b
 */
function distance(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  const dw = a[3] - b[3];
  return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
}
/**
 * Computes the distance between 2 points (same as distance)
 * @param a - vector.
 * @param b - vector.
 * @returns distance between a and b
 */
const dist = distance;
/**
 * Computes the square of the distance between 2 points
 * @param a - vector.
 * @param b - vector.
 * @returns square of the distance between a and b
 */
function distanceSq(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  const dw = a[3] - b[3];
  return dx * dx + dy * dy + dz * dz + dw * dw;
}
/**
 * Computes the square of the distance between 2 points (same as distanceSq)
 * @param a - vector.
 * @param b - vector.
 * @returns square of the distance between a and b
 */
const distSq = distanceSq;
/**
 * Divides a vector by its Euclidean length and returns the quotient.
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The normalized vector.
 */
function normalize(v, dst) {
  dst = dst || new VecType(4);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const v3 = v[3];
  const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
  if (len > 0.00001) {
    dst[0] = v0 / len;
    dst[1] = v1 / len;
    dst[2] = v2 / len;
    dst[3] = v3 / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
  }
  return dst;
}
/**
 * Negates a vector.
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns -v.
 */
function negate(v, dst) {
  dst = dst || new VecType(4);
  dst[0] = -v[0];
  dst[1] = -v[1];
  dst[2] = -v[2];
  dst[3] = -v[3];
  return dst;
}
/**
 * Copies a vector. (same as clone)
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A copy of v.
 */
function copy(v, dst) {
  dst = dst || new VecType(4);
  dst[0] = v[0];
  dst[1] = v[1];
  dst[2] = v[2];
  dst[3] = v[3];
  return dst;
}
/**
 * Clones a vector. (same as copy)
 * @param v - The vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns A copy of v.
 */
const clone = copy;
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of products of entries of a and b.
 */
function multiply(a, b, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] * b[0];
  dst[1] = a[1] * b[1];
  dst[2] = a[2] * b[2];
  dst[3] = a[3] * b[3];
  return dst;
}
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length. (same as mul)
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of products of entries of a and b.
 */
const mul = multiply;
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of quotients of entries of a and b.
 */
function divide(a, b, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] / b[0];
  dst[1] = a[1] / b[1];
  dst[2] = a[2] / b[2];
  dst[3] = a[3] / b[3];
  return dst;
}
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length. (same as divide)
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not new one is created.
 * @returns The vector of quotients of entries of a and b.
 */
const div = divide;
/**
 * Zero's a vector
 * @param dst - vector to hold result. If not new one is created.
 * @returns The zeroed vector.
 */
function zero(dst) {
  dst = dst || new VecType(4);
  dst[0] = 0;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  return dst;
}
/**
 * transform vec4 by 4x4 matrix
 * @param v - the vector
 * @param m - The matrix.
 * @param dst - optional vec4 to store result. If not passed a new one is created.
 * @returns the transformed vector
 */
function transformMat4(v, m, dst) {
  dst = dst || new VecType(4);
  const x = v[0];
  const y = v[1];
  const z = v[2];
  const w = v[3];
  dst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  dst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  dst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  dst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return dst;
}
var vec4Impl = exports.vec4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setDefaultType: setDefaultType$1,
  create: create,
  fromValues: fromValues,
  ceil: ceil,
  floor: floor,
  round: round,
  clamp: clamp,
  add: add,
  addScaled: addScaled,
  subtract: subtract,
  sub: sub,
  equalsApproximately: equalsApproximately,
  equals: equals,
  lerp: lerp,
  lerpV: lerpV,
  max: max,
  min: min,
  mulScalar: mulScalar,
  scale: scale,
  divScalar: divScalar,
  inverse: inverse,
  invert: invert,
  dot: dot,
  length: length,
  len: len,
  lengthSq: lengthSq,
  lenSq: lenSq,
  distance: distance,
  dist: dist,
  distanceSq: distanceSq,
  distSq: distSq,
  normalize: normalize,
  negate: negate,
  copy: copy,
  clone: clone,
  multiply: multiply,
  mul: mul,
  divide: divide,
  div: div,
  zero: zero,
  transformMat4: transformMat4
});

/**
 * Sets the type this library creates for all types
 * @remarks
 *
 * example:
 *
 * ```
 * setDefaultType(Float64Array);
 * ```
 *
 * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`
 */
function setDefaultType(ctor) {
  setDefaultType$4(ctor);
  setDefaultType$2(ctor);
  setDefaultType$5(ctor);
  setDefaultType$3(ctor);
  setDefaultType$1(ctor);
}

},{}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.quat = exports.mat4 = exports.mat3 = void 0;
exports.setDefaultType = setDefaultType;
exports.vec4 = exports.vec3 = exports.vec2 = exports.utils = void 0;
/* wgpu-matrix@2.5.1, license MIT */
/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
let EPSILON = 0.000001;
/**
 * Set the value for EPSILON for various checks
 * @param v - Value to use for EPSILON.
 * @returns previous value of EPSILON;
 */
function setEpsilon(v) {
  const old = EPSILON;
  EPSILON = v;
  return old;
}
/**
 * Convert degrees to radians
 * @param degrees - Angle in degrees
 * @returns angle converted to radians
 */
function degToRad(degrees) {
  return degrees * Math.PI / 180;
}
/**
 * Convert radians to degrees
 * @param radians - Angle in radians
 * @returns angle converted to degrees
 */
function radToDeg(radians) {
  return radians * 180 / Math.PI;
}
/**
 * Lerps between a and b via t
 * @param a - starting value
 * @param b - ending value
 * @param t - value where 0 = a and 1 = b
 * @returns a + (b - a) * t
 */
function lerp$4(a, b, t) {
  return a + (b - a) * t;
}
/**
 * Compute the opposite of lerp. Given a and b and a value between
 * a and b returns a value between 0 and 1. 0 if a, 1 if b.
 * Note: no clamping is done.
 * @param a - start value
 * @param b - end value
 * @param v - value between a and b
 * @returns (v - a) / (b - a)
 */
function inverseLerp(a, b, v) {
  const d = b - a;
  return Math.abs(b - a) < EPSILON ? a : (v - a) / d;
}
/**
 * Compute the euclidean modulo
 *
 * ```
 * // table for n / 3
 * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n
 * ------------------------------------
 * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3
 *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)
 * ```
 *
 * @param n - dividend
 * @param m - divisor
 * @returns the euclidean modulo of n / m
 */
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
var utils = exports.utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get EPSILON() {
    return EPSILON;
  },
  setEpsilon: setEpsilon,
  degToRad: degToRad,
  radToDeg: radToDeg,
  lerp: lerp$4,
  inverseLerp: inverseLerp,
  euclideanModulo: euclideanModulo
});

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 *
 * Vec2 math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new Vec2. In other words you can do this
 *
 *     const v = vec2.cross(v1, v2);  // Creates a new Vec2 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = vec2.create();
 *     vec2.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     vec2.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
let VecType$2 = Float32Array;
/**
 * Sets the type this library creates for a Vec2
 * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`
 * @returns previous constructor for Vec2
 */
function setDefaultType$6(ctor) {
  const oldType = VecType$2;
  VecType$2 = ctor;
  return oldType;
}
/**
 * Creates a Vec2; may be called with x, y, z to set initial values.
 *
 * Note: Since passing in a raw JavaScript array
 * is valid in all circumstances, if you want to
 * force a JavaScript array into a Vec2's specified type
 * it would be faster to use
 *
 * ```
 * const v = vec2.clone(someJSArray);
 * ```
 *
 * Note: a consequence of the implementation is if your Vec2Type = `Array`
 * instead of `Float32Array` or `Float64Array` then any values you
 * don't pass in will be undefined. Usually this is not an issue since
 * (a) using `Array` is rare and (b) using `vec2.create` is usually used
 * to create a Vec2 to be filled out as in
 *
 * ```
 * const sum = vec2.create();
 * vec2.add(v1, v2, sum);
 * ```
 *
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @returns the created vector
 */
function create$5(x = 0, y = 0) {
  const dst = new VecType$2(2);
  if (x !== undefined) {
    dst[0] = x;
    if (y !== undefined) {
      dst[1] = y;
    }
  }
  return dst;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 *
 * Vec3 math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new `Vec3`. In other words you can do this
 *
 *     const v = vec3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = vec3.create();
 *     vec3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     vec3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
let VecType$1 = Float32Array;
/**
 * Sets the type this library creates for a Vec3
 * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`
 * @returns previous constructor for Vec3
 */
function setDefaultType$5(ctor) {
  const oldType = VecType$1;
  VecType$1 = ctor;
  return oldType;
}
/**
 * Creates a vec3; may be called with x, y, z to set initial values.
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @param z - Initial z value.
 * @returns the created vector
 */
function create$4(x, y, z) {
  const dst = new VecType$1(3);
  if (x !== undefined) {
    dst[0] = x;
    if (y !== undefined) {
      dst[1] = y;
      if (z !== undefined) {
        dst[2] = z;
      }
    }
  }
  return dst;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @returns the created vector
 */
const fromValues$3 = create$5;
/**
 * Sets the values of a Vec2
 * Also see {@link vec2.create} and {@link vec2.copy}
 *
 * @param x first value
 * @param y second value
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector with its elements set.
 */
function set$5(x, y, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = x;
  dst[1] = y;
  return dst;
}
/**
 * Applies Math.ceil to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the ceil of each element of v.
 */
function ceil$2(v, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = Math.ceil(v[0]);
  dst[1] = Math.ceil(v[1]);
  return dst;
}
/**
 * Applies Math.floor to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the floor of each element of v.
 */
function floor$2(v, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = Math.floor(v[0]);
  dst[1] = Math.floor(v[1]);
  return dst;
}
/**
 * Applies Math.round to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the round of each element of v.
 */
function round$2(v, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = Math.round(v[0]);
  dst[1] = Math.round(v[1]);
  return dst;
}
/**
 * Clamp each element of vector between min and max
 * @param v - Operand vector.
 * @param max - Min value, default 0
 * @param min - Max value, default 1
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that the clamped value of each element of v.
 */
function clamp$2(v, min = 0, max = 1, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = Math.min(max, Math.max(min, v[0]));
  dst[1] = Math.min(max, Math.max(min, v[1]));
  return dst;
}
/**
 * Adds two vectors; assumes a and b have the same dimension.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the sum of a and b.
 */
function add$3(a, b, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  return dst;
}
/**
 * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param scale - Amount to scale b
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the sum of a + b * scale.
 */
function addScaled$2(a, b, scale, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] + b[0] * scale;
  dst[1] = a[1] + b[1] * scale;
  return dst;
}
/**
 * Returns the angle in radians between two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns The angle in radians between the 2 vectors.
 */
function angle$2(a, b) {
  const ax = a[0];
  const ay = a[1];
  const bx = a[0];
  const by = a[1];
  const mag1 = Math.sqrt(ax * ax + ay * ay);
  const mag2 = Math.sqrt(bx * bx + by * by);
  const mag = mag1 * mag2;
  const cosine = mag && dot$3(a, b) / mag;
  return Math.acos(cosine);
}
/**
 * Subtracts two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the difference of a and b.
 */
function subtract$3(a, b, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  return dst;
}
/**
 * Subtracts two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the difference of a and b.
 */
const sub$3 = subtract$3;
/**
 * Check if 2 vectors are approximately equal
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns true if vectors are approximately equal
 */
function equalsApproximately$5(a, b) {
  return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON;
}
/**
 * Check if 2 vectors are exactly equal
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns true if vectors are exactly equal
 */
function equals$5(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient t, returns
 * a + t * (b - a).
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param t - Interpolation coefficient.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The linear interpolated result.
 */
function lerp$3(a, b, t, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] + t * (b[0] - a[0]);
  dst[1] = a[1] + t * (b[1] - a[1]);
  return dst;
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient vector t, returns
 * a + t * (b - a).
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param t - Interpolation coefficients vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns the linear interpolated result.
 */
function lerpV$2(a, b, t, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] + t[0] * (b[0] - a[0]);
  dst[1] = a[1] + t[1] * (b[1] - a[1]);
  return dst;
}
/**
 * Return max values of two vectors.
 * Given vectors a and b returns
 * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The max components vector.
 */
function max$2(a, b, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = Math.max(a[0], b[0]);
  dst[1] = Math.max(a[1], b[1]);
  return dst;
}
/**
 * Return min values of two vectors.
 * Given vectors a and b returns
 * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The min components vector.
 */
function min$2(a, b, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = Math.min(a[0], b[0]);
  dst[1] = Math.min(a[1], b[1]);
  return dst;
}
/**
 * Multiplies a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The scaled vector.
 */
function mulScalar$3(v, k, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  return dst;
}
/**
 * Multiplies a vector by a scalar. (same as mulScalar)
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The scaled vector.
 */
const scale$5 = mulScalar$3;
/**
 * Divides a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The scaled vector.
 */
function divScalar$3(v, k, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  return dst;
}
/**
 * Inverse a vector.
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The inverted vector.
 */
function inverse$5(v, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = 1 / v[0];
  dst[1] = 1 / v[1];
  return dst;
}
/**
 * Invert a vector. (same as inverse)
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The inverted vector.
 */
const invert$4 = inverse$5;
/**
 * Computes the cross product of two vectors; assumes both vectors have
 * three entries.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of a cross b.
 */
function cross$1(a, b, dst) {
  dst = dst || new VecType$1(3);
  const z = a[0] * b[1] - a[1] * b[0];
  dst[0] = 0;
  dst[1] = 0;
  dst[2] = z;
  return dst;
}
/**
 * Computes the dot product of two vectors; assumes both vectors have
 * three entries.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns dot product
 */
function dot$3(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the length of vector
 * @param v - vector.
 * @returns length of vector.
 */
function length$3(v) {
  const v0 = v[0];
  const v1 = v[1];
  return Math.sqrt(v0 * v0 + v1 * v1);
}
/**
 * Computes the length of vector (same as length)
 * @param v - vector.
 * @returns length of vector.
 */
const len$3 = length$3;
/**
 * Computes the square of the length of vector
 * @param v - vector.
 * @returns square of the length of vector.
 */
function lengthSq$3(v) {
  const v0 = v[0];
  const v1 = v[1];
  return v0 * v0 + v1 * v1;
}
/**
 * Computes the square of the length of vector (same as lengthSq)
 * @param v - vector.
 * @returns square of the length of vector.
 */
const lenSq$3 = lengthSq$3;
/**
 * Computes the distance between 2 points
 * @param a - vector.
 * @param b - vector.
 * @returns distance between a and b
 */
function distance$2(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  return Math.sqrt(dx * dx + dy * dy);
}
/**
 * Computes the distance between 2 points (same as distance)
 * @param a - vector.
 * @param b - vector.
 * @returns distance between a and b
 */
const dist$2 = distance$2;
/**
 * Computes the square of the distance between 2 points
 * @param a - vector.
 * @param b - vector.
 * @returns square of the distance between a and b
 */
function distanceSq$2(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  return dx * dx + dy * dy;
}
/**
 * Computes the square of the distance between 2 points (same as distanceSq)
 * @param a - vector.
 * @param b - vector.
 * @returns square of the distance between a and b
 */
const distSq$2 = distanceSq$2;
/**
 * Divides a vector by its Euclidean length and returns the quotient.
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The normalized vector.
 */
function normalize$3(v, dst) {
  dst = dst || new VecType$2(2);
  const v0 = v[0];
  const v1 = v[1];
  const len = Math.sqrt(v0 * v0 + v1 * v1);
  if (len > 0.00001) {
    dst[0] = v0 / len;
    dst[1] = v1 / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
  }
  return dst;
}
/**
 * Negates a vector.
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns -v.
 */
function negate$4(v, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = -v[0];
  dst[1] = -v[1];
  return dst;
}
/**
 * Copies a vector. (same as {@link vec2.clone})
 * Also see {@link vec2.create} and {@link vec2.set}
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A copy of v.
 */
function copy$5(v, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = v[0];
  dst[1] = v[1];
  return dst;
}
/**
 * Clones a vector. (same as {@link vec2.copy})
 * Also see {@link vec2.create} and {@link vec2.set}
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A copy of v.
 */
const clone$5 = copy$5;
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of products of entries of a and b.
 */
function multiply$5(a, b, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] * b[0];
  dst[1] = a[1] * b[1];
  return dst;
}
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length. (same as mul)
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of products of entries of a and b.
 */
const mul$5 = multiply$5;
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of quotients of entries of a and b.
 */
function divide$2(a, b, dst) {
  dst = dst || new VecType$2(2);
  dst[0] = a[0] / b[0];
  dst[1] = a[1] / b[1];
  return dst;
}
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length. (same as divide)
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of quotients of entries of a and b.
 */
const div$2 = divide$2;
/**
 * Creates a random unit vector * scale
 * @param scale - Default 1
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The random vector.
 */
function random$1(scale = 1, dst) {
  dst = dst || new VecType$2(2);
  const angle = Math.random() * 2 * Math.PI;
  dst[0] = Math.cos(angle) * scale;
  dst[1] = Math.sin(angle) * scale;
  return dst;
}
/**
 * Zero's a vector
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The zeroed vector.
 */
function zero$2(dst) {
  dst = dst || new VecType$2(2);
  dst[0] = 0;
  dst[1] = 0;
  return dst;
}
/**
 * transform Vec2 by 4x4 matrix
 * @param v - the vector
 * @param m - The matrix.
 * @param dst - optional Vec2 to store result. If not passed a new one is created.
 * @returns the transformed vector
 */
function transformMat4$2(v, m, dst) {
  dst = dst || new VecType$2(2);
  const x = v[0];
  const y = v[1];
  dst[0] = x * m[0] + y * m[4] + m[12];
  dst[1] = x * m[1] + y * m[5] + m[13];
  return dst;
}
/**
 * Transforms vec4 by 3x3 matrix
 *
 * @param v - the vector
 * @param m - The matrix.
 * @param dst - optional Vec2 to store result. If not passed a new one is created.
 * @returns the transformed vector
 */
function transformMat3$1(v, m, dst) {
  dst = dst || new VecType$2(2);
  const x = v[0];
  const y = v[1];
  dst[0] = m[0] * x + m[4] * y + m[8];
  dst[1] = m[1] * x + m[5] * y + m[9];
  return dst;
}
var vec2Impl = exports.vec2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create: create$5,
  setDefaultType: setDefaultType$6,
  fromValues: fromValues$3,
  set: set$5,
  ceil: ceil$2,
  floor: floor$2,
  round: round$2,
  clamp: clamp$2,
  add: add$3,
  addScaled: addScaled$2,
  angle: angle$2,
  subtract: subtract$3,
  sub: sub$3,
  equalsApproximately: equalsApproximately$5,
  equals: equals$5,
  lerp: lerp$3,
  lerpV: lerpV$2,
  max: max$2,
  min: min$2,
  mulScalar: mulScalar$3,
  scale: scale$5,
  divScalar: divScalar$3,
  inverse: inverse$5,
  invert: invert$4,
  cross: cross$1,
  dot: dot$3,
  length: length$3,
  len: len$3,
  lengthSq: lengthSq$3,
  lenSq: lenSq$3,
  distance: distance$2,
  dist: dist$2,
  distanceSq: distanceSq$2,
  distSq: distSq$2,
  normalize: normalize$3,
  negate: negate$4,
  copy: copy$5,
  clone: clone$5,
  multiply: multiply$5,
  mul: mul$5,
  divide: divide$2,
  div: div$2,
  random: random$1,
  zero: zero$2,
  transformMat4: transformMat4$2,
  transformMat3: transformMat3$1
});

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * 3x3 Matrix math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new matrix. In other words you can do this
 *
 *     const mat = mat3.translation([1, 2, 3]);  // Creates a new translation matrix
 *
 * or
 *
 *     const mat = mat3.create();
 *     mat3.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any matrix as the destination. So for example
 *
 *     const mat = mat3.identity();
 *     const trans = mat3.translation([1, 2, 3]);
 *     mat3.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
 *
 */
let MatType$1 = Float32Array;
// This mess is because with Mat3 we have 3 unused elements.
// For Float32Array and Float64Array that's not an issue
// but for Array it's troublesome
const ctorMap = new Map([[Float32Array, () => new Float32Array(12)], [Float64Array, () => new Float64Array(12)], [Array, () => new Array(12).fill(0)]]);
let newMat3 = ctorMap.get(Float32Array);
/**
 * Sets the type this library creates for a Mat3
 * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`
 * @returns previous constructor for Mat3
 */
function setDefaultType$4(ctor) {
  const oldType = MatType$1;
  MatType$1 = ctor;
  newMat3 = ctorMap.get(ctor);
  return oldType;
}
/**
 * Create a Mat3 from values
 *
 * Note: Since passing in a raw JavaScript array
 * is valid in all circumstances, if you want to
 * force a JavaScript array into a Mat3's specified type
 * it would be faster to use
 *
 * ```
 * const m = mat3.clone(someJSArray);
 * ```
 *
 * Note: a consequence of the implementation is if your Mat3Type = `Array`
 * instead of `Float32Array` or `Float64Array` then any values you
 * don't pass in will be undefined. Usually this is not an issue since
 * (a) using `Array` is rare and (b) using `mat3.create` is usually used
 * to create a Mat3 to be filled out as in
 *
 * ```
 * const m = mat3.create();
 * mat3.perspective(fov, aspect, near, far, m);
 * ```
 *
 * @param v0 - value for element 0
 * @param v1 - value for element 1
 * @param v2 - value for element 2
 * @param v3 - value for element 3
 * @param v4 - value for element 4
 * @param v5 - value for element 5
 * @param v6 - value for element 6
 * @param v7 - value for element 7
 * @param v8 - value for element 8
 * @returns matrix created from values.
 */
function create$3(v0, v1, v2, v3, v4, v5, v6, v7, v8) {
  const dst = newMat3();
  // to make the array homogenous
  dst[3] = 0;
  dst[7] = 0;
  dst[11] = 0;
  if (v0 !== undefined) {
    dst[0] = v0;
    if (v1 !== undefined) {
      dst[1] = v1;
      if (v2 !== undefined) {
        dst[2] = v2;
        if (v3 !== undefined) {
          dst[4] = v3;
          if (v4 !== undefined) {
            dst[5] = v4;
            if (v5 !== undefined) {
              dst[6] = v5;
              if (v6 !== undefined) {
                dst[8] = v6;
                if (v7 !== undefined) {
                  dst[9] = v7;
                  if (v8 !== undefined) {
                    dst[10] = v8;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return dst;
}
/**
 * Sets the values of a Mat3
 * Also see {@link mat3.create} and {@link mat3.copy}
 *
 * @param v0 - value for element 0
 * @param v1 - value for element 1
 * @param v2 - value for element 2
 * @param v3 - value for element 3
 * @param v4 - value for element 4
 * @param v5 - value for element 5
 * @param v6 - value for element 6
 * @param v7 - value for element 7
 * @param v8 - value for element 8
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns Mat3 set from values.
 */
function set$4(v0, v1, v2, v3, v4, v5, v6, v7, v8, dst) {
  dst = dst || newMat3();
  dst[0] = v0;
  dst[1] = v1;
  dst[2] = v2;
  dst[3] = 0;
  dst[4] = v3;
  dst[5] = v4;
  dst[6] = v5;
  dst[7] = 0;
  dst[8] = v6;
  dst[9] = v7;
  dst[10] = v8;
  dst[11] = 0;
  return dst;
}
/**
 * Creates a Mat3 from the upper left 3x3 part of a Mat4
 * @param m4 - source matrix
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns Mat3 made from m4
 */
function fromMat4(m4, dst) {
  dst = dst || newMat3();
  dst[0] = m4[0];
  dst[1] = m4[1];
  dst[2] = m4[2];
  dst[3] = 0;
  dst[4] = m4[4];
  dst[5] = m4[5];
  dst[6] = m4[6];
  dst[7] = 0;
  dst[8] = m4[8];
  dst[9] = m4[9];
  dst[10] = m4[10];
  dst[11] = 0;
  return dst;
}
/**
 * Creates a Mat3 rotation matrix from a quaternion
 * @param q - quaternion to create matrix from
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns Mat3 made from q
 */
function fromQuat$1(q, dst) {
  dst = dst || newMat3();
  const x = q[0];
  const y = q[1];
  const z = q[2];
  const w = q[3];
  const x2 = x + x;
  const y2 = y + y;
  const z2 = z + z;
  const xx = x * x2;
  const yx = y * x2;
  const yy = y * y2;
  const zx = z * x2;
  const zy = z * y2;
  const zz = z * z2;
  const wx = w * x2;
  const wy = w * y2;
  const wz = w * z2;
  dst[0] = 1 - yy - zz;
  dst[1] = yx + wz;
  dst[2] = zx - wy;
  dst[3] = 0;
  dst[4] = yx - wz;
  dst[5] = 1 - xx - zz;
  dst[6] = zy + wx;
  dst[7] = 0;
  dst[8] = zx + wy;
  dst[9] = zy - wx;
  dst[10] = 1 - xx - yy;
  dst[11] = 0;
  return dst;
}
/**
 * Negates a matrix.
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns -m.
 */
function negate$3(m, dst) {
  dst = dst || newMat3();
  dst[0] = -m[0];
  dst[1] = -m[1];
  dst[2] = -m[2];
  dst[4] = -m[4];
  dst[5] = -m[5];
  dst[6] = -m[6];
  dst[8] = -m[8];
  dst[9] = -m[9];
  dst[10] = -m[10];
  return dst;
}
/**
 * Copies a matrix. (same as {@link mat3.clone})
 * Also see {@link mat3.create} and {@link mat3.set}
 * @param m - The matrix.
 * @param dst - The matrix. If not passed a new one is created.
 * @returns A copy of m.
 */
function copy$4(m, dst) {
  dst = dst || newMat3();
  dst[0] = m[0];
  dst[1] = m[1];
  dst[2] = m[2];
  dst[4] = m[4];
  dst[5] = m[5];
  dst[6] = m[6];
  dst[8] = m[8];
  dst[9] = m[9];
  dst[10] = m[10];
  return dst;
}
/**
 * Copies a matrix (same as {@link mat3.copy})
 * Also see {@link mat3.create} and {@link mat3.set}
 * @param m - The matrix.
 * @param dst - The matrix. If not passed a new one is created.
 * @returns A copy of m.
 */
const clone$4 = copy$4;
/**
 * Check if 2 matrices are approximately equal
 * @param a Operand matrix.
 * @param b Operand matrix.
 * @returns true if matrices are approximately equal
 */
function equalsApproximately$4(a, b) {
  return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON && Math.abs(a[4] - b[4]) < EPSILON && Math.abs(a[5] - b[5]) < EPSILON && Math.abs(a[6] - b[6]) < EPSILON && Math.abs(a[8] - b[8]) < EPSILON && Math.abs(a[9] - b[9]) < EPSILON && Math.abs(a[10] - b[10]) < EPSILON;
}
/**
 * Check if 2 matrices are exactly equal
 * @param a Operand matrix.
 * @param b Operand matrix.
 * @returns true if matrices are exactly equal
 */
function equals$4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10];
}
/**
 * Creates a 3-by-3 identity matrix.
 *
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns A 3-by-3 identity matrix.
 */
function identity$2(dst) {
  dst = dst || newMat3();
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  return dst;
}
/**
 * Takes the transpose of a matrix.
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The transpose of m.
 */
function transpose$1(m, dst) {
  dst = dst || newMat3();
  if (dst === m) {
    let t;
    // 0 1 2
    // 4 5 6
    // 8 9 10
    t = m[1];
    m[1] = m[4];
    m[4] = t;
    t = m[2];
    m[2] = m[8];
    m[8] = t;
    t = m[6];
    m[6] = m[9];
    m[9] = t;
    return dst;
  }
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  dst[0] = m00;
  dst[1] = m10;
  dst[2] = m20;
  dst[4] = m01;
  dst[5] = m11;
  dst[6] = m21;
  dst[8] = m02;
  dst[9] = m12;
  dst[10] = m22;
  return dst;
}
/**
 * Computes the inverse of a 3-by-3 matrix.
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The inverse of m.
 */
function inverse$4(m, dst) {
  dst = dst || newMat3();
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const b01 = m22 * m11 - m12 * m21;
  const b11 = -m22 * m10 + m12 * m20;
  const b21 = m21 * m10 - m11 * m20;
  const invDet = 1 / (m00 * b01 + m01 * b11 + m02 * b21);
  dst[0] = b01 * invDet;
  dst[1] = (-m22 * m01 + m02 * m21) * invDet;
  dst[2] = (m12 * m01 - m02 * m11) * invDet;
  dst[4] = b11 * invDet;
  dst[5] = (m22 * m00 - m02 * m20) * invDet;
  dst[6] = (-m12 * m00 + m02 * m10) * invDet;
  dst[8] = b21 * invDet;
  dst[9] = (-m21 * m00 + m01 * m20) * invDet;
  dst[10] = (m11 * m00 - m01 * m10) * invDet;
  return dst;
}
/**
 * Compute the determinant of a matrix
 * @param m - the matrix
 * @returns the determinant
 */
function determinant$1(m) {
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  return m00 * (m11 * m22 - m21 * m12) - m10 * (m01 * m22 - m21 * m02) + m20 * (m01 * m12 - m11 * m02);
}
/**
 * Computes the inverse of a 3-by-3 matrix. (same as inverse)
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The inverse of m.
 */
const invert$3 = inverse$4;
/**
 * Multiplies two 3-by-3 matrices with a on the left and b on the right
 * @param a - The matrix on the left.
 * @param b - The matrix on the right.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The matrix product of a and b.
 */
function multiply$4(a, b, dst) {
  dst = dst || newMat3();
  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a10 = a[4 + 0];
  const a11 = a[4 + 1];
  const a12 = a[4 + 2];
  const a20 = a[8 + 0];
  const a21 = a[8 + 1];
  const a22 = a[8 + 2];
  const b00 = b[0];
  const b01 = b[1];
  const b02 = b[2];
  const b10 = b[4 + 0];
  const b11 = b[4 + 1];
  const b12 = b[4 + 2];
  const b20 = b[8 + 0];
  const b21 = b[8 + 1];
  const b22 = b[8 + 2];
  dst[0] = a00 * b00 + a10 * b01 + a20 * b02;
  dst[1] = a01 * b00 + a11 * b01 + a21 * b02;
  dst[2] = a02 * b00 + a12 * b01 + a22 * b02;
  dst[4] = a00 * b10 + a10 * b11 + a20 * b12;
  dst[5] = a01 * b10 + a11 * b11 + a21 * b12;
  dst[6] = a02 * b10 + a12 * b11 + a22 * b12;
  dst[8] = a00 * b20 + a10 * b21 + a20 * b22;
  dst[9] = a01 * b20 + a11 * b21 + a21 * b22;
  dst[10] = a02 * b20 + a12 * b21 + a22 * b22;
  return dst;
}
/**
 * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)
 * @param a - The matrix on the left.
 * @param b - The matrix on the right.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The matrix product of a and b.
 */
const mul$4 = multiply$4;
/**
 * Sets the translation component of a 3-by-3 matrix to the given
 * vector.
 * @param a - The matrix.
 * @param v - The vector.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The matrix with translation set.
 */
function setTranslation$1(a, v, dst) {
  dst = dst || identity$2();
  if (a !== dst) {
    dst[0] = a[0];
    dst[1] = a[1];
    dst[2] = a[2];
    dst[4] = a[4];
    dst[5] = a[5];
    dst[6] = a[6];
  }
  dst[8] = v[0];
  dst[9] = v[1];
  dst[10] = 1;
  return dst;
}
/**
 * Returns the translation component of a 3-by-3 matrix as a vector with 3
 * entries.
 * @param m - The matrix.
 * @param dst - vector to hold result. If not passed a new one is created.
 * @returns The translation component of m.
 */
function getTranslation$2(m, dst) {
  dst = dst || create$5();
  dst[0] = m[8];
  dst[1] = m[9];
  return dst;
}
/**
 * Returns an axis of a 3x3 matrix as a vector with 2 entries
 * @param m - The matrix.
 * @param axis - The axis 0 = x, 1 = y,
 * @returns The axis component of m.
 */
function getAxis$2(m, axis, dst) {
  dst = dst || create$5();
  const off = axis * 4;
  dst[0] = m[off + 0];
  dst[1] = m[off + 1];
  return dst;
}
/**
 * Sets an axis of a 3x3 matrix as a vector with 2 entries
 * @param m - The matrix.
 * @param v - the axis vector
 * @param axis - The axis  0 = x, 1 = y;
 * @param dst - The matrix to set. If not passed a new one is created.
 * @returns The matrix with axis set.
 */
function setAxis$1(m, v, axis, dst) {
  if (dst !== m) {
    dst = copy$4(m, dst);
  }
  const off = axis * 4;
  dst[off + 0] = v[0];
  dst[off + 1] = v[1];
  return dst;
}
/**
 * Returns the scaling component of the matrix
 * @param m - The Matrix
 * @param dst - The vector to set. If not passed a new one is created.
 */
function getScaling$2(m, dst) {
  dst = dst || create$5();
  const xx = m[0];
  const xy = m[1];
  const yx = m[4];
  const yy = m[5];
  dst[0] = Math.sqrt(xx * xx + xy * xy);
  dst[1] = Math.sqrt(yx * yx + yy * yy);
  return dst;
}
/**
 * Creates a 3-by-3 matrix which translates by the given vector v.
 * @param v - The vector by which to translate.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The translation matrix.
 */
function translation$1(v, dst) {
  dst = dst || newMat3();
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[8] = v[0];
  dst[9] = v[1];
  dst[10] = 1;
  return dst;
}
/**
 * Translates the given 3-by-3 matrix by the given vector v.
 * @param m - The matrix.
 * @param v - The vector by which to translate.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The translated matrix.
 */
function translate$1(m, v, dst) {
  dst = dst || newMat3();
  const v0 = v[0];
  const v1 = v[1];
  const m00 = m[0];
  const m01 = m[1];
  const m02 = m[2];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  if (m !== dst) {
    dst[0] = m00;
    dst[1] = m01;
    dst[2] = m02;
    dst[4] = m10;
    dst[5] = m11;
    dst[6] = m12;
  }
  dst[8] = m00 * v0 + m10 * v1 + m20;
  dst[9] = m01 * v0 + m11 * v1 + m21;
  dst[10] = m02 * v0 + m12 * v1 + m22;
  return dst;
}
/**
 * Creates a 3-by-3 matrix which rotates  by the given angle.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotation matrix.
 */
function rotation$1(angleInRadians, dst) {
  dst = dst || newMat3();
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = s;
  dst[2] = 0;
  dst[4] = -s;
  dst[5] = c;
  dst[6] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  return dst;
}
/**
 * Rotates the given 3-by-3 matrix  by the given angle.
 * @param m - The matrix.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotated matrix.
 */
function rotate$1(m, angleInRadians, dst) {
  dst = dst || newMat3();
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c * m00 + s * m10;
  dst[1] = c * m01 + s * m11;
  dst[2] = c * m02 + s * m12;
  dst[4] = c * m10 - s * m00;
  dst[5] = c * m11 - s * m01;
  dst[6] = c * m12 - s * m02;
  if (m !== dst) {
    dst[8] = m[8];
    dst[9] = m[9];
    dst[10] = m[10];
  }
  return dst;
}
/**
 * Creates a 3-by-3 matrix which scales in each dimension by an amount given by
 * the corresponding entry in the given vector; assumes the vector has three
 * entries.
 * @param v - A vector of
 *     2 entries specifying the factor by which to scale in each dimension.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The scaling matrix.
 */
function scaling$1(v, dst) {
  dst = dst || newMat3();
  dst[0] = v[0];
  dst[1] = 0;
  dst[2] = 0;
  dst[4] = 0;
  dst[5] = v[1];
  dst[6] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  return dst;
}
/**
 * Scales the given 3-by-3 matrix in each dimension by an amount
 * given by the corresponding entry in the given vector; assumes the vector has
 * three entries.
 * @param m - The matrix to be modified.
 * @param v - A vector of 2 entries specifying the
 *     factor by which to scale in each dimension.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The scaled matrix.
 */
function scale$4(m, v, dst) {
  dst = dst || newMat3();
  const v0 = v[0];
  const v1 = v[1];
  dst[0] = v0 * m[0 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2];
  dst[4] = v1 * m[1 * 4 + 0];
  dst[5] = v1 * m[1 * 4 + 1];
  dst[6] = v1 * m[1 * 4 + 2];
  if (m !== dst) {
    dst[8] = m[8];
    dst[9] = m[9];
    dst[10] = m[10];
  }
  return dst;
}
/**
 * Creates a 3-by-3 matrix which scales uniformly in each dimension
 * @param s - Amount to scale
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The scaling matrix.
 */
function uniformScaling$1(s, dst) {
  dst = dst || newMat3();
  dst[0] = s;
  dst[1] = 0;
  dst[2] = 0;
  dst[4] = 0;
  dst[5] = s;
  dst[6] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  return dst;
}
/**
 * Scales the given 3-by-3 matrix in each dimension by an amount
 * given.
 * @param m - The matrix to be modified.
 * @param s - Amount to scale.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The scaled matrix.
 */
function uniformScale$1(m, s, dst) {
  dst = dst || newMat3();
  dst[0] = s * m[0 * 4 + 0];
  dst[1] = s * m[0 * 4 + 1];
  dst[2] = s * m[0 * 4 + 2];
  dst[4] = s * m[1 * 4 + 0];
  dst[5] = s * m[1 * 4 + 1];
  dst[6] = s * m[1 * 4 + 2];
  if (m !== dst) {
    dst[8] = m[8];
    dst[9] = m[9];
    dst[10] = m[10];
  }
  return dst;
}
var mat3Impl = exports.mat3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setDefaultType: setDefaultType$4,
  create: create$3,
  set: set$4,
  fromMat4: fromMat4,
  fromQuat: fromQuat$1,
  negate: negate$3,
  copy: copy$4,
  clone: clone$4,
  equalsApproximately: equalsApproximately$4,
  equals: equals$4,
  identity: identity$2,
  transpose: transpose$1,
  inverse: inverse$4,
  determinant: determinant$1,
  invert: invert$3,
  multiply: multiply$4,
  mul: mul$4,
  setTranslation: setTranslation$1,
  getTranslation: getTranslation$2,
  getAxis: getAxis$2,
  setAxis: setAxis$1,
  getScaling: getScaling$2,
  translation: translation$1,
  translate: translate$1,
  rotation: rotation$1,
  rotate: rotate$1,
  scaling: scaling$1,
  scale: scale$4,
  uniformScaling: uniformScaling$1,
  uniformScale: uniformScale$1
});

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Creates a vec3; may be called with x, y, z to set initial values. (same as create)
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @param z - Initial z value.
 * @returns the created vector
 */
const fromValues$2 = create$4;
/**
 * Sets the values of a Vec3
 * Also see {@link vec3.create} and {@link vec3.copy}
 *
 * @param x first value
 * @param y second value
 * @param z third value
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector with its elements set.
 */
function set$3(x, y, z, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = x;
  dst[1] = y;
  dst[2] = z;
  return dst;
}
/**
 * Applies Math.ceil to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the ceil of each element of v.
 */
function ceil$1(v, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = Math.ceil(v[0]);
  dst[1] = Math.ceil(v[1]);
  dst[2] = Math.ceil(v[2]);
  return dst;
}
/**
 * Applies Math.floor to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the floor of each element of v.
 */
function floor$1(v, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = Math.floor(v[0]);
  dst[1] = Math.floor(v[1]);
  dst[2] = Math.floor(v[2]);
  return dst;
}
/**
 * Applies Math.round to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the round of each element of v.
 */
function round$1(v, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = Math.round(v[0]);
  dst[1] = Math.round(v[1]);
  dst[2] = Math.round(v[2]);
  return dst;
}
/**
 * Clamp each element of vector between min and max
 * @param v - Operand vector.
 * @param max - Min value, default 0
 * @param min - Max value, default 1
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that the clamped value of each element of v.
 */
function clamp$1(v, min = 0, max = 1, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = Math.min(max, Math.max(min, v[0]));
  dst[1] = Math.min(max, Math.max(min, v[1]));
  dst[2] = Math.min(max, Math.max(min, v[2]));
  return dst;
}
/**
 * Adds two vectors; assumes a and b have the same dimension.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the sum of a and b.
 */
function add$2(a, b, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  dst[2] = a[2] + b[2];
  return dst;
}
/**
 * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param scale - Amount to scale b
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the sum of a + b * scale.
 */
function addScaled$1(a, b, scale, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] + b[0] * scale;
  dst[1] = a[1] + b[1] * scale;
  dst[2] = a[2] + b[2] * scale;
  return dst;
}
/**
 * Returns the angle in radians between two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns The angle in radians between the 2 vectors.
 */
function angle$1(a, b) {
  const ax = a[0];
  const ay = a[1];
  const az = a[2];
  const bx = a[0];
  const by = a[1];
  const bz = a[2];
  const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);
  const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);
  const mag = mag1 * mag2;
  const cosine = mag && dot$2(a, b) / mag;
  return Math.acos(cosine);
}
/**
 * Subtracts two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the difference of a and b.
 */
function subtract$2(a, b, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  dst[2] = a[2] - b[2];
  return dst;
}
/**
 * Subtracts two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the difference of a and b.
 */
const sub$2 = subtract$2;
/**
 * Check if 2 vectors are approximately equal
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns true if vectors are approximately equal
 */
function equalsApproximately$3(a, b) {
  return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON;
}
/**
 * Check if 2 vectors are exactly equal
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns true if vectors are exactly equal
 */
function equals$3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient t, returns
 * a + t * (b - a).
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param t - Interpolation coefficient.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The linear interpolated result.
 */
function lerp$2(a, b, t, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] + t * (b[0] - a[0]);
  dst[1] = a[1] + t * (b[1] - a[1]);
  dst[2] = a[2] + t * (b[2] - a[2]);
  return dst;
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient vector t, returns
 * a + t * (b - a).
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param t - Interpolation coefficients vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns the linear interpolated result.
 */
function lerpV$1(a, b, t, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] + t[0] * (b[0] - a[0]);
  dst[1] = a[1] + t[1] * (b[1] - a[1]);
  dst[2] = a[2] + t[2] * (b[2] - a[2]);
  return dst;
}
/**
 * Return max values of two vectors.
 * Given vectors a and b returns
 * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The max components vector.
 */
function max$1(a, b, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = Math.max(a[0], b[0]);
  dst[1] = Math.max(a[1], b[1]);
  dst[2] = Math.max(a[2], b[2]);
  return dst;
}
/**
 * Return min values of two vectors.
 * Given vectors a and b returns
 * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The min components vector.
 */
function min$1(a, b, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = Math.min(a[0], b[0]);
  dst[1] = Math.min(a[1], b[1]);
  dst[2] = Math.min(a[2], b[2]);
  return dst;
}
/**
 * Multiplies a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The scaled vector.
 */
function mulScalar$2(v, k, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  dst[2] = v[2] * k;
  return dst;
}
/**
 * Multiplies a vector by a scalar. (same as mulScalar)
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The scaled vector.
 */
const scale$3 = mulScalar$2;
/**
 * Divides a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The scaled vector.
 */
function divScalar$2(v, k, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  dst[2] = v[2] / k;
  return dst;
}
/**
 * Inverse a vector.
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The inverted vector.
 */
function inverse$3(v, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = 1 / v[0];
  dst[1] = 1 / v[1];
  dst[2] = 1 / v[2];
  return dst;
}
/**
 * Invert a vector. (same as inverse)
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The inverted vector.
 */
const invert$2 = inverse$3;
/**
 * Computes the cross product of two vectors; assumes both vectors have
 * three entries.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of a cross b.
 */
function cross(a, b, dst) {
  dst = dst || new VecType$1(3);
  const t1 = a[2] * b[0] - a[0] * b[2];
  const t2 = a[0] * b[1] - a[1] * b[0];
  dst[0] = a[1] * b[2] - a[2] * b[1];
  dst[1] = t1;
  dst[2] = t2;
  return dst;
}
/**
 * Computes the dot product of two vectors; assumes both vectors have
 * three entries.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns dot product
 */
function dot$2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the length of vector
 * @param v - vector.
 * @returns length of vector.
 */
function length$2(v) {
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);
}
/**
 * Computes the length of vector (same as length)
 * @param v - vector.
 * @returns length of vector.
 */
const len$2 = length$2;
/**
 * Computes the square of the length of vector
 * @param v - vector.
 * @returns square of the length of vector.
 */
function lengthSq$2(v) {
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  return v0 * v0 + v1 * v1 + v2 * v2;
}
/**
 * Computes the square of the length of vector (same as lengthSq)
 * @param v - vector.
 * @returns square of the length of vector.
 */
const lenSq$2 = lengthSq$2;
/**
 * Computes the distance between 2 points
 * @param a - vector.
 * @param b - vector.
 * @returns distance between a and b
 */
function distance$1(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}
/**
 * Computes the distance between 2 points (same as distance)
 * @param a - vector.
 * @param b - vector.
 * @returns distance between a and b
 */
const dist$1 = distance$1;
/**
 * Computes the square of the distance between 2 points
 * @param a - vector.
 * @param b - vector.
 * @returns square of the distance between a and b
 */
function distanceSq$1(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  return dx * dx + dy * dy + dz * dz;
}
/**
 * Computes the square of the distance between 2 points (same as distanceSq)
 * @param a - vector.
 * @param b - vector.
 * @returns square of the distance between a and b
 */
const distSq$1 = distanceSq$1;
/**
 * Divides a vector by its Euclidean length and returns the quotient.
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The normalized vector.
 */
function normalize$2(v, dst) {
  dst = dst || new VecType$1(3);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);
  if (len > 0.00001) {
    dst[0] = v0 / len;
    dst[1] = v1 / len;
    dst[2] = v2 / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
    dst[2] = 0;
  }
  return dst;
}
/**
 * Negates a vector.
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns -v.
 */
function negate$2(v, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = -v[0];
  dst[1] = -v[1];
  dst[2] = -v[2];
  return dst;
}
/**
 * Copies a vector. (same as {@link vec3.clone})
 * Also see {@link vec3.create} and {@link vec3.set}
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A copy of v.
 */
function copy$3(v, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = v[0];
  dst[1] = v[1];
  dst[2] = v[2];
  return dst;
}
/**
 * Clones a vector. (same as {@link vec3.copy})
 * Also see {@link vec3.create} and {@link vec3.set}
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A copy of v.
 */
const clone$3 = copy$3;
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of products of entries of a and b.
 */
function multiply$3(a, b, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] * b[0];
  dst[1] = a[1] * b[1];
  dst[2] = a[2] * b[2];
  return dst;
}
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length. (same as mul)
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of products of entries of a and b.
 */
const mul$3 = multiply$3;
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of quotients of entries of a and b.
 */
function divide$1(a, b, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = a[0] / b[0];
  dst[1] = a[1] / b[1];
  dst[2] = a[2] / b[2];
  return dst;
}
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length. (same as divide)
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of quotients of entries of a and b.
 */
const div$1 = divide$1;
/**
 * Creates a random vector
 * @param scale - Default 1
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The random vector.
 */
function random(scale = 1, dst) {
  dst = dst || new VecType$1(3);
  const angle = Math.random() * 2 * Math.PI;
  const z = Math.random() * 2 - 1;
  const zScale = Math.sqrt(1 - z * z) * scale;
  dst[0] = Math.cos(angle) * zScale;
  dst[1] = Math.sin(angle) * zScale;
  dst[2] = z * scale;
  return dst;
}
/**
 * Zero's a vector
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The zeroed vector.
 */
function zero$1(dst) {
  dst = dst || new VecType$1(3);
  dst[0] = 0;
  dst[1] = 0;
  dst[2] = 0;
  return dst;
}
/**
 * transform vec3 by 4x4 matrix
 * @param v - the vector
 * @param m - The matrix.
 * @param dst - optional vec3 to store result. If not passed a new one is created.
 * @returns the transformed vector
 */
function transformMat4$1(v, m, dst) {
  dst = dst || new VecType$1(3);
  const x = v[0];
  const y = v[1];
  const z = v[2];
  const w = m[3] * x + m[7] * y + m[11] * z + m[15] || 1;
  dst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  dst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  dst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return dst;
}
/**
 * Transform vec4 by upper 3x3 matrix inside 4x4 matrix.
 * @param v - The direction.
 * @param m - The matrix.
 * @param dst - optional Vec3 to store result. If not passed a new one is created.
 * @returns The transformed vector.
 */
function transformMat4Upper3x3(v, m, dst) {
  dst = dst || new VecType$1(3);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];
  return dst;
}
/**
 * Transforms vec3 by 3x3 matrix
 *
 * @param v - the vector
 * @param m - The matrix.
 * @param dst - optional vec3 to store result. If not passed a new one is created.
 * @returns the transformed vector
 */
function transformMat3(v, m, dst) {
  dst = dst || new VecType$1(3);
  const x = v[0];
  const y = v[1];
  const z = v[2];
  dst[0] = x * m[0] + y * m[4] + z * m[8];
  dst[1] = x * m[1] + y * m[5] + z * m[9];
  dst[2] = x * m[2] + y * m[6] + z * m[10];
  return dst;
}
/**
 * Transforms vec3 by Quaternion
 * @param v - the vector to transform
 * @param q - the quaternion to transform by
 * @param dst - optional vec3 to store result. If not passed a new one is created.
 * @returns the transformed
 */
function transformQuat(v, q, dst) {
  dst = dst || new VecType$1(3);
  const qx = q[0];
  const qy = q[1];
  const qz = q[2];
  const w2 = q[3] * 2;
  const x = v[0];
  const y = v[1];
  const z = v[2];
  const uvX = qy * z - qz * y;
  const uvY = qz * x - qx * z;
  const uvZ = qx * y - qy * x;
  dst[0] = x + uvX * w2 + (qy * uvZ - qz * uvY) * 2;
  dst[1] = y + uvY * w2 + (qz * uvX - qx * uvZ) * 2;
  dst[2] = z + uvZ * w2 + (qx * uvY - qy * uvX) * 2;
  return dst;
}
/**
 * Returns the translation component of a 4-by-4 matrix as a vector with 3
 * entries.
 * @param m - The matrix.
 * @param dst - vector to hold result. If not passed a new one is created.
 * @returns The translation component of m.
 */
function getTranslation$1(m, dst) {
  dst = dst || new VecType$1(3);
  dst[0] = m[12];
  dst[1] = m[13];
  dst[2] = m[14];
  return dst;
}
/**
 * Returns an axis of a 4x4 matrix as a vector with 3 entries
 * @param m - The matrix.
 * @param axis - The axis 0 = x, 1 = y, 2 = z;
 * @returns The axis component of m.
 */
function getAxis$1(m, axis, dst) {
  dst = dst || new VecType$1(3);
  const off = axis * 4;
  dst[0] = m[off + 0];
  dst[1] = m[off + 1];
  dst[2] = m[off + 2];
  return dst;
}
/**
 * Returns the scaling component of the matrix
 * @param m - The Matrix
 * @param dst - The vector to set. If not passed a new one is created.
 */
function getScaling$1(m, dst) {
  dst = dst || new VecType$1(3);
  const xx = m[0];
  const xy = m[1];
  const xz = m[2];
  const yx = m[4];
  const yy = m[5];
  const yz = m[6];
  const zx = m[8];
  const zy = m[9];
  const zz = m[10];
  dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);
  dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);
  dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);
  return dst;
}
var vec3Impl = exports.vec3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create: create$4,
  setDefaultType: setDefaultType$5,
  fromValues: fromValues$2,
  set: set$3,
  ceil: ceil$1,
  floor: floor$1,
  round: round$1,
  clamp: clamp$1,
  add: add$2,
  addScaled: addScaled$1,
  angle: angle$1,
  subtract: subtract$2,
  sub: sub$2,
  equalsApproximately: equalsApproximately$3,
  equals: equals$3,
  lerp: lerp$2,
  lerpV: lerpV$1,
  max: max$1,
  min: min$1,
  mulScalar: mulScalar$2,
  scale: scale$3,
  divScalar: divScalar$2,
  inverse: inverse$3,
  invert: invert$2,
  cross: cross,
  dot: dot$2,
  length: length$2,
  len: len$2,
  lengthSq: lengthSq$2,
  lenSq: lenSq$2,
  distance: distance$1,
  dist: dist$1,
  distanceSq: distanceSq$1,
  distSq: distSq$1,
  normalize: normalize$2,
  negate: negate$2,
  copy: copy$3,
  clone: clone$3,
  multiply: multiply$3,
  mul: mul$3,
  divide: divide$1,
  div: div$1,
  random: random,
  zero: zero$1,
  transformMat4: transformMat4$1,
  transformMat4Upper3x3: transformMat4Upper3x3,
  transformMat3: transformMat3,
  transformQuat: transformQuat,
  getTranslation: getTranslation$1,
  getAxis: getAxis$1,
  getScaling: getScaling$1
});

/**
 * 4x4 Matrix math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new matrix. In other words you can do this
 *
 *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix
 *
 * or
 *
 *     const mat = mat4.create();
 *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any matrix as the destination. So for example
 *
 *     const mat = mat4.identity();
 *     const trans = mat4.translation([1, 2, 3]);
 *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
 *
 */
let MatType = Float32Array;
/**
 * Sets the type this library creates for a Mat4
 * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`
 * @returns previous constructor for Mat4
 */
function setDefaultType$3(ctor) {
  const oldType = MatType;
  MatType = ctor;
  return oldType;
}
/**
 * Create a Mat4 from values
 *
 * Note: Since passing in a raw JavaScript array
 * is valid in all circumstances, if you want to
 * force a JavaScript array into a Mat4's specified type
 * it would be faster to use
 *
 * ```
 * const m = mat4.clone(someJSArray);
 * ```
 *
 * Note: a consequence of the implementation is if your Mat4Type = `Array`
 * instead of `Float32Array` or `Float64Array` then any values you
 * don't pass in will be undefined. Usually this is not an issue since
 * (a) using `Array` is rare and (b) using `mat4.create` is usually used
 * to create a Mat4 to be filled out as in
 *
 * ```
 * const m = mat4.create();
 * mat4.perspective(fov, aspect, near, far, m);
 * ```
 *
 * @param v0 - value for element 0
 * @param v1 - value for element 1
 * @param v2 - value for element 2
 * @param v3 - value for element 3
 * @param v4 - value for element 4
 * @param v5 - value for element 5
 * @param v6 - value for element 6
 * @param v7 - value for element 7
 * @param v8 - value for element 8
 * @param v9 - value for element 9
 * @param v10 - value for element 10
 * @param v11 - value for element 11
 * @param v12 - value for element 12
 * @param v13 - value for element 13
 * @param v14 - value for element 14
 * @param v15 - value for element 15
 * @returns created from values.
 */
function create$2(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
  const dst = new MatType(16);
  if (v0 !== undefined) {
    dst[0] = v0;
    if (v1 !== undefined) {
      dst[1] = v1;
      if (v2 !== undefined) {
        dst[2] = v2;
        if (v3 !== undefined) {
          dst[3] = v3;
          if (v4 !== undefined) {
            dst[4] = v4;
            if (v5 !== undefined) {
              dst[5] = v5;
              if (v6 !== undefined) {
                dst[6] = v6;
                if (v7 !== undefined) {
                  dst[7] = v7;
                  if (v8 !== undefined) {
                    dst[8] = v8;
                    if (v9 !== undefined) {
                      dst[9] = v9;
                      if (v10 !== undefined) {
                        dst[10] = v10;
                        if (v11 !== undefined) {
                          dst[11] = v11;
                          if (v12 !== undefined) {
                            dst[12] = v12;
                            if (v13 !== undefined) {
                              dst[13] = v13;
                              if (v14 !== undefined) {
                                dst[14] = v14;
                                if (v15 !== undefined) {
                                  dst[15] = v15;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return dst;
}
/**
 * Sets the values of a Mat4
 * Also see {@link mat4.create} and {@link mat4.copy}
 *
 * @param v0 - value for element 0
 * @param v1 - value for element 1
 * @param v2 - value for element 2
 * @param v3 - value for element 3
 * @param v4 - value for element 4
 * @param v5 - value for element 5
 * @param v6 - value for element 6
 * @param v7 - value for element 7
 * @param v8 - value for element 8
 * @param v9 - value for element 9
 * @param v10 - value for element 10
 * @param v11 - value for element 11
 * @param v12 - value for element 12
 * @param v13 - value for element 13
 * @param v14 - value for element 14
 * @param v15 - value for element 15
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns Mat4 created from values.
 */
function set$2(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, dst) {
  dst = dst || new MatType(16);
  dst[0] = v0;
  dst[1] = v1;
  dst[2] = v2;
  dst[3] = v3;
  dst[4] = v4;
  dst[5] = v5;
  dst[6] = v6;
  dst[7] = v7;
  dst[8] = v8;
  dst[9] = v9;
  dst[10] = v10;
  dst[11] = v11;
  dst[12] = v12;
  dst[13] = v13;
  dst[14] = v14;
  dst[15] = v15;
  return dst;
}
/**
 * Creates a Mat4 from a Mat3
 * @param m3 - source matrix
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns Mat4 made from m3
 */
function fromMat3(m3, dst) {
  dst = dst || new MatType(16);
  dst[0] = m3[0];
  dst[1] = m3[1];
  dst[2] = m3[2];
  dst[3] = 0;
  dst[4] = m3[4];
  dst[5] = m3[5];
  dst[6] = m3[6];
  dst[7] = 0;
  dst[8] = m3[8];
  dst[9] = m3[9];
  dst[10] = m3[10];
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Creates a Mat4 rotation matrix from a quaternion
 * @param q - quaternion to create matrix from
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns Mat4 made from q
 */
function fromQuat(q, dst) {
  dst = dst || new MatType(16);
  const x = q[0];
  const y = q[1];
  const z = q[2];
  const w = q[3];
  const x2 = x + x;
  const y2 = y + y;
  const z2 = z + z;
  const xx = x * x2;
  const yx = y * x2;
  const yy = y * y2;
  const zx = z * x2;
  const zy = z * y2;
  const zz = z * z2;
  const wx = w * x2;
  const wy = w * y2;
  const wz = w * z2;
  dst[0] = 1 - yy - zz;
  dst[1] = yx + wz;
  dst[2] = zx - wy;
  dst[3] = 0;
  dst[4] = yx - wz;
  dst[5] = 1 - xx - zz;
  dst[6] = zy + wx;
  dst[7] = 0;
  dst[8] = zx + wy;
  dst[9] = zy - wx;
  dst[10] = 1 - xx - yy;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Negates a matrix.
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns -m.
 */
function negate$1(m, dst) {
  dst = dst || new MatType(16);
  dst[0] = -m[0];
  dst[1] = -m[1];
  dst[2] = -m[2];
  dst[3] = -m[3];
  dst[4] = -m[4];
  dst[5] = -m[5];
  dst[6] = -m[6];
  dst[7] = -m[7];
  dst[8] = -m[8];
  dst[9] = -m[9];
  dst[10] = -m[10];
  dst[11] = -m[11];
  dst[12] = -m[12];
  dst[13] = -m[13];
  dst[14] = -m[14];
  dst[15] = -m[15];
  return dst;
}
/**
 * Copies a matrix. (same as {@link mat4.clone})
 * Also see {@link mat4.create} and {@link mat4.set}
 * @param m - The matrix.
 * @param dst - The matrix. If not passed a new one is created.
 * @returns A copy of m.
 */
function copy$2(m, dst) {
  dst = dst || new MatType(16);
  dst[0] = m[0];
  dst[1] = m[1];
  dst[2] = m[2];
  dst[3] = m[3];
  dst[4] = m[4];
  dst[5] = m[5];
  dst[6] = m[6];
  dst[7] = m[7];
  dst[8] = m[8];
  dst[9] = m[9];
  dst[10] = m[10];
  dst[11] = m[11];
  dst[12] = m[12];
  dst[13] = m[13];
  dst[14] = m[14];
  dst[15] = m[15];
  return dst;
}
/**
 * Copies a matrix (same as {@link mat4.copy})
 * Also see {@link mat4.create} and {@link mat4.set}
 * @param m - The matrix.
 * @param dst - The matrix. If not passed a new one is created.
 * @returns A copy of m.
 */
const clone$2 = copy$2;
/**
 * Check if 2 matrices are approximately equal
 * @param a - Operand matrix.
 * @param b - Operand matrix.
 * @returns true if matrices are approximately equal
 */
function equalsApproximately$2(a, b) {
  return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON && Math.abs(a[3] - b[3]) < EPSILON && Math.abs(a[4] - b[4]) < EPSILON && Math.abs(a[5] - b[5]) < EPSILON && Math.abs(a[6] - b[6]) < EPSILON && Math.abs(a[7] - b[7]) < EPSILON && Math.abs(a[8] - b[8]) < EPSILON && Math.abs(a[9] - b[9]) < EPSILON && Math.abs(a[10] - b[10]) < EPSILON && Math.abs(a[11] - b[11]) < EPSILON && Math.abs(a[12] - b[12]) < EPSILON && Math.abs(a[13] - b[13]) < EPSILON && Math.abs(a[14] - b[14]) < EPSILON && Math.abs(a[15] - b[15]) < EPSILON;
}
/**
 * Check if 2 matrices are exactly equal
 * @param a - Operand matrix.
 * @param b - Operand matrix.
 * @returns true if matrices are exactly equal
 */
function equals$2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Creates a 4-by-4 identity matrix.
 *
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns A 4-by-4 identity matrix.
 */
function identity$1(dst) {
  dst = dst || new MatType(16);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Takes the transpose of a matrix.
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The transpose of m.
 */
function transpose(m, dst) {
  dst = dst || new MatType(16);
  if (dst === m) {
    let t;
    t = m[1];
    m[1] = m[4];
    m[4] = t;
    t = m[2];
    m[2] = m[8];
    m[8] = t;
    t = m[3];
    m[3] = m[12];
    m[12] = t;
    t = m[6];
    m[6] = m[9];
    m[9] = t;
    t = m[7];
    m[7] = m[13];
    m[13] = t;
    t = m[11];
    m[11] = m[14];
    m[14] = t;
    return dst;
  }
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  dst[0] = m00;
  dst[1] = m10;
  dst[2] = m20;
  dst[3] = m30;
  dst[4] = m01;
  dst[5] = m11;
  dst[6] = m21;
  dst[7] = m31;
  dst[8] = m02;
  dst[9] = m12;
  dst[10] = m22;
  dst[11] = m32;
  dst[12] = m03;
  dst[13] = m13;
  dst[14] = m23;
  dst[15] = m33;
  return dst;
}
/**
 * Computes the inverse of a 4-by-4 matrix.
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The inverse of m.
 */
function inverse$2(m, dst) {
  dst = dst || new MatType(16);
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  const tmp0 = m22 * m33;
  const tmp1 = m32 * m23;
  const tmp2 = m12 * m33;
  const tmp3 = m32 * m13;
  const tmp4 = m12 * m23;
  const tmp5 = m22 * m13;
  const tmp6 = m02 * m33;
  const tmp7 = m32 * m03;
  const tmp8 = m02 * m23;
  const tmp9 = m22 * m03;
  const tmp10 = m02 * m13;
  const tmp11 = m12 * m03;
  const tmp12 = m20 * m31;
  const tmp13 = m30 * m21;
  const tmp14 = m10 * m31;
  const tmp15 = m30 * m11;
  const tmp16 = m10 * m21;
  const tmp17 = m20 * m11;
  const tmp18 = m00 * m31;
  const tmp19 = m30 * m01;
  const tmp20 = m00 * m21;
  const tmp21 = m20 * m01;
  const tmp22 = m00 * m11;
  const tmp23 = m10 * m01;
  const t0 = tmp0 * m11 + tmp3 * m21 + tmp4 * m31 - (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
  const t1 = tmp1 * m01 + tmp6 * m21 + tmp9 * m31 - (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
  const t2 = tmp2 * m01 + tmp7 * m11 + tmp10 * m31 - (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
  const t3 = tmp5 * m01 + tmp8 * m11 + tmp11 * m21 - (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
  const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
  dst[0] = d * t0;
  dst[1] = d * t1;
  dst[2] = d * t2;
  dst[3] = d * t3;
  dst[4] = d * (tmp1 * m10 + tmp2 * m20 + tmp5 * m30 - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));
  dst[5] = d * (tmp0 * m00 + tmp7 * m20 + tmp8 * m30 - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));
  dst[6] = d * (tmp3 * m00 + tmp6 * m10 + tmp11 * m30 - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));
  dst[7] = d * (tmp4 * m00 + tmp9 * m10 + tmp10 * m20 - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));
  dst[8] = d * (tmp12 * m13 + tmp15 * m23 + tmp16 * m33 - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));
  dst[9] = d * (tmp13 * m03 + tmp18 * m23 + tmp21 * m33 - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));
  dst[10] = d * (tmp14 * m03 + tmp19 * m13 + tmp22 * m33 - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));
  dst[11] = d * (tmp17 * m03 + tmp20 * m13 + tmp23 * m23 - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));
  dst[12] = d * (tmp14 * m22 + tmp17 * m32 + tmp13 * m12 - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));
  dst[13] = d * (tmp20 * m32 + tmp12 * m02 + tmp19 * m22 - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));
  dst[14] = d * (tmp18 * m12 + tmp23 * m32 + tmp15 * m02 - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));
  dst[15] = d * (tmp22 * m22 + tmp16 * m02 + tmp21 * m12 - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));
  return dst;
}
/**
 * Compute the determinant of a matrix
 * @param m - the matrix
 * @returns the determinant
 */
function determinant(m) {
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  const tmp0 = m22 * m33;
  const tmp1 = m32 * m23;
  const tmp2 = m12 * m33;
  const tmp3 = m32 * m13;
  const tmp4 = m12 * m23;
  const tmp5 = m22 * m13;
  const tmp6 = m02 * m33;
  const tmp7 = m32 * m03;
  const tmp8 = m02 * m23;
  const tmp9 = m22 * m03;
  const tmp10 = m02 * m13;
  const tmp11 = m12 * m03;
  const t0 = tmp0 * m11 + tmp3 * m21 + tmp4 * m31 - (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
  const t1 = tmp1 * m01 + tmp6 * m21 + tmp9 * m31 - (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
  const t2 = tmp2 * m01 + tmp7 * m11 + tmp10 * m31 - (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
  const t3 = tmp5 * m01 + tmp8 * m11 + tmp11 * m21 - (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
  return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;
}
/**
 * Computes the inverse of a 4-by-4 matrix. (same as inverse)
 * @param m - The matrix.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The inverse of m.
 */
const invert$1 = inverse$2;
/**
 * Multiplies two 4-by-4 matrices with a on the left and b on the right
 * @param a - The matrix on the left.
 * @param b - The matrix on the right.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The matrix product of a and b.
 */
function multiply$2(a, b, dst) {
  dst = dst || new MatType(16);
  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a03 = a[3];
  const a10 = a[4 + 0];
  const a11 = a[4 + 1];
  const a12 = a[4 + 2];
  const a13 = a[4 + 3];
  const a20 = a[8 + 0];
  const a21 = a[8 + 1];
  const a22 = a[8 + 2];
  const a23 = a[8 + 3];
  const a30 = a[12 + 0];
  const a31 = a[12 + 1];
  const a32 = a[12 + 2];
  const a33 = a[12 + 3];
  const b00 = b[0];
  const b01 = b[1];
  const b02 = b[2];
  const b03 = b[3];
  const b10 = b[4 + 0];
  const b11 = b[4 + 1];
  const b12 = b[4 + 2];
  const b13 = b[4 + 3];
  const b20 = b[8 + 0];
  const b21 = b[8 + 1];
  const b22 = b[8 + 2];
  const b23 = b[8 + 3];
  const b30 = b[12 + 0];
  const b31 = b[12 + 1];
  const b32 = b[12 + 2];
  const b33 = b[12 + 3];
  dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
  dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
  dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
  dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
  dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
  dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
  dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
  dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
  dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
  dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
  dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
  dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
  dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
  dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
  dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
  dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
  return dst;
}
/**
 * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)
 * @param a - The matrix on the left.
 * @param b - The matrix on the right.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The matrix product of a and b.
 */
const mul$2 = multiply$2;
/**
 * Sets the translation component of a 4-by-4 matrix to the given
 * vector.
 * @param a - The matrix.
 * @param v - The vector.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The matrix with translation set.
 */
function setTranslation(a, v, dst) {
  dst = dst || identity$1();
  if (a !== dst) {
    dst[0] = a[0];
    dst[1] = a[1];
    dst[2] = a[2];
    dst[3] = a[3];
    dst[4] = a[4];
    dst[5] = a[5];
    dst[6] = a[6];
    dst[7] = a[7];
    dst[8] = a[8];
    dst[9] = a[9];
    dst[10] = a[10];
    dst[11] = a[11];
  }
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}
/**
 * Returns the translation component of a 4-by-4 matrix as a vector with 3
 * entries.
 * @param m - The matrix.
 * @param dst - vector to hold result. If not passed a new one is created.
 * @returns The translation component of m.
 */
function getTranslation(m, dst) {
  dst = dst || create$4();
  dst[0] = m[12];
  dst[1] = m[13];
  dst[2] = m[14];
  return dst;
}
/**
 * Returns an axis of a 4x4 matrix as a vector with 3 entries
 * @param m - The matrix.
 * @param axis - The axis 0 = x, 1 = y, 2 = z;
 * @returns The axis component of m.
 */
function getAxis(m, axis, dst) {
  dst = dst || create$4();
  const off = axis * 4;
  dst[0] = m[off + 0];
  dst[1] = m[off + 1];
  dst[2] = m[off + 2];
  return dst;
}
/**
 * Sets an axis of a 4x4 matrix as a vector with 3 entries
 * @param m - The matrix.
 * @param v - the axis vector
 * @param axis - The axis  0 = x, 1 = y, 2 = z;
 * @param dst - The matrix to set. If not passed a new one is created.
 * @returns The matrix with axis set.
 */
function setAxis(a, v, axis, dst) {
  if (dst !== a) {
    dst = copy$2(a, dst);
  }
  const off = axis * 4;
  dst[off + 0] = v[0];
  dst[off + 1] = v[1];
  dst[off + 2] = v[2];
  return dst;
}
/**
 * Returns the scaling component of the matrix
 * @param m - The Matrix
 * @param dst - The vector to set. If not passed a new one is created.
 */
function getScaling(m, dst) {
  dst = dst || create$4();
  const xx = m[0];
  const xy = m[1];
  const xz = m[2];
  const yx = m[4];
  const yy = m[5];
  const yz = m[6];
  const zx = m[8];
  const zy = m[9];
  const zz = m[10];
  dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);
  dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);
  dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);
  return dst;
}
/**
 * Computes a 4-by-4 perspective transformation matrix given the angular height
 * of the frustum, the aspect ratio, and the near and far clipping planes.  The
 * arguments define a frustum extending in the negative z direction.  The given
 * angle is the vertical angle of the frustum, and the horizontal angle is
 * determined to produce the given aspect ratio.  The arguments near and far are
 * the distances to the near and far clipping planes.  Note that near and far
 * are not z coordinates, but rather they are distances along the negative
 * z-axis.  The matrix generated sends the viewing frustum to the unit box.
 * We assume a unit box extending from -1 to 1 in the x and y dimensions and
 * from 0 to 1 in the z dimension.
 *
 * Note: If you pass `Infinity` for zFar then it will produce a projection matrix
 * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z
 * otherwise.
 *
 * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).
 * @param aspect - The aspect ratio width / height.
 * @param zNear - The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param zFar - The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The perspective matrix.
 */
function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
  dst = dst || new MatType(16);
  const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
  dst[0] = f / aspect;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = f;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[15] = 0;
  if (zFar === Infinity) {
    dst[10] = -1;
    dst[14] = -zNear;
  } else {
    const rangeInv = 1 / (zNear - zFar);
    dst[10] = zFar * rangeInv;
    dst[14] = zFar * zNear * rangeInv;
  }
  return dst;
}
/**
 * Computes a 4-by-4 orthogonal transformation matrix that transforms from
 * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y
 * and 0 to +1 in z.
 * @param left - Left side of the near clipping plane viewport.
 * @param right - Right side of the near clipping plane viewport.
 * @param bottom - Bottom of the near clipping plane viewport.
 * @param top - Top of the near clipping plane viewport.
 * @param near - The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param far - The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param dst - Output matrix. If not passed a new one is created.
 * @returns The orthographic projection matrix.
 */
function ortho(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);
  dst[0] = 2 / (right - left);
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 2 / (top - bottom);
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1 / (near - far);
  dst[11] = 0;
  dst[12] = (right + left) / (left - right);
  dst[13] = (top + bottom) / (bottom - top);
  dst[14] = near / (near - far);
  dst[15] = 1;
  return dst;
}
/**
 * Computes a 4-by-4 perspective transformation matrix given the left, right,
 * top, bottom, near and far clipping planes. The arguments define a frustum
 * extending in the negative z direction. The arguments near and far are the
 * distances to the near and far clipping planes. Note that near and far are not
 * z coordinates, but rather they are distances along the negative z-axis. The
 * matrix generated sends the viewing frustum to the unit box. We assume a unit
 * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z
 * dimension.
 * @param left - The x coordinate of the left plane of the box.
 * @param right - The x coordinate of the right plane of the box.
 * @param bottom - The y coordinate of the bottom plane of the box.
 * @param top - The y coordinate of the right plane of the box.
 * @param near - The negative z coordinate of the near plane of the box.
 * @param far - The negative z coordinate of the far plane of the box.
 * @param dst - Output matrix. If not passed a new one is created.
 * @returns The perspective projection matrix.
 */
function frustum(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);
  const dx = right - left;
  const dy = top - bottom;
  const dz = near - far;
  dst[0] = 2 * near / dx;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 2 * near / dy;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = (left + right) / dx;
  dst[9] = (top + bottom) / dy;
  dst[10] = far / dz;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = near * far / dz;
  dst[15] = 0;
  return dst;
}
let xAxis;
let yAxis;
let zAxis;
/**
 * Computes a 4-by-4 aim transformation.
 *
 * This is a matrix which positions an object aiming down positive Z.
 * toward the target.
 *
 * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.
 *
 * @param position - The position of the object.
 * @param target - The position meant to be aimed at.
 * @param up - A vector pointing up.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The aim matrix.
 */
function aim(position, target, up, dst) {
  dst = dst || new MatType(16);
  xAxis = xAxis || create$4();
  yAxis = yAxis || create$4();
  zAxis = zAxis || create$4();
  normalize$2(subtract$2(target, position, zAxis), zAxis);
  normalize$2(cross(up, zAxis, xAxis), xAxis);
  normalize$2(cross(zAxis, xAxis, yAxis), yAxis);
  dst[0] = xAxis[0];
  dst[1] = xAxis[1];
  dst[2] = xAxis[2];
  dst[3] = 0;
  dst[4] = yAxis[0];
  dst[5] = yAxis[1];
  dst[6] = yAxis[2];
  dst[7] = 0;
  dst[8] = zAxis[0];
  dst[9] = zAxis[1];
  dst[10] = zAxis[2];
  dst[11] = 0;
  dst[12] = position[0];
  dst[13] = position[1];
  dst[14] = position[2];
  dst[15] = 1;
  return dst;
}
/**
 * Computes a 4-by-4 camera aim transformation.
 *
 * This is a matrix which positions an object aiming down negative Z.
 * toward the target.
 *
 * Note: this is the inverse of `lookAt`
 *
 * @param eye - The position of the object.
 * @param target - The position meant to be aimed at.
 * @param up - A vector pointing up.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The aim matrix.
 */
function cameraAim(eye, target, up, dst) {
  dst = dst || new MatType(16);
  xAxis = xAxis || create$4();
  yAxis = yAxis || create$4();
  zAxis = zAxis || create$4();
  normalize$2(subtract$2(eye, target, zAxis), zAxis);
  normalize$2(cross(up, zAxis, xAxis), xAxis);
  normalize$2(cross(zAxis, xAxis, yAxis), yAxis);
  dst[0] = xAxis[0];
  dst[1] = xAxis[1];
  dst[2] = xAxis[2];
  dst[3] = 0;
  dst[4] = yAxis[0];
  dst[5] = yAxis[1];
  dst[6] = yAxis[2];
  dst[7] = 0;
  dst[8] = zAxis[0];
  dst[9] = zAxis[1];
  dst[10] = zAxis[2];
  dst[11] = 0;
  dst[12] = eye[0];
  dst[13] = eye[1];
  dst[14] = eye[2];
  dst[15] = 1;
  return dst;
}
/**
 * Computes a 4-by-4 view transformation.
 *
 * This is a view matrix which transforms all other objects
 * to be in the space of the view defined by the parameters.
 *
 * @param eye - The position of the object.
 * @param target - The position meant to be aimed at.
 * @param up - A vector pointing up.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The look-at matrix.
 */
function lookAt(eye, target, up, dst) {
  dst = dst || new MatType(16);
  xAxis = xAxis || create$4();
  yAxis = yAxis || create$4();
  zAxis = zAxis || create$4();
  normalize$2(subtract$2(eye, target, zAxis), zAxis);
  normalize$2(cross(up, zAxis, xAxis), xAxis);
  normalize$2(cross(zAxis, xAxis, yAxis), yAxis);
  dst[0] = xAxis[0];
  dst[1] = yAxis[0];
  dst[2] = zAxis[0];
  dst[3] = 0;
  dst[4] = xAxis[1];
  dst[5] = yAxis[1];
  dst[6] = zAxis[1];
  dst[7] = 0;
  dst[8] = xAxis[2];
  dst[9] = yAxis[2];
  dst[10] = zAxis[2];
  dst[11] = 0;
  dst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);
  dst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);
  dst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);
  dst[15] = 1;
  return dst;
}
/**
 * Creates a 4-by-4 matrix which translates by the given vector v.
 * @param v - The vector by
 *     which to translate.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The translation matrix.
 */
function translation(v, dst) {
  dst = dst || new MatType(16);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}
/**
 * Translates the given 4-by-4 matrix by the given vector v.
 * @param m - The matrix.
 * @param v - The vector by
 *     which to translate.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The translated matrix.
 */
function translate(m, v, dst) {
  dst = dst || new MatType(16);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const m00 = m[0];
  const m01 = m[1];
  const m02 = m[2];
  const m03 = m[3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  if (m !== dst) {
    dst[0] = m00;
    dst[1] = m01;
    dst[2] = m02;
    dst[3] = m03;
    dst[4] = m10;
    dst[5] = m11;
    dst[6] = m12;
    dst[7] = m13;
    dst[8] = m20;
    dst[9] = m21;
    dst[10] = m22;
    dst[11] = m23;
  }
  dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;
  dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;
  dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;
  dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotation matrix.
 */
function rotationX(angleInRadians, dst) {
  dst = dst || new MatType(16);
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = c;
  dst[6] = s;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = -s;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the x-axis by the given
 * angle.
 * @param m - The matrix.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotated matrix.
 */
function rotateX$1(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  const m10 = m[4];
  const m11 = m[5];
  const m12 = m[6];
  const m13 = m[7];
  const m20 = m[8];
  const m21 = m[9];
  const m22 = m[10];
  const m23 = m[11];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[4] = c * m10 + s * m20;
  dst[5] = c * m11 + s * m21;
  dst[6] = c * m12 + s * m22;
  dst[7] = c * m13 + s * m23;
  dst[8] = c * m20 - s * m10;
  dst[9] = c * m21 - s * m11;
  dst[10] = c * m22 - s * m12;
  dst[11] = c * m23 - s * m13;
  if (m !== dst) {
    dst[0] = m[0];
    dst[1] = m[1];
    dst[2] = m[2];
    dst[3] = m[3];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotation matrix.
 */
function rotationY(angleInRadians, dst) {
  dst = dst || new MatType(16);
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = 0;
  dst[2] = -s;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = s;
  dst[9] = 0;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the y-axis by the given
 * angle.
 * @param m - The matrix.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotated matrix.
 */
function rotateY$1(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c * m00 - s * m20;
  dst[1] = c * m01 - s * m21;
  dst[2] = c * m02 - s * m22;
  dst[3] = c * m03 - s * m23;
  dst[8] = c * m20 + s * m00;
  dst[9] = c * m21 + s * m01;
  dst[10] = c * m22 + s * m02;
  dst[11] = c * m23 + s * m03;
  if (m !== dst) {
    dst[4] = m[4];
    dst[5] = m[5];
    dst[6] = m[6];
    dst[7] = m[7];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotation matrix.
 */
function rotationZ(angleInRadians, dst) {
  dst = dst || new MatType(16);
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = s;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = -s;
  dst[5] = c;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the z-axis by the given
 * angle.
 * @param m - The matrix.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotated matrix.
 */
function rotateZ$1(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c * m00 + s * m10;
  dst[1] = c * m01 + s * m11;
  dst[2] = c * m02 + s * m12;
  dst[3] = c * m03 + s * m13;
  dst[4] = c * m10 - s * m00;
  dst[5] = c * m11 - s * m01;
  dst[6] = c * m12 - s * m02;
  dst[7] = c * m13 - s * m03;
  if (m !== dst) {
    dst[8] = m[8];
    dst[9] = m[9];
    dst[10] = m[10];
    dst[11] = m[11];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the given axis by the given
 * angle.
 * @param axis - The axis
 *     about which to rotate.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns A matrix which rotates angle radians
 *     around the axis.
 */
function axisRotation(axis, angleInRadians, dst) {
  dst = dst || new MatType(16);
  let x = axis[0];
  let y = axis[1];
  let z = axis[2];
  const n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  const xx = x * x;
  const yy = y * y;
  const zz = z * z;
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  const oneMinusCosine = 1 - c;
  dst[0] = xx + (1 - xx) * c;
  dst[1] = x * y * oneMinusCosine + z * s;
  dst[2] = x * z * oneMinusCosine - y * s;
  dst[3] = 0;
  dst[4] = x * y * oneMinusCosine - z * s;
  dst[5] = yy + (1 - yy) * c;
  dst[6] = y * z * oneMinusCosine + x * s;
  dst[7] = 0;
  dst[8] = x * z * oneMinusCosine + y * s;
  dst[9] = y * z * oneMinusCosine - x * s;
  dst[10] = zz + (1 - zz) * c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Creates a 4-by-4 matrix which rotates around the given axis by the given
 * angle. (same as axisRotation)
 * @param axis - The axis
 *     about which to rotate.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns A matrix which rotates angle radians
 *     around the axis.
 */
const rotation = axisRotation;
/**
 * Rotates the given 4-by-4 matrix around the given axis by the
 * given angle.
 * @param m - The matrix.
 * @param axis - The axis
 *     about which to rotate.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotated matrix.
 */
function axisRotate(m, axis, angleInRadians, dst) {
  dst = dst || new MatType(16);
  let x = axis[0];
  let y = axis[1];
  let z = axis[2];
  const n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  const xx = x * x;
  const yy = y * y;
  const zz = z * z;
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  const oneMinusCosine = 1 - c;
  const r00 = xx + (1 - xx) * c;
  const r01 = x * y * oneMinusCosine + z * s;
  const r02 = x * z * oneMinusCosine - y * s;
  const r10 = x * y * oneMinusCosine - z * s;
  const r11 = yy + (1 - yy) * c;
  const r12 = y * z * oneMinusCosine + x * s;
  const r20 = x * z * oneMinusCosine + y * s;
  const r21 = y * z * oneMinusCosine - x * s;
  const r22 = zz + (1 - zz) * c;
  const m00 = m[0];
  const m01 = m[1];
  const m02 = m[2];
  const m03 = m[3];
  const m10 = m[4];
  const m11 = m[5];
  const m12 = m[6];
  const m13 = m[7];
  const m20 = m[8];
  const m21 = m[9];
  const m22 = m[10];
  const m23 = m[11];
  dst[0] = r00 * m00 + r01 * m10 + r02 * m20;
  dst[1] = r00 * m01 + r01 * m11 + r02 * m21;
  dst[2] = r00 * m02 + r01 * m12 + r02 * m22;
  dst[3] = r00 * m03 + r01 * m13 + r02 * m23;
  dst[4] = r10 * m00 + r11 * m10 + r12 * m20;
  dst[5] = r10 * m01 + r11 * m11 + r12 * m21;
  dst[6] = r10 * m02 + r11 * m12 + r12 * m22;
  dst[7] = r10 * m03 + r11 * m13 + r12 * m23;
  dst[8] = r20 * m00 + r21 * m10 + r22 * m20;
  dst[9] = r20 * m01 + r21 * m11 + r22 * m21;
  dst[10] = r20 * m02 + r21 * m12 + r22 * m22;
  dst[11] = r20 * m03 + r21 * m13 + r22 * m23;
  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}
/**
 * Rotates the given 4-by-4 matrix around the given axis by the
 * given angle. (same as rotate)
 * @param m - The matrix.
 * @param axis - The axis
 *     about which to rotate.
 * @param angleInRadians - The angle by which to rotate (in radians).
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The rotated matrix.
 */
const rotate = axisRotate;
/**
 * Creates a 4-by-4 matrix which scales in each dimension by an amount given by
 * the corresponding entry in the given vector; assumes the vector has three
 * entries.
 * @param v - A vector of
 *     three entries specifying the factor by which to scale in each dimension.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The scaling matrix.
 */
function scaling(v, dst) {
  dst = dst || new MatType(16);
  dst[0] = v[0];
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = v[1];
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = v[2];
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Scales the given 4-by-4 matrix in each dimension by an amount
 * given by the corresponding entry in the given vector; assumes the vector has
 * three entries.
 * @param m - The matrix to be modified.
 * @param v - A vector of three entries specifying the
 *     factor by which to scale in each dimension.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The scaled matrix.
 */
function scale$2(m, v, dst) {
  dst = dst || new MatType(16);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  dst[0] = v0 * m[0 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2];
  dst[3] = v0 * m[0 * 4 + 3];
  dst[4] = v1 * m[1 * 4 + 0];
  dst[5] = v1 * m[1 * 4 + 1];
  dst[6] = v1 * m[1 * 4 + 2];
  dst[7] = v1 * m[1 * 4 + 3];
  dst[8] = v2 * m[2 * 4 + 0];
  dst[9] = v2 * m[2 * 4 + 1];
  dst[10] = v2 * m[2 * 4 + 2];
  dst[11] = v2 * m[2 * 4 + 3];
  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}
/**
 * Creates a 4-by-4 matrix which scales a uniform amount in each dimension.
 * @param s - the amount to scale
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The scaling matrix.
 */
function uniformScaling(s, dst) {
  dst = dst || new MatType(16);
  dst[0] = s;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = s;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = s;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}
/**
 * Scales the given 4-by-4 matrix in each dimension by a uniform scale.
 * @param m - The matrix to be modified.
 * @param s - The amount to scale.
 * @param dst - matrix to hold result. If not passed a new one is created.
 * @returns The scaled matrix.
 */
function uniformScale(m, s, dst) {
  dst = dst || new MatType(16);
  dst[0] = s * m[0 * 4 + 0];
  dst[1] = s * m[0 * 4 + 1];
  dst[2] = s * m[0 * 4 + 2];
  dst[3] = s * m[0 * 4 + 3];
  dst[4] = s * m[1 * 4 + 0];
  dst[5] = s * m[1 * 4 + 1];
  dst[6] = s * m[1 * 4 + 2];
  dst[7] = s * m[1 * 4 + 3];
  dst[8] = s * m[2 * 4 + 0];
  dst[9] = s * m[2 * 4 + 1];
  dst[10] = s * m[2 * 4 + 2];
  dst[11] = s * m[2 * 4 + 3];
  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}
var mat4Impl = exports.mat4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setDefaultType: setDefaultType$3,
  create: create$2,
  set: set$2,
  fromMat3: fromMat3,
  fromQuat: fromQuat,
  negate: negate$1,
  copy: copy$2,
  clone: clone$2,
  equalsApproximately: equalsApproximately$2,
  equals: equals$2,
  identity: identity$1,
  transpose: transpose,
  inverse: inverse$2,
  determinant: determinant,
  invert: invert$1,
  multiply: multiply$2,
  mul: mul$2,
  setTranslation: setTranslation,
  getTranslation: getTranslation,
  getAxis: getAxis,
  setAxis: setAxis,
  getScaling: getScaling,
  perspective: perspective,
  ortho: ortho,
  frustum: frustum,
  aim: aim,
  cameraAim: cameraAim,
  lookAt: lookAt,
  translation: translation,
  translate: translate,
  rotationX: rotationX,
  rotateX: rotateX$1,
  rotationY: rotationY,
  rotateY: rotateY$1,
  rotationZ: rotationZ,
  rotateZ: rotateZ$1,
  axisRotation: axisRotation,
  rotation: rotation,
  axisRotate: axisRotate,
  rotate: rotate,
  scaling: scaling,
  scale: scale$2,
  uniformScaling: uniformScaling,
  uniformScale: uniformScale
});

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 *
 * Quat4 math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new `Quat4`. In other words you can do this
 *
 *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = quat4.create();
 *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
let QuatType = Float32Array;
/**
 * Sets the type this library creates for a Quat4
 * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`
 * @returns previous constructor for Quat4
 */
function setDefaultType$2(ctor) {
  const oldType = QuatType;
  QuatType = ctor;
  return oldType;
}
/**
 * Creates a quat4; may be called with x, y, z to set initial values.
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @param z - Initial z value.
 * @param w - Initial w value.
 * @returns the created vector
 */
function create$1(x, y, z, w) {
  const dst = new QuatType(4);
  if (x !== undefined) {
    dst[0] = x;
    if (y !== undefined) {
      dst[1] = y;
      if (z !== undefined) {
        dst[2] = z;
        if (w !== undefined) {
          dst[3] = w;
        }
      }
    }
  }
  return dst;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Creates a Quat; may be called with x, y, z to set initial values. (same as create)
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @param z - Initial z value.
 * @param z - Initial w value.
 * @returns the created vector
 */
const fromValues$1 = create$1;
/**
 * Sets the values of a Quat
 * Also see {@link quat.create} and {@link quat.copy}
 *
 * @param x first value
 * @param y second value
 * @param z third value
 * @param w fourth value
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector with its elements set.
 */
function set$1(x, y, z, w, dst) {
  dst = dst || new QuatType(4);
  dst[0] = x;
  dst[1] = y;
  dst[2] = z;
  dst[3] = w;
  return dst;
}
/**
 * Sets a quaternion from the given angle and  axis,
 * then returns it.
 *
 * @param axis - the axis to rotate around
 * @param angleInRadians - the angle
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns The quaternion that represents the given axis and angle
 **/
function fromAxisAngle(axis, angleInRadians, dst) {
  dst = dst || new QuatType(4);
  const halfAngle = angleInRadians * 0.5;
  const s = Math.sin(halfAngle);
  dst[0] = s * axis[0];
  dst[1] = s * axis[1];
  dst[2] = s * axis[2];
  dst[3] = Math.cos(halfAngle);
  return dst;
}
/**
 * Gets the rotation axis and angle
 * @param q - quaternion to compute from
 * @param dst - Vec3 to hold result. If not passed in a new one is created.
 * @return angle and axis
 */
function toAxisAngle(q, dst) {
  dst = dst || create$4(4);
  const angle = Math.acos(q[3]) * 2;
  const s = Math.sin(angle * 0.5);
  if (s > EPSILON) {
    dst[0] = q[0] / s;
    dst[1] = q[1] / s;
    dst[2] = q[2] / s;
  } else {
    dst[0] = 1;
    dst[1] = 0;
    dst[2] = 0;
  }
  return {
    angle,
    axis: dst
  };
}
/**
 * Returns the angle in degrees between two rotations a and b.
 * @param a - quaternion a
 * @param b - quaternion b
 * @return angle in radians between the two quaternions
 */
function angle(a, b) {
  const d = dot$1(a, b);
  return Math.acos(2 * d * d - 1);
}
/**
 * Multiplies two quaternions
 *
 * @param a - the first quaternion
 * @param b - the second quaternion
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns A quaternion that is the result of a * b
 */
function multiply$1(a, b, dst) {
  dst = dst || new QuatType(4);
  const ax = a[0];
  const ay = a[1];
  const az = a[2];
  const aw = a[3];
  const bx = b[0];
  const by = b[1];
  const bz = b[2];
  const bw = b[3];
  dst[0] = ax * bw + aw * bx + ay * bz - az * by;
  dst[1] = ay * bw + aw * by + az * bx - ax * bz;
  dst[2] = az * bw + aw * bz + ax * by - ay * bx;
  dst[3] = aw * bw - ax * bx - ay * by - az * bz;
  return dst;
}
/**
 * Multiplies two quaternions
 *
 * @param a - the first quaternion
 * @param b - the second quaternion
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns A quaternion that is the result of a * b
 */
const mul$1 = multiply$1;
/**
 * Rotates the given quaternion around the X axis by the given angle.
 * @param q - quaternion to rotate
 * @param angleInRadians - The angle by which to rotate
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns A quaternion that is the result of a * b
 */
function rotateX(q, angleInRadians, dst) {
  dst = dst || new QuatType(4);
  const halfAngle = angleInRadians * 0.5;
  const qx = q[0];
  const qy = q[1];
  const qz = q[2];
  const qw = q[3];
  const bx = Math.sin(halfAngle);
  const bw = Math.cos(halfAngle);
  dst[0] = qx * bw + qw * bx;
  dst[1] = qy * bw + qz * bx;
  dst[2] = qz * bw - qy * bx;
  dst[3] = qw * bw - qx * bx;
  return dst;
}
/**
 * Rotates the given quaternion around the Y axis by the given angle.
 * @param q - quaternion to rotate
 * @param angleInRadians - The angle by which to rotate
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns A quaternion that is the result of a * b
 */
function rotateY(q, angleInRadians, dst) {
  dst = dst || new QuatType(4);
  const halfAngle = angleInRadians * 0.5;
  const qx = q[0];
  const qy = q[1];
  const qz = q[2];
  const qw = q[3];
  const by = Math.sin(halfAngle);
  const bw = Math.cos(halfAngle);
  dst[0] = qx * bw - qz * by;
  dst[1] = qy * bw + qw * by;
  dst[2] = qz * bw + qx * by;
  dst[3] = qw * bw - qy * by;
  return dst;
}
/**
 * Rotates the given quaternion around the Z axis by the given angle.
 * @param q - quaternion to rotate
 * @param angleInRadians - The angle by which to rotate
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns A quaternion that is the result of a * b
 */
function rotateZ(q, angleInRadians, dst) {
  dst = dst || new QuatType(4);
  const halfAngle = angleInRadians * 0.5;
  const qx = q[0];
  const qy = q[1];
  const qz = q[2];
  const qw = q[3];
  const bz = Math.sin(halfAngle);
  const bw = Math.cos(halfAngle);
  dst[0] = qx * bw + qy * bz;
  dst[1] = qy * bw - qx * bz;
  dst[2] = qz * bw + qw * bz;
  dst[3] = qw * bw - qz * bz;
  return dst;
}
/**
 * Spherically linear interpolate between two quaternions
 *
 * @param a - starting value
 * @param b - ending value
 * @param t - value where 0 = a and 1 = b
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns A quaternion that is the result of a * b
 */
function slerp(a, b, t, dst) {
  dst = dst || new QuatType(4);
  const ax = a[0];
  const ay = a[1];
  const az = a[2];
  const aw = a[3];
  let bx = b[0];
  let by = b[1];
  let bz = b[2];
  let bw = b[3];
  let cosOmega = ax * bx + ay * by + az * bz + aw * bw;
  if (cosOmega < 0) {
    cosOmega = -cosOmega;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  let scale0;
  let scale1;
  if (1.0 - cosOmega > EPSILON) {
    const omega = Math.acos(cosOmega);
    const sinOmega = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinOmega;
    scale1 = Math.sin(t * omega) / sinOmega;
  } else {
    scale0 = 1.0 - t;
    scale1 = t;
  }
  dst[0] = scale0 * ax + scale1 * bx;
  dst[1] = scale0 * ay + scale1 * by;
  dst[2] = scale0 * az + scale1 * bz;
  dst[3] = scale0 * aw + scale1 * bw;
  return dst;
}
/**
 * Compute the inverse of a quaternion
 *
 * @param q - quaternion to compute the inverse of
 * @returns A quaternion that is the result of a * b
 */
function inverse$1(q, dst) {
  dst = dst || new QuatType(4);
  const a0 = q[0];
  const a1 = q[1];
  const a2 = q[2];
  const a3 = q[3];
  const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  const invDot = dot ? 1 / dot : 0;
  dst[0] = -a0 * invDot;
  dst[1] = -a1 * invDot;
  dst[2] = -a2 * invDot;
  dst[3] = a3 * invDot;
  return dst;
}
/**
 * Compute the conjugate of a quaternion
 * For quaternions with a magnitude of 1 (a unit quaternion)
 * this returns the same as the inverse but is faster to calculate.
 *
 * @param q - quaternion to compute the conjugate of.
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns The conjugate of q
 */
function conjugate(q, dst) {
  dst = dst || new QuatType(4);
  dst[0] = -q[0];
  dst[1] = -q[1];
  dst[2] = -q[2];
  dst[3] = q[3];
  return dst;
}
/**
 * Creates a quaternion from the given rotation matrix.
 *
 * The created quaternion is not normalized.
 *
 * @param m - rotation matrix
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns the result
 */
function fromMat(m, dst) {
  dst = dst || new QuatType(4);
  /*
  0 1 2
  3 4 5
  6 7 8
     0 1 2
  4 5 6
  8 9 10
   */
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  const trace = m[0] + m[5] + m[10];
  if (trace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    const root = Math.sqrt(trace + 1); // 2w
    dst[3] = 0.5 * root;
    const invRoot = 0.5 / root; // 1/(4w)
    dst[0] = (m[6] - m[9]) * invRoot;
    dst[1] = (m[8] - m[2]) * invRoot;
    dst[2] = (m[1] - m[4]) * invRoot;
  } else {
    // |w| <= 1/2
    let i = 0;
    if (m[5] > m[0]) {
      i = 1;
    }
    if (m[10] > m[i * 4 + i]) {
      i = 2;
    }
    const j = (i + 1) % 3;
    const k = (i + 2) % 3;
    const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);
    dst[i] = 0.5 * root;
    const invRoot = 0.5 / root;
    dst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;
    dst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;
    dst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;
  }
  return dst;
}
/**
 * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.
 *
 * @param xAngleInRadians - angle to rotate around X axis in radians.
 * @param yAngleInRadians - angle to rotate around Y axis in radians.
 * @param zAngleInRadians - angle to rotate around Z axis in radians.
 * @param order - order to apply euler angles
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns A quaternion representing the same rotation as the euler angles applied in the given order
 */
function fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {
  dst = dst || new QuatType(4);
  const xHalfAngle = xAngleInRadians * 0.5;
  const yHalfAngle = yAngleInRadians * 0.5;
  const zHalfAngle = zAngleInRadians * 0.5;
  const sx = Math.sin(xHalfAngle);
  const cx = Math.cos(xHalfAngle);
  const sy = Math.sin(yHalfAngle);
  const cy = Math.cos(yHalfAngle);
  const sz = Math.sin(zHalfAngle);
  const cz = Math.cos(zHalfAngle);
  switch (order) {
    case 'xyz':
      dst[0] = sx * cy * cz + cx * sy * sz;
      dst[1] = cx * sy * cz - sx * cy * sz;
      dst[2] = cx * cy * sz + sx * sy * cz;
      dst[3] = cx * cy * cz - sx * sy * sz;
      break;
    case 'xzy':
      dst[0] = sx * cy * cz - cx * sy * sz;
      dst[1] = cx * sy * cz - sx * cy * sz;
      dst[2] = cx * cy * sz + sx * sy * cz;
      dst[3] = cx * cy * cz + sx * sy * sz;
      break;
    case 'yxz':
      dst[0] = sx * cy * cz + cx * sy * sz;
      dst[1] = cx * sy * cz - sx * cy * sz;
      dst[2] = cx * cy * sz - sx * sy * cz;
      dst[3] = cx * cy * cz + sx * sy * sz;
      break;
    case 'yzx':
      dst[0] = sx * cy * cz + cx * sy * sz;
      dst[1] = cx * sy * cz + sx * cy * sz;
      dst[2] = cx * cy * sz - sx * sy * cz;
      dst[3] = cx * cy * cz - sx * sy * sz;
      break;
    case 'zxy':
      dst[0] = sx * cy * cz - cx * sy * sz;
      dst[1] = cx * sy * cz + sx * cy * sz;
      dst[2] = cx * cy * sz + sx * sy * cz;
      dst[3] = cx * cy * cz - sx * sy * sz;
      break;
    case 'zyx':
      dst[0] = sx * cy * cz - cx * sy * sz;
      dst[1] = cx * sy * cz + sx * cy * sz;
      dst[2] = cx * cy * sz - sx * sy * cz;
      dst[3] = cx * cy * cz + sx * sy * sz;
      break;
    default:
      throw new Error(`Unknown rotation order: ${order}`);
  }
  return dst;
}
/**
 * Copies a quaternion. (same as {@link quat.clone})
 * Also see {@link quat.create} and {@link quat.set}
 * @param q - The quaternion.
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns A quaternion that is a copy of q
 */
function copy$1(q, dst) {
  dst = dst || new QuatType(4);
  dst[0] = q[0];
  dst[1] = q[1];
  dst[2] = q[2];
  dst[3] = q[3];
  return dst;
}
/**
 * Clones a quaternion. (same as {@link quat.copy})
 * Also see {@link quat.create} and {@link quat.set}
 * @param q - The quaternion.
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns A copy of q.
 */
const clone$1 = copy$1;
/**
 * Adds two quaternions; assumes a and b have the same dimension.
 * @param a - Operand quaternion.
 * @param b - Operand quaternion.
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns A quaternion that is the sum of a and b.
 */
function add$1(a, b, dst) {
  dst = dst || new QuatType(4);
  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  dst[2] = a[2] + b[2];
  dst[3] = a[3] + b[3];
  return dst;
}
/**
 * Subtracts two quaternions.
 * @param a - Operand quaternion.
 * @param b - Operand quaternion.
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns A quaternion that is the difference of a and b.
 */
function subtract$1(a, b, dst) {
  dst = dst || new QuatType(4);
  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  dst[2] = a[2] - b[2];
  dst[3] = a[3] - b[3];
  return dst;
}
/**
 * Subtracts two quaternions.
 * @param a - Operand quaternion.
 * @param b - Operand quaternion.
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns A quaternion that is the difference of a and b.
 */
const sub$1 = subtract$1;
/**
 * Multiplies a quaternion by a scalar.
 * @param v - The quaternion.
 * @param k - The scalar.
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns The scaled quaternion.
 */
function mulScalar$1(v, k, dst) {
  dst = dst || new QuatType(4);
  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  dst[2] = v[2] * k;
  dst[3] = v[3] * k;
  return dst;
}
/**
 * Multiplies a quaternion by a scalar. (same as mulScalar)
 * @param v - The quaternion.
 * @param k - The scalar.
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns The scaled quaternion.
 */
const scale$1 = mulScalar$1;
/**
 * Divides a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns The scaled quaternion.
 */
function divScalar$1(v, k, dst) {
  dst = dst || new QuatType(4);
  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  dst[2] = v[2] / k;
  dst[3] = v[3] / k;
  return dst;
}
/**
 * Computes the dot product of two quaternions
 * @param a - Operand quaternion.
 * @param b - Operand quaternion.
 * @returns dot product
 */
function dot$1(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Performs linear interpolation on two quaternions.
 * Given quaternions a and b and interpolation coefficient t, returns
 * a + t * (b - a).
 * @param a - Operand quaternion.
 * @param b - Operand quaternion.
 * @param t - Interpolation coefficient.
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns The linear interpolated result.
 */
function lerp$1(a, b, t, dst) {
  dst = dst || new QuatType(4);
  dst[0] = a[0] + t * (b[0] - a[0]);
  dst[1] = a[1] + t * (b[1] - a[1]);
  dst[2] = a[2] + t * (b[2] - a[2]);
  dst[3] = a[3] + t * (b[3] - a[3]);
  return dst;
}
/**
 * Computes the length of quaternion
 * @param v - quaternion.
 * @returns length of quaternion.
 */
function length$1(v) {
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const v3 = v[3];
  return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
}
/**
 * Computes the length of quaternion (same as length)
 * @param v - quaternion.
 * @returns length of quaternion.
 */
const len$1 = length$1;
/**
 * Computes the square of the length of quaternion
 * @param v - quaternion.
 * @returns square of the length of quaternion.
 */
function lengthSq$1(v) {
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const v3 = v[3];
  return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;
}
/**
 * Computes the square of the length of quaternion (same as lengthSq)
 * @param v - quaternion.
 * @returns square of the length of quaternion.
 */
const lenSq$1 = lengthSq$1;
/**
 * Divides a quaternion by its Euclidean length and returns the quotient.
 * @param v - The quaternion.
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns The normalized quaternion.
 */
function normalize$1(v, dst) {
  dst = dst || new QuatType(4);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const v3 = v[3];
  const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
  if (len > 0.00001) {
    dst[0] = v0 / len;
    dst[1] = v1 / len;
    dst[2] = v2 / len;
    dst[3] = v3 / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
  }
  return dst;
}
/**
 * Check if 2 quaternions are approximately equal
 * @param a - Operand quaternion.
 * @param b - Operand quaternion.
 * @returns true if quaternions are approximately equal
 */
function equalsApproximately$1(a, b) {
  return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON && Math.abs(a[3] - b[3]) < EPSILON;
}
/**
 * Check if 2 quaternions are exactly equal
 * @param a - Operand quaternion.
 * @param b - Operand quaternion.
 * @returns true if quaternions are exactly equal
 */
function equals$1(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Creates an identity quaternion
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns an identity quaternion
 */
function identity(dst) {
  dst = dst || new QuatType(4);
  dst[0] = 0;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 1;
  return dst;
}
let tempVec3;
let xUnitVec3;
let yUnitVec3;
/**
 * Computes a quaternion to represent the shortest rotation from one vector to another.
 *
 * @param aUnit - the start vector
 * @param bUnit - the end vector
 * @param dst - quaternion to hold result. If not passed in a new one is created.
 * @returns the result
 */
function rotationTo(aUnit, bUnit, dst) {
  dst = dst || new QuatType(4);
  tempVec3 = tempVec3 || create$4();
  xUnitVec3 = xUnitVec3 || create$4(1, 0, 0);
  yUnitVec3 = yUnitVec3 || create$4(0, 1, 0);
  const dot = dot$2(aUnit, bUnit);
  if (dot < -0.999999) {
    cross(xUnitVec3, aUnit, tempVec3);
    if (len$2(tempVec3) < 0.000001) {
      cross(yUnitVec3, aUnit, tempVec3);
    }
    normalize$2(tempVec3, tempVec3);
    fromAxisAngle(tempVec3, Math.PI, dst);
    return dst;
  } else if (dot > 0.999999) {
    dst[0] = 0;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 1;
    return dst;
  } else {
    cross(aUnit, bUnit, tempVec3);
    dst[0] = tempVec3[0];
    dst[1] = tempVec3[1];
    dst[2] = tempVec3[2];
    dst[3] = 1 + dot;
    return normalize$1(dst, dst);
  }
}
let tempQuat1;
let tempQuat2;
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param a - the first quaternion
 * @param b - the second quaternion
 * @param c - the third quaternion
 * @param d - the fourth quaternion
 * @param t - Interpolation coefficient 0 to 1
 * @returns result
 */
function sqlerp(a, b, c, d, t, dst) {
  dst = dst || new QuatType(4);
  tempQuat1 = tempQuat1 || new QuatType(4);
  tempQuat2 = tempQuat2 || new QuatType(4);
  slerp(a, d, t, tempQuat1);
  slerp(b, c, t, tempQuat2);
  slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), dst);
  return dst;
}
var quatImpl = exports.quat = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create: create$1,
  setDefaultType: setDefaultType$2,
  fromValues: fromValues$1,
  set: set$1,
  fromAxisAngle: fromAxisAngle,
  toAxisAngle: toAxisAngle,
  angle: angle,
  multiply: multiply$1,
  mul: mul$1,
  rotateX: rotateX,
  rotateY: rotateY,
  rotateZ: rotateZ,
  slerp: slerp,
  inverse: inverse$1,
  conjugate: conjugate,
  fromMat: fromMat,
  fromEuler: fromEuler,
  copy: copy$1,
  clone: clone$1,
  add: add$1,
  subtract: subtract$1,
  sub: sub$1,
  mulScalar: mulScalar$1,
  scale: scale$1,
  divScalar: divScalar$1,
  dot: dot$1,
  lerp: lerp$1,
  length: length$1,
  len: len$1,
  lengthSq: lengthSq$1,
  lenSq: lenSq$1,
  normalize: normalize$1,
  equalsApproximately: equalsApproximately$1,
  equals: equals$1,
  identity: identity,
  rotationTo: rotationTo,
  sqlerp: sqlerp
});

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 *
 * Vec4 math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new `Vec4`. In other words you can do this
 *
 *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = vec4.create();
 *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
let VecType = Float32Array;
/**
 * Sets the type this library creates for a Vec4
 * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`
 * @returns previous constructor for Vec4
 */
function setDefaultType$1(ctor) {
  const oldType = VecType;
  VecType = ctor;
  return oldType;
}
/**
 * Creates a vec4; may be called with x, y, z to set initial values.
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @param z - Initial z value.
 * @param w - Initial w value.
 * @returns the created vector
 */
function create(x, y, z, w) {
  const dst = new VecType(4);
  if (x !== undefined) {
    dst[0] = x;
    if (y !== undefined) {
      dst[1] = y;
      if (z !== undefined) {
        dst[2] = z;
        if (w !== undefined) {
          dst[3] = w;
        }
      }
    }
  }
  return dst;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Creates a vec4; may be called with x, y, z to set initial values. (same as create)
 * @param x - Initial x value.
 * @param y - Initial y value.
 * @param z - Initial z value.
 * @param z - Initial w value.
 * @returns the created vector
 */
const fromValues = create;
/**
 * Sets the values of a Vec4
 * Also see {@link vec4.create} and {@link vec4.copy}
 *
 * @param x first value
 * @param y second value
 * @param z third value
 * @param w fourth value
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector with its elements set.
 */
function set(x, y, z, w, dst) {
  dst = dst || new VecType(4);
  dst[0] = x;
  dst[1] = y;
  dst[2] = z;
  dst[3] = w;
  return dst;
}
/**
 * Applies Math.ceil to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the ceil of each element of v.
 */
function ceil(v, dst) {
  dst = dst || new VecType(4);
  dst[0] = Math.ceil(v[0]);
  dst[1] = Math.ceil(v[1]);
  dst[2] = Math.ceil(v[2]);
  dst[3] = Math.ceil(v[3]);
  return dst;
}
/**
 * Applies Math.floor to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the floor of each element of v.
 */
function floor(v, dst) {
  dst = dst || new VecType(4);
  dst[0] = Math.floor(v[0]);
  dst[1] = Math.floor(v[1]);
  dst[2] = Math.floor(v[2]);
  dst[3] = Math.floor(v[3]);
  return dst;
}
/**
 * Applies Math.round to each element of vector
 * @param v - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the round of each element of v.
 */
function round(v, dst) {
  dst = dst || new VecType(4);
  dst[0] = Math.round(v[0]);
  dst[1] = Math.round(v[1]);
  dst[2] = Math.round(v[2]);
  dst[3] = Math.round(v[3]);
  return dst;
}
/**
 * Clamp each element of vector between min and max
 * @param v - Operand vector.
 * @param max - Min value, default 0
 * @param min - Max value, default 1
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that the clamped value of each element of v.
 */
function clamp(v, min = 0, max = 1, dst) {
  dst = dst || new VecType(4);
  dst[0] = Math.min(max, Math.max(min, v[0]));
  dst[1] = Math.min(max, Math.max(min, v[1]));
  dst[2] = Math.min(max, Math.max(min, v[2]));
  dst[3] = Math.min(max, Math.max(min, v[3]));
  return dst;
}
/**
 * Adds two vectors; assumes a and b have the same dimension.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the sum of a and b.
 */
function add(a, b, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  dst[2] = a[2] + b[2];
  dst[3] = a[3] + b[3];
  return dst;
}
/**
 * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param scale - Amount to scale b
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the sum of a + b * scale.
 */
function addScaled(a, b, scale, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] + b[0] * scale;
  dst[1] = a[1] + b[1] * scale;
  dst[2] = a[2] + b[2] * scale;
  dst[3] = a[3] + b[3] * scale;
  return dst;
}
/**
 * Subtracts two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the difference of a and b.
 */
function subtract(a, b, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  dst[2] = a[2] - b[2];
  dst[3] = a[3] - b[3];
  return dst;
}
/**
 * Subtracts two vectors.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A vector that is the difference of a and b.
 */
const sub = subtract;
/**
 * Check if 2 vectors are approximately equal
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns true if vectors are approximately equal
 */
function equalsApproximately(a, b) {
  return Math.abs(a[0] - b[0]) < EPSILON && Math.abs(a[1] - b[1]) < EPSILON && Math.abs(a[2] - b[2]) < EPSILON && Math.abs(a[3] - b[3]) < EPSILON;
}
/**
 * Check if 2 vectors are exactly equal
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns true if vectors are exactly equal
 */
function equals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient t, returns
 * a + t * (b - a).
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param t - Interpolation coefficient.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The linear interpolated result.
 */
function lerp(a, b, t, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] + t * (b[0] - a[0]);
  dst[1] = a[1] + t * (b[1] - a[1]);
  dst[2] = a[2] + t * (b[2] - a[2]);
  dst[3] = a[3] + t * (b[3] - a[3]);
  return dst;
}
/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient vector t, returns
 * a + t * (b - a).
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param t - Interpolation coefficients vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns the linear interpolated result.
 */
function lerpV(a, b, t, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] + t[0] * (b[0] - a[0]);
  dst[1] = a[1] + t[1] * (b[1] - a[1]);
  dst[2] = a[2] + t[2] * (b[2] - a[2]);
  dst[3] = a[3] + t[3] * (b[3] - a[3]);
  return dst;
}
/**
 * Return max values of two vectors.
 * Given vectors a and b returns
 * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The max components vector.
 */
function max(a, b, dst) {
  dst = dst || new VecType(4);
  dst[0] = Math.max(a[0], b[0]);
  dst[1] = Math.max(a[1], b[1]);
  dst[2] = Math.max(a[2], b[2]);
  dst[3] = Math.max(a[3], b[3]);
  return dst;
}
/**
 * Return min values of two vectors.
 * Given vectors a and b returns
 * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The min components vector.
 */
function min(a, b, dst) {
  dst = dst || new VecType(4);
  dst[0] = Math.min(a[0], b[0]);
  dst[1] = Math.min(a[1], b[1]);
  dst[2] = Math.min(a[2], b[2]);
  dst[3] = Math.min(a[3], b[3]);
  return dst;
}
/**
 * Multiplies a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The scaled vector.
 */
function mulScalar(v, k, dst) {
  dst = dst || new VecType(4);
  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  dst[2] = v[2] * k;
  dst[3] = v[3] * k;
  return dst;
}
/**
 * Multiplies a vector by a scalar. (same as mulScalar)
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The scaled vector.
 */
const scale = mulScalar;
/**
 * Divides a vector by a scalar.
 * @param v - The vector.
 * @param k - The scalar.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The scaled vector.
 */
function divScalar(v, k, dst) {
  dst = dst || new VecType(4);
  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  dst[2] = v[2] / k;
  dst[3] = v[3] / k;
  return dst;
}
/**
 * Inverse a vector.
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The inverted vector.
 */
function inverse(v, dst) {
  dst = dst || new VecType(4);
  dst[0] = 1 / v[0];
  dst[1] = 1 / v[1];
  dst[2] = 1 / v[2];
  dst[3] = 1 / v[3];
  return dst;
}
/**
 * Invert a vector. (same as inverse)
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The inverted vector.
 */
const invert = inverse;
/**
 * Computes the dot product of two vectors
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @returns dot product
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Computes the length of vector
 * @param v - vector.
 * @returns length of vector.
 */
function length(v) {
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const v3 = v[3];
  return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
}
/**
 * Computes the length of vector (same as length)
 * @param v - vector.
 * @returns length of vector.
 */
const len = length;
/**
 * Computes the square of the length of vector
 * @param v - vector.
 * @returns square of the length of vector.
 */
function lengthSq(v) {
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const v3 = v[3];
  return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;
}
/**
 * Computes the square of the length of vector (same as lengthSq)
 * @param v - vector.
 * @returns square of the length of vector.
 */
const lenSq = lengthSq;
/**
 * Computes the distance between 2 points
 * @param a - vector.
 * @param b - vector.
 * @returns distance between a and b
 */
function distance(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  const dw = a[3] - b[3];
  return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
}
/**
 * Computes the distance between 2 points (same as distance)
 * @param a - vector.
 * @param b - vector.
 * @returns distance between a and b
 */
const dist = distance;
/**
 * Computes the square of the distance between 2 points
 * @param a - vector.
 * @param b - vector.
 * @returns square of the distance between a and b
 */
function distanceSq(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  const dw = a[3] - b[3];
  return dx * dx + dy * dy + dz * dz + dw * dw;
}
/**
 * Computes the square of the distance between 2 points (same as distanceSq)
 * @param a - vector.
 * @param b - vector.
 * @returns square of the distance between a and b
 */
const distSq = distanceSq;
/**
 * Divides a vector by its Euclidean length and returns the quotient.
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The normalized vector.
 */
function normalize(v, dst) {
  dst = dst || new VecType(4);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const v3 = v[3];
  const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
  if (len > 0.00001) {
    dst[0] = v0 / len;
    dst[1] = v1 / len;
    dst[2] = v2 / len;
    dst[3] = v3 / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
  }
  return dst;
}
/**
 * Negates a vector.
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns -v.
 */
function negate(v, dst) {
  dst = dst || new VecType(4);
  dst[0] = -v[0];
  dst[1] = -v[1];
  dst[2] = -v[2];
  dst[3] = -v[3];
  return dst;
}
/**
 * Copies a vector. (same as {@link vec4.clone})
 * Also see {@link vec4.create} and {@link vec4.set}
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A copy of v.
 */
function copy(v, dst) {
  dst = dst || new VecType(4);
  dst[0] = v[0];
  dst[1] = v[1];
  dst[2] = v[2];
  dst[3] = v[3];
  return dst;
}
/**
 * Clones a vector. (same as {@link vec4.copy})
 * Also see {@link vec4.create} and {@link vec4.set}
 * @param v - The vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns A copy of v.
 */
const clone = copy;
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of products of entries of a and b.
 */
function multiply(a, b, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] * b[0];
  dst[1] = a[1] * b[1];
  dst[2] = a[2] * b[2];
  dst[3] = a[3] * b[3];
  return dst;
}
/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length. (same as mul)
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of products of entries of a and b.
 */
const mul = multiply;
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of quotients of entries of a and b.
 */
function divide(a, b, dst) {
  dst = dst || new VecType(4);
  dst[0] = a[0] / b[0];
  dst[1] = a[1] / b[1];
  dst[2] = a[2] / b[2];
  dst[3] = a[3] / b[3];
  return dst;
}
/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length. (same as divide)
 * @param a - Operand vector.
 * @param b - Operand vector.
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The vector of quotients of entries of a and b.
 */
const div = divide;
/**
 * Zero's a vector
 * @param dst - vector to hold result. If not passed in a new one is created.
 * @returns The zeroed vector.
 */
function zero(dst) {
  dst = dst || new VecType(4);
  dst[0] = 0;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  return dst;
}
/**
 * transform vec4 by 4x4 matrix
 * @param v - the vector
 * @param m - The matrix.
 * @param dst - optional vec4 to store result. If not passed a new one is created.
 * @returns the transformed vector
 */
function transformMat4(v, m, dst) {
  dst = dst || new VecType(4);
  const x = v[0];
  const y = v[1];
  const z = v[2];
  const w = v[3];
  dst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  dst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  dst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  dst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return dst;
}
var vec4Impl = exports.vec4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create: create,
  setDefaultType: setDefaultType$1,
  fromValues: fromValues,
  set: set,
  ceil: ceil,
  floor: floor,
  round: round,
  clamp: clamp,
  add: add,
  addScaled: addScaled,
  subtract: subtract,
  sub: sub,
  equalsApproximately: equalsApproximately,
  equals: equals,
  lerp: lerp,
  lerpV: lerpV,
  max: max,
  min: min,
  mulScalar: mulScalar,
  scale: scale,
  divScalar: divScalar,
  inverse: inverse,
  invert: invert,
  dot: dot,
  length: length,
  len: len,
  lengthSq: lengthSq,
  lenSq: lenSq,
  distance: distance,
  dist: dist,
  distanceSq: distanceSq,
  distSq: distSq,
  normalize: normalize,
  negate: negate,
  copy: copy,
  clone: clone,
  multiply: multiply,
  mul: mul,
  divide: divide,
  div: div,
  zero: zero,
  transformMat4: transformMat4
});

/**
 * Sets the type this library creates for all types
 *
 * example:
 *
 * ```
 * setDefaultType(Float64Array);
 * ```
 *
 * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`
 */
function setDefaultType(ctor) {
  setDefaultType$4(ctor);
  setDefaultType$3(ctor);
  setDefaultType$2(ctor);
  setDefaultType$6(ctor);
  setDefaultType$5(ctor);
  setDefaultType$1(ctor);
}

},{}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.en = void 0;
const en = exports.en = {
  "play": "Play",
  "sendmsg": "Send message",
  "changeTheme": "Theme dark/light",
  "yes": "Yes",
  "no": "No",
  "on": "On",
  "off": "Off",
  "startGame": "🎲Start Game",
  "changeLang": "Change Lang",
  "english": "English",
  "serbian": "Serbian",
  "MAX": "MAX",
  "MIN": "MIN",
  "straight": "Straight",
  "threeOf": "ThreeOf",
  "fullhouse": "FULLH",
  "help": "HELP",
  "roll": "ROLL DICES",
  "settings": "Settings",
  "hand": "Hand",
  "up": "Up |",
  "down": "Down",
  "free": "Free",
  "cornerText": "🎲",
  "poker": "Poker",
  "jamb": "Jamb",
  "final": "Final Σ",
  "hide": "HIDE",
  "sounds": "Sounds",
  "welcomeMsg": "Welcome here, <br> open source project 🎲 Jamb 3d deluxe game <br> download from ",
  "ready": "Ready for play 🎲!",
  "freetoroll": "Free for roll 🎲!",
  "pick5": "Pick best 5 🎲 and choose table field!",
  "hand1": "First hand in play - please wait...",
  "hand2": "Secound hand in play - please wait...",
  "graphics": "Graphics options",
  "choosename": "Choose nickname:",
  "table": "Table",
  "aboutword": "About",
  "about": "<i>Jamb 3d deluxe</i> is a modern 3D dice game built entirely with MatrixEngineWGPU, a high-performance WebGPU-based rendering engine developed for creating interactive graphics directly in the browser. The game delivers smooth visuals, realistic dice physics, and an engaging user experience — all without requiring any plugins or installations. \n This project is powered by open technologies and is designed to be lightweight, fast, and highly customizable. It’s a great example of how WebGPU can be used for real-time interactive content. \n 🔗 Download / Try it: \n github.com/zlatnaspirala/matrix-engine-wgpu \n 🛠 License: \n The core engine and the Jamb 3d deluxe project are released under the GPL v3 license, making them free and open-source for both personal and commercial use — as long as you respect the terms of the license. \n Whether you're a developer, gamer, or enthusiast, Jamb 3d deluxe is a fun way to experience the potential of modern browser-based 3D technology. <img width='320' height='320' src='https://github.com/zlatnaspirala/matrix-engine-wgpu/blob/main/public/res/icons/512.png?raw=true' />",
  "letthegame": "Let the game begin!",
  "leaderboard": "Leaderboard",
  "about_": "About",
  "next": "Next",
  "back": "Back",
  "used": "used",
  "gameplaychannel": "gameplay channel",
  "alreadyingame": "Already in game:",
  "waiting_for_others": "Waiting for others...",
  "titleBan": "✭Ban 🟢🟢🟢",
  "aboutRPG": "Forest Of Hollow Blood Made in MatrixEngineWGPU webGPU engine. Open source part can be found in engine repo <a href='https://github.com/zlatnaspirala/matrix-engine-wgpu'> @zlatnaspirala Github.com </a>. Music by <a href='https://pixabay.com/users/mfcc-28627740/?utm_source=link-attribution&utm_medium=referral&utm_campaign=music&utm_content=274290'>Mykola Sosin</a> from <a href='https://pixabay.com//?utm_source=link-attribution&utm_medium=referral&utm_campaign=music&utm_content=274290'>Pixabay</a> Characters used from great mixamo.com -✅What you can do You can use Mixamo characters and animations royalty-free in commercial, personal, or non‑profit projects (games, films, prints, etc.).You own your creations / how you use them.No requirement to credit Adobe / Mixamo (though allowed). -🚫What you cannot do You cannot redistribute or sell the raw Mixamo character or animation files “as is” (i.e. as standalone assets) to others.You can’t use Mixamo content to create a competing library of characters / animations (i.e. you can’t just package them and sell them to others). You can’t use Mixamo’s content (or outputs) to train AI / machine learning models. Used free assets from great https://craftpix.net Magic icons : https://craftpix.net/freebies/free-rpg-splash-game-512x512-icons/ For background music in rpg template used: Music by Dvir Silverstone from Pixabay Sound Effect by Crunchpix Studio from Pixabay Music by Emmraan from Pixabay . Logo includes the official WebGPU logo. WebGPU logo by W3C Licensed under Creative Commons Attribution 4.0 .   'Ruined rock fence' (https://skfb.ly/6RLwN) by VladNeko is licensed under Creative Commons Attribution (http://creativecommons.org/licenses/by/4.0/).",
  "mariasword": "Maria Sword, the silver blade of the East, strikes with speed and elegance. Her courage burns quietly but never falters.",
  "slayzer": "Slayzer — a dark creation with blades for arms. Silent, swift, and born from shadow.",
  "steelborn": "Steelborn — a small yet fearless warrior clad in shining iron armor, wielding his sword with unshakable resolve.",
  "warrok": "Warrok — a fierce brute forged in battle, wielding raw strength and unbreakable will.",
  "skeletonz": "Skeletonz — a restless warrior of bone and shadow, risen again to fight without fear.",
  "erika": "Erika moves like a shadow: quiet, precise and watchful. She carries one dark arrow — simple, deadly and personal.",
  "arissa": "Arissa hides her power behind calm eyes and empty hands. No blade or staff—only the swirling dark orbs she conjures when the fight begins.",
  "gameplayused": "Forest Of Hollow Blood for now have only one channel for gameplay. Please wait for current party end...",
  "nogold": "Not enough gold!",
  "invertorysecret": "Corona Ignifera magic secret Sol Corona,Flamma Crystal\n  Aqua Sanctum magic secret Mare Pearl,Luna Gemma\n Umbra Silens magic secret Umbra Vellum,Noctis Band\n Terra Fortis magic secret Terra Clavis,Ardent Vine,Silva Heart\n Ventus Aegis magic secret Ventus Pluma,Ignifur Cape\n Ferrum Lux magic secret Ferrum Anulus,Lux Feather\n Sanguis Vita magic secret Sanguis Orb,Vita Flos \n Tenebris Vox magic secret Tenebris Fang,Vox Chime \n Aether Gladius magic secret Gladius Ignis,Aether Scale \n Fulgur Mortis magic secret Fulgur Stone,Mortis Bone \n Corona Umbra magic secret Umbra Silens,Corona Ignifera,Tenebris Vox \n Terra Sanctum magic secret Terra Fortis,Aqua Sanctum \n Aether Fortis magic secret Aether Gladius,Ferrum Lux \n  Vita Mindza magic secret Sanguis Vita,Ventus Aegis \n Mortis Ultima magic secret Fulgur Mortis,Corona Umbra,Aether Fortis"
};

},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = require("./utils");
/**
 * @description
 * Can be reuse for any other tasks.
 * @author Nikola Lukic
 */

class Behavior {
  status = "Only oscillator";
  constructor() {
    this.osc0 = new _utils.OSCILLATOR(0, 5, 0.01);
  }
  setOsc0(min, max, step) {
    this.osc0.min = min;
    this.osc0.max = max;
    this.osc0.step = step;
  }

  // apend - keep init origin
  addPath(NUMBER) {
    let inc = this.osc0.UPDATE();
    console.log('test inc', inc);
    console.log('test inc + number', NUMBER + inc);
    return inc + NUMBER;
  }
  setPath0() {
    return this.osc0.UPDATE();
  }
}
exports.default = Behavior;

},{"./utils":56}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextureCache = void 0;
class TextureCache {
  constructor(device) {
    this.device = device;
    this.cache = new Map(); // path -> Promise<TextureEntry>
  }
  async get(path, format, isEnvMap = false) {
    if (this.cache.has(path)) {
      return this.cache.get(path); // reuse promise
    }
    let promise;
    if (isEnvMap == true) {
      promise = this.#loadEnvMap(path, format);
      this.cache.set(path, promise);
    } else {
      promise = this.#load(path, format);
      this.cache.set(path, promise);
    }
    return promise;
  }
  async loadEnvMap(path) {
    // Use a special cache key for env maps
    const envKey = `env:${path}`;
    if (this.cache.has(envKey)) {
      return this.cache.get(envKey);
    }
    const promise = this.#loadEnvMap(path);
    this.cache.set(envKey, promise);
    return promise;
  }
  async #load(path, format) {
    const response = await fetch(path);
    const blob = await response.blob();
    const imageBitmap = await createImageBitmap(blob);
    const texture = this.device.createTexture({
      size: [imageBitmap.width, imageBitmap.height, 1],
      format,
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    this.device.queue.copyExternalImageToTexture({
      source: imageBitmap
    }, {
      texture
    }, [imageBitmap.width, imageBitmap.height]);
    const sampler = this.device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear',
      addressModeU: "repeat",
      addressModeV: "repeat",
      addressModeW: "repeat"
    });
    return {
      texture,
      sampler
    };
  }
  async #loadEnvMap(path) {
    const response = await fetch(path);
    const blob = await response.blob();
    const imageBitmap = await createImageBitmap(blob);
    const width = imageBitmap.width;
    const height = imageBitmap.height;
    // Calculate mip levels for better quality
    // const mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
    const mipLevelCount = 1;
    const texture = this.device.createTexture({
      label: `EnvMap: ${path}`,
      size: [width, height],
      format: 'rgba16float',
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
      mipLevelCount // ✅ Enable mipmaps for smooth sampling
    });
    this.device.queue.copyExternalImageToTexture({
      source: imageBitmap
    }, {
      texture
    }, [width, height]);

    // TODO: Generate mipmaps here if you have a mipmap generator
    // For now, base level (level 0) will work fine

    // Sampler optimized for environment maps
    const sampler = this.device.createSampler({
      label: 'EnvMap Sampler',
      magFilter: 'linear',
      minFilter: 'linear',
      mipmapFilter: 'linear',
      // ✅ Smooth between mip levels
      addressModeU: 'repeat',
      // ✅ Wrap horizontally (360°)
      addressModeV: 'clamp-to-edge' // ✅ Clamp at poles (top/bottom)
    });
    return {
      texture,
      sampler
    };
  }
}
exports.TextureCache = TextureCache;

},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DestructionEffect = void 0;
var _wgpuMatrix = require("wgpu-matrix");
var _dustShaderWgsl = require("../../shaders/desctruction/dust-shader.wgsl.js");
/**
 * @class DestructionEffect
 * @description Complete destruction effect with particle smoke/dust for MOBA
 * Matches Matrix-Engine-WGPU effect interface (like FlameEffect)
 * 
 * Features:
 * - Particle-based smoke/dust system
 * - GPU instancing for performance
 * - Inherits parent transform via baseModelMatrix
 * - Own pipeline, shares draw pass
 * 
 * @note Based on Matrix-Engine-WGPU architecture
 * but can be isolatted.Effects are standalone sub
 * system in matrix-engine-wgpu.
 */

class DestructionEffect {
  constructor(device, format, config = {}) {
    this.device = device;
    this.format = format;

    // Configuration
    this.particleCount = config.particleCount || 100;
    this.duration = config.duration || 2.5;
    this.spread = config.spread || 5.0;

    // State
    this.time = 0;
    this.enabled = false;
    this.particles = [];

    // Visual properties
    this.color = config.color || [0.6, 0.5, 0.4, 1.0]; // Brownish dust
    this.intensity = 1.0;
    this._initPipeline();
    this._initParticles();
  }
  _initPipeline() {
    // Single quad for billboarded particles
    const S = 1.0; // Base particle size
    const vertexData = new Float32Array([-0.5 * S, 0.5 * S, 0,
    // Top-left
    0.5 * S, 0.5 * S, 0,
    // Top-right
    -0.5 * S, -0.5 * S, 0,
    // Bottom-left
    0.5 * S, -0.5 * S, 0 // Bottom-right
    ]);
    const uvData = new Float32Array([0, 0,
    // Top-left
    1, 0,
    // Top-right
    0, 1,
    // Bottom-left
    1, 1 // Bottom-right
    ]);
    const indexData = new Uint16Array([0, 2, 1, 1, 2, 3]);

    // Vertex buffer (shared quad geometry)
    this.vertexBuffer = this.device.createBuffer({
      size: vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.vertexBuffer, 0, vertexData);

    // UV buffer
    this.uvBuffer = this.device.createBuffer({
      size: uvData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.uvBuffer, 0, uvData);

    // Index buffer
    this.indexBuffer = this.device.createBuffer({
      size: Math.ceil(indexData.byteLength / 4) * 4,
      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.indexBuffer, 0, indexData);
    this.indexCount = indexData.length;

    // Instance buffer (per-particle data: position, velocity, life, size)
    // Format: vec4(pos.xyz, size) + vec4(vel.xyz, life) + vec4(color.rgba)
    const maxParticles = this.particleCount;
    const instanceDataSize = maxParticles * (4 + 4 + 4) * 4; // 3 vec4s per particle

    this.instanceBuffer = this.device.createBuffer({
      size: instanceDataSize,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });

    // Uniform buffers
    this.cameraBuffer = this.device.createBuffer({
      size: 64,
      // mat4x4
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.modelBuffer = this.device.createBuffer({
      size: 64 + 16 + 16,
      // model matrix + time + intensity (padded)
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Bind group layout
    const bindGroupLayout = this.device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      },
      // camera
      {
        binding: 1,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: {}
      } // model + time
      ]
    });
    this.bindGroup = this.device.createBindGroup({
      layout: bindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.cameraBuffer
        }
      }, {
        binding: 1,
        resource: {
          buffer: this.modelBuffer
        }
      }]
    });

    // Shader module
    const shaderModule = this.device.createShaderModule({
      code: _dustShaderWgsl.dustShader
    });
    const pipelineLayout = this.device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });

    // Render pipeline with alpha blending
    this.pipeline = this.device.createRenderPipeline({
      label: 'destruction Pipeline',
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: "vsMain",
        buffers: [
        // Vertex positions (per-vertex, shared quad)
        {
          arrayStride: 3 * 4,
          stepMode: "vertex",
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: "float32x3"
          }]
        },
        // UVs (per-vertex, shared quad)
        {
          arrayStride: 2 * 4,
          stepMode: "vertex",
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: "float32x2"
          }]
        },
        // Instance data (per-particle)
        {
          arrayStride: 12 * 4,
          // 3 vec4s = 12 floats
          stepMode: "instance",
          attributes: [{
            shaderLocation: 2,
            offset: 0,
            format: "float32x4"
          },
          // position + size
          {
            shaderLocation: 3,
            offset: 16,
            format: "float32x4"
          },
          // velocity + life
          {
            shaderLocation: 4,
            offset: 32,
            format: "float32x4"
          } // color
          ]
        }]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fsMain",
        targets: [{
          format: this.format,
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha",
              operation: "add"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha",
              operation: "add"
            }
          }
        }]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: false,
        // Particles don't write depth
        depthCompare: "less",
        format: "depth24plus"
      }
    });
  }
  _initParticles() {
    // Initialize particle data
    for (let i = 0; i < this.particleCount; i++) {
      this.particles.push({
        // Local position offset from parent
        position: [0, 0, 0],
        velocity: [0, 0, 0],
        life: 0,
        maxLife: 0,
        size: 0,
        color: [...this.color]
      });
    }
  }

  /**
   * Trigger the destruction effect
   * Spawns all particles with random velocities
   */
  trigger() {
    this.enabled = true;
    this.time = 0;

    // Spawn particles
    for (let i = 0; i < this.particleCount; i++) {
      const particle = this.particles[i];

      // Random position in small sphere
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = Math.random() * 0.5;
      particle.position = [r * Math.sin(phi) * Math.cos(theta), Math.random() * 1.0,
      // Slightly upward bias
      r * Math.sin(phi) * Math.sin(theta)];

      // Random velocity (explosion pattern)
      const speed = 2.0 + Math.random() * 3.0;
      const vTheta = Math.random() * Math.PI * 2;
      const vPhi = Math.acos(2 * Math.random() - 1);
      particle.velocity = [speed * Math.sin(vPhi) * Math.cos(vTheta), speed * Math.abs(Math.sin(vPhi)) * 2.0,
      // Upward bias
      speed * Math.sin(vPhi) * Math.sin(vTheta)];

      // Random lifetime
      particle.maxLife = 1.0 + Math.random() * 1.5;
      particle.life = particle.maxLife;

      // Random size
      particle.size = 0.5 + Math.random() * 1.5;

      // Color with slight variation
      particle.color = [this.color[0] + (Math.random() - 0.5) * 0.2, this.color[1] + (Math.random() - 0.5) * 0.2, this.color[2] + (Math.random() - 0.5) * 0.2, 1.0];
    }
  }

  /**
   * Update particle simulation
   */
  update(dt) {
    if (!this.enabled) return;
    this.time += dt;
    let aliveCount = 0;

    // Update each particle
    for (let i = 0; i < this.particleCount; i++) {
      const p = this.particles[i];
      if (p.life <= 0) continue;

      // Physics update
      p.velocity[1] -= 2.0 * dt; // Gravity

      // Damping (air resistance)
      p.velocity[0] *= 0.98;
      p.velocity[1] *= 0.98;
      p.velocity[2] *= 0.98;

      // Position update
      p.position[0] += p.velocity[0] * dt;
      p.position[1] += p.velocity[1] * dt;
      p.position[2] += p.velocity[2] * dt;

      // Life update
      p.life -= dt;

      // Fade out
      const lifeRatio = p.life / p.maxLife;
      p.color[3] = lifeRatio * this.intensity;

      // Size grows over time (smoke expansion)
      p.size = (0.5 + Math.random() * 1.5) * (1.0 + (1.0 - lifeRatio) * 2.0);
      aliveCount++;
    }

    // Disable if all particles dead
    if (aliveCount === 0 && this.time > this.duration) {
      this.enabled = false;
    }

    // Update instance buffer
    this._updateInstanceBuffer();
  }
  _updateInstanceBuffer() {
    // Pack particle data into instance buffer
    const instanceData = new Float32Array(this.particleCount * 12);
    for (let i = 0; i < this.particleCount; i++) {
      const p = this.particles[i];
      const offset = i * 12;

      // vec4: position + size
      instanceData[offset + 0] = p.position[0];
      instanceData[offset + 1] = p.position[1];
      instanceData[offset + 2] = p.position[2];
      instanceData[offset + 3] = p.size;

      // vec4: velocity + life
      instanceData[offset + 4] = p.velocity[0];
      instanceData[offset + 5] = p.velocity[1];
      instanceData[offset + 6] = p.velocity[2];
      instanceData[offset + 7] = p.life;

      // vec4: color
      instanceData[offset + 8] = p.color[0];
      instanceData[offset + 9] = p.color[1];
      instanceData[offset + 10] = p.color[2];
      instanceData[offset + 11] = p.color[3];
    }
    this.device.queue.writeBuffer(this.instanceBuffer, 0, instanceData);
  }

  /**
   * Update instance data with parent transform
   * Called by parent object before rendering
   */
  updateInstanceData(baseModelMatrix) {
    const local = _wgpuMatrix.mat4.identity();

    // Local offset (if needed)
    // mat4.translate(local, [0, 2, 0], local); // Offset upward slightly

    // Multiply with baseModelMatrix to inherit world transform
    const finalMat = _wgpuMatrix.mat4.identity();
    _wgpuMatrix.mat4.multiply(baseModelMatrix, local, finalMat);

    // Update GPU buffer
    const timeBuffer = new Float32Array([this.time]);
    const intensityBuffer = new Float32Array([this.intensity]);
    this.device.queue.writeBuffer(this.modelBuffer, 0, finalMat);
    this.device.queue.writeBuffer(this.modelBuffer, 64, timeBuffer);
    this.device.queue.writeBuffer(this.modelBuffer, 80, intensityBuffer);
  }

  /**
   * Draw particles
   */
  draw(pass, cameraMatrix) {
    if (!this.enabled) return;
    this.device.queue.writeBuffer(this.cameraBuffer, 0, cameraMatrix);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setVertexBuffer(1, this.uvBuffer);
    pass.setVertexBuffer(2, this.instanceBuffer);
    pass.setIndexBuffer(this.indexBuffer, "uint16");

    // Draw instanced (one quad per particle)
    pass.drawIndexed(this.indexCount, this.particleCount);
  }

  /**
   * Main render method (called by parent)
   */
  render(pass, mesh, viewProjMatrix, dt = 0.016) {
    if (!this.enabled) return;
    this.update(dt);
    this.draw(pass, viewProjMatrix);
  }

  /**
   * Set effect intensity
   */
  setIntensity(v) {
    this.intensity = v;
  }

  /**
   * Check if effect is still active
   */
  isActive() {
    return this.enabled;
  }

  /**
   * Reset effect
   */
  reset() {
    this.enabled = false;
    this.time = 0;
    for (let p of this.particles) {
      p.life = 0;
    }
  }
}
exports.DestructionEffect = DestructionEffect;

},{"../../shaders/desctruction/dust-shader.wgsl.js":59,"wgpu-matrix":22}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HPBarEffect = void 0;
var _wgpuMatrix = require("wgpu-matrix");
var _energyBarShader = require("../../shaders/energy-bars/energy-bar-shader.js");
class HPBarEffect {
  constructor(device, format) {
    this.device = device;
    this.format = format;
    this.progress = 1.0;
    this.color = [0.1, 0.9, 0.1, 1.0];
    this.offsetY = 48;
    this.enabled = true;
    this._initPipeline();
  }
  _initPipeline() {
    // Simple flat bar (width 100, height 10)
    const W = 40;
    const H = 3;
    const vertexData = new Float32Array([-0.5 * W, 0.5 * H, 0.0, 0.5 * W, 0.5 * H, 0.0, -0.5 * W, -0.5 * H, 0.0, 0.5 * W, -0.5 * H, 0.0]);
    const uvData = new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]);
    const indexData = new Uint16Array([0, 2, 1, 1, 2, 3]);

    // Buffers
    this.vertexBuffer = this.device.createBuffer({
      size: vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.vertexBuffer, 0, vertexData);
    this.uvBuffer = this.device.createBuffer({
      size: uvData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.uvBuffer, 0, uvData);
    this.indexBuffer = this.device.createBuffer({
      size: Math.ceil(indexData.byteLength / 4) * 4,
      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.indexBuffer, 0, indexData);
    this.indexCount = indexData.length;

    // Uniforms
    this.cameraBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // model + color + progress (64 + 16 + 4)
    this.modelBuffer = this.device.createBuffer({
      size: 64 + 16 + 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // BindGroup
    const bindGroupLayout = this.device.createBindGroupLayout({
      label: 'energy-bar bindGroupLayout',
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }, {
        binding: 1,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: {}
      }]
    });
    this.bindGroup = this.device.createBindGroup({
      label: 'energy-bar bindGroup',
      layout: bindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.cameraBuffer
        }
      }, {
        binding: 1,
        resource: {
          buffer: this.modelBuffer
        }
      }]
    });

    // Pipeline
    const shaderModule = this.device.createShaderModule({
      code: _energyBarShader.hpBarEffectShaders
    });
    const pipelineLayout = this.device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    this.pipeline = this.device.createRenderPipeline({
      label: 'energy-bar pipeline',
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: 'vsMain',
        buffers: [{
          arrayStride: 3 * 4,
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: 'float32x3'
          }]
        }, {
          arrayStride: 2 * 4,
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: 'float32x2'
          }]
        }]
      },
      fragment: {
        module: shaderModule,
        entryPoint: 'fsMain',
        targets: [{
          format: this.format
        }]
      },
      primitive: {
        topology: 'triangle-list'
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: 'always',
        format: 'depth24plus'
      }
    });
  }
  setProgress(value) {
    this.progress = Math.max(0.0, Math.min(1.0, value));
  }
  setColor(r, g, b, a = 1.0) {
    this.color = [r, g, b, a];
  }
  draw(pass, cameraMatrix, modelMatrix) {
    const color = new Float32Array(this.color);
    const progressData = new Float32Array([this.progress]);

    // Pack uniforms manually
    const buffer = new ArrayBuffer(64 + 16 + 4);
    const f32 = new Float32Array(buffer);
    f32.set(cameraMatrix, 0); // not needed here
    this.device.queue.writeBuffer(this.cameraBuffer, 0, cameraMatrix);
    this.device.queue.writeBuffer(this.modelBuffer, 0, modelMatrix);
    this.device.queue.writeBuffer(this.modelBuffer, 64, color);
    this.device.queue.writeBuffer(this.modelBuffer, 64 + 16, progressData);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setVertexBuffer(1, this.uvBuffer);
    pass.setIndexBuffer(this.indexBuffer, 'uint16');
    pass.drawIndexed(this.indexCount);
  }
  render(pass, mesh, viewProjMatrix) {
    const pos = mesh.position;
    const modelMatrix = _wgpuMatrix.mat4.identity();
    _wgpuMatrix.mat4.translate(modelMatrix, [pos.x, pos.y + this.offsetY, pos.z], modelMatrix);
    this.draw(pass, viewProjMatrix, modelMatrix);
  }
}
exports.HPBarEffect = HPBarEffect;

},{"../../shaders/energy-bars/energy-bar-shader.js":60,"wgpu-matrix":22}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlameEmitter = void 0;
var _wgpuMatrix = require("wgpu-matrix");
var _flameInstanced = require("../../shaders/flame-effect/flame-instanced");
var _utils = require("../utils");
/**
 * @description
 * FlameEmitter
 */
class FlameEmitter {
  constructor(device, format, maxParticles = 20) {
    this.device = device;
    this.format = format;
    this.time = 0;
    this.intensity = 1.0;
    this.enabled = true;
    this.maxParticles = maxParticles;
    this.instanceTargets = [];
    this.floatsPerInstance = 28;
    this.instanceData = new Float32Array(maxParticles * this.floatsPerInstance);
    this.smoothFlickeringScale = 0.1;
    this.minBound = 0;
    this.maxBound = 1.9;
    this.swap0 = 0;
    this.swap1 = 1;
    this.swap2 = 2;
    this.riseDirection = 1;
    this.baseRotation = [0, 0, 0];
    this.scaleCoeficient = 0.12;
    for (let i = 0; i < maxParticles; i++) {
      this.instanceTargets.push({
        position: [0, 0, 0],
        currentPosition: [0, 0, 0],
        scale: [1, 1, 1],
        currentScale: [1, 1, 1],
        rotation: 0.1,
        color: [1, 0.3, 0, 0.1],
        time: 1,
        intensity: 1,
        riseSpeed: 1
      });
    }
    this._initPipeline();
  }
  recreateVertexData(S) {
    const vertexData = new Float32Array([-0.4 * S, 0.5 * S, 0.0 * S, 0.4 * S, 0.5 * S, 0.0 * S, -0.2 * S, -0.5 * S, 0.0 * S, 0.2 * S, -0.5 * S, 0.0 * S]);
    this.device.queue.writeBuffer(this.vertexBuffer, 0, vertexData);
  }
  recreateVertexDataRND(S) {
    const vertexData = new Float32Array([-(0, _utils.randomFloatFromTo)(0.1, 0.8) * S, (0, _utils.randomFloatFromTo)(0.4, 0.6) * S, 0.0 * S, (0, _utils.randomFloatFromTo)(0.1, 0.8) * S, (0, _utils.randomFloatFromTo)(0.4, 0.6) * S, 0.0 * S, -(0, _utils.randomFloatFromTo)(0.1, 0.4) * S, -(0, _utils.randomFloatFromTo)(0.4, 0.6) * S, 0.0 * S, (0, _utils.randomFloatFromTo)(0.1, 0.4) * S, -(0, _utils.randomFloatFromTo)(0.4, 0.6) * S, 0.0 * S]);
    if (this.vertexBuffer) this.device.queue.writeBuffer(this.vertexBuffer, 0, vertexData);
    return vertexData;
  }

  // not tested
  recreateVertexDataCrazzy(S) {
    const vertexData = new Float32Array([-(0, _utils.randomFloatFromTo)(0.1, 0.1 + S), (0, _utils.randomFloatFromTo)(0.4, 0.4 + S), 0.0, (0, _utils.randomFloatFromTo)(0.1, 0.1 + S), (0, _utils.randomFloatFromTo)(0.4, 0.4 + S), 0.0, -(0, _utils.randomFloatFromTo)(0.1, 0.1 + S), -(0, _utils.randomFloatFromTo)(0.4, 0.4 + S), 0.0, (0, _utils.randomFloatFromTo)(0.1, 0.1 + S), -(0, _utils.randomFloatFromTo)(0.4, 0.4 + S), 0.0]);
    if (this.vertexBuffer) this.device.queue.writeBuffer(this.vertexBuffer, 0, vertexData);
    return vertexData;
  }
  _initPipeline() {
    const S = 2;
    const vertexData = this.recreateVertexDataRND(1);
    const uvData = new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]);
    const indexData = new Uint16Array([0, 2, 1, 1, 2, 3]);
    this.vertexBuffer = this.device.createBuffer({
      size: vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.vertexBuffer, 0, vertexData);
    this.uvBuffer = this.device.createBuffer({
      size: uvData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.uvBuffer, 0, uvData);
    this.indexBuffer = this.device.createBuffer({
      size: Math.ceil(indexData.byteLength / 4) * 4,
      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.indexBuffer, 0, indexData);
    this.indexCount = indexData.length;
    this.cameraBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.modelBuffer = this.device.createBuffer({
      label: 'flame-emmiter modeBuffer',
      size: this.maxParticles * this.floatsPerInstance * 4,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    const bindGroupLayout = this.device.createBindGroupLayout({
      label: 'flame-emmiter bindGroupLayout',
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }, {
        binding: 1,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: {
          type: "read-only-storage"
        }
      }]
    });
    this.bindGroup = this.device.createBindGroup({
      label: 'flame-emmiter bindGroup',
      layout: bindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.cameraBuffer
        }
      }, {
        binding: 1,
        resource: {
          buffer: this.modelBuffer
        }
      }]
    });
    const shaderModule = this.device.createShaderModule({
      code: _flameInstanced.flameEffectInstance
    });
    const pipelineLayout = this.device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    this.pipeline = this.device.createRenderPipeline({
      label: 'flame-emmiter pipeline',
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: "vsMain",
        buffers: [{
          arrayStride: 3 * 4,
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: "float32x3"
          }]
        }, {
          arrayStride: 2 * 4,
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: "float32x2"
          }]
        }]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fsMain",
        targets: [{
          format: this.format,
          blend: {
            color: {
              srcFactor: 'src-alpha',
              dstFactor: 'one',
              operation: 'add'
            },
            alpha: {
              srcFactor: 'one',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add'
            }
          }
        }]
      },
      primitive: {
        topology: "triangle-list"
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: "less",
        format: "depth24plus"
      }
    });
  }
  updateInstanceData = baseModelMatrix => {
    const count = Math.min(this.instanceTargets.length, this.maxParticles);
    const floatsPerInstance = 28; // 112 bytes / 4
    for (let i = 0; i < count; i++) {
      const t = this.instanceTargets[i];
      for (let j = 0; j < 3; j++) {
        t.currentPosition[j] += (t.position[j] - t.currentPosition[j]) * this.scaleCoeficient;
      }
      const local = _wgpuMatrix.mat4.identity();
      _wgpuMatrix.mat4.translate(local, t.currentPosition, local);
      _wgpuMatrix.mat4.rotateY(local, t.rotation, local);
      _wgpuMatrix.mat4.scale(local, t.currentScale, local);
      const finalMat = _wgpuMatrix.mat4.identity();
      _wgpuMatrix.mat4.multiply(baseModelMatrix, local, finalMat);
      const offset = i * floatsPerInstance;
      this.instanceData.set(finalMat, offset);
      this.instanceData.set([t.time, t.speed ?? 1.0, 0, 0], offset + 16);
      this.instanceData.set([(t.intensity ?? 1.0) * this.intensity, t.turbulence ?? 0.5, t.stretch ?? 1.0, 0], offset + 20);
      this.instanceData.set([t.color[0], t.color[1], t.color[2], t.tintStrength ?? 0.0], offset + 24);
    }
    this.device.queue.writeBuffer(this.modelBuffer, 0, this.instanceData.subarray(0, count * floatsPerInstance));
  };
  render(pass, mesh, viewProjMatrix, dt = 0.1) {
    this.time += dt;
    for (const p of this.instanceTargets) {
      p.position[this.swap1] += dt * p.riseSpeed * this.riseDirection;
      // Reset check
      const resetCondition = this.riseDirection > 0 ? p.position[this.swap1] > this.maxBound : p.position[this.swap1] < this.minBound;
      if (resetCondition) {
        p.position[this.swap1] = this.riseDirection > 0 ? this.minBound + Math.random() * 0.5 : this.maxBound - Math.random() * 0.5;
        p.position[this.swap0] = (Math.random() - 0.5) * 0.2;
        p.position[this.swap2] = (Math.random() - 0.5) * 0.2;
        p.riseSpeed = 0.2 + Math.random() * 1.0;
      }
      p.scale[0] = p.scale[1] = this.smoothFlickeringScale + Math.sin(this.time * 2.0 + p.position[this.swap1]) * 0.1;
      p.rotation += dt * (0, _utils.randomIntFromTo)(1, 4);
    }
    this.device.queue.writeBuffer(this.cameraBuffer, 0, viewProjMatrix);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setVertexBuffer(1, this.uvBuffer);
    pass.setIndexBuffer(this.indexBuffer, "uint16");
    pass.drawIndexed(this.indexCount, this.instanceTargets.length);
  }
  setIntensity(v) {
    this.intensity = v;
  }
  setDirection(direction) {
    this.riseDirection = 1;
    this.baseRotation = [0, 0, 0]; // Reset
    switch (direction) {
      case 'up':
        this.swap0 = 0;
        this.swap1 = 1;
        this.swap2 = 2;
        break;
      case 'down':
        this.swap0 = 0;
        this.swap1 = 1;
        this.swap2 = 2;
        this.riseDirection = -1;
        break;
      case 'forward':
        this.swap0 = 0;
        this.swap1 = 2;
        this.swap2 = 1;
        this.baseRotation = [Math.PI / 2, 0, 0];
        break;
      case 'back':
        this.swap0 = 0;
        this.swap1 = 2;
        this.swap2 = 1;
        this.riseDirection = -1;
        this.baseRotation = [-Math.PI / 2, 0, 0]; // Tilt -90 on X
        break;
      case 'right':
        this.swap0 = 1;
        this.swap1 = 0;
        this.swap2 = 2;
        this.baseRotation = [0, 0, -Math.PI / 2]; // Tilt -90 on Z
        break;
      case 'left':
        this.swap0 = 1;
        this.swap1 = 0;
        this.swap2 = 2;
        this.riseDirection = -1;
        this.baseRotation = [0, 0, Math.PI / 2]; // Tilt 90 on Z
        break;
    }
  }
}
exports.FlameEmitter = FlameEmitter;

},{"../../shaders/flame-effect/flame-instanced":61,"../utils":56,"wgpu-matrix":22}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlamePresets = exports.FlameEffect = void 0;
var _wgpuMatrix = require("wgpu-matrix");
var _flameEffect = require("../../shaders/flame-effect/flameEffect");
var _geometryFactory = require("../geometry-factory");
const FlamePresets = exports.FlamePresets = {
  // Natural campfire / torch
  natural: {
    intensity: 12.0,
    speed: 1.0,
    turbulence: 0.5,
    stretch: 1.0,
    tint: [1.0, 1.0, 1.0],
    tintStrength: 0.0,
    scale: 2,
    localOffset: [0, 0, 0],
    localRotation: [0, 0, 0],
    activeRotate: [0, 0, 0]
  },
  // Tall torch / pillar of fire
  torch: {
    intensity: 14.0,
    speed: 1.2,
    turbulence: 0.35,
    stretch: 2.0,
    tint: [1.0, 1.0, 1.0],
    tintStrength: 0.0,
    scale: 2,
    localOffset: [0, 0, 0],
    localRotation: [0, 0, 0],
    activeRotate: [0, 0, 0]
  },
  // Wide, low bonfire
  bonfire: {
    intensity: 10.0,
    speed: 0.8,
    turbulence: 0.9,
    stretch: 0.5,
    tint: [1.0, 1.0, 1.0],
    tintStrength: 0.0,
    scale: 2,
    localOffset: [0, 0, 0],
    localRotation: [0, 0, 0],
    activeRotate: [0, 0, 0]
  },
  // Magical blue flame
  magic: {
    intensity: 8.0,
    speed: 1.4,
    turbulence: 0.6,
    stretch: 1.3,
    tint: [0.1, 0.4, 1.0],
    tintStrength: 0.85,
    scale: 2,
    localOffset: [0, 0, 0],
    localRotation: [0, 0, 0],
    activeRotate: [0, 0, 0]
  },
  // Hellfire — dark purple/red
  hell: {
    intensity: 16.0,
    speed: 0.9,
    turbulence: 0.8,
    stretch: 1.6,
    tint: [0.6, 0.0, 0.8],
    tintStrength: 0.7,
    scale: 2,
    localOffset: [0, 0, 0],
    localRotation: [0, 0, 0],
    activeRotate: [0, 0, 0]
  },
  // Poison green
  poison: {
    intensity: 9.0,
    speed: 1.1,
    turbulence: 0.7,
    stretch: 1.1,
    tint: [0.1, 1.0, 0.15],
    tintStrength: 0.9,
    scale: 2,
    localOffset: [0, 0, 0],
    localRotation: [0, 0, 0],
    activeRotate: [0, 0, 0]
  }
};

// FlameEffect
class FlameEffect {
  constructor(device, format, colorFormat, params = {}) {
    this.device = device;
    this.format = format;
    this.colorFormat = colorFormat ?? format;
    const config = typeof params === 'string' ? FlamePresets[params] : params;
    const defaults = FlamePresets.natural;
    this.intensity = config.intensity ?? defaults.intensity;
    this.speed = config.speed ?? defaults.speed;
    this.turbulence = config.turbulence ?? defaults.turbulence;
    this.stretch = config.stretch ?? defaults.stretch;
    this.tint = config.tint ?? defaults.tint;
    this.tintStrength = config.tintStrength ?? defaults.tintStrength;
    this.scale = config.scale ?? defaults.scale;
    this.time = 0;
    this.enabled = true;
    this.localOffset = config.localOffset ?? defaults.localOffset;
    this.localRotation = config.localRotation ?? defaults.localRotation;
    this.activeRotate = config.activeRotate ?? defaults.activeRotate;
    this._initPipeline();
    this.setGeometry("quad", this.scale);
  }
  setGeometry(type, size = 1, segments = 32) {
    const geo = _geometryFactory.GeometryFactory.create(type, size, segments);
    this.vertexBuffer = this._uploadVertex(geo.positions);
    this.uvBuffer = this._uploadVertex(geo.uvs);
    const byteLen = geo.indices.byteLength;
    const paddedByteLen = Math.ceil(byteLen / 4) * 4;
    this.indexBuffer = this.device.createBuffer({
      size: paddedByteLen,
      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
    });
    if (byteLen % 4 !== 0) {
      const paddedData = new Uint8Array(paddedByteLen);
      paddedData.set(new Uint8Array(geo.indices.buffer, geo.indices.byteOffset, byteLen));
      this.device.queue.writeBuffer(this.indexBuffer, 0, paddedData);
    } else {
      this.device.queue.writeBuffer(this.indexBuffer, 0, geo.indices);
    }
    this.indexCount = geo.indices.length;
    this.indexFormat = geo.indices instanceof Uint16Array ? "uint16" : "uint32";
  }
  _initPipeline() {
    this.cameraBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.modelBuffer = this.device.createBuffer({
      size: 112,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    const bindGroupLayout = this.device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {
          type: "uniform"
        }
      }, {
        binding: 1,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      }]
    });
    this.bindGroup = this.device.createBindGroup({
      layout: bindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.cameraBuffer
        }
      }, {
        binding: 1,
        resource: {
          buffer: this.modelBuffer
        }
      }]
    });
    const shaderModule = this.device.createShaderModule({
      code: _flameEffect.flameEffect
    });
    this.pipeline = this.device.createRenderPipeline({
      layout: this.device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
      }),
      vertex: {
        module: shaderModule,
        entryPoint: "vsMain",
        buffers: [{
          arrayStride: 12,
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: "float32x3"
          }]
        }, {
          arrayStride: 8,
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: "float32x2"
          }]
        }]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fsMain",
        targets: [{
          format: this.colorFormat,
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one",
              operation: "add"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha",
              operation: "add"
            }
          }
        }]
      },
      primitive: {
        topology: "triangle-list"
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: "less",
        format: "depth24plus"
      }
    });
  }
  async morphTo(type, size = 40, duration = 200) {
    const originalIntensity = this.intensity;
    const steps = 10;
    const stepTime = duration / (steps * 2);
    for (let i = 0; i < steps; i++) {
      this.intensity *= 0.5;
      await new Promise(r => setTimeout(r, stepTime));
    }
    this.setGeometry(type, size);
    for (let i = 0; i < steps; i++) {
      this.intensity = originalIntensity * (i / steps);
      await new Promise(r => setTimeout(r, stepTime));
    }
    this.intensity = originalIntensity;
  }
  _uploadVertex(data) {
    const buf = this.device.createBuffer({
      size: data.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(buf, 0, data);
    return buf;
  }
  updateInstanceData(baseModelMatrix) {
    const local = _wgpuMatrix.mat4.identity();
    _wgpuMatrix.mat4.translate(local, this.localOffset, local);
    _wgpuMatrix.mat4.rotateX(local, this.localRotation[0], local);
    _wgpuMatrix.mat4.rotateY(local, this.localRotation[1], local);
    _wgpuMatrix.mat4.rotateZ(local, this.localRotation[2], local);
    if (this.activeRotate[0] !== 0) {
      _wgpuMatrix.mat4.rotateX(local, this.activeRotate[0] * this.time, local);
    }
    if (this.activeRotate[1] !== 0) {
      _wgpuMatrix.mat4.rotateY(local, this.activeRotate[1] * this.time, local);
    }
    if (this.activeRotate[2] !== 0) {
      _wgpuMatrix.mat4.rotateZ(local, this.activeRotate[2] * this.time, local);
    }
    const finalMat = _wgpuMatrix.mat4.identity();
    _wgpuMatrix.mat4.multiply(baseModelMatrix, local, finalMat);
    const timeSpeed = new Float32Array([this.time, this.speed, 0, 0]);
    const params = new Float32Array([this.intensity, this.turbulence, this.stretch, 0]);
    const tint = new Float32Array([...this.tint, this.tintStrength]);
    this.device.queue.writeBuffer(this.modelBuffer, 0, finalMat);
    this.device.queue.writeBuffer(this.modelBuffer, 64, timeSpeed);
    this.device.queue.writeBuffer(this.modelBuffer, 80, params);
    this.device.queue.writeBuffer(this.modelBuffer, 96, tint);
  }
  draw(pass, cameraMatrix) {
    this.device.queue.writeBuffer(this.cameraBuffer, 0, cameraMatrix);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setVertexBuffer(1, this.uvBuffer);
    pass.setIndexBuffer(this.indexBuffer, this.indexFormat);
    pass.drawIndexed(this.indexCount);
  }
  // Interface for effect -> (pass, mesh, viewProj)
  render(pass, mesh, viewProjMatrix) {
    this.time += 0.016;
    this.draw(pass, viewProjMatrix);
  }
}
exports.FlameEffect = FlameEffect;

},{"../../shaders/flame-effect/flameEffect":62,"../geometry-factory":39,"wgpu-matrix":22}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenGeoTexture = void 0;
var _geoTex = require("../../shaders/standalone/geo.tex.js");
var _geometryFactory = require("../geometry-factory.js");
var _wgpuMatrix = require("wgpu-matrix");
class GenGeoTexture {
  constructor(device, format, type = "sphere", path, scale = 1) {
    this.device = device;
    this.format = format;
    const geom = _geometryFactory.GeometryFactory.create(type, scale);
    this.vertexData = geom.positions;
    this.uvData = geom.uvs;
    this.indexData = geom.indices;
    this.enabled = true;
    this.rotateEffect = true;
    this.rotateEffectSpeed = 10;
    this.rotateAngle = 0;
    this.loadTexture(path).then(() => {
      this._initPipeline();
    });
  }
  async loadTexture(url) {
    return new Promise(async (resolve, reject) => {
      const img = await fetch(url).then(r => r.blob()).then(createImageBitmap);
      const texture = this.device.createTexture({
        size: [img.width, img.height, 1],
        format: "rgba8unorm",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
      });
      this.device.queue.copyExternalImageToTexture({
        source: img
      }, {
        texture
      }, [img.width, img.height]);
      const sampler = this.device.createSampler({
        magFilter: "linear",
        minFilter: "linear",
        addressModeU: "repeat",
        addressModeV: "repeat"
      });
      this.texture = texture;
      this.sampler = sampler;
      resolve();
    });
  }
  _initPipeline() {
    const {
      vertexData,
      uvData,
      indexData
    } = this;
    // GPU buffers
    this.vertexBuffer = this.device.createBuffer({
      size: vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.vertexBuffer, 0, vertexData);
    this.uvBuffer = this.device.createBuffer({
      size: uvData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.uvBuffer, 0, uvData);
    this.indexBuffer = this.device.createBuffer({
      size: Math.ceil(indexData.byteLength / 4) * 4,
      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.indexBuffer, 0, indexData);
    this.indexCount = indexData.length;
    this.cameraBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.instanceTargets = [];
    this.lerpSpeed = 0.05;
    this.maxInstances = 5;
    this.instanceCount = 2;
    this.floatsPerInstance = 16 + 4;
    for (let x = 0; x < this.maxInstances; x++) {
      this.instanceTargets.push({
        index: x,
        position: [0, 0, 0],
        currentPosition: [0, 0, 0],
        scale: [1, 1, 1],
        currentScale: [1, 1, 1],
        color: [0.6, 0.8, 1.0, 0.4]
      });
    }
    this.instanceData = new Float32Array(this.instanceCount * this.floatsPerInstance);
    this.modelBuffer = this.device.createBuffer({
      size: this.instanceData.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    const bindGroupLayout = this.device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }, {
        binding: 1,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: {
          type: "read-only-storage"
        }
      }, {
        binding: 2,
        visibility: GPUShaderStage.FRAGMENT,
        sampler: {}
      }, {
        binding: 3,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {}
      }]
    });
    this.bindGroup = this.device.createBindGroup({
      layout: bindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.cameraBuffer
        }
      }, {
        binding: 1,
        resource: {
          buffer: this.modelBuffer
        }
      }, {
        binding: 2,
        resource: this.sampler
      }, {
        binding: 3,
        resource: this.texture.createView()
      }]
    });
    const shaderModule = this.device.createShaderModule({
      code: _geoTex.geoInstancedTexEffect
    });
    const pipelineLayout = this.device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    this.pipeline = this.device.createRenderPipeline({
      label: 'gen-geo-tex pipeline',
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: 'vsMain',
        buffers: [{
          arrayStride: 3 * 4,
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: 'float32x3'
          }]
        }, {
          arrayStride: 2 * 4,
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: 'float32x2'
          }]
        }]
      },
      fragment: {
        module: shaderModule,
        entryPoint: 'fsMain',
        targets: [{
          format: this.format,
          blend: {
            color: {
              srcFactor: 'src-alpha',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add'
            },
            alpha: {
              srcFactor: 'one',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add'
            }
          }
        }]
      },
      primitive: {
        topology: 'triangle-list'
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: 'less-equal',
        format: 'depth24plus'
      }
    });
  }
  updateInstanceData = baseModelMatrix => {
    if (this.rotateEffect) {
      this.rotateAngle = (this.rotateAngle ?? 0) + this.rotateEffectSpeed; // accumulate rotation
      if (this.rotateAngle >= 360) {
        this.rotateAngle = 0;
      }
    }
    const count = Math.min(this.instanceCount, this.maxInstances);
    for (let i = 0; i < count; i++) {
      const t = this.instanceTargets[i];
      // smooth interpolation of position & scale
      for (let j = 0; j < 3; j++) {
        t.currentPosition[j] += (t.position[j] - t.currentPosition[j]) * this.lerpSpeed;
        t.currentScale[j] += (t.scale[j] - t.currentScale[j]) * this.lerpSpeed;
      }
      const local = _wgpuMatrix.mat4.identity();
      if (this.rotateEffect == true) {
        _wgpuMatrix.mat4.rotateY(local, this.rotateAngle, local);
      }
      _wgpuMatrix.mat4.translate(local, t.currentPosition, local);
      _wgpuMatrix.mat4.scale(local, t.currentScale, local);
      const finalMat = _wgpuMatrix.mat4.identity();
      _wgpuMatrix.mat4.multiply(baseModelMatrix, local, finalMat);
      const offset = i * this.floatsPerInstance;
      this.instanceData.set(finalMat, offset);
      this.instanceData.set(t.color, offset + 16);
    }
    // IMPORTANT: upload ONLY the active range of floats to GPU to avoid leftover instances
    const activeFloatCount = count * this.floatsPerInstance;
    const activeBytes = activeFloatCount * 4;
    this.device.queue.writeBuffer(this.modelBuffer, 0, this.instanceData.subarray(0, activeFloatCount));
  };
  draw(pass, cameraMatrix) {
    this.device.queue.writeBuffer(this.cameraBuffer, 0, cameraMatrix);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setVertexBuffer(1, this.uvBuffer);
    pass.setIndexBuffer(this.indexBuffer, 'uint16');
    pass.drawIndexed(this.indexCount, this.instanceCount);
  }
  render(transPass, mesh, viewProjMatrix) {
    this.draw(transPass, viewProjMatrix);
  }
}
exports.GenGeoTexture = GenGeoTexture;

},{"../../shaders/standalone/geo.tex.js":77,"../geometry-factory.js":39,"wgpu-matrix":22}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenGeoTexture2 = void 0;
var _geoTex = require("../../shaders/standalone/geo.tex.js");
var _geometryFactory = require("../geometry-factory.js");
var _wgpuMatrix = require("wgpu-matrix");
class GenGeoTexture2 {
  constructor(device, format, type = "sphere", path, scale = 1) {
    this.device = device;
    this.format = format;
    const geom = _geometryFactory.GeometryFactory.create(type, scale);
    this.vertexData = geom.positions;
    this.uvData = geom.uvs;
    this.indexData = geom.indices;
    this.enabled = true;
    this.rotateEffect = true;
    this.rotateEffectSpeed = 10;
    this.rotateAngle = 0;
    this.loadTexture(path).then(() => {
      this._initPipeline();
    });
  }
  async loadTexture(url) {
    return new Promise(async (resolve, reject) => {
      const img = await fetch(url).then(r => r.blob()).then(createImageBitmap);
      const texture = this.device.createTexture({
        size: [img.width, img.height, 1],
        format: 'rgba16float',
        // "rgba8unorm",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
      });
      this.device.queue.copyExternalImageToTexture({
        source: img
      }, {
        texture
      }, [img.width, img.height]);
      const sampler = this.device.createSampler({
        magFilter: "linear",
        minFilter: "linear",
        addressModeU: "repeat",
        addressModeV: "repeat"
      });
      this.texture = texture;
      this.sampler = sampler;
      resolve();
    });
  }
  _initPipeline() {
    const {
      vertexData,
      uvData,
      indexData
    } = this;

    // --- POSITION BUFFER (aligned)
    this.vertexBuffer = this.device.createBuffer({
      size: Math.ceil(vertexData.byteLength / 4) * 4,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.vertexBuffer, 0, vertexData);

    // --- UV BUFFER (aligned)
    this.uvBuffer = this.device.createBuffer({
      size: Math.ceil(uvData.byteLength / 4) * 4,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.uvBuffer, 0, uvData);

    // --- INDEX BUFFER (aligned)
    const alignedIndexSize = Math.ceil(indexData.byteLength / 4) * 4;
    this.indexBuffer = this.device.createBuffer({
      size: alignedIndexSize,
      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
    });

    // Create a temporary padded buffer if necessary
    if (indexData.byteLength !== alignedIndexSize) {
      const tmp = new Uint8Array(alignedIndexSize);
      tmp.set(new Uint8Array(indexData.buffer));
      this.device.queue.writeBuffer(this.indexBuffer, 0, tmp);
    } else {
      this.device.queue.writeBuffer(this.indexBuffer, 0, indexData);
    }
    this.indexCount = indexData.length;

    // --- rest of your setup (no change)
    this.cameraBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.instanceTargets = [];
    this.lerpSpeed = 0.05;
    this.maxInstances = 5;
    this.instanceCount = 2;
    this.floatsPerInstance = 16 + 4;
    for (let x = 0; x < this.maxInstances; x++) {
      this.instanceTargets.push({
        index: x,
        position: [0, 0, 0],
        currentPosition: [0, 0, 0],
        scale: [1, 1, 1],
        currentScale: [1, 1, 1],
        color: [0.6, 0.8, 1.0, 0.4]
      });
    }
    this.instanceData = new Float32Array(this.instanceCount * this.floatsPerInstance);
    this.modelBuffer = this.device.createBuffer({
      size: Math.ceil(this.instanceData.byteLength / 4) * 4,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    const bindGroupLayout = this.device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }, {
        binding: 1,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: {
          type: "read-only-storage"
        }
      }, {
        binding: 2,
        visibility: GPUShaderStage.FRAGMENT,
        sampler: {}
      }, {
        binding: 3,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {}
      }]
    });
    this.bindGroup = this.device.createBindGroup({
      layout: bindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.cameraBuffer
        }
      }, {
        binding: 1,
        resource: {
          buffer: this.modelBuffer
        }
      }, {
        binding: 2,
        resource: this.sampler
      }, {
        binding: 3,
        resource: this.texture.createView()
      }]
    });
    const shaderModule = this.device.createShaderModule({
      code: _geoTex.geoInstancedTexEffect
    });
    const pipelineLayout = this.device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    this.pipeline = this.device.createRenderPipeline({
      label: 'geo tex 2 Pipeline',
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: 'vsMain',
        buffers: [{
          arrayStride: 3 * 4,
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: 'float32x3'
          }]
        }, {
          arrayStride: 2 * 4,
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: 'float32x2'
          }]
        }]
      },
      fragment: {
        module: shaderModule,
        entryPoint: 'fsMain',
        targets: [{
          format: this.format,
          blend: {
            color: {
              srcFactor: 'src-alpha',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add'
            },
            alpha: {
              srcFactor: 'one',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add'
            }
          }
        }]
      },
      primitive: {
        topology: 'triangle-list'
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: 'less-equal',
        format: 'depth24plus'
      }
    });
  }
  updateInstanceData = baseModelMatrix => {
    if (this.rotateEffect) {
      this.rotateAngle = (this.rotateAngle ?? 0) + this.rotateEffectSpeed; // accumulate rotation
      if (this.rotateAngle >= 360) {
        this.rotateAngle = 0;
      }
    }
    const count = Math.min(this.instanceCount, this.maxInstances);
    for (let i = 0; i < count; i++) {
      const t = this.instanceTargets[i];
      // smooth interpolation of position & scale
      for (let j = 0; j < 3; j++) {
        t.currentPosition[j] += (t.position[j] - t.currentPosition[j]) * this.lerpSpeed;
        t.currentScale[j] += (t.scale[j] - t.currentScale[j]) * this.lerpSpeed;
      }
      const local = _wgpuMatrix.mat4.identity();
      if (this.rotateEffect == true) {
        _wgpuMatrix.mat4.rotateY(local, this.rotateAngle, local);
      }
      _wgpuMatrix.mat4.translate(local, t.currentPosition, local);
      _wgpuMatrix.mat4.scale(local, t.currentScale, local);
      const finalMat = _wgpuMatrix.mat4.identity();
      _wgpuMatrix.mat4.multiply(baseModelMatrix, local, finalMat);
      const offset = i * this.floatsPerInstance;
      this.instanceData.set(finalMat, offset);
      this.instanceData.set(t.color, offset + 16);
    }
    // IMPORTANT: upload ONLY the active range of floats to GPU to avoid leftover instances
    const activeFloatCount = count * this.floatsPerInstance;
    const activeBytes = activeFloatCount * 4;
    this.device.queue.writeBuffer(this.modelBuffer, 0, this.instanceData.subarray(0, activeFloatCount));
  };
  draw(pass, cameraMatrix) {
    this.device.queue.writeBuffer(this.cameraBuffer, 0, cameraMatrix);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setVertexBuffer(1, this.uvBuffer);
    pass.setIndexBuffer(this.indexBuffer, 'uint16');
    pass.drawIndexed(this.indexCount, this.instanceCount);
  }
  render(transPass, mesh, viewProjMatrix) {
    this.draw(transPass, viewProjMatrix);
  }
}
exports.GenGeoTexture2 = GenGeoTexture2;

},{"../../shaders/standalone/geo.tex.js":77,"../geometry-factory.js":39,"wgpu-matrix":22}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenGeo = void 0;
var _geometryFactory = require("../geometry-factory.js");
var _wgpuMatrix = require("wgpu-matrix");
var _geoInstanced = require("../../shaders/standalone/geo.instanced.js");
class GenGeo {
  constructor(device, format, type = "sphere", scale = 1) {
    this.device = device;
    this.format = format;
    const geom = _geometryFactory.GeometryFactory.create(type, scale);
    this.vertexData = geom.positions;
    this.uvData = geom.uvs;
    this.indexData = geom.indices;
    this.enabled = true;
    this._initPipeline();
  }
  _initPipeline() {
    const {
      vertexData,
      uvData,
      indexData
    } = this;
    // GPU buffers
    this.vertexBuffer = this.device.createBuffer({
      size: vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.vertexBuffer, 0, vertexData);
    this.uvBuffer = this.device.createBuffer({
      size: uvData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.uvBuffer, 0, uvData);
    this.indexBuffer = this.device.createBuffer({
      size: Math.ceil(indexData.byteLength / 4) * 4,
      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.indexBuffer, 0, indexData);
    this.indexCount = indexData.length;
    this.cameraBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.instanceTargets = [];
    this.lerpSpeed = 0.05;
    this.maxInstances = 5;
    this.instanceCount = 2;
    this.floatsPerInstance = 16 + 4;
    for (let x = 0; x < this.maxInstances; x++) {
      this.instanceTargets.push({
        index: x,
        position: [0, 0, 0],
        currentPosition: [0, 0, 0],
        scale: [1, 1, 1],
        currentScale: [1, 1, 1],
        color: [0.6, 0.8, 1.0, 0.4]
      });
    }
    this.instanceData = new Float32Array(this.instanceCount * this.floatsPerInstance);
    this.modelBuffer = this.device.createBuffer({
      size: this.instanceData.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    const bindGroupLayout = this.device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }, {
        binding: 1,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: {
          type: "read-only-storage"
        }
      }]
    });
    this.bindGroup = this.device.createBindGroup({
      layout: bindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.cameraBuffer
        }
      }, {
        binding: 1,
        resource: {
          buffer: this.modelBuffer
        }
      }]
    });
    const shaderModule = this.device.createShaderModule({
      code: _geoInstanced.geoInstancedEffect
    });
    const pipelineLayout = this.device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    this.pipeline = this.device.createRenderPipeline({
      label: 'geo gen Pipeline',
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: 'vsMain',
        buffers: [{
          arrayStride: 3 * 4,
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: 'float32x3'
          }]
        }, {
          arrayStride: 2 * 4,
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: 'float32x2'
          }]
        }]
      },
      fragment: {
        module: shaderModule,
        entryPoint: 'fsMain',
        targets: [{
          format: this.format,
          blend: {
            color: {
              srcFactor: 'src-alpha',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add'
            },
            alpha: {
              srcFactor: 'one',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add'
            }
          }
        }]
      },
      primitive: {
        topology: 'triangle-list'
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: 'less-equal',
        format: 'depth24plus'
      }
    });
  }
  updateInstanceData = baseModelMatrix => {
    const count = Math.min(this.instanceCount, this.maxInstances);
    for (let i = 0; i < count; i++) {
      const t = this.instanceTargets[i];
      // smooth interpolation of position & scale
      for (let j = 0; j < 3; j++) {
        t.currentPosition[j] += (t.position[j] - t.currentPosition[j]) * this.lerpSpeed;
        t.currentScale[j] += (t.scale[j] - t.currentScale[j]) * this.lerpSpeed;
      }
      const local = _wgpuMatrix.mat4.identity();
      _wgpuMatrix.mat4.translate(local, t.currentPosition, local);
      _wgpuMatrix.mat4.scale(local, t.currentScale, local);
      const finalMat = _wgpuMatrix.mat4.identity();
      _wgpuMatrix.mat4.multiply(baseModelMatrix, local, finalMat);
      const offset = i * this.floatsPerInstance;
      this.instanceData.set(finalMat, offset);
      this.instanceData.set(t.color, offset + 16);
    }
    // IMPORTANT: upload ONLY the active range of floats to GPU to avoid leftover instances
    const activeFloatCount = count * this.floatsPerInstance;
    const activeBytes = activeFloatCount * 4;
    // .subarray(0, activeFloatCount) ensures we don't upload garbage beyond instanceCount
    this.device.queue.writeBuffer(this.modelBuffer, 0, this.instanceData.subarray(0, activeFloatCount));
  };
  draw(pass, cameraMatrix) {
    this.device.queue.writeBuffer(this.cameraBuffer, 0, cameraMatrix);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setVertexBuffer(1, this.uvBuffer);
    pass.setIndexBuffer(this.indexBuffer, 'uint16');
    pass.drawIndexed(this.indexCount, this.instanceCount);
  }
  render(transPass, mesh, viewProjMatrix) {
    this.draw(transPass, viewProjMatrix);
  }
}
exports.GenGeo = GenGeo;

},{"../../shaders/standalone/geo.instanced.js":76,"../geometry-factory.js":39,"wgpu-matrix":22}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GizmoEffect = void 0;
var _gimzoShader = require("../../shaders/gizmo/gimzoShader");
class GizmoEffect {
  constructor(device, format) {
    this.device = device;
    this.format = format;
    this.enabled = true;
    // 0=translate, 1=rotate, 2=scale
    this.mode = 0;
    this.size = 3;
    this.selectedAxis = 0;
    this.movementScale = 0.01;
    this.isDragging = false;
    this.dragStartPoint = null;
    this.dragAxis = 0;
    this.parentMesh = null;
    this.initialPosition = null;
    this._initPipeline();
    this._setupEventListeners();
    addEventListener("editor-set-gizmo-mode", e => {
      console.log("MODE:", e.detail.mode);
      this.setMode(e.detail.mode);
    });
  }
  _initPipeline() {
    this._createTranslateGizmo();
    this.cameraBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.modelBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.gizmoSettingsBuffer = this.device.createBuffer({
      size: 32,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this._updateGizmoSettings();
    const bindGroupLayout = this.device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }, {
        binding: 1,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }, {
        binding: 2,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: {}
      }]
    });
    this.bindGroup = this.device.createBindGroup({
      layout: bindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.cameraBuffer
        }
      }, {
        binding: 1,
        resource: {
          buffer: this.modelBuffer
        }
      }, {
        binding: 2,
        resource: {
          buffer: this.gizmoSettingsBuffer
        }
      }]
    });
    const shaderModule = this.device.createShaderModule({
      code: _gimzoShader.gizmoEffect
    });
    const pipelineLayout = this.device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    this.pipeline = this.device.createRenderPipeline({
      label: 'gizmo Pipeline',
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: "vsMain",
        buffers: [{
          arrayStride: 3 * 4,
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: "float32x3"
          }]
        }, {
          arrayStride: 3 * 4,
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: "float32x3"
          }]
        }]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fsMain",
        targets: [{
          format: this.format,
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha",
              operation: "add"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha",
              operation: "add"
            }
          }
        }]
      },
      primitive: {
        topology: "line-list"
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: "always",
        format: "depth24plus"
      }
    });
  }
  _createTranslateGizmo() {
    const axisLength = 2.0;
    const arrowSize = 0.15;
    const positions = new Float32Array([0, 0, 0, axisLength, 0, 0, axisLength, 0, 0, axisLength - arrowSize, arrowSize, 0, axisLength, 0, 0, axisLength - arrowSize, -arrowSize, 0, axisLength, 0, 0, axisLength - arrowSize, 0, arrowSize, axisLength, 0, 0, axisLength - arrowSize, 0, -arrowSize, 0, 0, 0, 0, axisLength, 0, 0, axisLength, 0, arrowSize, axisLength - arrowSize, 0, 0, axisLength, 0, -arrowSize, axisLength - arrowSize, 0, 0, axisLength, 0, 0, axisLength - arrowSize, arrowSize, 0, axisLength, 0, 0, axisLength - arrowSize, -arrowSize, 0, 0, 0, 0, 0, axisLength, 0, 0, axisLength, arrowSize, 0, axisLength - arrowSize, 0, 0, axisLength, -arrowSize, 0, axisLength - arrowSize, 0, 0, axisLength, 0, arrowSize, axisLength - arrowSize, 0, 0, axisLength, 0, -arrowSize, axisLength - arrowSize]);
    const colors = new Float32Array([1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
    // Y axis (green)
    0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
    // Z axis (blue)
    0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
    this.vertexBuffer = this.device.createBuffer({
      size: positions.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.vertexBuffer, 0, positions);
    this.colorBuffer = this.device.createBuffer({
      size: colors.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.colorBuffer, 0, colors);
    this.vertexCount = positions.length / 3;
  }
  _setupEventListeners() {
    app.canvas.addEventListener("ray.hit.mousedown", e => {
      const detail = e.detail;
      if (detail.hitObject === this.parentMesh && detail.hitObject.name === this.parentMesh.name) {
        this._handleRayHit(detail);
      } else {
        e.detail.hitObject.effects.gizmoEffect = this;
        this.parentMesh.effects.gizmoEffect = null;
        this.parentMesh = e.detail.hitObject;
        app.editor.editorHud.updateSceneObjPropertiesFromGizmo(this.parentMesh.name);
        // console.log('Gizmo: ray.hit.mousedown :FINLA   ', this.parentMesh.name);
      }
    });
    app.canvas.addEventListener("mousemove", e => {
      if (this.isDragging && e.buttons === 1) {
        this._handleDrag(e);
        if (app.cameras.WASD) app.cameras.WASD.suspendDrag = true;
      } else if (this.isDragging && e.buttons === 0) {
        this.isDragging = false;
        this.selectedAxis = 0;
        this._updateGizmoSettings();
      } else {
        if (app.cameras.WASD) app.cameras.WASD.suspendDrag = false;
      }
    });
    app.canvas.addEventListener("mouseup", () => {
      if (this.isDragging) {
        // console.log('Gizmo: Stopped dragging:', this.parentMesh.name);
        // console.log('What is selectedAxis: ', this.selectedAxis)
        // console.log('What is operation: ', this.mode)
        if (this.parentMesh._GRAPH_CACHE) return;
        if (this.mode == 0) {
          // 1 x  2 y  3 z
          // // inputFor: "Cube_0" property: "x" propertyId: "position" value: "1"
          document.dispatchEvent(new CustomEvent('web.editor.update.pos', {
            detail: {
              inputFor: this.parentMesh.name,
              propertyId: "position",
              property: this.selectedAxis == 1 ? "x" : this.selectedAxis == 2 ? "y" : "z",
              value: this.selectedAxis == 1 ? this.parentMesh.position.x : this.selectedAxis == 2 ? this.parentMesh.position.y : this.parentMesh.position.z
            }
          }));
        } else if (this.mode == 1) {
          document.dispatchEvent(new CustomEvent('web.editor.update.rot', {
            detail: {
              inputFor: this.parentMesh.name,
              propertyId: "rotation",
              property: this.selectedAxis == 1 ? "x" : this.selectedAxis == 2 ? "y" : "z",
              value: this.selectedAxis == 1 ? this.parentMesh.rotation.x : this.selectedAxis == 2 ? this.parentMesh.rotation.y : this.parentMesh.rotation.z
            }
          }));
        } else if (this.mode == 2) {
          // if(e.detail.property == '0' || e.detail.property == '1' || e.detail.property == '2') {
          document.dispatchEvent(new CustomEvent('web.editor.update.scale', {
            detail: {
              inputFor: this.parentMesh.name,
              propertyId: "scale",
              property: this.selectedAxis == 1 ? "0" : this.selectedAxis == 2 ? "1" : "2",
              value: this.selectedAxis == 1 ? this.parentMesh.rotation.x : this.selectedAxis == 2 ? this.parentMesh.rotation.y : this.parentMesh.rotation.z
            }
          }));
        }
        // finish job
        this.isDragging = false;
        this.selectedAxis = 0;
        this._updateGizmoSettings();
      }
    });
  }
  _handleRayHit(detail) {
    const {
      rayOrigin,
      rayDirection,
      hitPoint
    } = detail;
    const axis = this._raycastAxis(rayOrigin, rayDirection, detail.hitObject);
    if (axis > 0) {
      this.selectedAxis = axis;
      this.dragStartPoint = [...hitPoint];
      this.initialPosition = {
        x: this.parentMesh.position.x,
        y: this.parentMesh.position.y,
        z: this.parentMesh.position.z
      };
      this.dragAxis = axis;
      this._updateGizmoSettings();
      this.isDragging = true;
    }
  }

  /**
  * Get the screen-space direction of a world axis
  * @param {number} axisIndex - 0=X, 1=Y, 2=Z
  * @returns {{x: number, y: number}} - Normalized 2D screen direction
  */
  _getAxisScreenDirection(axisIndex) {
    // Get world axis vector
    const worldAxis = [[1, 0, 0],
    // X
    [0, 1, 0],
    // Y
    [0, 0, 1] // Z
    ][axisIndex];
    // Transform axis to camera space
    const viewMatrix = app.cameras.WASD.matrix_;
    const projMatrix = app.cameras.WASD.projectionMatrix;
    const p1 = this.parentMesh.position;
    // Point 2: Object position + axis direction
    const p2 = {
      x: p1.x + worldAxis[0],
      y: p1.y + worldAxis[1],
      z: p1.z + worldAxis[2]
    };

    // Project both points to screen space
    const screen1 = this._worldToScreen(p1, viewMatrix, projMatrix);
    const screen2 = this._worldToScreen(p2, viewMatrix, projMatrix);

    // Get screen-space direction
    const dx = screen2.x - screen1.x;
    const dy = screen2.y - screen1.y;
    const length = Math.sqrt(dx * dx + dy * dy);

    // Return normalized direction
    return {
      x: length > 0.001 ? dx / length : 0,
      y: length > 0.001 ? dy / length : 0
    };
  }
  _worldToScreen(worldPos, viewMatrix, projMatrix) {
    // Transform to clip space
    const clipPos = this._transformPoint(worldPos, viewMatrix, projMatrix);

    // Perspective divide
    const ndcX = clipPos.x / clipPos.w;
    const ndcY = clipPos.y / clipPos.w;

    // Convert to screen coordinates (assuming viewport)
    const screenX = (ndcX + 1) * 0.5 * app.canvas.width;
    const screenY = (1 - ndcY) * 0.5 * app.canvas.height; // Flip Y

    return {
      x: screenX,
      y: screenY
    };
  }
  _transformPoint(point, viewMatrix, projMatrix) {
    // Combine view * projection
    const vp = this._multiplyMatrices(projMatrix, viewMatrix);

    // Transform point
    const x = vp[0] * point.x + vp[4] * point.y + vp[8] * point.z + vp[12];
    const y = vp[1] * point.x + vp[5] * point.y + vp[9] * point.z + vp[13];
    const z = vp[2] * point.x + vp[6] * point.y + vp[10] * point.z + vp[14];
    const w = vp[3] * point.x + vp[7] * point.y + vp[11] * point.z + vp[15];
    return {
      x,
      y,
      z,
      w
    };
  }
  _multiplyMatrices(a, b) {
    const result = new Array(16);
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        result[i * 4 + j] = a[i * 4 + 0] * b[0 * 4 + j] + a[i * 4 + 1] * b[1 * 4 + j] + a[i * 4 + 2] * b[2 * 4 + j] + a[i * 4 + 3] * b[3 * 4 + j];
      }
    }
    return result;
  }
  _handleDrag(mouseEvent) {
    if (!this.parentMesh || !this.dragStartPoint || !this.isDragging) return;
    const deltaX = mouseEvent.movementX;
    const deltaY = mouseEvent.movementY;
    const direction = deltaX > Math.abs(deltaY) ? deltaX : -deltaY;
    switch (this.mode) {
      case 0:
        switch (this.dragAxis) {
          case 1:
            this.parentMesh.position.x += deltaX * this.movementScale;
            break;
          case 2:
            this.parentMesh.position.y -= deltaY * this.movementScale;
            break;
          // case 3: this.parentMesh.position.z -= direction * this.movementScale; break;
          case 3:
            const zAxisScreenDir = this._getAxisScreenDirection(2); // Z = axis index 2
            const mouseDelta = {
              x: deltaX,
              y: -deltaY
            }; // Flip Y for screen coords
            // Dot product: how much does mouse movement align with Z-axis on screen?
            const movement = mouseDelta.x * zAxisScreenDir.x + mouseDelta.y * zAxisScreenDir.y;
            this.parentMesh.position.z += movement * this.movementScale;
        }
        break;
      case 1:
        const rotSpeed = 0.1;
        switch (this.dragAxis) {
          case 1:
            this.parentMesh.rotation.x += deltaY * rotSpeed;
            break;
          case 2:
            this.parentMesh.rotation.y += deltaX * rotSpeed;
            break;
          case 3:
            this.parentMesh.rotation.z += direction * rotSpeed;
            break;
        }
        break;
      case 2:
        const scaleSpeed = 0.01;
        switch (this.dragAxis) {
          case 1:
            this.parentMesh.scale[0] += deltaX * scaleSpeed;
            break;
          case 2:
            this.parentMesh.scale[1] += -deltaY * scaleSpeed;
            break;
          case 3:
            this.parentMesh.scale[2] += -direction * scaleSpeed;
            break;
        }
        break;
    }
  }
  _raycastAxis(rayOrigin, rayDirection, mesh) {
    const gizmoPos = [mesh.position.x, mesh.position.y, mesh.position.z];
    const threshold = 0.1 * this.size;
    const xEnd = [gizmoPos[0] + 2 * this.size, gizmoPos[1], gizmoPos[2]];
    const xHit = this._rayIntersectsLine(rayOrigin, rayDirection, gizmoPos, xEnd, threshold);
    if (xHit) return 1;
    const yEnd = [gizmoPos[0], gizmoPos[1] + 2 * this.size, gizmoPos[2]];
    const yHit = this._rayIntersectsLine(rayOrigin, rayDirection, gizmoPos, yEnd, threshold);
    if (yHit) return 2;
    const zEnd = [gizmoPos[0], gizmoPos[1], gizmoPos[2] + 2 * this.size];
    const zHit = this._rayIntersectsLine(rayOrigin, rayDirection, gizmoPos, zEnd, threshold);
    if (zHit) return 3;
    return 0;
  }
  _rayIntersectsLine(rayOrigin, rayDir, lineStart, lineEnd, threshold) {
    const ro = Array.isArray(rayOrigin) ? rayOrigin : [rayOrigin[0], rayOrigin[1], rayOrigin[2]];
    const rd = [rayDir[0], rayDir[1], rayDir[2]];
    const rdLen = Math.sqrt(rd[0] ** 2 + rd[1] ** 2 + rd[2] ** 2);
    const ray = [rd[0] / rdLen, rd[1] / rdLen, rd[2] / rdLen];
    const line = [lineEnd[0] - lineStart[0], lineEnd[1] - lineStart[1], lineEnd[2] - lineStart[2]];
    const w = [ro[0] - lineStart[0], ro[1] - lineStart[1], ro[2] - lineStart[2]];
    const a = ray[0] ** 2 + ray[1] ** 2 + ray[2] ** 2;
    const b = ray[0] * line[0] + ray[1] * line[1] + ray[2] * line[2];
    const c = line[0] ** 2 + line[1] ** 2 + line[2] ** 2;
    const d = ray[0] * w[0] + ray[1] * w[1] + ray[2] * w[2];
    const e = line[0] * w[0] + line[1] * w[1] + line[2] * w[2];
    const denom = a * c - b * b;
    if (Math.abs(denom) < 0.0001) return false;
    const sc = (b * e - c * d) / denom;
    const tc = (a * e - b * d) / denom;
    if (tc < 0 || tc > 1) return false;
    const closestOnRay = [ro[0] + sc * ray[0], ro[1] + sc * ray[1], ro[2] + sc * ray[2]];
    const closestOnLine = [lineStart[0] + tc * line[0], lineStart[1] + tc * line[1], lineStart[2] + tc * line[2]];
    const dist = Math.sqrt((closestOnRay[0] - closestOnLine[0]) ** 2 + (closestOnRay[1] - closestOnLine[1]) ** 2 + (closestOnRay[2] - closestOnLine[2]) ** 2);
    // console.log('Distance to line:', dist, 'threshold:', threshold);
    return dist < threshold;
  }
  _updateGizmoSettings() {
    const data = new Float32Array([this.mode, this.size, this.selectedAxis, 1.0]);
    this.device.queue.writeBuffer(this.gizmoSettingsBuffer, 0, data);
  }
  updateInstanceData(baseModelMatrix) {
    this.device.queue.writeBuffer(this.modelBuffer, 0, baseModelMatrix);
  }
  draw(pass, cameraMatrix) {
    if (!this.enabled) return;
    this.device.queue.writeBuffer(this.cameraBuffer, 0, cameraMatrix);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setVertexBuffer(1, this.colorBuffer);
    pass.draw(this.vertexCount);
  }
  render(pass, mesh, viewProjMatrix) {
    this.parentMesh = mesh;
    this.draw(pass, viewProjMatrix);
  }
  setMode(mode) {
    this.mode = mode;
    this._updateGizmoSettings();
  }
  setSize(size) {
    this.size = size;
    this._updateGizmoSettings();
  }
  setSelectedAxis(axis) {
    this.selectedAxis = axis;
    this._updateGizmoSettings();
  }
  setEnabled(enabled) {
    this.enabled = enabled;
  }
}
exports.GizmoEffect = GizmoEffect;

},{"../../shaders/gizmo/gimzoShader":70}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MANABarEffect = void 0;
var _wgpuMatrix = require("wgpu-matrix");
var _energyBarShader = require("../../shaders/energy-bars/energy-bar-shader.js");
class MANABarEffect {
  constructor(device, format) {
    this.device = device;
    this.format = format;
    this.progress = 1.0;
    this.color = [0.1, 0.1, 0.9, 1.0];
    this.offsetY = 45;
    this.enabled = true;
    this._initPipeline();
  }
  _initPipeline() {
    // Simple flat bar (width 100, height 10)
    const W = 40;
    const H = 3;
    const vertexData = new Float32Array([-0.5 * W, 0.5 * H, 0.0, 0.5 * W, 0.5 * H, 0.0, -0.5 * W, -0.5 * H, 0.0, 0.5 * W, -0.5 * H, 0.0]);
    const uvData = new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]);
    const indexData = new Uint16Array([0, 2, 1, 1, 2, 3]);

    // Buffers
    this.vertexBuffer = this.device.createBuffer({
      size: vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.vertexBuffer, 0, vertexData);
    this.uvBuffer = this.device.createBuffer({
      size: uvData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.uvBuffer, 0, uvData);
    this.indexBuffer = this.device.createBuffer({
      size: Math.ceil(indexData.byteLength / 4) * 4,
      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.indexBuffer, 0, indexData);
    this.indexCount = indexData.length;

    // Uniforms
    this.cameraBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // model + color + progress (64 + 16 + 4)
    this.modelBuffer = this.device.createBuffer({
      size: 64 + 16 + 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // BindGroup
    const bindGroupLayout = this.device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }, {
        binding: 1,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: {}
      }]
    });
    this.bindGroup = this.device.createBindGroup({
      layout: bindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.cameraBuffer
        }
      }, {
        binding: 1,
        resource: {
          buffer: this.modelBuffer
        }
      }]
    });

    // Pipeline
    const shaderModule = this.device.createShaderModule({
      code: _energyBarShader.hpBarEffectShaders
    });
    const pipelineLayout = this.device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    this.pipeline = this.device.createRenderPipeline({
      label: 'mana Pipeline',
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: 'vsMain',
        buffers: [{
          arrayStride: 3 * 4,
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: 'float32x3'
          }]
        }, {
          arrayStride: 2 * 4,
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: 'float32x2'
          }]
        }]
      },
      fragment: {
        module: shaderModule,
        entryPoint: 'fsMain',
        targets: [{
          format: this.format
        }]
      },
      primitive: {
        topology: 'triangle-list'
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: 'always',
        format: 'depth24plus'
      }
    });
  }
  setProgress(value) {
    this.progress = Math.max(0.0, Math.min(1.0, value));
  }
  setColor(r, g, b, a = 1.0) {
    this.color = [r, g, b, a];
  }
  draw(pass, cameraMatrix, modelMatrix) {
    const color = new Float32Array(this.color);
    const progressData = new Float32Array([this.progress]);

    // Pack uniforms manually
    const buffer = new ArrayBuffer(64 + 16 + 4);
    const f32 = new Float32Array(buffer);
    f32.set(cameraMatrix, 0); // not needed here
    this.device.queue.writeBuffer(this.cameraBuffer, 0, cameraMatrix);
    this.device.queue.writeBuffer(this.modelBuffer, 0, modelMatrix);
    this.device.queue.writeBuffer(this.modelBuffer, 64, color);
    this.device.queue.writeBuffer(this.modelBuffer, 64 + 16, progressData);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setVertexBuffer(1, this.uvBuffer);
    pass.setIndexBuffer(this.indexBuffer, 'uint16');
    pass.drawIndexed(this.indexCount);
  }
  render(pass, mesh, viewProjMatrix) {
    const pos = mesh.position;
    const modelMatrix = _wgpuMatrix.mat4.identity();
    _wgpuMatrix.mat4.translate(modelMatrix, [pos.x, pos.y + this.offsetY, pos.z], modelMatrix);
    this.draw(pass, viewProjMatrix, modelMatrix);
  }
}
exports.MANABarEffect = MANABarEffect;

},{"../../shaders/energy-bars/energy-bar-shader.js":60,"wgpu-matrix":22}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointerEffect = void 0;
var _wgpuMatrix = require("wgpu-matrix");
var _pointerEffect = require("../../shaders/standalone/pointer.effect.js");
class PointerEffect {
  constructor(device, format) {
    this.device = device;
    this.format = format;

    // fiktive 
    this.enabled = true;
    this._initPipeline();
  }
  _initPipeline() {
    // Vertex data: simple quad
    let S = 10;
    const vertexData = new Float32Array([-0.5 * S, 0.5 * S, 0.0 * S,
    // top-left
    0.5 * S, 0.5 * S, 0.0 * S,
    // top-right
    -0.1 * S, -0.1 * S, 0.0 * S,
    // bottom-left
    0.1 * S, -0.1 * S, 0.0 * S // bottom-right
    ]);
    const uvData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
    const indexData = new Uint16Array([0, 2, 1, 1, 2, 3]);
    this.vertexBuffer = this.device.createBuffer({
      size: vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.vertexBuffer, 0, vertexData);
    this.uvBuffer = this.device.createBuffer({
      size: uvData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.uvBuffer, 0, uvData);
    this.indexBuffer = this.device.createBuffer({
      size: Math.ceil(indexData.byteLength / 4) * 4,
      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.indexBuffer, 0, indexData);
    this.indexCount = indexData.length;
    this.cameraBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.modelBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    const bindGroupLayout = this.device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }, {
        binding: 1,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }]
    });
    this.bindGroup = this.device.createBindGroup({
      layout: bindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.cameraBuffer
        }
      }, {
        binding: 1,
        resource: {
          buffer: this.modelBuffer
        }
      }]
    });
    const shaderModule = this.device.createShaderModule({
      code: _pointerEffect.pointerEffect
    });
    const pipelineLayout = this.device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    this.pipeline = this.device.createRenderPipeline({
      label: 'pointEffect Pipeline',
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: 'vsMain',
        buffers: [{
          arrayStride: 3 * 4,
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: 'float32x3'
          }]
        }, {
          arrayStride: 2 * 4,
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: 'float32x2'
          }]
        }]
      },
      fragment: {
        module: shaderModule,
        entryPoint: 'fsMain',
        targets: [{
          format: this.format
        }]
      },
      primitive: {
        topology: 'triangle-list'
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: 'always',
        format: 'depth24plus'
      }
    });
  }
  draw(pass, cameraMatrix, modelMatrix) {
    this.device.queue.writeBuffer(this.cameraBuffer, 0, cameraMatrix);
    this.device.queue.writeBuffer(this.modelBuffer, 0, modelMatrix);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setVertexBuffer(1, this.uvBuffer);
    pass.setIndexBuffer(this.indexBuffer, 'uint16');
    pass.drawIndexed(this.indexCount);
  }
  render(transPass, mesh, viewProjMatrix) {
    const objPos = mesh.position;
    const modelMatrix = _wgpuMatrix.mat4.identity();
    _wgpuMatrix.mat4.translate(modelMatrix, [objPos.x, objPos.y + 60, objPos.z], modelMatrix);
    this.draw(transPass, viewProjMatrix, modelMatrix);
  }
}
exports.PointerEffect = PointerEffect;

},{"../../shaders/standalone/pointer.effect.js":78,"wgpu-matrix":22}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointEffect = void 0;
var _pointEffect = require("../../shaders/topology-point/pointEffect");
class PointEffect {
  constructor(device, format) {
    this.device = device;
    this.format = format;
    this.pointSize = 8.0;
    this.enabled = true;
    this._initPipeline();
  }
  _initPipeline() {
    // Camera uniform buffer
    this.cameraBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Model buffer
    this.modelBuffer = this.device.createBuffer({
      size: 64,
      // mat4x4
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Point settings buffer
    this.pointSettingsBuffer = this.device.createBuffer({
      size: 32,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.pointSettingsBuffer, 0, new Float32Array([this.pointSize, 0, 0, 0]));
    const bindGroupLayout = this.device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }, {
        binding: 1,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }, {
        binding: 2,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      }]
    });
    this.bindGroup = this.device.createBindGroup({
      layout: bindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.cameraBuffer
        }
      }, {
        binding: 1,
        resource: {
          buffer: this.modelBuffer
        }
      }, {
        binding: 2,
        resource: {
          buffer: this.pointSettingsBuffer
        }
      }]
    });
    const shaderModule = this.device.createShaderModule({
      code: _pointEffect.pointEffectShader
    });
    const pipelineLayout = this.device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    this.pipeline = this.device.createRenderPipeline({
      label: 'Topology Pipeline',
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: "vsMain",
        buffers: [{
          arrayStride: 3 * 4,
          stepMode: 'instance',
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: "float32x3"
          }]
        }, {
          arrayStride: 3 * 4,
          stepMode: 'instance',
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: "float32x3"
          }]
        }]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fsMain",
        targets: [{
          format: this.format,
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha",
              operation: "add"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha",
              operation: "add"
            }
          }
        }]
      },
      primitive: {
        topology: "triangle-strip"
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: "less-equal",
        format: "depth24plus"
      }
    });
  }

  // ✅ THIS MATCHES FlameEffect PATTERN
  updateInstanceData(baseModelMatrix) {
    // You can apply additional transforms here if needed
    // For now, just use the parent's model matrix directly
    this.device.queue.writeBuffer(this.modelBuffer, 0, baseModelMatrix);
  }
  draw(pass, cameraMatrix, vertexBuffer, colorBuffer, vertexCount) {
    if (!this.enabled) return;
    if (!vertexCount || typeof vertexCount !== 'number' || vertexCount <= 0) {
      console.warn('PointEffect: invalid vertexCount', vertexCount);
      return;
    }
    this.device.queue.writeBuffer(this.cameraBuffer, 0, cameraMatrix);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    pass.setVertexBuffer(0, vertexBuffer);
    pass.setVertexBuffer(1, colorBuffer);
    pass.draw(4, vertexCount, 0, 0);
  }
  render(pass, mesh, viewProjMatrix) {
    if (!mesh.vertexBuffer) {
      console.warn('PointEffect: mesh has no vertexBuffer');
      return;
    }
    let vertexCount = mesh.vertexCount;
    if (!vertexCount && mesh.vertexBuffer.size) {
      vertexCount = mesh.vertexBuffer.size / (3 * 4);
    }
    if (!vertexCount && mesh.geometry?.positions) {
      vertexCount = mesh.geometry.positions.length / 3;
    }
    if (!vertexCount || vertexCount <= 0) {
      console.warn('PointEffect: could not determine vertexCount', mesh);
      return;
    }
    const colorBuffer = mesh.vertexNormalsBuffer;
    if (!colorBuffer) {
      console.warn('PointEffect: mesh has no vertexNormalsBuffer');
      return;
    }
    this.draw(pass, viewProjMatrix, mesh.vertexBuffer, colorBuffer, vertexCount);
  }
  setPointSize(size) {
    this.pointSize = size;
    this.device.queue.writeBuffer(this.pointSettingsBuffer, 0, new Float32Array([this.pointSize, 0, 0, 0]));
  }
  setEnabled(enabled) {
    this.enabled = enabled;
  }
}
exports.PointEffect = PointEffect;

},{"../../shaders/topology-point/pointEffect":79}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WASDCamera = exports.RPGCamera = exports.ArcballCamera = void 0;
exports.createInputHandler = createInputHandler;
var _wgpuMatrix = require("wgpu-matrix");
var _utils = require("./utils");
// Note: The code in this file does not use the 'dst' output parameter of functions in the
// 'wgpu-matrix' library, so produces many temporary vectors and matrices.
// This is intentional, as this sample prefers readability over performance.

// The common functionality between camera implementations
class CameraBase {
  // The camera matrix
  matrix_ = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

  // The calculated view matrix readonly
  view_ = _wgpuMatrix.mat4.create();

  // Aliases to column vectors of the matrix
  right_ = new Float32Array(this.matrix_.buffer, 4 * 0, 4);
  up_ = new Float32Array(this.matrix_.buffer, 4 * 4, 4);
  back_ = new Float32Array(this.matrix_.buffer, 4 * 8, 4);
  position_ = new Float32Array(this.matrix_.buffer, 4 * 12, 4);

  // Returns the camera matrix
  get matrix() {
    return this.matrix_;
  }
  // Assigns `mat` to the camera matrix
  set matrix(mat) {
    _wgpuMatrix.mat4.copy(mat, this.matrix_);
  }

  // setProjection(fov = (2*Math.PI) / 5 , aspect = 1, near = 0.5, far = 1000) {
  //   this.projectionMatrix = mat4.perspective(fov, aspect, near, far);
  // }

  // Returns the camera view matrix
  get view() {
    return this.view_;
  }
  // Assigns `mat` to the camera view
  set view(mat) {
    _wgpuMatrix.mat4.copy(mat, this.view_);
  }

  // Returns column vector 0 of the camera matrix
  get right() {
    return this.right_;
  }

  // Assigns `vec` to the first 3 elements of column vector 0 of the camera matrix
  set right(vec) {
    _wgpuMatrix.vec3.copy(vec, this.right_);
  }

  // Returns column vector 1 of the camera matrix
  get up() {
    return this.up_;
  }

  // Assigns `vec` to the first 3 elements of column vector 1 of the camera matrix \ Vec3
  set up(vec) {
    _wgpuMatrix.vec3.copy(vec, this.up_);
  }

  // Returns column vector 2 of the camera matrix
  get back() {
    return this.back_;
  }

  // Assigns `vec` to the first 3 elements of column vector 2 of the camera matrix
  set back(vec) {
    _wgpuMatrix.vec3.copy(vec, this.back_);
  }

  // Returns column vector 3 of the camera matrix
  get position() {
    return this.position_;
  }

  // Assigns `vec` to the first 3 elements of column vector 3 of the camera matrix
  set position(vec) {
    _wgpuMatrix.vec3.copy(vec, this.position_);
  }
}

// WASDCamera is a camera implementation that behaves similar to first-person-shooter PC games.
class WASDCamera extends CameraBase {
  // The camera absolute pitch angle
  pitch = 0;
  // The camera absolute yaw angle
  yaw = 0;
  setPitch = pitch => {
    this.pitch = pitch;
  };
  setYaw = yaw => {
    this.yaw = yaw;
  };
  setX = x => {
    this.position[0] = x;
  };
  setY = y => {
    this.position[1] = y;
  };
  setZ = z => {
    this.position[2] = z;
  };

  // The movement veloicty readonly
  velocity_ = _wgpuMatrix.vec3.create();

  // Speed multiplier for camera movement
  movementSpeed = 10;

  // Speed multiplier for camera rotation
  rotationSpeed = 1;

  // Movement velocity drag coeffient [0 .. 1]
  // 0: Continues forever
  // 1: Instantly stops moving
  frictionCoefficient = 0.99;

  // Returns velocity vector
  get velocity() {
    return this.velocity_;
  }
  // Assigns `vec` to the velocity vector
  set velocity(vec) {
    _wgpuMatrix.vec3.copy(vec, this.velocity_);
  }
  setProjection(fov = 2 * Math.PI / 5, aspect = 1, near = 1, far = 1000) {
    this.projectionMatrix = _wgpuMatrix.mat4.perspective(fov, aspect, near, far);
  }
  constructor(options) {
    super();
    if (options && (options.position || options.target)) {
      const position = options.position ?? _wgpuMatrix.vec3.create(0, 0, 0);
      const target = options.target ?? _wgpuMatrix.vec3.create(0, 0, 0);
      const forward = _wgpuMatrix.vec3.normalize(_wgpuMatrix.vec3.sub(target, position));
      this.recalculateAngles(forward);
      this.position = position;
      this.canvas = options.canvas;
      this.aspect = options.canvas.width / options.canvas.height;
      this.setProjection(2 * Math.PI / 5, this.aspect, 1, 2000);
      this.suspendDrag = false;
      if (options.pitch) this.setPitch(options.pitch);
      if (options.yaw) this.setYaw(options.yaw);
      // console.log(`%cCamera constructor : ${position}`, LOG_INFO);
    }
  }

  // Returns the camera matrix
  get matrix() {
    return super.matrix;
  }

  // Assigns `mat` to the camera matrix, and recalcuates the camera angles
  set matrix(mat) {
    super.matrix = mat;
    this.recalculateAngles(this.back);
  }
  update(deltaTime, input) {
    const sign = (positive, negative) => (positive ? 1 : 0) - (negative ? 1 : 0);
    if (this.suspendDrag == false) {
      // Apply the delta rotation to the pitch and yaw angles
      this.yaw -= input.analog.x * deltaTime * this.rotationSpeed;
      this.pitch -= input.analog.y * deltaTime * this.rotationSpeed;
    }

    // Wrap yaw between [0° .. 360°], just to prevent large accumulation.
    this.yaw = mod(this.yaw, Math.PI * 2);
    // Clamp pitch between [-90° .. +90°] to prevent somersaults.
    this.pitch = clamp(this.pitch, -Math.PI / 2, Math.PI / 2);

    // Save the current position, as we're about to rebuild the camera matrix.
    const position = _wgpuMatrix.vec3.copy(this.position);

    // Reconstruct the camera's rotation, and store into the camera matrix.
    super.matrix = _wgpuMatrix.mat4.rotateX(_wgpuMatrix.mat4.rotationY(this.yaw), this.pitch);
    // super.matrix = mat4.rotateX(mat4.rotationY(this.yaw), -this.pitch);
    // super.matrix = mat4.rotateY(mat4.rotateX(this.pitch), this.yaw);

    // Calculate the new target velocity
    const digital = input.digital;
    const deltaRight = sign(digital.right, digital.left);
    const deltaUp = sign(digital.up, digital.down);
    const targetVelocity = _wgpuMatrix.vec3.create();
    const deltaBack = sign(digital.backward, digital.forward);
    _wgpuMatrix.vec3.addScaled(targetVelocity, this.right, deltaRight, targetVelocity);
    _wgpuMatrix.vec3.addScaled(targetVelocity, this.up, deltaUp, targetVelocity);
    _wgpuMatrix.vec3.addScaled(targetVelocity, this.back, deltaBack, targetVelocity);
    _wgpuMatrix.vec3.normalize(targetVelocity, targetVelocity);
    _wgpuMatrix.vec3.mulScalar(targetVelocity, this.movementSpeed, targetVelocity);

    // Mix new target velocity
    this.velocity = lerp(targetVelocity, this.velocity, Math.pow(1 - this.frictionCoefficient, deltaTime));

    // Integrate velocity to calculate new position
    this.position = _wgpuMatrix.vec3.addScaled(position, this.velocity, deltaTime);

    // Invert the camera matrix to build the view matrix
    this.view = _wgpuMatrix.mat4.invert(this.matrix);
    return this.view;
  }

  // Recalculates the yaw and pitch values from a directional vector
  recalculateAngles(dir) {
    this.yaw = Math.atan2(dir[0], dir[2]);
    this.pitch = -Math.asin(dir[1]);
  }
}

// ArcballCamera implements a basic orbiting camera around the world origin
exports.WASDCamera = WASDCamera;
class ArcballCamera extends CameraBase {
  // The camera distance from the target
  distance = 0;

  // The current angular velocity
  angularVelocity = 0;

  // The current rotation axis
  axis_ = _wgpuMatrix.vec3.create();

  // Returns the rotation axis
  get axis() {
    return this.axis_;
  }
  // Assigns `vec` to the rotation axis
  set axis(vec) {
    _wgpuMatrix.vec3.copy(vec, this.axis_);
  }

  // Speed multiplier for camera rotation
  rotationSpeed = 1;

  // Speed multiplier for camera zoom
  zoomSpeed = 0.1;

  // Rotation velocity drag coeffient [0 .. 1]
  // 0: Spins forever
  // 1: Instantly stops spinning
  frictionCoefficient = 0.999;
  setProjection(fov = 2 * Math.PI / 5, aspect = 1, near = 1, far = 1000) {
    this.projectionMatrix = _wgpuMatrix.mat4.perspective(fov, aspect, near, far);
  }
  // Construtor
  constructor(options) {
    super();
    if (options && options.position) {
      this.position = options.position;
      this.distance = _wgpuMatrix.vec3.len(this.position);
      this.back = _wgpuMatrix.vec3.normalize(this.position);
      this.setProjection(2 * Math.PI / 5, this.aspect, 1, 2000);
      this.recalcuateRight();
      this.recalcuateUp();
    }
  }

  // Returns the camera matrix
  get matrix() {
    return super.matrix;
  }

  // Assigns `mat` to the camera matrix, and recalcuates the distance
  set matrix(mat) {
    super.matrix = mat;
    this.distance = _wgpuMatrix.vec3.len(this.position);
  }
  update(deltaTime, input) {
    const epsilon = 0.0000001;
    if (input.analog.touching) {
      // Currently being dragged.
      this.angularVelocity = 0;
    } else {
      // Dampen any existing angular velocity
      this.angularVelocity *= Math.pow(1 - this.frictionCoefficient, deltaTime);
    }

    // Calculate the movement vector
    const movement = _wgpuMatrix.vec3.create();
    _wgpuMatrix.vec3.addScaled(movement, this.right, input.analog.x, movement);
    _wgpuMatrix.vec3.addScaled(movement, this.up, -input.analog.y, movement);

    // Cross the movement vector with the view direction to calculate the rotation axis x magnitude
    const crossProduct = _wgpuMatrix.vec3.cross(movement, this.back);

    // Calculate the magnitude of the drag
    const magnitude = _wgpuMatrix.vec3.len(crossProduct);
    if (magnitude > epsilon) {
      // Normalize the crossProduct to get the rotation axis
      this.axis = _wgpuMatrix.vec3.scale(crossProduct, 1 / magnitude);

      // Remember the current angular velocity. This is used when the touch is released for a fling.
      this.angularVelocity = magnitude * this.rotationSpeed;
    }

    // The rotation around this.axis to apply to the camera matrix this update
    const rotationAngle = this.angularVelocity * deltaTime;
    if (rotationAngle > epsilon) {
      // Rotate the matrix around axis
      // Note: The rotation is not done as a matrix-matrix multiply as the repeated multiplications
      // will quickly introduce substantial error into the matrix.
      this.back = _wgpuMatrix.vec3.normalize(rotate(this.back, this.axis, rotationAngle));
      this.recalcuateRight();
      this.recalcuateUp();
    }

    // recalculate `this.position` from `this.back` considering zoom
    if (input.analog.zoom !== 0) {
      this.distance *= 1 + input.analog.zoom * this.zoomSpeed;
    }
    this.position = _wgpuMatrix.vec3.scale(this.back, this.distance);

    // Invert the camera matrix to build the view matrix
    this.view = _wgpuMatrix.mat4.invert(this.matrix);
    return this.view;
  }

  // Assigns `this.right` with the cross product of `this.up` and `this.back`
  recalcuateRight() {
    this.right = _wgpuMatrix.vec3.normalize(_wgpuMatrix.vec3.cross(this.up, this.back));
  }

  // Assigns `this.up` with the cross product of `this.back` and `this.right`
  recalcuateUp() {
    this.up = _wgpuMatrix.vec3.normalize(_wgpuMatrix.vec3.cross(this.back, this.right));
  }
}

// Returns `x` clamped between [`min` .. `max`]
exports.ArcballCamera = ArcballCamera;
function clamp(x, min, max) {
  return Math.min(Math.max(x, min), max);
}

// Returns `x` float-modulo `div`
function mod(x, div) {
  return x - Math.floor(Math.abs(x) / div) * div * Math.sign(x);
}

// Returns `vec` rotated `angle` radians around `axis`
function rotate(vec, axis, angle) {
  return _wgpuMatrix.vec3.transformMat4Upper3x3(vec, _wgpuMatrix.mat4.rotation(axis, angle));
}

// Returns the linear interpolation between 'a' and 'b' using 's'
function lerp(a, b, s) {
  return _wgpuMatrix.vec3.addScaled(a, _wgpuMatrix.vec3.sub(b, a), s);
}
function createInputHandler(window, canvas) {
  let digital = {
    forward: false,
    backward: false,
    left: false,
    right: false,
    up: false,
    down: false
  };
  let analog = {
    x: 0,
    y: 0,
    zoom: 0
  };
  let mouseDown = false;
  const setDigital = (e, value) => {
    switch (e.code) {
      case 'KeyW':
        digital.forward = value;
        break;
      case 'KeyS':
        digital.backward = value;
        break;
      case 'KeyA':
        digital.left = value;
        break;
      case 'KeyD':
        digital.right = value;
        break;
      case 'KeyV':
        digital.up = value;
        break;
      case 'KeyC':
        digital.down = value;
        break;
    }
    // if you wanna dosavle all keyboard input for some reason...
    // add later like new option feature...
    // e.preventDefault();
    e.stopPropagation();
  };
  window.addEventListener('keydown', e => setDigital(e, true));
  window.addEventListener('keyup', e => setDigital(e, false));
  canvas.style.touchAction = 'pinch-zoom';
  canvas.addEventListener('pointerdown', () => {
    mouseDown = true;
  });
  canvas.addEventListener('pointerup', () => {
    mouseDown = false;
  });
  canvas.addEventListener('pointermove', e => {
    mouseDown = e.pointerType === 'mouse' ? (e.buttons & 1) !== 0 : true;
    if (mouseDown) {
      analog.x += e.movementX / 10;
      analog.y += e.movementY / 10;
    }
  });
  canvas.addEventListener('wheel', e => {
    // if((e.buttons & 1) !== 0) {
    //   analog.zoom += Math.sign(e.deltaY);
    //   e.preventDefault();
    //   e.stopPropagation();
    // }
  }, {
    passive: false
  });
  return () => {
    // Guard: prevent zero deltas from breaking camera math
    const safeX = analog.x || 0.0001;
    const safeY = analog.y || 0.0001;
    const out = {
      digital,
      analog: {
        x: safeX,
        y: safeY,
        zoom: analog.zoom,
        touching: mouseDown
      }
    };
    // Reset only the deltas for next frame
    analog.x = 0;
    analog.y = 0;
    analog.zoom = 0;
    return out;
  };
}
class RPGCamera extends CameraBase {
  followMe = null;
  pitch = 0;
  yaw = 0;
  velocity_ = _wgpuMatrix.vec3.create();
  movementSpeed = 10;
  rotationSpeed = 1;
  followMeOffset = 150; // << mobile adaptation needed after all...
  // Movement velocity drag coeffient [0 .. 1]
  // 0: Continues forever
  // 1: Instantly stops moving
  frictionCoefficient = 0.99;
  // Inside your camera control init
  scrollY = 50;
  minY = 50.5; // minimum camera height
  maxY = 135.0; // maximum camera height
  scrollSpeed = 1;
  get velocity() {
    return this.velocity_;
  }
  set velocity(vec) {
    _wgpuMatrix.vec3.copy(vec, this.velocity_);
  }
  setProjection(fov = 2 * Math.PI / 5, aspect = 1, near = 1, far = 1000) {
    this.projectionMatrix = _wgpuMatrix.mat4.perspective(fov, aspect, near, far);
  }
  constructor(options) {
    super();
    if (options && (options.position || options.target)) {
      const position = options.position ?? _wgpuMatrix.vec3.create(0, 0, 0);
      const target = options.target ?? _wgpuMatrix.vec3.create(0, 0, 0);
      const forward = _wgpuMatrix.vec3.normalize(_wgpuMatrix.vec3.sub(target, position));
      this.recalculateAngles(forward);
      this.position = position;
      this.canvas = options.canvas;
      this.aspect = options.canvas.width / options.canvas.height;
      this.setProjection(2 * Math.PI / 5, this.aspect, 1, 2000);
      // console.log(`%cCamera constructor : ${position}`, LOG_INFO);

      this.mousRollInAction = false;
      addEventListener('wheel', e => {
        // Scroll up = zoom out / higher Y
        this.mousRollInAction = true;
        this.scrollY -= e.deltaY * this.scrollSpeed * 0.01;
        // Clamp to range
        this.scrollY = Math.max(this.minY, Math.min(this.maxY, this.scrollY));
      });
    }
  }
  get matrix() {
    return super.matrix;
  }

  // Assigns `mat` to the camera matrix, and recalcuates the camera angles
  set matrix(mat) {
    super.matrix = mat;
    this.recalculateAngles(this.back);
  }
  update(deltaTime, input) {
    const sign = (positive, negative) => (positive ? 1 : 0) - (negative ? 1 : 0);
    // Apply the delta rotation to the pitch and yaw angles
    this.yaw = 0; //-= input.analog.x * deltaTime * this.rotationSpeed;
    this.pitch = -0.88; //  -= input.analog.y * deltaTime * this.rotationSpeed;
    // // Wrap yaw between [0° .. 360°], just to prevent large accumulation.
    this.yaw = mod(this.yaw, Math.PI * 2);
    // // Clamp pitch between [-90° .. +90°] to prevent somersaults.
    this.pitch = clamp(this.pitch, -Math.PI / 2, Math.PI / 2);
    // Save the current position, as we're about to rebuild the camera matrix.
    if (this.followMe != null && this.followMe.inMove === true || this.mousRollInAction == true) {
      //  console.log("  follow : " + this.followMe.x)

      this.followMeOffset = this.scrollY;
      // if player not move allow mouse explore map 
      this.position[0] = this.followMe.x;
      this.position[2] = this.followMe.z + this.followMeOffset;
      app.lightContainer[0].position[0] = this.followMe.x;
      app.lightContainer[0].position[2] = this.followMe.z;
      app.lightContainer[0].target[0] = this.followMe.x;
      app.lightContainer[0].target[2] = this.followMe.z;
      this.mousRollInAction = false;
    }
    const smoothFactor = 0.1;
    this.position[1] += (this.scrollY - this.position[1]) * smoothFactor;
    let position = _wgpuMatrix.vec3.copy(this.position);
    // Reconstruct the camera's rotation, and store into the camera matrix.
    super.matrix = _wgpuMatrix.mat4.rotateX(_wgpuMatrix.mat4.rotationY(this.yaw), this.pitch);
    // Calculate the new target velocity
    const digital = input.digital;
    const deltaRight = sign(digital.right, digital.left);
    const deltaUp = sign(digital.up, digital.down);
    const targetVelocity = _wgpuMatrix.vec3.create();
    const deltaBack = sign(digital.backward, digital.forward);
    // older then follow
    if (deltaBack == -1) {
      // console.log(deltaBack + "  deltaBack ")
      position[2] += -10;
    } else if (deltaBack == 1) {
      position[2] += 10;
    }
    position[0] += deltaRight * 10;
    _wgpuMatrix.vec3.addScaled(targetVelocity, this.right, deltaRight, targetVelocity);
    _wgpuMatrix.vec3.addScaled(targetVelocity, this.up, deltaUp, targetVelocity);
    _wgpuMatrix.vec3.normalize(targetVelocity, targetVelocity);
    _wgpuMatrix.vec3.mulScalar(targetVelocity, this.movementSpeed, targetVelocity);
    this.velocity = lerp(targetVelocity, this.velocity, Math.pow(1 - this.frictionCoefficient, deltaTime));
    this.position = _wgpuMatrix.vec3.addScaled(position, this.velocity, deltaTime);
    this.view = _wgpuMatrix.mat4.invert(this.matrix);
    return this.view;
  }
  recalculateAngles(dir) {
    this.yaw = Math.atan2(dir[0], dir[2]);
    this.pitch = -Math.asin(dir[1]);
  }
}
exports.RPGCamera = RPGCamera;

},{"./utils":56,"wgpu-matrix":22}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addOBJ = addOBJ;
exports.physicsBodiesGenerator = physicsBodiesGenerator;
exports.physicsBodiesGeneratorDeepPyramid = physicsBodiesGeneratorDeepPyramid;
exports.physicsBodiesGeneratorPyramid = physicsBodiesGeneratorPyramid;
exports.physicsBodiesGeneratorTower = physicsBodiesGeneratorTower;
exports.physicsBodiesGeneratorWall = physicsBodiesGeneratorWall;
exports.stabilizeTowerBody = stabilizeTowerBody;
var _fluxCodexVertex = require("../../tools/editor/fluxCodexVertex");
var _loaderObj = require("../loader-obj");
// general function for stabilisation 
function stabilizeTowerBody(body) {
  body.setDamping(0.8, 0.95);
  body.setSleepingThresholds(0.4, 0.4);
  body.setAngularFactor(new Ammo.btVector3(0.1, 0.1, 0.1));
  body.setFriction(1.0);
  body.setRollingFriction(0.8);
  // body.setSpinningFriction(0.8);
}

/**
 * @description Generator can be used also from visual scripting.
 * Work only for physics bodie variant.
 * @param {string} material 
 * @enum "standard", "power"
 */
function physicsBodiesGenerator(material = "standard", pos, rot, texturePath, name = "gen1", geometry = "Cube", raycast = false, scale = [1, 1, 1], sum = 100, delay = 500, mesh = null) {
  let engine = this;
  const inputCube = {
    mesh: "./res/meshes/blender/cube.obj"
  };
  const inputSphere = {
    mesh: "./res/meshes/blender/sphere.obj"
  };
  function handler(m) {
    let RAY = {
      enabled: raycast == true ? true : false,
      radius: 1
    };
    for (var x = 0; x < sum; x++) {
      setTimeout(() => {
        engine.addMeshObj({
          material: {
            type: material
          },
          position: pos,
          rotation: rot,
          rotationSpeed: {
            x: 0,
            y: 0,
            z: 0
          },
          texturesPaths: [texturePath],
          name: name + '_' + x,
          mesh: m.mesh,
          physics: {
            enabled: true,
            geometry: geometry
          },
          raycast: RAY
        });
        // cache
        const o = app.getSceneObjectByName(cubeName);
        _fluxCodexVertex.runtimeCacheObjs.push(o);
      }, x * delay);
    }
  }
  if (geometry == "Cube") {
    (0, _loaderObj.downloadMeshes)(inputCube, handler, {
      scale: scale
    });
  } else if (geometry == "Sphere") {
    (0, _loaderObj.downloadMeshes)(inputSphere, handler, {
      scale: scale
    });
  }
}

/**
 * @description Generate a wall of physics cubes
 * @param {string} material
 * @param {object} pos        starting position {x,y,z}
 * @param {object} rot
 * @param {string} texturePath
 * @param {string} name       base name
 * @param {string} size       "WIDTHxHEIGHT" → e.g. "10x3"
 * @param {boolean} raycast
 * @param {Array} scale
 * @param {number} spacing    distance between cubes
 */
function physicsBodiesGeneratorWall(material = "standard", pos, rot, texturePath, name = "wallCube", size = "10x3", raycast = false, scale = [1, 1, 1], spacing = 2, delay = 200, useMeshPath = "./res/meshes/blender/cube.obj") {
  const engine = this;
  const [width, height] = size.toLowerCase().split("x").map(n => parseInt(n, 10));
  const inputCube = {
    mesh: useMeshPath
  };
  function handler(m) {
    let index = 0;
    const RAY = {
      enabled: raycast,
      radius: 1
    };
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const cubeName = `${name}_${index}`;
        setTimeout(() => {
          engine.addMeshObj({
            material: {
              type: material
            },
            envMapParams: material == 'mirror' ? {
              baseColorMix: 0.5,
              // normal mix
              mirrorTint: [0.9, 0.95, 1.0],
              // Slight cool tint
              reflectivity: 0.95,
              // 25% reflection blend
              illuminateColor: [0.3, 0.7, 1.0],
              // Soft cyan
              illuminateStrength: 0.4,
              // Gentle rim
              illuminatePulse: 0.01,
              // No pulse (static)
              fresnelPower: 2.0,
              // Medium-sharp edge
              envLodBias: 2.5,
              usePlanarReflection: false // ✅ Env map mode
            } : null,
            position: {
              x: pos.x + x * spacing,
              y: pos.y + y * spacing - 2.8,
              z: pos.z
            },
            rotation: rot,
            rotationSpeed: {
              x: 0,
              y: 0,
              z: 0
            },
            texturesPaths: typeof texturePath == "object" ? texturePath : [texturePath],
            name: cubeName,
            mesh: m.mesh,
            physics: {
              scale: scale,
              enabled: true,
              geometry: "Cube"
            },
            raycast: RAY
          });
          const o = app.getSceneObjectByName(cubeName);
          _fluxCodexVertex.runtimeCacheObjs.push(o);
        }, index * delay);
        index++;
      }
    }
  }
  (0, _loaderObj.downloadMeshes)(inputCube, handler, {
    scale
  });
}

/**
 * @description Generate a pyramid of physics cubes
 * @param {object} pos       base position {x,y,z}
 * @param {object} rot
 * @param {string} texturePath
 * @param {string} name
 * @param {number} levels    number of pyramid levels
 * @param {boolean} raycast
 * @param {Array} scale
 * @param {number} spacing
 */
function physicsBodiesGeneratorPyramid(material = "standard", pos, rot, texturePath, name = "pyramidCube", levels = 5, raycast = false, scale = [1, 1, 1], spacing = 2, delay = 500) {
  const engine = this;
  const inputCube = {
    mesh: "./res/meshes/blender/cube.obj"
  };
  function handler(m) {
    let index = 0;
    const RAY = {
      enabled: !!raycast,
      radius: 1
    };
    for (let y = 0; y < levels; y++) {
      const rowCount = levels - y;
      const xOffset = (rowCount - 1) * spacing * 0.5;
      for (let x = 0; x < rowCount; x++) {
        const cubeName = `${name}_${index}`;
        setTimeout(() => {
          engine.addMeshObj({
            material: {
              type: material
            },
            position: {
              x: pos.x + x * spacing - xOffset,
              y: pos.y + y * spacing,
              z: pos.z
            },
            rotation: rot,
            rotationSpeed: {
              x: 0,
              y: 0,
              z: 0
            },
            texturesPaths: [texturePath],
            name: cubeName,
            mesh: m.mesh,
            physics: {
              scale: scale,
              enabled: true,
              geometry: "Cube"
            },
            raycast: RAY
          });
          // cache
          const o = app.getSceneObjectByName(cubeName);
          _fluxCodexVertex.runtimeCacheObjs.push(o);
        }, delay);
        index++;
      }
    }
  }
  (0, _loaderObj.downloadMeshes)(inputCube, handler, {
    scale
  });
}

/**
 * @description Generate a full 3D pyramid of physics cubes
 * @param {object} pos       base position {x,y,z}
 * @param {object} rot
 * @param {string} texturePath
 * @param {string} name
 * @param {number} levels    number of pyramid levels
 * @param {boolean} raycast
 * @param {Array} scale
 * @param {number} spacing
 */
function physicsBodiesGeneratorDeepPyramid(material = "standard", pos, rot, texturePath, name = "pyramidCube", levels = 5, raycast = false, scale = [1, 1, 1], spacing = 2, delay = 200) {
  return new Promise((resolve, reject) => {
    const engine = this;
    const inputCube = {
      mesh: "./res/meshes/blender/cube.obj"
    };
    levels = parseFloat(levels);
    function handler(m) {
      let index = 0;
      const totalCubes = levels * (levels + 1) * (2 * levels + 1) / 6;
      const lastIndex = totalCubes - 1;
      const RAY = {
        enabled: !!raycast,
        radius: 1
      };
      const objects = [];
      for (let y = 0; y < levels; y++) {
        const sizeX = levels - y;
        const sizeZ = levels - y;
        const xOffset = (sizeX - 1) * spacing * 0.5;
        const zOffset = (sizeZ - 1) * spacing * 0.5;
        for (let x = 0; x < sizeX; x++) {
          for (let z = 0; z < sizeZ; z++) {
            const cubeName = `${name}_${index}`;
            const currentIndex = index;
            setTimeout(() => {
              engine.addMeshObj({
                material: {
                  type: material
                },
                position: {
                  x: pos.x + x * spacing - xOffset,
                  y: pos.y + y * spacing,
                  z: pos.z + z * spacing - zOffset
                },
                rotation: rot,
                rotationSpeed: {
                  x: 0,
                  y: 0,
                  z: 0
                },
                texturesPaths: [texturePath],
                name: cubeName,
                mesh: m.mesh,
                physics: {
                  scale: scale,
                  enabled: true,
                  geometry: "Cube"
                },
                raycast: RAY
              });
              const b = app.matrixAmmo.getBodyByName(cubeName);
              stabilizeTowerBody(b);
              const o = app.getSceneObjectByName(cubeName);
              _fluxCodexVertex.runtimeCacheObjs.push(o);
              objects.push(o.name);
              if (currentIndex === lastIndex) {
                // console.log("Last cube added!");
                resolve(objects);
              }
            }, delay * index);
            index++;
          }
        }
      }
    }
    (0, _loaderObj.downloadMeshes)(inputCube, handler, {
      scale
    });
  });
}
function physicsBodiesGeneratorTower(material = "standard", pos, rot, texturePath, name = "towerCube", height = 10, raycast = false, scale = [1, 1, 1], spacing = 2) {
  const engine = this;
  const inputCube = {
    mesh: "./res/meshes/blender/cube.obj"
  };
  function handler(m) {
    const RAY = {
      enabled: !!raycast,
      radius: 1
    };
    for (let y = 0; y < height; y++) {
      const cubeName = `${name}_${y}`;
      setTimeout(() => {
        engine.addMeshObj({
          material: {
            type: material
          },
          position: {
            x: pos.x,
            y: pos.y + y * spacing,
            z: pos.z
          },
          rotation: rot,
          rotationSpeed: {
            x: 0,
            y: 0,
            z: 0
          },
          texturesPaths: [texturePath],
          name: cubeName,
          mesh: m.mesh,
          physics: {
            scale: scale,
            enabled: true,
            geometry: "Cube"
          },
          raycast: RAY
        });
        const b = app.matrixAmmo.getBodyByName(cubeName);
        stabilizeTowerBody(b);
        // cache
        const o = app.getSceneObjectByName(cubeName);
        _fluxCodexVertex.runtimeCacheObjs.push(o);
      }, delay);
    }
  }
  (0, _loaderObj.downloadMeshes)(inputCube, handler, {
    scale
  });
}

// universal (both physics and non physics objects)
// app.editorAddOBJ(mat, pos, rot, texturePath, name, isPhysicsBody, raycast, scale, isInstancedObj
function addOBJ(path, material = "standard", pos, rot, texturePath, name, isPhysicsBody = false, raycast = false, scale = [1, 1, 1], isInstancedObj = false) {
  return new Promise((resolve, reject) => {
    const engine = this;
    const inputCube = {
      mesh: path
    };
    function handler(m) {
      const RAY = {
        enabled: !!raycast,
        radius: 1
      };
      // console.info('add cube form graph..')
      engine.addMeshObj({
        material: {
          type: material
        },
        position: {
          x: pos.x,
          y: pos.y,
          z: pos.z
        },
        rotation: rot,
        rotationSpeed: {
          x: 0,
          y: 0,
          z: 0
        },
        texturesPaths: [texturePath],
        name: name,
        mesh: m.mesh,
        physics: {
          scale: scale,
          enabled: isPhysicsBody,
          geometry: "Cube"
        },
        raycast: RAY
      });
      // const b = app.matrixAmmo.getBodyByName(name);
      const o = app.getSceneObjectByName(name);
      _fluxCodexVertex.runtimeCacheObjs.push(o);
      resolve(o);
    }
    (0, _loaderObj.downloadMeshes)(inputCube, handler, {
      scale
    });
  });
}

},{"../../tools/editor/fluxCodexVertex":92,"../loader-obj":44}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeometryFactory = void 0;
/**
 * @description
 * GeometryFactory - can be reused for any level of pipeline integration.
 * It is already integrated with level of 'me effects'.
 */
class GeometryFactory {
  static create(type, size = 1, segments = 16, options = {}) {
    switch (type) {
      case "quad":
        return GeometryFactory.quad(size);
      case "cube":
        return GeometryFactory.cube(size);
      case "sphere":
        return GeometryFactory.sphere(size, segments);
      case "pyramid":
        return GeometryFactory.pyramid(size);
      case "star":
        return GeometryFactory.star(size);
      case "circle":
        return GeometryFactory.circle(size, segments);
      case "circle2":
        return GeometryFactory.circle2(size, segments);
      case "diamond":
        return GeometryFactory.diamond(size);
      case "rock":
        return GeometryFactory.rock(size, options.detail || 3);
      case "meteor":
        return GeometryFactory.meteor(size, options.detail || 6);
      case "thunder":
        return GeometryFactory.thunder(size);
      case "shard":
        return GeometryFactory.shard(size);
      case "circlePlane":
        return GeometryFactory.circlePlane(size, segments);
      case "ring":
        return GeometryFactory.ring(size, options.innerRatio || 0.7, segments, options.height || 0.05);
      default:
        throw new Error(`Unknown geometry: ${type}`);
    }
  }

  // --- BASIC SHAPES ---------------------------------------------------------
  static quad(S = 1) {
    const positions = new Float32Array([-S, S, 0, S, S, 0, -S, -S, 0, S, -S, 0]);
    const uvs = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
    const indices = new Uint16Array([0, 2, 1, 1, 2, 3]);
    return {
      positions,
      uvs,
      indices
    };
  }

  // static cube(S = 1) {
  //   const p = S / 2;
  //   const positions = new Float32Array([
  //     -p, -p, p, p, -p, p, p, p, p, -p, p, p,
  //     -p, -p, -p, -p, p, -p, p, p, -p, p, -p, -p,
  //     -p, p, -p, -p, p, p, p, p, p, p, p, -p,
  //     -p, -p, -p, p, -p, -p, p, -p, p, -p, -p, p,
  //     p, -p, -p, p, p, -p, p, p, p, p, -p, p,
  //     -p, -p, -p, -p, -p, p, -p, p, p, -p, p, -p
  //   ]);
  //   const uvs = new Float32Array(6 * 8).fill(0);
  //   const indices = [];
  //   for(let i = 0;i < 6;i++) {
  //     const o = i * 4; indices.push(o, o + 1, o + 2, o, o + 2, o + 3);
  //   }
  //   let i = new Uint16Array(i);
  //   return {positions, uvs, i};
  // }
  static cube(S = 1) {
    const p = S / 2;
    const positions = new Float32Array([-p, -p, p, p, -p, p, p, p, p, -p, p, p,
    // Front
    -p, -p, -p, -p, p, -p, p, p, -p, p, -p, -p,
    // Back
    -p, p, -p, -p, p, p, p, p, p, p, p, -p,
    // Top
    -p, -p, -p, p, -p, -p, p, -p, p, -p, -p, p,
    // Bottom
    p, -p, -p, p, p, -p, p, p, p, p, -p, p,
    // Right
    -p, -p, -p, -p, -p, p, -p, p, p, -p, p, -p // Left
    ]);
    const uvs = new Float32Array(6 * 8).fill(0); // Add real UVs if needed
    const indices = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
    return {
      positions,
      uvs,
      indices
    };
  }
  static sphere(R = 0.1, seg = 16) {
    const p = [],
      uv = [],
      ind = [];
    for (let y = 0; y <= seg; y++) {
      const v = y / seg,
        θ = v * Math.PI;
      for (let x = 0; x <= seg; x++) {
        const u = x / seg,
          φ = u * Math.PI * 2;
        p.push(R * Math.sin(θ) * Math.cos(φ), R * Math.cos(θ), R * Math.sin(θ) * Math.sin(φ));
        uv.push(u, v);
      }
    }
    for (let y = 0; y < seg; y++) {
      for (let x = 0; x < seg; x++) {
        const i = y * (seg + 1) + x;
        ind.push(i, i + seg + 1, i + 1, i + 1, i + seg + 1, i + seg + 2);
      }
    }
    return {
      positions: new Float32Array(p),
      uvs: new Float32Array(uv),
      indices: new Uint16Array(ind)
    };
  }
  static pyramid(S = 1) {
    const h = S,
      p = S / 2;
    const pos = new Float32Array([-p, 0, -p, p, 0, -p, p, 0, p, -p, 0, p, 0, h, 0]);
    const uv = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 0.5, 0]);
    const idx = new Uint16Array([0, 1, 2, 0, 2, 3, 0, 1, 4, 1, 2, 4, 2, 3, 4, 3, 0, 4]);
    return {
      positions: pos,
      uvs: uv,
      indices: idx
    };
  }
  static star(S = 1) {
    const R = S,
      r = S * 0.4,
      v = [],
      uv = [],
      ind = [];
    for (let i = 0; i < 10; i++) {
      const a = i / 10 * Math.PI * 2;
      const rr = i % 2 ? r : R;
      v.push(Math.cos(a) * rr, Math.sin(a) * rr, 0);
      uv.push((Math.cos(a) + 1) / 2, (Math.sin(a) + 1) / 2);
    }
    for (let i = 1; i < 9; i++) ind.push(0, i, i + 1);
    ind.push(0, 9, 1);
    return {
      positions: new Float32Array(v),
      uvs: new Float32Array(uv),
      indices: new Uint16Array(ind)
    };
  }
  static circle(R = 1, seg = 32) {
    const p = [0, 0, 0],
      uv = [0.5, 0.5],
      ind = [];
    for (let i = 0; i <= seg; i++) {
      const a = i / seg * Math.PI * 2;
      p.push(Math.cos(a) * R, Math.sin(a) * R, 0);
      uv.push((Math.cos(a) + 1) / 2, (Math.sin(a) + 1) / 2);
      if (i > 1) ind.push(0, i - 1, i);
    }
    return {
      positions: new Float32Array(p),
      uvs: new Float32Array(uv),
      indices: new Uint16Array(ind)
    };
  }
  static circle2(radius = 1, segments = 64) {
    const positions = [0, 0, 0]; // center
    const uvs = [0.5, 0.5]; // center UV
    const indices = [];

    // create outer vertices
    for (let i = 0; i <= segments; i++) {
      const angle = i / segments * Math.PI * 2;
      const x = Math.cos(angle) * radius;
      const y = Math.sin(angle) * radius;
      positions.push(x, y, 0);
      // map to circular UV range [0,1]
      uvs.push((x / radius + 1) / 2, (y / radius + 1) / 2);
      if (i > 0) {
        // center = 0, connect previous outer vertex with current outer vertex
        indices.push(0, i, i + 1);
      }
    }

    // close the circle (last triangle connects to first outer vertex)
    // we already pushed (segments + 1) outer vertices, so last index = segments + 1
    // but first outer vertex is index 1
    indices.push(0, segments + 1, 1);
    return {
      positions: new Float32Array(positions),
      uvs: new Float32Array(uvs),
      indices: new Uint16Array(indices)
    };
  }
  static diamond(S = 1) {
    const h = S,
      p = S / 2;
    // 6 Vertices
    const pos = new Float32Array([0, h, 0,
    // 0: Top
    -p, 0, -p,
    // 1: Mid Left-Back
    p, 0, -p,
    // 2: Mid Right-Back
    p, 0, p,
    // 3: Mid Right-Front
    -p, 0, p,
    // 4: Mid Left-Front
    0, -h, 0 // 5: Bottom
    ]);

    // Added simple UVs so the texture actually shows up
    const uv = new Float32Array([0.5, 1,
    // Top
    0, 0.5,
    // Sides...
    1, 0.5, 0, 0.5, 1, 0.5, 0.5, 0 // Bottom
    ]);
    const idx = new Uint16Array([0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 1,
    // Top pyramid
    5, 2, 1, 5, 3, 2, 5, 4, 3, 5, 1, 4 // Bottom pyramid
    ]);
    return {
      positions: pos,
      uvs: uv,
      indices: idx
    };
  }

  // --- FANTASY & EFFECT GEOMETRIES -----------------------------------------
  static thunder(S = 1) {
    // jagged lightning bolt made of zig-zag quads
    const pts = [0, 0, 0];
    for (let i = 1; i < 8; i++) {
      const x = (Math.random() - 0.5) * 0.2 * S;
      const y = i * (S / 7);
      const z = (Math.random() - 0.5) * 0.1 * S;
      pts.push(x, y, z);
    }
    const p = [],
      uv = [],
      ind = [];
    for (let i = 0; i < pts.length / 3 - 1; i++) {
      const x1 = pts[i * 3],
        y1 = pts[i * 3 + 1],
        z1 = pts[i * 3 + 2];
      const x2 = pts[(i + 1) * 3],
        y2 = pts[(i + 1) * 3 + 1],
        z2 = pts[(i + 1) * 3 + 2];
      const w = 0.03 * S;
      p.push(x1 - w, y1, z1, x1 + w, y1, z1, x2 - w, y2, z2, x2 + w, y2, z2);
      uv.push(0, 0, 1, 0, 0, 1, 1, 1);
      const o = i * 4;
      ind.push(o, o + 1, o + 2, o + 1, o + 3, o + 2);
    }
    return {
      positions: new Float32Array(p),
      uvs: new Float32Array(uv),
      indices: new Uint16Array(ind)
    };
  }
  static rock(S = 1, detail = 4) {
    // randomly perturbed sphere for organic shape
    const base = GeometryFactory.sphere(S, detail);
    const p = base.positions;
    for (let i = 0; i < p.length; i += 3) {
      const n = Math.random() * 0.3 + 0.85;
      p[i] *= n;
      p[i + 1] *= n;
      p[i + 2] *= n;
    }
    return base;
  }
  static meteor(S = 1, detail = 6) {
    const base = GeometryFactory.rock(S, detail);
    const p = base.positions;
    // stretch and skew
    for (let i = 0; i < p.length; i += 3) {
      p[i + 1] *= 1.4 + Math.random() * 0.5;
      p[i] *= 0.8 + Math.random() * 0.3;
    }
    return base;
  }
  static shard(S = 1) {
    const positions = new Float32Array([0, 0, 0, S * 0.3, 0, S * 0.2, -S * 0.2, 0, S * 0.3, 0, S * 1.2, 0]);
    const uvs = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
    const indices = new Uint16Array([0, 1, 2, 1, 2, 3, 0, 2, 3, 0, 1, 3]);
    return {
      positions,
      uvs,
      indices
    };
  }
  static circlePlane(radius = 1, segments = 32) {
    const positions = [];
    const uvs = [];
    const indices = [];

    // Center vertex
    positions.push(0, 0, 0);
    uvs.push(0.5, 0.5);

    // Outer ring vertices
    for (let i = 0; i <= segments; i++) {
      const angle = i / segments * Math.PI * 2;
      const x = Math.cos(angle) * radius;
      const y = 0;
      const z = Math.sin(angle) * radius;
      positions.push(x, y, z);
      uvs.push((x / radius + 1) / 2, (z / radius + 1) / 2);
    }

    // Triangles (fan)
    for (let i = 1; i <= segments; i++) {
      indices.push(0, i, i + 1);
    }
    return {
      positions: new Float32Array(positions),
      uvs: new Float32Array(uvs),
      indices: new Uint16Array(indices)
    };
  }
  static ring(outerRadius = 4, innerRadiusRatio = 0.7, segments = 48, height = 0.05) {
    const innerRadius = outerRadius * innerRadiusRatio;
    const positions = [];
    const uvs = [];
    const indices = [];
    for (let i = 0; i <= segments; i++) {
      const angle = i / segments * Math.PI * 2;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      // outer edge
      positions.push(cos * outerRadius, 0, sin * outerRadius);
      uvs.push((cos + 1) / 2, (sin + 1) / 2);

      // inner edge (slightly higher if you want a bit of volume)
      positions.push(cos * innerRadius, height, sin * innerRadius);
      uvs.push((cos * innerRadius / outerRadius + 1) / 2, (sin * innerRadius / outerRadius + 1) / 2);
    }

    // Triangles
    for (let i = 0; i < segments * 2; i += 2) {
      indices.push(i, i + 1, i + 2);
      indices.push(i + 1, i + 3, i + 2);
    }
    return {
      positions: new Float32Array(positions),
      uvs: new Float32Array(uvs),
      indices: new Uint16Array(indices)
    };
  }
}
exports.GeometryFactory = GeometryFactory;

},{}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _fragmentMirror = require("../../shaders/fragment.mirror.wgsl");
var _fragment = require("../../shaders/fragment.wgsl");
var _fragmentWgsl = require("../../shaders/fragment.wgsl.metal");
var _fragmentWgsl2 = require("../../shaders/fragment.wgsl.normalmap");
var _fragmentWgsl3 = require("../../shaders/fragment.wgsl.pong");
var _fragmentWgsl4 = require("../../shaders/fragment.wgsl.power");
var _fragmentInstanced = require("../../shaders/instanced/fragment.instanced.wgsl");
var _fragmentMirrorInstanced = require("../../shaders/instanced/fragment.mirror.instanced.wgsl");
var _waterC = require("../../shaders/water/water-c.wgls");
/**
 * @description
 * Created for matrix-engine-wgpu project.
 * MeshObj class estends Materials.
 * @var material is engine meta data variable not real material object.
 * @author Nikola Lukic
 * @email zlatnaspirala@gmail.com
 */
class MaterialsInstanced {
  constructor(device, material, glb, textureCache) {
    this.device = device;
    this.glb = glb;
    this.material = material;
    this.textureCache = textureCache;
    this.isVideo = false;
    this.videoIsReady = 'NONE';
    this.compareSampler = this.device.createSampler({
      compare: 'less-equal',
      // safer for shadow comparison
      addressModeU: 'clamp-to-edge',
      // prevents UV leaking outside
      addressModeV: 'clamp-to-edge',
      magFilter: 'linear',
      // smooth PCF
      minFilter: 'linear'
    });
    // For image textures (standard sampler)
    this.imageSampler = this.device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear'
    });
    // For external video textures (needs to be filtering sampler too!)
    this.videoSampler = this.device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear'
    });
    // FX effect
    this.postFXModeBuffer = this.device.createBuffer({
      size: 4,
      // u32 = 4 bytes
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    // Dymmy buffer
    this.dummySpotlightUniformBuffer = this.device.createBuffer({
      size: 80,
      // Must match size in shader
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.dummySpotlightUniformBuffer, 0, new Float32Array(20));
    // Create a 1x1 RGBA texture filled with white
    const mrDummyTex = this.device.createTexture({
      size: [1, 1, 1],
      format: this.getFormat(),
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    // Upload a single pixel
    const pixel = new Uint8Array([255, 255, 255, 255]); // white RGBA
    this.device.queue.writeTexture({
      texture: mrDummyTex
    }, pixel, {
      bytesPerRow: 4
    }, [1, 1, 1]);
    this.metallicRoughnessTextureView = mrDummyTex.createView();
    this.metallicRoughnessSampler = this.device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear'
    });
    // 4 floats for baseColorFactor + 1 metallic + 1 roughness + 2 pad floats = 8 floats
    const materialPBRSize = 8 * 4; // 32 bytes
    this.materialPBRBuffer = this.device.createBuffer({
      size: materialPBRSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    // Dummy values
    const baseColorFactor = [1.0, 1.0, 1.0, 1.0];
    const metallicFactor = 0.1; // diffuse like plastic
    const roughnessFactor = 0.5; // some gloss
    const pad = [0.0, 0.0];
    // Pack into Float32Array
    const materialArray = new Float32Array([...baseColorFactor, metallicFactor, roughnessFactor, ...pad]);
    this.device.queue.writeBuffer(this.materialPBRBuffer, 0, materialArray.buffer);
    if (this.material.type == 'normalmap') {
      const normalTexInfo = this.glb.glbJsonData.materials[0].normalTexture;
      if (normalTexInfo) {
        const tex = this.glb.glbJsonData.glbTextures[normalTexInfo.index];
        this.normalTextureView = tex.createView();
        this.normalSampler = this.device.createSampler({
          magFilter: 'linear',
          minFilter: 'linear'
        });
      } else {
        // console.log('>>>ERRR >>>normalTexture>>')
      }
    } else {
      // console.log('>DUMMY>normalTexture>')
      // dummy for normal map 1x1 neutral normal map
      this.normalDummyTex = device.createTexture({
        size: [1, 1, 1],
        format: 'rgba8unorm',
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
      // RGBA value for neutral normal in tangent space
      const neutralNormal = new Uint8Array([128, 128, 255, 255]);
      this.device.queue.writeTexture({
        texture: this.normalDummyTex
      }, neutralNormal, {
        bytesPerRow: 4
      }, [1, 1, 1]);
      // Create texture view & sampler
      this.normalTextureView = this.normalDummyTex.createView();
      this.normalSampler = this.device.createSampler({
        magFilter: 'linear',
        minFilter: 'linear'
      });
    }
    this.createBufferForWater();
  }
  createBufferForWater = () => {
    // new water test
    this.waterBindGroupLayout = this.device.createBindGroupLayout({
      label: 'Water MAT Bind Group Layout for main pass',
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {
          type: 'uniform'
        }
      }]
    });
    this.waterParamsBuffer = this.device.createBuffer({
      size: 48,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.waterParamsData = new Float32Array([0.0, 0.2, 0.4,
    // deepColor (vec3f)
    0.5,
    // waveSpeed
    0.0, 0.5, 0.7,
    // shallowColor (vec3f)
    4.0,
    // waveScale
    0.15,
    // waveHeight
    3.0,
    // fresnelPower
    128.0,
    // specularPower
    0.0 // padding
    ]);
    this.device.queue.writeBuffer(this.waterParamsBuffer, 0, this.waterParamsData);
    this.waterBindGroup = this.device.createBindGroup({
      layout: this.waterBindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.waterParamsBuffer
        }
      }]
    });
    // To update values at runtime:
    this.updateWaterParams = (deepColor, shallowColor, waveSpeed, waveScale, waveHeight, fresnelPower, specularPower) => {
      const data = new Float32Array([deepColor[0], deepColor[1], deepColor[2], waveSpeed, shallowColor[0], shallowColor[1], shallowColor[2], waveScale, waveHeight, fresnelPower, specularPower, 0.0 // padding
      ]);
      device.queue.writeBuffer(waterParamsBuffer, 0, data);
    };
  };
  createMirrorIlluminateBindGroup(mirrorBindGroupLayout, opts) {
    const defaults = {
      mirrorTint: [0.9, 0.95, 1.0],
      // Slight cool tint
      reflectivity: 0.25,
      // 25% reflection blend
      illuminateColor: [0.3, 0.7, 1.0],
      // Soft cyan
      illuminateStrength: 0.4,
      // Gentle rim
      illuminatePulse: 0.0,
      // No pulse (static)
      fresnelPower: 4.0,
      // Medium-sharp edge
      envLodBias: 1.5 // Slightly blurred env
    };
    const cfg = {
      ...defaults,
      ...opts
    };
    const PARAMS_SIZE = 80;
    const paramsBuffer = this.device.createBuffer({
      label: 'MirrorIlluminateParams',
      size: PARAMS_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.writeParamsMirror = o => {
      const data = new Float32Array(16); // Was 12, now 16
      const t = o.mirrorTint ?? cfg.mirrorTint;
      data[0] = t[0];
      data[1] = t[1];
      data[2] = t[2];
      data[3] = o.reflectivity ?? cfg.reflectivity;
      const ic = o.illuminateColor ?? cfg.illuminateColor;
      data[4] = ic[0];
      data[5] = ic[1];
      data[6] = ic[2];
      data[7] = o.illuminateStrength ?? cfg.illuminateStrength;
      data[8] = o.illuminatePulse ?? cfg.illuminatePulse;
      data[9] = o.fresnelPower ?? cfg.fresnelPower;
      data[10] = o.envLodBias ?? cfg.envLodBias;
      data[11] = o.usePlanarReflection ? 1.0 : 0.0;
      data[12] = o.baseColorMix ?? cfg.baseColorMix;
      data[13] = 0; // padding
      data[14] = 0; // padding
      data[15] = 0; // padding
      this.device.queue.writeBuffer(paramsBuffer, 0, data);
    };
    this.writeParamsMirror(cfg);
    const samplerDummy = this.device.createSampler({
      label: 'EnvMap Sampler',
      magFilter: 'linear',
      minFilter: 'linear',
      addressModeU: 'repeat',
      addressModeV: 'clamp-to-edge'
    });
    // ── Dummy 1×1 white env texture (used when no real env map is supplied) ──
    console.warn('⚠️ envTexture provided, using white dummy!');
    const envTexture = cfg.envTexture instanceof GPUTexture ? cfg.envTexture : cfg.envTexture.texture ?? (() => {
      console.warn('⚠️ No envTexture provided, using white dummy!');
      const tex = this.device.createTexture({
        label: 'MirrorEnvDummy',
        size: [1, 1],
        format: 'rgba8unorm',
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
      this.device.queue.writeTexture({
        texture: tex
      }, new Uint8Array([255, 0, 0, 255]), {
        bytesPerRow: 4
      }, [1, 1]);
      return tex;
    })();
    const bindGroup = this.device.createBindGroup({
      label: 'MirrorIlluminate BindGroup',
      layout: mirrorBindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: paramsBuffer
        }
      }, {
        binding: 1,
        resource: envTexture.createView()
      }, {
        binding: 2,
        resource: cfg.envTexture.sampler ?? samplerDummy
      }]
    });
    return {
      bindGroup,
      paramsBuffer,
      /** Call this at runtime to hot-update mirror params without rebuilding. */
      updateParams: o => this.writeParamsMirror(o)
    };
  }
  changeTexture(newTexture) {
    // Accept GPUTexture OR GPUTextureView
    if (newTexture instanceof GPUTexture) {
      this.texture0 = newTexture;
    } else {
      this.texture0 = {
        createView: () => newTexture
      };
    }
    this.isVideo = false;
    // Recreate bind group only
    this.createBindGroupForRender();
  }
  changeMaterial(newType = 'graph', graphShader) {
    this.material.fromGraph = graphShader;
    this.material.type = newType;
    this.setupPipeline();
  }
  setBlend = alpha => {
    this.material.useBlend = true;
    this.setupMaterialPBR([1, 1, 1, alpha]);
  };
  getMaterial() {
    // make it for all after all....
    if (this.material.type == 'standard') {
      return _fragmentInstanced.fragmentWGSLInstanced;
    } else if (this.material.type == 'pong') {
      return _fragmentWgsl3.fragmentWGSLPong;
    } else if (this.material.type == 'power') {
      return _fragmentWgsl4.fragmentWGSLPower;
    } else if (this.material.type == 'metal') {
      return _fragmentWgsl.fragmentWGSLMetal;
    } else if (this.material.type == 'normalmap') {
      return _fragmentWgsl2.fragmentWGSLNormalMap;
    } else if (this.material.type == 'water') {
      return _waterC.fragmentWaterWGSL;
    } else if (this.material.type == 'graph') {
      return this.material.fromGraph;
    } else if (this.material.type === "mirror") {
      return _fragmentMirrorInstanced.fragmentMirrorWGSLInstanced;
    }
    //  else if(this.material.type == 'mix1') {
    //   return fragmentWGSLMix1;
    // }
    console.warn('Unknown material type use standard:', this.material?.type);
    return _fragment.fragmentWGSL;
  }
  getFormat() {
    if (this.material?.format == 'darker') {
      return 'rgba8unorm-srgb';
    } else if (this.material?.format == 'normal') {
      return 'rgba8unorm';
    } else {
      return 'rgba8unorm';
    }
  }
  setupMaterialPBR(baseColorFactor, metallicFactor, roughnessFactor) {
    if (!metallicFactor) metallicFactor = [0.5, 0.5, 0.5];
    if (!baseColorFactor) baseColorFactor = [1.0, 1.0, 1.0, 0.5];
    if (!roughnessFactor) roughnessFactor = 0.5;
    const pad = [0.0];
    const materialArray = new Float32Array([...baseColorFactor, metallicFactor, roughnessFactor, 0.5, ...pad]);
    this.device.queue.writeBuffer(this.materialPBRBuffer, 0, materialArray.buffer);
  }
  updatePostFXMode(mode) {
    const arrayBuffer = new Uint32Array([mode]);
    this.device.queue.writeBuffer(this.postFXModeBuffer, 0, arrayBuffer);
  }
  async loadTex0(texturesPaths) {
    this.sampler = this.device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear'
    });
    return new Promise(async resolve => {
      const response = await fetch(texturesPaths[0]);
      const imageBitmap = await createImageBitmap(await response.blob());
      this.texture0 = this.device.createTexture({
        size: [imageBitmap.width, imageBitmap.height, 1],
        // REMOVED 1
        format: this.getFormat(),
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
      });
      this.device.queue.copyExternalImageToTexture({
        source: imageBitmap
      }, {
        texture: this.texture0
      }, [imageBitmap.width, imageBitmap.height]);
      resolve();
    });
  }
  async loadEnvMap(texturesPaths, isEnvMap = false) {
    const path = texturesPaths[1] || texturesPaths[0];
    const {
      texture,
      sampler
    } = await this.textureCache.get(path, this.getFormat(), isEnvMap);
    return {
      texture,
      sampler
    };
  }
  async loadVideoTexture(arg) {
    this.videoIsReady = 'MAYBE';
    if (arg.type === 'video') {
      this.video = document.createElement('video');
      this.video.src = arg.src || 'res/videos/tunel.mp4';
      this.video.crossOrigin = 'anonymous';
      this.video.autoplay = true;
      this.video.loop = true;
      document.body.append(this.video);
      this.video.style.display = 'none';
      this.video.style.position = 'absolute';
      this.video.style.top = '750px';
      this.video.style.left = '50px';
      await this.video.play();
      this.isVideo = true;
    } else if (arg.type === 'videoElement') {
      this.video = arg.el;
      await this.video.play();
    } else if (arg.type === 'camera') {
      this.video = document.createElement('video');
      this.video.autoplay = true;
      this.video.muted = true;
      this.video.playsInline = true;
      this.video.style.display = 'none';
      document.body.append(this.video);
      try {
        const stream = await navigator.mediaDevices?.getUserMedia?.({
          video: {
            width: {
              ideal: 1280
            },
            height: {
              ideal: 720
            }
          },
          audio: false
        });
        this.video.srcObject = stream;
        await this.video.play();
        this.isVideo = true;
      } catch (err) {
        console.error("❌ Failed to access camera:", err);
        return;
      }
    } else if (arg.type === 'canvas2d') {
      // Existing canvas (arg.el) — assume it's actively drawing
      this.video = document.createElement('video');
      this.video.autoplay = true;
      this.video.muted = true;
      this.video.playsInline = true;
      this.video.style.display = 'none';
      document.body.append(this.video);
      const stream = arg.el.captureStream?.() || arg.el.mozCaptureStream?.();
      if (!stream) {
        console.error('❌ Cannot capture stream from canvas2d');
        return;
      }
      this.video.srcObject = stream;
      await this.video.play();
      this.isVideo = true;
    } else if (arg.type === 'canvas2d-inline') {
      // Miniature inline-drawn canvas created dynamically
      const canvas = document.createElement('canvas');
      canvas.width = arg.width || 256;
      canvas.height = arg.height || 256;
      const ctx = canvas.getContext('2d');
      if (typeof arg.canvaInlineProgram === 'function') {
        // Start drawing loop
        const drawLoop = () => {
          arg.canvaInlineProgram(ctx, canvas);
          requestAnimationFrame(drawLoop);
        };
        drawLoop();
      }
      this.video = document.createElement('video');
      this.video.autoplay = true;
      this.video.muted = true;
      this.video.playsInline = true;
      this.video.style.display = 'none';
      document.body.append(this.video);
      this.isVideo = true;
      const stream = canvas.captureStream?.() || canvas.mozCaptureStream?.();
      if (!stream) {
        console.error('❌ Cannot capture stream from inline canvas');
        return;
      }
      this.video.srcObject = stream;
      await this.video.play();
    }
    this.sampler = this.device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear'
    });
    // ✅ Now - maybe noT
    this.createLayoutForRender();
  }
  updateVideoTexture() {
    if (!this.video || this.video.readyState < 2) return;
    if (!this.externalTexture) {
      // create it once
      this.externalTexture = this.device.importExternalTexture({
        source: this.video
      });
      this.createBindGroupForRender();
      this.videoIsReady = 'YES';
      console.log("%c✅video bind.", LOG_FUNNY_ARCADE);
    } else {
      this.externalTexture = this.device.importExternalTexture({
        source: this.video
      });
      this.createBindGroupForRender();
    }
  }
  getMaterialTexture(glb, materialIndex) {
    const matDef = glb.glbJsonData.materials[materialIndex];
    if (!matDef) {
      console.warn('[engine] no material in glb...');
      return null;
    }
    if (matDef.pbrMetallicRoughness?.baseColorTexture) {
      const texIndex = matDef.pbrMetallicRoughness.baseColorTexture.index;
      return glb.glbJsonData.glbTextures[texIndex].createView();
    }
    return null;
  }
  getMaterialTextureFromMaterial(material) {
    if (!material || !material.pbrMetallicRoughness) return this.fallbackTextureView;
    const texInfo = material.pbrMetallicRoughness.baseColorTexture;
    if (!texInfo) return this.fallbackTextureView;
    const texIndex = texInfo.index;
    return this.glb.glbTextures[texIndex].createView();
  }
  createBindGroupForRender() {
    let textureResource = this.isVideo ? this.externalTexture : this.texture0.createView();
    // console.log('TEST TEX this.texture0 ', this.texture0);
    if (this.material.useTextureFromGlb === true) {
      // console.log('TEST TEX material use from file ', this.name);
      // 0 probably always for basicColor
      const material = this.skinnedNode.mesh.primitives[0].material;
      const textureView = material.baseColorTexture.imageView;
      // const sampler = material.baseColorTexture.sampler;
      textureResource = textureView;
    }
    if (!textureResource || !this.sceneUniformBuffer || !this.shadowDepthTextureView) {
      if (!textureResource) console.warn("❗Missing res texture: ", textureResource);
      if (!this.sceneUniformBuffer) console.warn("❗Missing res: this.sceneUniformBuffer: ", this.sceneUniformBuffer);
      // if(!this.shadowDepthTextureView) console.warn("❗Missing res: this.shadowDepthTextureView: ", this.shadowDepthTextureView);
      if (typeof textureResource === 'undefined') {
        this.updateVideoTexture();
      }
      return;
    }
    if (this.isVideo == true) {
      // console.info("✅ video sceneBindGroupForRender");
      this.sceneBindGroupForRender = this.device.createBindGroup({
        layout: this.bglForRender,
        entries: [{
          binding: 0,
          resource: {
            buffer: this.sceneUniformBuffer
          }
        }, {
          binding: 1,
          resource: this.shadowDepthTextureView
        }, {
          binding: 2,
          resource: this.compareSampler
        }, {
          binding: 3,
          resource: textureResource
        }, {
          binding: 4,
          resource: this.videoSampler
        }, {
          binding: 5,
          resource: {
            buffer: this.postFXModeBuffer
          }
        }]
      });
      // Special case for video maybe better solution exist
      if (this.video.paused == true) this.video.play();
    } else {
      this.sceneBindGroupForRender = this.device.createBindGroup({
        layout: this.bglForRender,
        entries: [{
          binding: 0,
          resource: {
            buffer: this.sceneUniformBuffer
          }
        }, {
          binding: 1,
          resource: this.shadowDepthTextureView
        }, {
          binding: 2,
          resource: this.compareSampler
        }, {
          binding: 3,
          resource: textureResource
        }, {
          binding: 4,
          resource: this.imageSampler
        }, {
          binding: 5,
          resource: {
            buffer: !this.spotlightUniformBuffer ? this.dummySpotlightUniformBuffer : this.spotlightUniformBuffer
          }
        }, {
          binding: 6,
          resource: this.metallicRoughnessTextureView
        }, {
          binding: 7,
          resource: this.metallicRoughnessSampler
        }, {
          binding: 8,
          resource: {
            buffer: this.materialPBRBuffer
          }
        },
        // NEW: dummy normal map
        {
          binding: 9,
          resource: this.normalTextureView
        }, {
          binding: 10,
          resource: this.normalSampler
        }]
      });
    }
  }
  createLayoutForRender() {
    let e = [{
      binding: 0,
      visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }, ...(this.isVideo == false ? [{
      binding: 1,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: "depth",
        viewDimension: "2d-array",
        // <- must match shadowMapArray
        multisampled: false
      }
    }] : [{
      binding: 1,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: "depth",
        viewDimension: "2d"
      }
    }]), {
      binding: 2,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'comparison'
      }
    }, ...(this.isVideo ? [
    // VIDEO
    {
      binding: 3,
      visibility: GPUShaderStage.FRAGMENT,
      externalTexture: {}
    }, {
      binding: 4,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'filtering'
      } // for video sampling
    }, {
      binding: 5,
      visibility: GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }] : [
    // IMAGE
    {
      binding: 3,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: 'float',
        viewDimension: '2d'
      }
    }, {
      binding: 4,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'filtering'
      }
    }, {
      binding: 5,
      visibility: GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }, {
      binding: 6,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: 'float',
        viewDimension: '2d'
      }
    }, {
      binding: 7,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'filtering'
      }
    }, {
      binding: 8,
      visibility: GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }, {
      binding: 9,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: 'float',
        viewDimension: '2d'
      }
    }, {
      binding: 10,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'filtering'
      }
    }])];
    // console.log("BG E :  is used normal  ", this.material.type)
    this.bglForRender = this.device.createBindGroupLayout({
      label: 'bglForRender',
      entries: e
    });
  }
}
exports.default = MaterialsInstanced;

},{"../../shaders/fragment.mirror.wgsl":63,"../../shaders/fragment.wgsl":65,"../../shaders/fragment.wgsl.metal":66,"../../shaders/fragment.wgsl.normalmap":67,"../../shaders/fragment.wgsl.pong":68,"../../shaders/fragment.wgsl.power":69,"../../shaders/instanced/fragment.instanced.wgsl":71,"../../shaders/instanced/fragment.mirror.instanced.wgsl":72,"../../shaders/water/water-c.wgls":83}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _wgpuMatrix = require("wgpu-matrix");
var _matrixClass = require("../matrix-class");
var _utils = require("../utils");
var _fragmentVideo = require("../../shaders/fragment.video.wgsl");
var _pointerEffect = require("../effects/pointerEffect");
var _materialsInstanced = _interopRequireDefault(require("./materials-instanced"));
var _vertexInstanced = require("../../shaders/instanced/vertex.instanced.wgsl");
var _bvhInstaced = require("../loaders/bvh-instaced");
var _gen = require("../effects/gen");
var _energyBar = require("../effects/energy-bar");
var _manaBar = require("../effects/mana-bar");
var _flame = require("../effects/flame");
var _flameEmmiter = require("../effects/flame-emmiter");
var _genTex = require("../effects/gen-tex");
var _genTex2 = require("../effects/gen-tex2");
var _literals = require("../literals");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class MEMeshObjInstances extends _materialsInstanced.default {
  constructor(canvas, device, context, o, inputHandler, globalAmbient, _glbFile = null, primitiveIndex = null, skinnedNodeIndex = null) {
    super(device, o.material, _glbFile, o.textureCache);
    if (typeof o.name === 'undefined') o.name = (0, _utils.genName)(3);
    if (typeof o.raycast === 'undefined') {
      this.raycast = {
        enabled: false,
        radius: 2
      };
    } else {
      this.raycast = o.raycast;
    }
    this.pointerEffect = o.pointerEffect;
    this.name = o.name;
    this.done = false;
    this.canvas = canvas;
    this.device = device;
    this.context = context;
    this.entityArgPass = o.entityArgPass;
    this.clearColor = "red";
    this.video = null;
    this.FINISH_VIDIO_INIT = false;
    this.globalAmbient = [...globalAmbient];
    this.useScale = o.useScale || false;
    if (typeof o.material.useTextureFromGlb === 'undefined' || typeof o.material.useTextureFromGlb !== "boolean") {
      o.material.useTextureFromGlb = false;
    }
    if (typeof o.material.useBlend === 'undefined' || typeof o.material.useBlend !== "boolean") {
      o.material.useBlend = false;
    }
    if (o.envMapParams !== null) {
      this.envMapParams = o.envMapParams;
    }
    this.material = o.material;
    this.time = 0;
    this.deltaTimeAdapter = 10;
    this._sceneData = new Float32Array(48);

    // Mesh stuff - for single mesh or t-posed (fiktive-first in loading order)
    this.mesh = o.mesh;
    if (_glbFile != null) {
      if (typeof this.mesh == 'undefined') {
        this.mesh = {};
        this.mesh.feedFromRealGlb = true;
      }
      // V
      const verView = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].positions.view;
      const byteOffsetV = verView.byteOffset || 0;
      const byteLengthV = verView.buffer.byteLength;
      const vertices = new Float32Array(verView.buffer.buffer, byteOffsetV, byteLengthV / 4);
      this.mesh.vertices = vertices;
      //N
      const norView = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].normals.view;
      const normalsUint8 = norView.buffer;
      const byteOffsetN = norView.byteOffset || 0;
      const byteLengthN = normalsUint8.byteLength;
      const normals = new Float32Array(normalsUint8.buffer, byteOffsetN, byteLengthN / 4);
      this.mesh.vertexNormals = normals;
      //UV
      let accessor = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].texcoords[0];
      const bufferView = accessor.view;
      const byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
      const count = accessor.count * 2;
      const uvFloatArray = new Float32Array(bufferView.buffer.buffer, byteOffset, count);
      this.mesh.uvs = uvFloatArray;
      this.mesh.textures = uvFloatArray;
      // I
      let binaryI = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].indices;
      const indicesView = binaryI.view;
      const indicesUint8 = indicesView.buffer;
      const byteOffsetI = indicesView.byteOffset || 0;
      const byteLengthI = indicesUint8.byteLength;
      // Decide on type from accessor.componentType
      // (5121 = UNSIGNED_BYTE, 5123 = UNSIGNED_SHORT, 5125 = UNSIGNED_INT)
      let indicesArray;
      switch (binaryI.componentType) {
        case 5121:
          // UNSIGNED_BYTE
          indicesArray = new Uint8Array(indicesUint8.buffer, byteOffsetI, byteLengthI);
          break;
        case 5123:
          // UNSIGNED_SHORT
          indicesArray = new Uint16Array(indicesUint8.buffer, byteOffsetI, byteLengthI / 2);
          break;
        case 5125:
          // UNSIGNED_INT
          indicesArray = new Uint32Array(indicesUint8.buffer, byteOffsetI, byteLengthI / 4);
          break;
        default:
          throw new Error("Unknown index componentType");
      }
      this.mesh.indices = indicesArray;
      // W
      let weightsView = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].weights.view;
      this.mesh.weightsView = weightsView;
      let primitive = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex];
      let finalRoundedWeights = this.getAccessorArray(_glbFile, primitive.weights.weightsAccessIndex);
      const weightsArray = finalRoundedWeights;
      // Normalize each group of 4
      for (let i = 0; i < weightsArray.length; i += 4) {
        const sum = weightsArray[i] + weightsArray[i + 1] + weightsArray[i + 2] + weightsArray[i + 3];
        if (sum > 0) {
          const inv = 1 / sum;
          weightsArray[i] *= inv;
          weightsArray[i + 1] *= inv;
          weightsArray[i + 2] *= inv;
          weightsArray[i + 3] *= inv;
        } else {
          weightsArray[i] = 1;
          weightsArray[i + 1] = 0;
          weightsArray[i + 2] = 0;
          weightsArray[i + 3] = 0;
        }
      }
      for (let i = 0; i < weightsArray.length; i += 4) {
        const s = weightsArray[i] + weightsArray[i + 1] + weightsArray[i + 2] + weightsArray[i + 3];
        if (Math.abs(s - 1.0) > 0.001) console.warn("Weight not normalized!", i, s);
      }
      this.mesh.weightsBuffer = this.device.createBuffer({
        label: "weightsBuffer real data",
        size: weightsArray.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Float32Array(this.mesh.weightsBuffer.getMappedRange()).set(weightsArray);
      this.mesh.weightsBuffer.unmap();
      let jointsView = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].joints.view;
      this.mesh.jointsView = jointsView;
      // Create typed array from the buffer (Uint16Array or Uint8Array depending on GLB)
      let jointsArray16 = new Uint16Array(jointsView.buffer, jointsView.byteOffset || 0, jointsView.byteLength / 2 // in Uint16 elements
      );
      const jointsArray32 = new Uint32Array(jointsArray16.length);
      for (let i = 0; i < jointsArray16.length; i++) {
        jointsArray32[i] = jointsArray16[i];
      }
      // Create GPU buffer for joints
      this.mesh.jointsBuffer = this.device.createBuffer({
        label: "jointsBuffer[real-data]",
        size: jointsArray32.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      // Upload the data to GPU
      new Uint32Array(this.mesh.jointsBuffer.getMappedRange()).set(jointsArray32);
      this.mesh.jointsBuffer.unmap();

      // TANGENTS
      let tangentArray = null;
      if (_glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].tangents) {
        const tangentView = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].tangents.view;
        const byteOffsetT = tangentView.byteOffset || 0;
        const byteLengthT = tangentView.buffer.byteLength;
        tangentArray = new Float32Array(tangentView.buffer, byteOffsetT, byteLengthT / 4);
        this.mesh.tangents = tangentArray;
        this.mesh.tangentsBuffer = this.device.createBuffer({
          label: "tangentsBuffer[real-data]",
          size: tangentArray.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          mappedAtCreation: true
        });
        new Float32Array(this.mesh.tangentsBuffer.getMappedRange()).set(tangentArray);
        this.mesh.tangentsBuffer.unmap();
      } else {
        // Dummy
        const dummyTangents = new Float32Array(this.mesh.vertices.length / 3 * 4);
        for (let i = 0; i < dummyTangents.length; i += 4) {
          dummyTangents[i + 0] = 1.0; // T = (1,0,0)
          dummyTangents[i + 1] = 0.0;
          dummyTangents[i + 2] = 0.0;
          dummyTangents[i + 3] = 1.0; // handedness
        }
        this.mesh.tangentsBuffer = this.device.createBuffer({
          label: "tangentsBuffer dummy",
          size: dummyTangents.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          mappedAtCreation: true
        });
        new Float32Array(this.mesh.tangentsBuffer.getMappedRange()).set(dummyTangents);
        this.mesh.tangentsBuffer.unmap();
        console.warn("GLTF primitive has no TANGENT attribute (normal map won’t work properly).");
      }
    } else {
      this.mesh.uvs = this.mesh.textures;
    }
    // ObjSequence animation
    if (typeof o.objAnim !== 'undefined' && o.objAnim != null) {
      this.objAnim = o.objAnim;
      for (var key in this.objAnim.animations) {
        if (key != 'active') this.objAnim.animations[key].speedCounter = 0;
      }
      console.log(`%c Mesh objAnim exist: ${o.objAnim}`, _utils.LOG_FUNNY_SMALL);
      this.drawElements = this.drawElementsAnim;
    }
    this.inputHandler = inputHandler;
    this.cameras = o.cameras;
    this.mainCameraParams = {
      type: o.mainCameraParams.type,
      responseCoef: o.mainCameraParams.responseCoef
    };
    this.lastFrameMS = 0;
    this.texturesPaths = [];
    o.texturesPaths.forEach(t => {
      this.texturesPaths.push(t);
    });
    this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
    this.position = new _matrixClass.Position(o.position.x, o.position.y, o.position.z);
    this.rotation = new _matrixClass.Rotation(o.rotation.x, o.rotation.y, o.rotation.z);
    this.rotation.rotationSpeed.x = o.rotationSpeed.x;
    this.rotation.rotationSpeed.y = o.rotationSpeed.y;
    this.rotation.rotationSpeed.z = o.rotationSpeed.z;
    this.scale = o.scale;
    // new dummy for skin mesh
    if (!this.joints) {
      const jointsData = new Uint32Array(this.mesh.vertices.length / 3 * 4);
      const jointsBuffer = this.device.createBuffer({
        label: "jointsBuffer",
        size: jointsData.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Uint32Array(jointsBuffer.getMappedRange()).set(jointsData);
      jointsBuffer.unmap();
      this.joints = {
        data: jointsData,
        buffer: jointsBuffer,
        stride: 16 // vec4<u32>
      };
      const numVerts = this.mesh.vertices.length / 3;
      // Weights data (vec4<f32>) – default all weight to bone 0
      const weightsData = new Float32Array(numVerts * 4);
      for (let i = 0; i < numVerts; i++) {
        weightsData[i * 4 + 0] = 1.0; // 100% influence of bone 0
        weightsData[i * 4 + 1] = 0.0;
        weightsData[i * 4 + 2] = 0.0;
        weightsData[i * 4 + 3] = 0.0;
      }
      // GPU buffer
      const weightsBuffer = this.device.createBuffer({
        label: "weightsBuffer dummy",
        size: weightsData.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Float32Array(weightsBuffer.getMappedRange()).set(weightsData);
      weightsBuffer.unmap();
      this.weights = {
        data: weightsData,
        buffer: weightsBuffer,
        stride: 16 // vec4<f32>
      };
    }
    this.runProgram = () => {
      return new Promise(async resolve => {
        this.shadowDepthTextureSize = 1024;
        this.modelViewProjectionMatrix = _wgpuMatrix.mat4.create();
        this.loadTex0(this.texturesPaths).then(() => {
          resolve();
        });
      });
    };
    this.runProgram().then(() => {
      this.context.configure({
        device: this.device,
        format: this.presentationFormat,
        alphaMode: 'premultiplied'
      });

      // Create the model vertex buffer.
      this.vertexBuffer = this.device.createBuffer({
        size: this.mesh.vertices.length * Float32Array.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      {
        new Float32Array(this.vertexBuffer.getMappedRange()).set(this.mesh.vertices);
        this.vertexBuffer.unmap();
      }

      // Create the model vertex buffer.
      this.vertexNormalsBuffer = this.device.createBuffer({
        size: this.mesh.vertexNormals.length * Float32Array.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      {
        new Float32Array(this.vertexNormalsBuffer.getMappedRange()).set(this.mesh.vertexNormals);
        this.vertexNormalsBuffer.unmap();
      }
      this.vertexTexCoordsBuffer = this.device.createBuffer({
        size: this.mesh.textures.length * Float32Array.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      {
        new Float32Array(this.vertexTexCoordsBuffer.getMappedRange()).set(this.mesh.textures);
        this.vertexTexCoordsBuffer.unmap();
      }

      // Create the model index buffer.
      this.indexCount = this.mesh.indices.length;
      const indexCount = this.mesh.indices.length;
      const size = Math.ceil(indexCount * Uint16Array.BYTES_PER_ELEMENT / 4) * 4;
      this.indexBuffer = this.device.createBuffer({
        size,
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Uint16Array(this.indexBuffer.getMappedRange()).set(this.mesh.indices);
      this.indexBuffer.unmap();
      this.indexCount = indexCount;
      let glbInfo = {
        arrayStride: 4 * 4,
        // vec4<f32> = 4 * 4 bytes
        attributes: [{
          format: 'float32x4',
          offset: 0,
          shaderLocation: 4
        }]
      };
      this.vertexBuffers = [{
        arrayStride: Float32Array.BYTES_PER_ELEMENT * 3,
        attributes: [{
          // position
          shaderLocation: 0,
          offset: 0,
          format: "float32x3"
        }]
      }, {
        arrayStride: Float32Array.BYTES_PER_ELEMENT * 3,
        attributes: [{
          // normal
          shaderLocation: 1,
          offset: 0,
          format: "float32x3"
        }]
      }, {
        arrayStride: Float32Array.BYTES_PER_ELEMENT * 2,
        attributes: [{
          // uvs
          shaderLocation: 2,
          offset: 0,
          format: "float32x2"
        }]
      },
      // joint indices
      {
        arrayStride: 4 * 4,
        attributes: [{
          format: 'uint32x4',
          offset: 0,
          shaderLocation: 3
        }]
      },
      // weights
      glbInfo];
      if (this.mesh.tangentsBuffer) {
        this.vertexBuffers.push({
          arrayStride: 4 * 4,
          attributes: [{
            shaderLocation: 5,
            format: "float32x4",
            offset: 0
          }]
        });
      }

      // Note: The frontFace and cullMode values have no effect on the 
      // "point-list", "line-list", or "line-strip" topologies.
      this.primitive = {
        topology: 'triangle-list',
        cullMode: 'back',
        // typical for shadow passes
        frontFace: 'ccw'
      };
      this.mirrorBindGroupLayout = this.device.createBindGroupLayout({
        label: 'mirrorBindGroupLayout',
        entries: [{
          binding: 0,
          visibility: GPUShaderStage.FRAGMENT,
          buffer: {
            type: 'uniform',
            minBindingSize: 80
          }
        }, {
          binding: 1,
          visibility: GPUShaderStage.FRAGMENT,
          texture: {
            sampleType: 'float',
            viewDimension: '2d',
            multisampled: false
          }
        }, {
          binding: 2,
          visibility: GPUShaderStage.FRAGMENT,
          sampler: {
            type: 'filtering'
          }
        }]
      });

      // Create a bind group layout which holds the scene uniforms and
      // the texture+sampler for depth. We create it manually because the WebPU
      // implementation doesn't infer this from the shader (yet).
      this.createLayoutForRender();

      // EDIT INSTANCED PART
      this.instanceTargets = [];
      this.lerpSpeed = 0.05;
      this.lerpSpeedAlpha = 0.05;
      this.maxInstances = 5;
      this.instanceCount = 2;
      this.floatsPerInstance = 16 + 4;
      for (let x = 0; x < this.maxInstances; x++) {
        this.instanceTargets.push({
          index: x,
          position: [0, 0, 0],
          currentPosition: [0, 0, 0],
          scale: [1, 1, 1],
          currentScale: [1, 1, 1],
          color: [0.6, 0.8, 1.0, 0.4],
          currentColor: [0.6, 0.8, 1.0, 0.4]
        });
      }
      this.instanceData = new Float32Array(this.instanceCount * this.floatsPerInstance);
      this.instanceBuffer = device.createBuffer({
        size: this.instanceData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
      });
      this.updateInstanceData = modelMatrix => {
        // original (base instance)
        this.instanceData.set(modelMatrix, 0);
        this.instanceData.set([1, 1, 1, 1], 16);

        // instanced clones
        for (let i = 1; i < this.instanceCount; i++) {
          const t = this.instanceTargets[i];
          const ghost = new Float32Array(modelMatrix);
          // --- Smooth interpolate position
          for (let j = 0; j < 3; j++) {
            t.currentPosition[j] += (t.position[j] - t.currentPosition[j]) * this.lerpSpeed;
            t.currentScale[j] += (t.scale[j] - t.currentScale[j]) * this.lerpSpeed;
            t.currentColor[j] += (t.color[j] - t.currentColor[j]) * this.lerpSpeed;
            if (j == 2) {
              t.currentColor[j + 1] += (t.color[j + 1] - t.currentColor[j + 1]) * this.lerpSpeedAlpha;
            }
          }
          // Apply smoothed transforms
          ghost[0] *= t.currentScale[0];
          ghost[5] *= t.currentScale[1];
          ghost[10] *= t.currentScale[2];
          // pos
          ghost[12] += t.currentPosition[0]; // X
          ghost[13] += t.currentPosition[1]; // Y
          ghost[14] += t.currentPosition[2]; // Z

          // t.color[0] += t.currentColor[0]//r;
          // t.color[1] += t.currentColor[1]//r;
          // t.color[2] += t.currentColor[2]//r;
          // t.color[3] += t.currentColor[3]//r;
          // Write instance matrix + color
          const offset = 20 * i;
          this.instanceData.set(ghost, offset);
          this.instanceData.set(t.currentColor, offset + 16);
        }
        device.queue.writeBuffer(this.instanceBuffer, 0, this.instanceData);
      };
      this.updateInstances = newCount => {
        if (newCount > this.maxInstances) {
          console.error(`Instance count ${newCount} exceeds buffer max ${this.maxInstances}`);
          return;
        }
        this.instanceCount = newCount;
        this.instanceData = new Float32Array(this.instanceCount * this.floatsPerInstance);
        this.instanceBuffer = device.createBuffer({
          label: 'instanceBuffer in bvh mesh [instanced]',
          size: this.instanceData.byteLength,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
        });
        let m = this.getModelMatrix(this.position, this.useScale);
        this.updateInstanceData(m);
        this.modelBindGroupInstanced = this.device.createBindGroup({
          label: 'modelBindGroup in mesh [instanced]',
          layout: this.uniformBufferBindGroupLayoutInstanced,
          entries: [
          //
          {
            binding: 0,
            resource: {
              buffer: this.instanceBuffer
            }
          }, {
            binding: 1,
            resource: {
              buffer: this.bonesBuffer
            }
          }, {
            binding: 2,
            resource: {
              buffer: this.vertexAnimBuffer
            }
          }]
        });
      };
      this.updateMaxInstances = newMax => {
        let isBigger = false;
        this.instanceTargets = [];
        if (this.maxInstances < newMax) {
          isBigger = true;
        }
        this.maxInstances = newMax;
        for (let x = 0; x < this.maxInstances; x++) {
          this.instanceTargets.push({
            index: x,
            position: [0, 0, 0],
            currentPosition: [0, 0, 0],
            scale: [1, 1, 1],
            currentScale: [1, 1, 1],
            color: [0.6, 0.8, 1.0, 0.4],
            currentColor: [0.6, 0.8, 1.0, 0.4]
          });
        }
        if (isBigger == false) {
          console.log('new max values is smaller than current - auto correct updateInstances(newMax)');
          this.updateInstances(newMax);
        }
      };
      // end of instanced

      this.modelUniformBuffer = this.device.createBuffer({
        size: 4 * 16,
        // 4x4 matrix
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      this.sceneUniformBuffer = this.device.createBuffer({
        label: 'sceneUniformBuffer per mesh',
        size: 192,
        //176,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });

      // test MUST BE IF
      this.uniformBufferBindGroupLayoutInstanced = this.device.createBindGroupLayout({
        label: 'uniformBufferBindGroupLayout in mesh [instanced]',
        entries: [{
          binding: 0,
          visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
          buffer: {
            type: "read-only-storage"
          }
        }, {
          binding: 1,
          visibility: GPUShaderStage.VERTEX,
          buffer: {
            type: 'uniform'
          }
        }, {
          binding: 2,
          visibility: GPUShaderStage.VERTEX,
          buffer: {
            type: 'uniform'
          }
        }]
      });
      this.uniformBufferBindGroupLayout = this.device.createBindGroupLayout({
        label: 'uniformBufferBindGroupLayout in mesh [regular]',
        entries: [{
          binding: 0,
          visibility: GPUShaderStage.VERTEX,
          buffer: {
            type: 'uniform'
          }
        }, {
          binding: 1,
          visibility: GPUShaderStage.VERTEX,
          buffer: {
            type: 'uniform'
          }
        }, {
          binding: 2,
          visibility: GPUShaderStage.VERTEX,
          buffer: {
            type: 'uniform'
          }
        }]
      });

      // dummy for non skin mesh like this class
      function alignTo256(n) {
        return Math.ceil(n / 256) * 256;
      }
      let MAX_BONES = 100;
      this.MAX_BONES = MAX_BONES;
      // this.bonesBuffer = device.createBuffer({
      //   label: "bonesBuffer",
      //   size: alignTo256(64 * MAX_BONES),
      //   usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      // });

      // const bones = new Float32Array(this.MAX_BONES * 16);
      // for(let i = 0;i < this.MAX_BONES;i++) {
      //   // identity matrices
      //   bones.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], i * 16);
      // }
      // this.device.queue.writeBuffer(this.bonesBuffer, 0, bones);
      const TRAIL_INSTANCES = 10; // your total instance count
      const BYTES_PER_INSTANCE = alignTo256(64 * this.MAX_BONES);
      this.bonesBuffer = device.createBuffer({
        label: "bonesBuffer",
        size: BYTES_PER_INSTANCE * TRAIL_INSTANCES,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });

      // identity init for all slots
      const bones = new Float32Array(this.MAX_BONES * 16 * TRAIL_INSTANCES);
      for (let i = 0; i < this.MAX_BONES * TRAIL_INSTANCES; i++) {
        bones.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], i * 16);
      }
      this.device.queue.writeBuffer(this.bonesBuffer, 0, bones);

      //
      // vertex Anim
      this.vertexAnimParams = new Float32Array([0.0, 0.0, 0.0, 0.0, 2.0, 0.1, 2.0, 0.0, 1.5, 0.3, 2.0, 0.5, 1.0, 0.1, 0.0, 0.0, 1.0, 0.5, 0.0, 0.0, 1.0, 0.05, 0.5, 0.0, 1.0, 0.05, 2.0, 0.0, 1.0, 0.1, 0.0, 0.0]);
      this.vertexAnimBuffer = this.device.createBuffer({
        label: "Vertex Animation Params",
        size: Math.ceil(this.vertexAnimParams.byteLength / 256) * 256,
        // 256, //this.vertexAnimParams.byteLength, // 128 bytes
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      this.vertexAnim = {
        enableWave: () => {
          this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS.WAVE;
          this.updateVertexAnimBuffer();
        },
        disableWave: () => {
          this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS.WAVE;
          this.updateVertexAnimBuffer();
        },
        enableWind: () => {
          this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS.WIND;
          this.updateVertexAnimBuffer();
        },
        disableWind: () => {
          this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS.WIND;
          this.updateVertexAnimBuffer();
        },
        enablePulse: () => {
          this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS.PULSE;
          this.updateVertexAnimBuffer();
        },
        disablePulse: () => {
          this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS.PULSE;
          this.updateVertexAnimBuffer();
        },
        enableTwist: () => {
          this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS.TWIST;
          this.updateVertexAnimBuffer();
        },
        disableTwist: () => {
          this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS.TWIST;
          this.updateVertexAnimBuffer();
        },
        enableNoise: () => {
          this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS.NOISE;
          this.updateVertexAnimBuffer();
        },
        disableNoise: () => {
          this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS.NOISE;
          this.updateVertexAnimBuffer();
        },
        enableOcean: () => {
          this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS.OCEAN;
          this.updateVertexAnimBuffer();
        },
        disableOcean: () => {
          this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS.OCEAN;
          this.updateVertexAnimBuffer();
        },
        enable: (...effects) => {
          effects.forEach(effect => {
            this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS[effect.toUpperCase()];
          });
          this.updateVertexAnimBuffer();
        },
        disable: (...effects) => {
          effects.forEach(effect => {
            this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS[effect.toUpperCase()];
          });
          this.updateVertexAnimBuffer();
        },
        disableAll: () => {
          this.vertexAnimParams[1] = 0;
          this.updateVertexAnimBuffer();
        },
        isEnabled: effect => {
          return (this.vertexAnimParams[1] & _literals.VERTEX_ANIM_FLAGS[effect.toUpperCase()]) !== 0;
        },
        setWaveParams: (speed, amplitude, frequency) => {
          this.vertexAnimParams[4] = speed;
          this.vertexAnimParams[5] = amplitude;
          this.vertexAnimParams[6] = frequency;
          this.updateVertexAnimBuffer();
        },
        setWindParams: (speed, strength, heightInfluence, turbulence) => {
          this.vertexAnimParams[8] = speed;
          this.vertexAnimParams[9] = strength;
          this.vertexAnimParams[10] = heightInfluence;
          this.vertexAnimParams[11] = turbulence;
          this.updateVertexAnimBuffer();
        },
        setPulseParams: (speed, amount, centerX = 0, centerY = 0) => {
          this.vertexAnimParams[12] = speed;
          this.vertexAnimParams[13] = amount;
          this.vertexAnimParams[14] = centerX;
          this.vertexAnimParams[15] = centerY;
          this.updateVertexAnimBuffer();
        },
        setTwistParams: (speed, amount) => {
          this.vertexAnimParams[16] = speed;
          this.vertexAnimParams[17] = amount;
          this.updateVertexAnimBuffer();
        },
        setNoiseParams: (scale, strength, speed) => {
          this.vertexAnimParams[20] = scale;
          this.vertexAnimParams[21] = strength;
          this.vertexAnimParams[22] = speed;
          this.updateVertexAnimBuffer();
        },
        setOceanParams: (scale, height, speed) => {
          this.vertexAnimParams[24] = scale;
          this.vertexAnimParams[25] = height;
          this.vertexAnimParams[26] = speed;
          this.updateVertexAnimBuffer();
        },
        setIntensity: value => {
          this.vertexAnimParams[2] = Math.max(0, Math.min(1, value));
          this.updateVertexAnimBuffer();
        },
        getIntensity: () => {
          return this.vertexAnimParams[2];
        }
      };
      this.updateVertexAnimBuffer = () => {
        this.device.queue.writeBuffer(this.vertexAnimBuffer, 0, this.vertexAnimParams);
      };

      // globalIntensity
      this.vertexAnimParams[2] = 1.0;
      this.updateVertexAnimBuffer();
      this.updateTime = time => {
        this.time += time * this.deltaTimeAdapter;
        this.vertexAnimParams[0] = time;
        this.device.queue.writeBuffer(this.vertexAnimBuffer, 0, this.vertexAnimParams);
        // const effectMix = 0.5 + 0.5 * Math.sin(this.time * 0.5);
        // Pass explicit alpha — 0.5 = semi transparent
        // this.setupMaterialPBR([1.0, 1.0, 1.0, 0.5], false, false, effectMix, 1.0);
      };
      //
      this.modelBindGroup = this.device.createBindGroup({
        label: 'modelBindGroup in mesh',
        layout: this.uniformBufferBindGroupLayout,
        entries: [{
          binding: 0,
          resource: {
            buffer: this.modelUniformBuffer
          }
        }, {
          binding: 1,
          resource: {
            buffer: this.bonesBuffer
          }
        }, {
          binding: 2,
          resource: {
            buffer: this.vertexAnimBuffer
          }
        }]
      });
      this.modelBindGroupInstanced = this.device.createBindGroup({
        label: 'modelBindGroup in mesh [instanced]',
        layout: this.uniformBufferBindGroupLayoutInstanced,
        entries: [
        //
        {
          binding: 0,
          resource: {
            buffer: this.instanceBuffer
          }
        }, {
          binding: 1,
          resource: {
            buffer: this.bonesBuffer
          }
        }, {
          binding: 2,
          resource: {
            buffer: this.vertexAnimBuffer
          }
        }]
      });
      this.mainPassBindGroupLayout = this.device.createBindGroupLayout({
        label: 'mainPassBindGroupLayout mesh [instaced]',
        entries: [{
          binding: 0,
          visibility: GPUShaderStage.FRAGMENT,
          texture: {
            sampleType: 'depth'
          }
        }, {
          binding: 1,
          visibility: GPUShaderStage.FRAGMENT,
          sampler: {
            type: 'comparison'
          }
        }]
      });
      this.effects = {};
      // console.log('>>>>>>>>>>>>>EFFECTS>>>>>>>>>>>>>>>>>>>>>>>')
      if (this.pointerEffect && this.pointerEffect.enabled === true) {
        let pf = navigator.gpu.getPreferredCanvasFormat();
        pf = 'rgba16float';
        if (typeof this.pointerEffect.pointer !== 'undefined' && this.pointerEffect.pointer == true) {
          this.effects.pointer = new _pointerEffect.PointerEffect(device, pf, this, true);
        }
        if (typeof this.pointerEffect.ballEffect !== 'undefined' && this.pointerEffect.ballEffect == true) {
          this.effects.ballEffect = new _gen.GenGeo(device, pf, 'sphere');
        }
        if (typeof this.pointerEffect.energyBar !== 'undefined' && this.pointerEffect.energyBar == true) {
          this.effects.energyBar = new _energyBar.HPBarEffect(device, pf);
          this.effects.manaBar = new _manaBar.MANABarEffect(device, pf);
        }
        if (typeof this.pointerEffect.flameEffect !== 'undefined' && this.pointerEffect.flameEffect == true) {
          this.effects.flameEffect = new _flame.FlameEffect(device, pf);
        }
        if (typeof this.pointerEffect.pointEffect !== 'undefined' && this.pointerEffect.pointEffect == true) {
          this.effects.pointEffect = new PointEffect(device, pf);
        }
        if (typeof this.pointerEffect.flameEmitter !== 'undefined' && this.pointerEffect.flameEmitter == true) {
          this.effects.flameEmitter = new _flameEmmiter.FlameEmitter(device, pf);
        }
        if (typeof this.pointerEffect.circlePlane !== 'undefined' && this.pointerEffect.circlePlane == true) {
          this.effects.circlePlane = new _gen.GenGeo(device, pf, 'circlePlane');
        }
        if (typeof this.pointerEffect.circlePlaneTex !== 'undefined' && this.pointerEffect.circlePlaneTex == true) {
          this.effects.circlePlaneTex = new _genTex.GenGeoTexture(device, pf, 'ring', this.pointerEffect.circlePlaneTexPath);
        }
        if (typeof this.pointerEffect.circle !== 'undefined' && this.pointerEffect.circlePlaneTexPath !== 'undefined') {
          this.effects.circle = new _genTex2.GenGeoTexture2(device, pf, 'circle2', this.pointerEffect.circlePlaneTexPath);
        }
      }

      // Rotates the camera around the origin based on time.
      this.getTransformationMatrix = (mainRenderBundle, spotLight, index) => {
        const now = Date.now();
        const dt = (now - this.lastFrameMS) / this.mainCameraParams.responseCoef;
        this.lastFrameMS = now;
        const camera = this.cameras[this.mainCameraParams.type];
        if (index == 0) camera.update(dt, inputHandler());
        const camVP = _wgpuMatrix.mat4.multiply(camera.projectionMatrix, camera.view);
        this._sceneData.set(spotLight.viewProjMatrix, 0);
        this._sceneData.set(camVP, 16);
        this._sceneData[32] = camera.position[0];
        this._sceneData[33] = camera.position[1];
        this._sceneData[34] = camera.position[2];
        this._sceneData[35] = 0.0;
        this._sceneData[36] = spotLight.position[0];
        this._sceneData[37] = spotLight.position[1];
        this._sceneData[38] = spotLight.position[2];
        this._sceneData[39] = 0.0;
        this._sceneData[40] = this.globalAmbient[0];
        this._sceneData[41] = this.globalAmbient[1];
        this._sceneData[42] = this.globalAmbient[2];
        this._sceneData[43] = 0.0;
        this._sceneData[44] = this.time;
        this._sceneData[45] = dt;
        this._sceneData[46] = 0;
        this._sceneData[47] = 0;
        device.queue.writeBuffer(this.sceneUniformBuffer, 0, this._sceneData.buffer, this._sceneData.byteOffset, this._sceneData.byteLength);
      };
      this.getModelMatrix = (pos, useScale = false) => {
        let modelMatrix = _wgpuMatrix.mat4.identity();
        _wgpuMatrix.mat4.translate(modelMatrix, [pos.x, pos.y, pos.z], modelMatrix);
        if (this.itIsPhysicsBody) {
          _wgpuMatrix.mat4.rotate(modelMatrix, [this.rotation.axis.x, this.rotation.axis.y, this.rotation.axis.z], (0, _utils.degToRad)(this.rotation.angle), modelMatrix);
        } else {
          _wgpuMatrix.mat4.rotateX(modelMatrix, this.rotation.getRotX(), modelMatrix);
          _wgpuMatrix.mat4.rotateY(modelMatrix, this.rotation.getRotY(), modelMatrix);
          _wgpuMatrix.mat4.rotateZ(modelMatrix, this.rotation.getRotZ(), modelMatrix);
        }
        if (useScale == true) _wgpuMatrix.mat4.scale(modelMatrix, [this.scale[0], this.scale[1], this.scale[2]], modelMatrix);
        return modelMatrix;
      };
      this.done = true;
      if (this.texturesPaths.length > 1 && this.material.type == "mirror") {
        this.loadEnvMap(this.texturesPaths, true).then(envTexture => {
          this.envMapParams.envTexture = envTexture;
          this.mirrorBindGroup = this.createMirrorIlluminateBindGroup(this.mirrorBindGroupLayout, this.envMapParams).bindGroup;
          try {
            this.setupPipeline();
          } catch (err) {
            console.log('Err[create pipeline]:', err);
          }
        });
      } else {
        try {
          this.setupPipeline();
        } catch (err) {
          console.log('Err[create pipeline]:', err);
        }
      }
    }).then(() => {
      if (typeof this.objAnim !== 'undefined' && this.objAnim !== null) {
        console.log('updateMeshListBuffers...');
        this.updateMeshListBuffers();
      }
    });
  }
  setupPipeline = () => {
    this.createBindGroupForRender();
    const pipelineLayout = this.device.createPipelineLayout({
      label: 'PipelineLayout Mesh',
      bindGroupLayouts: [this.bglForRender, this.uniformBufferBindGroupLayoutInstanced, this.material.type === 'mirror' ? this.mirrorBindGroupLayout : null]
    });
    const vertexModule = this.device.createShaderModule({
      label: 'VertexShader Mesh',
      code: _vertexInstanced.vertexWGSLInstanced
    });
    const fragmentModule = this.device.createShaderModule({
      label: 'FragmentShader Mesh',
      code: this.isVideo == true ? _fragmentVideo.fragmentVideoWGSL : this.getMaterial()
    });
    const vertexState = {
      entryPoint: 'main',
      module: vertexModule,
      buffers: this.vertexBuffers
    };
    const fragmentConstants = {
      shadowDepthTextureSize: this.shadowDepthTextureSize
    };

    // ── Opaque pipeline ───────────────────────────────────────────────────────
    this.pipeline = this.device.createRenderPipeline({
      label: 'Pipeline Opaque ✅',
      layout: pipelineLayout,
      vertex: vertexState,
      fragment: {
        entryPoint: 'main',
        module: fragmentModule,
        constants: fragmentConstants,
        targets: [{
          format: 'rgba16float'
        }]
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: 'less',
        format: 'depth24plus'
      },
      primitive: this.primitive
    });

    // ── Transparent pipeline ──────────────────────────────────────────────────
    this.pipelineTransparent = this.device.createRenderPipeline({
      label: 'Pipeline Transparent ✅',
      layout: pipelineLayout,
      vertex: vertexState,
      fragment: {
        entryPoint: 'main',
        module: fragmentModule,
        constants: fragmentConstants,
        targets: [{
          format: 'rgba16float',
          blend: {
            color: {
              srcFactor: 'src-alpha',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add'
            },
            alpha: {
              srcFactor: 'one',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add'
            }
          }
        }]
      },
      depthStencil: {
        depthWriteEnabled: false,
        // transparent never writes depth
        depthCompare: 'less',
        format: 'depth24plus'
      },
      primitive: this.primitive
    });
  };
  updateModelUniformBuffer = () => {};
  createGPUBuffer(dataArray, usage) {
    if (!dataArray || typeof dataArray.length !== 'number') {
      throw new Error('Invalid array passed to createGPUBuffer');
    }
    const size = dataArray.length * dataArray.BYTES_PER_ELEMENT;
    if (!Number.isFinite(size) || size <= 0) {
      throw new Error(`Invalid buffer size: ${size}`);
    }
    const buffer = this.device.createBuffer({
      size,
      usage,
      mappedAtCreation: true
    });
    const writeArray = dataArray.constructor === Float32Array ? new Float32Array(buffer.getMappedRange()) : new Uint16Array(buffer.getMappedRange());
    writeArray.set(dataArray);
    buffer.unmap();
    return buffer;
  }
  updateMeshListBuffers() {
    for (const key in this.objAnim.meshList) {
      const mesh = this.objAnim.meshList[key];
      mesh.vertexBuffer = this.device.createBuffer({
        size: mesh.vertices.length * Float32Array.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      new Float32Array(mesh.vertexBuffer.getMappedRange()).set(mesh.vertices);
      mesh.vertexBuffer.unmap();
      // Normals
      mesh.vertexNormalsBuffer = this.device.createBuffer({
        size: mesh.vertexNormals.length * Float32Array.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      new Float32Array(mesh.vertexNormalsBuffer.getMappedRange()).set(mesh.vertexNormals);
      mesh.vertexNormalsBuffer.unmap();
      // UVs
      mesh.vertexTexCoordsBuffer = this.device.createBuffer({
        size: mesh.textures.length * Float32Array.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      new Float32Array(mesh.vertexTexCoordsBuffer.getMappedRange()).set(mesh.textures);
      mesh.vertexTexCoordsBuffer.unmap();
      // Indices
      const indexCount = mesh.indices.length;
      const indexSize = Math.ceil(indexCount * Uint16Array.BYTES_PER_ELEMENT / 4) * 4;
      mesh.indexBuffer = this.device.createBuffer({
        size: indexSize,
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Uint16Array(mesh.indexBuffer.getMappedRange()).set(mesh.indices);
      mesh.indexBuffer.unmap();
      mesh.indexCount = indexCount;
    }
  }
  drawElements = (pass, lightContainer) => {
    if (this.isVideo) {
      this.updateVideoTexture();
    }
    pass.setBindGroup(0, this.sceneBindGroupForRender);
    if (this instanceof _bvhInstaced.BVHPlayerInstances) {
      pass.setBindGroup(1, this.modelBindGroupInstanced);
    } else {
      pass.setBindGroup(1, this.modelBindGroup);
    }

    // Bind each light’s shadow texture & sampler
    if (this.isVideo == false) {
      if (this.material.type === "mirror" && this.mirrorBindGroup) {
        pass.setBindGroup(2, this.mirrorBindGroup);
      } else if (this.isVideo == false) {
        let bindIndex = 2;
        for (const light of lightContainer) {
          pass.setBindGroup(bindIndex++, light.getMainPassBindGroup(this));
        }
      }
    }
    pass.setBindGroup(3, this.waterBindGroup);
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setVertexBuffer(1, this.vertexNormalsBuffer);
    pass.setVertexBuffer(2, this.vertexTexCoordsBuffer);
    if (this.joints) {
      if (this.constructor.name === "BVHPlayer" || this.constructor.name === "BVHPlayerInstances") {
        pass.setVertexBuffer(3, this.mesh.jointsBuffer); // real
        pass.setVertexBuffer(4, this.mesh.weightsBuffer); //real
      } else {
        pass.setVertexBuffer(3, this.joints.buffer); // new dummy
        pass.setVertexBuffer(4, this.weights.buffer); // new dummy
      }
    }
    if (this.mesh.tangentsBuffer) {
      pass.setVertexBuffer(5, this.mesh.tangentsBuffer);
    }
    if (this.material.useBlend == true) pass.setPipeline(this.pipelineTransparent);else pass.setPipeline(this.pipeline);
    pass.setIndexBuffer(this.indexBuffer, 'uint16');
    for (var ins = 1; ins < this.instanceCount; ins++) {
      if (ins == 0) pass.drawIndexed(this.indexCount, 0, 0, 0, ins);else pass.drawIndexed(this.indexCount, 1, 0, 0, ins);
    }
  };
  drawElementsAnim = (renderPass, lightContainer) => {
    if (!this.sceneBindGroupForRender || !this.modelBindGroup) {
      console.log(' NULL 1');
      return;
    }
    if (!this.objAnim.meshList[this.objAnim.id + this.objAnim.currentAni]) {
      console.log(' NULL 2');
      return;
    }
    renderPass.setBindGroup(0, this.sceneBindGroupForRender);
    renderPass.setBindGroup(1, this.modelBindGroup);
    const mesh = this.objAnim.meshList[this.objAnim.id + this.objAnim.currentAni];
    if (this.isVideo == false) {
      if (this.material.type === "mirror" && this.mirrorBindGroup) {
        pass.setBindGroup(2, this.mirrorBindGroup);
      } else if (this.isVideo == false) {
        let bindIndex = 2;
        for (const light of lightContainer) {
          pass.setBindGroup(bindIndex++, light.getMainPassBindGroup(this));
        }
      }
    }
    pass.setBindGroup(3, this.waterBindGroup);
    renderPass.setVertexBuffer(0, mesh.vertexBuffer);
    renderPass.setVertexBuffer(1, mesh.vertexNormalsBuffer);
    renderPass.setVertexBuffer(2, mesh.vertexTexCoordsBuffer);
    if (this.constructor.name === "BVHPlayer") {
      renderPass.setVertexBuffer(3, this.mesh.jointsBuffer); // real
      renderPass.setVertexBuffer(4, this.mesh.weightsBuffer); // real
    } else {
      // dummy
      renderPass.setVertexBuffer(3, this.joints.buffer); // dummy
      renderPass.setVertexBuffer(4, this.weights.buffer); // dummy
    }
    renderPass.setIndexBuffer(mesh.indexBuffer, 'uint16');
    renderPass.drawIndexed(mesh.indexCount);
    if (this.objAnim.playing == true) {
      if (this.objAnim.animations[this.objAnim.animations.active].speedCounter >= this.objAnim.animations[this.objAnim.animations.active].speed) {
        this.objAnim.currentAni++;
        this.objAnim.animations[this.objAnim.animations.active].speedCounter = 0;
      } else {
        this.objAnim.animations[this.objAnim.animations.active].speedCounter++;
      }
      if (this.objAnim.currentAni >= this.objAnim.animations[this.objAnim.animations.active].to) {
        this.objAnim.currentAni = this.objAnim.animations[this.objAnim.animations.active].from;
      }
    }
  };
  drawShadows = shadowPass => {
    shadowPass.setVertexBuffer(0, this.vertexBuffer);
    shadowPass.setVertexBuffer(1, this.vertexNormalsBuffer);
    shadowPass.setVertexBuffer(2, this.vertexTexCoordsBuffer);
    if (this.joints) {
      if (this.constructor.name === "BVHPlayer" || this.constructor.name === "BVHPlayerInstances") {
        shadowPass.setVertexBuffer(3, this.mesh.jointsBuffer); // real
        shadowPass.setVertexBuffer(4, this.mesh.weightsBuffer); // real
      } else {
        shadowPass.setVertexBuffer(3, this.joints.buffer); // dummy
        shadowPass.setVertexBuffer(4, this.weights.buffer); // dummy
      }
    }
    shadowPass.setIndexBuffer(this.indexBuffer, 'uint16');
    if (this instanceof _bvhInstaced.BVHPlayerInstances) {
      shadowPass.drawIndexed(this.indexCount, this.instanceCount, 0, 0, 0);
    } else {
      shadowPass.drawIndexed(this.indexCount);
    }
  };
}
exports.default = MEMeshObjInstances;

},{"../../shaders/fragment.video.wgsl":64,"../../shaders/instanced/vertex.instanced.wgsl":73,"../effects/energy-bar":27,"../effects/flame":29,"../effects/flame-emmiter":28,"../effects/gen":32,"../effects/gen-tex":30,"../effects/gen-tex2":31,"../effects/mana-bar":34,"../effects/pointerEffect":35,"../literals":43,"../loaders/bvh-instaced":45,"../matrix-class":49,"../utils":56,"./materials-instanced":40,"wgpu-matrix":22}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpotLight = void 0;
var _wgpuMatrix = require("wgpu-matrix");
var _vertexShadow = require("../shaders/vertexShadow.wgsl");
var _behavior = _interopRequireDefault(require("./behavior"));
var _vertexShadowInstanced = require("../shaders/instanced/vertexShadow.instanced.wgsl");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * @description
 * Spot light with shadow cast.
 * @author Nikola Lukic
 * @email zlatnaspirala@gmail.com
 */
class SpotLight {
  name;
  camera;
  inputHandler;
  position;
  target;
  up;
  direction;
  viewMatrix;
  projectionMatrix;
  viewProjMatrix;
  fov;
  aspect;
  near;
  far;
  innerCutoff;
  outerCutoff;
  spotlightUniformBuffer;
  constructor(camera, inputHandler, device, indexx, position = _wgpuMatrix.vec3.create(0, 10, -20), target = _wgpuMatrix.vec3.create(0, 0, -20), fov = 45, aspect = 1.0, near = 0.1, far = 200) {
    aspect = 1; // hot fix
    this.name = "light" + indexx;
    this.getName = () => {
      return "light" + indexx;
    };
    this.fov = fov;
    this.aspect = 1;
    this.near = near;
    this.far = far;
    this.camera = camera;
    this.inputHandler = inputHandler;
    this.position = position;
    this.target = target;
    this.up = _wgpuMatrix.vec3.create(0, 0, -1);
    this.direction = _wgpuMatrix.vec3.normalize(_wgpuMatrix.vec3.subtract(target, position));
    this.intensity = 1.0;
    this.color = _wgpuMatrix.vec3.create(1.0, 1.0, 1.0);
    this.viewMatrix = _wgpuMatrix.mat4.lookAt(position, target, this.up);
    this.projectionMatrix = _wgpuMatrix.mat4.perspective(this.fov * Math.PI / 180, this.aspect, this.near, this.far);
    this.setProjection = function (fov = 2 * Math.PI / 5, aspect = 1.0, near = 0.1, far = 200) {
      this.projectionMatrix = _wgpuMatrix.mat4.perspective(fov, aspect, near, far);
    };
    this.updateProjection = function () {
      this.projectionMatrix = _wgpuMatrix.mat4.perspective(this.fov, this.aspect, this.near, this.far);
    };
    this.device = device;
    this.viewProjMatrix = _wgpuMatrix.mat4.multiply(this.projectionMatrix, this.viewMatrix);
    this.fov = fov;
    this.aspect = aspect;
    this.near = near;
    this.far = far;
    this.innerCutoff = Math.cos(Math.PI / 180 * 20.0);
    this.outerCutoff = Math.cos(Math.PI / 180 * 30.0);
    this.ambientFactor = 0.5;
    this.range = 20.0;
    this.shadowBias = 0.01;
    this.SHADOW_RES = 1024;
    this.primitive = {
      topology: 'triangle-list',
      cullMode: 'back',
      // for front interest border drawen shadows !
      frontFace: 'ccw'
    };
    this.shadowTexture = this.device.createTexture({
      label: 'shadowTexture[light]',
      size: [this.SHADOW_RES, this.SHADOW_RES, 1],
      format: "depth32float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.shadowSampler = device.createSampler({
      label: 'shadowSampler[light]',
      compare: 'less',
      magFilter: 'linear',
      minFilter: 'linear'
    });
    this.renderPassDescriptor = {
      label: "descriptor shadowPass[SpotLigth]",
      colorAttachments: [],
      depthStencilAttachment: {
        view: this.shadowTexture.createView(),
        depthClearValue: 1.0,
        depthLoadOp: "clear",
        depthStoreOp: "store"
      }
    };
    this.uniformBufferBindGroupLayout = this.device.createBindGroupLayout({
      label: 'uniformBufferBindGroupLayout light',
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {
          type: 'uniform'
        }
      }]
    });
    this.shadowBindGroupContainer = [];
    this.shadowBindGroup = [];
    this.getShadowBindGroup = (mesh, index) => {
      if (this.shadowBindGroupContainer[index]) {
        return this.shadowBindGroupContainer[index];
      }
      this.shadowBindGroupContainer[index] = this.device.createBindGroup({
        label: 'sceneBindGroupForShadow light',
        layout: this.uniformBufferBindGroupLayout,
        entries: [{
          binding: 0,
          resource: {
            buffer: mesh.sceneUniformBuffer
          }
        }]
      });
      return this.shadowBindGroupContainer[index];
    };
    this.getShadowBindGroup_bones = index => {
      if (this.shadowBindGroup[index]) return this.shadowBindGroup[index];
      this.modelUniformBuffer = this.device.createBuffer({
        size: 4 * 16,
        // 4x4 matrix
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      this.shadowBindGroup[index] = this.device.createBindGroup({
        label: 'model BindGroupForShadow in light',
        layout: this.uniformBufferBindGroupLayout,
        entries: [{
          binding: 0,
          resource: {
            buffer: this.modelUniformBuffer
          }
        }]
      });
      return this.shadowBindGroup[index];
    };
    this.modelBindGroupLayout = this.device.createBindGroupLayout({
      label: 'modelBindGroupLayout light [one bindings]',
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {
          type: 'uniform'
        }
      }, {
        binding: 1,
        visibility: GPUShaderStage.VERTEX,
        buffer: {
          type: 'uniform'
        }
      }, {
        binding: 2,
        visibility: GPUShaderStage.VERTEX,
        buffer: {
          type: 'uniform'
        }
      }]
    });
    this.modelBindGroupLayoutInstanced = this.device.createBindGroupLayout({
      label: 'modelBindGroupLayout light [skinned][instanced]',
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: {
          type: "read-only-storage"
        }
      }, {
        binding: 1,
        visibility: GPUShaderStage.VERTEX,
        buffer: {
          type: 'uniform'
        }
      }, {
        binding: 2,
        visibility: GPUShaderStage.VERTEX,
        buffer: {
          type: 'uniform'
        }
      }]
    });
    this.shadowPipeline = this.device.createRenderPipeline({
      label: 'shadowPipeline light',
      layout: this.device.createPipelineLayout({
        label: 'uniformBufferBindGroupLayout light[regular]',
        bindGroupLayouts: [this.uniformBufferBindGroupLayout, this.modelBindGroupLayout]
      }),
      vertex: {
        module: this.device.createShaderModule({
          code: _vertexShadow.vertexShadowWGSL
        }),
        buffers: [{
          arrayStride: 12,
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: "float32x3"
          }]
        },
        // ✅ ADD @location(1) - normal
        {
          arrayStride: 12,
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: "float32x3"
          }]
        },
        // ✅ ADD @location(2) - uv
        {
          arrayStride: 8,
          attributes: [{
            shaderLocation: 2,
            offset: 0,
            format: "float32x2"
          }]
        },
        // ✅ ADD @location(3) - joints
        {
          arrayStride: 16,
          attributes: [{
            shaderLocation: 3,
            offset: 0,
            format: "uint32x4"
          }]
        },
        // ✅ ADD @location(4) - weights
        {
          arrayStride: 16,
          attributes: [{
            shaderLocation: 4,
            offset: 0,
            format: "float32x4"
          }]
        }]
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: 'less',
        format: 'depth32float'
      },
      primitive: this.primitive
    });
    this.shadowPipelineInstanced = this.device.createRenderPipeline({
      label: 'shadowPipeline [instanced]light',
      layout: this.device.createPipelineLayout({
        label: 'uniformBufferBindGroupLayout light[instanced]',
        bindGroupLayouts: [this.uniformBufferBindGroupLayout, this.modelBindGroupLayoutInstanced]
      }),
      vertex: {
        module: this.device.createShaderModule({
          code: _vertexShadowInstanced.vertexShadowWGSLInstanced
        }),
        buffers: [{
          arrayStride: 12,
          // 3 * 4 bytes (vec3f)
          attributes: [{
            shaderLocation: 0,
            // must match @location(0) in vertex shader
            offset: 0,
            format: "float32x3"
          }]
        },
        // ✅ ADD @location(1) - normal
        {
          arrayStride: 12,
          attributes: [{
            shaderLocation: 1,
            offset: 0,
            format: "float32x3"
          }]
        },
        // ✅ ADD @location(2) - uv
        {
          arrayStride: 8,
          attributes: [{
            shaderLocation: 2,
            offset: 0,
            format: "float32x2"
          }]
        },
        // ✅ ADD @location(3) - joints
        {
          arrayStride: 16,
          attributes: [{
            shaderLocation: 3,
            offset: 0,
            format: "uint32x4"
          }]
        },
        // ✅ ADD @location(4) - weights
        {
          arrayStride: 16,
          attributes: [{
            shaderLocation: 4,
            offset: 0,
            format: "float32x4"
          }]
        }]
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: 'less',
        depthBias: 2,
        // Constant bias (try 1-4)
        depthBiasSlopeScale: 2.0,
        format: 'depth32float'
      },
      primitive: this.primitive
    });
    this.getMainPassBindGroup = function (mesh) {
      // You can cache it per mesh to avoid recreating each frame
      if (!this.mainPassBindGroupContainer) this.mainPassBindGroupContainer = [];
      const index = mesh._lightBindGroupIndex || 0;
      if (this.mainPassBindGroupContainer[index]) {
        return this.mainPassBindGroupContainer[index];
      }
      this.mainPassBindGroupContainer[index] = this.device.createBindGroup({
        label: `mainPassBindGroup for mesh`,
        layout: mesh.mainPassBindGroupLayout,
        entries: [{
          binding: 0,
          resource: this.shadowTexture.createView()
        }, {
          binding: 1,
          resource: this.shadowSampler
        }]
      });
      return this.mainPassBindGroupContainer[index];
    };

    // Only osc values +-
    this.behavior = new _behavior.default();

    // put here only func
    this.updater = [];
  }
  update() {
    this.updater.forEach(update => {
      update(this);
    });
    this.direction = _wgpuMatrix.vec3.normalize(_wgpuMatrix.vec3.subtract(this.target, this.position));
    const target = _wgpuMatrix.vec3.add(this.position, this.direction);
    this.viewMatrix = _wgpuMatrix.mat4.lookAt(this.position, target, this.up);
    this.viewProjMatrix = _wgpuMatrix.mat4.multiply(this.projectionMatrix, this.viewMatrix);
  }
  getLightDataBuffer() {
    const m = this.viewProjMatrix;
    return new Float32Array([...this.position, 0.0, ...this.direction, 0.0, this.innerCutoff, this.outerCutoff, this.intensity, 0.0, ...this.color, 0.0, this.range, this.ambientFactor, this.shadowBias, 0.0, ...m]);
  }

  // Setters
  setPosX = x => {
    this.position[0] = x;
  };
  setPosY = y => {
    this.position[1] = y;
  };
  setPosZ = z => {
    this.position[2] = z;
  };
  setInnerCutoff = innerCutoff => {
    this.innerCutoff = innerCutoff;
  };
  setOuterCutoff = outerCutoff => {
    this.outerCutoff = outerCutoff;
  };
  setIntensity = intensity => {
    this.intensity = intensity;
  };
  setColor = color => {
    this.color = color;
  };
  setColorR = colorR => {
    this.color[0] = colorR;
  };
  setColorB = colorB => {
    this.color[1] = colorB;
  };
  setColorG = colorG => {
    this.color[2] = colorG;
  };
  setRange = range => {
    this.range = range;
  };
  setAmbientFactor = ambientFactor => {
    this.ambientFactor = ambientFactor;
  };
  setShadowBias = shadowBias => {
    this.shadowBias = shadowBias;
  };
}
exports.SpotLight = SpotLight;

},{"../shaders/instanced/vertexShadow.instanced.wgsl":74,"../shaders/vertexShadow.wgsl":82,"./behavior":24,"wgpu-matrix":22}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERTEX_ANIM_FLAGS = void 0;
const VERTEX_ANIM_FLAGS = exports.VERTEX_ANIM_FLAGS = {
  NONE: 0,
  WAVE: 1 << 0,
  // 1
  WIND: 1 << 1,
  // 2
  PULSE: 1 << 2,
  // 4
  TWIST: 1 << 3,
  // 8
  NOISE: 1 << 4,
  // 16
  OCEAN: 1 << 5,
  // 32
  DISPLACEMENT: 1 << 6 // 64
};

},{}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeObjSeqArg = exports.initMeshBuffers = exports.downloadMeshes = exports.constructMesh = void 0;
exports.play = play;
/**
 * The main Mesh class. The constructor will parse through the OBJ file data
 * and collect the vertex, vertex normal, texture, and face information. This
 * information can then be used later on when creating your VBOs. See
 * OBJ.initMeshBuffers for an example of how to use the newly created Mesh
 *
 * Nidza Note:
 * There is difference from me source obj loader and me-wgpu obj loader
 * Here we need scele in comp x,y,z because we use also primitive [cube, sphere etc...]
 * @class Mesh
 * @constructor
 *
 * @param {String} objectData a string representation of an OBJ file with newlines preserved.
 */

class constructMesh {
  constructor(objectData, inputArg) {
    this.inputArg = inputArg;
    this.objectData = objectData;
    this.create(objectData, inputArg);
    this.setScale = s => {
      this.inputArg.scale = s;
      this.create(this.objectData, this.inputArg);
    };
    this.updateBuffers = () => {
      this.inputArg.scale = [0.1, 0.1, 0.1];
      this.create(this.objectData, this.inputArg);
    };
  }
  create = (objectData, inputArg, callback) => {
    if (typeof callback === 'undefined') callback = function () {};
    let initOrientation = [0, 1, 2];
    /*
      The OBJ file format does a sort of compression when saving a model in a
      program like Blender. There are at least 3 sections (4 including textures)
      within the file. Each line in a section begins with the same string:
        * 'v': indicates vertex section
        * 'vn': indicates vertex normal section
        * 'f': indicates the faces section
        * 'vt': indicates vertex texture section (if textures were used on the model)
      Each of the above sections (except for the faces section) is a list/set of
      unique vertices.
      Each line of the faces section contains a list of
      (vertex, [texture], normal) groups
      Some examples:
          // the texture index is optional, both formats are possible for models
          // without a texture applied
          f 1/25 18/46 12/31
          f 1//25 18//46 12//31
          // A 3 vertex face with texture indices
          f 16/92/11 14/101/22 1/69/1
          // A 4 vertex face
          f 16/92/11 40/109/40 38/114/38 14/101/22
      The first two lines are examples of a 3 vertex face without a texture applied.
      The second is an example of a 3 vertex face with a texture applied.
      The third is an example of a 4 vertex face. Note: a face can contain N
      number of vertices.
      Each number that appears in one of the groups is a 1-based index
      corresponding to an item from the other sections (meaning that indexing
      starts at one and *not* zero).
      For example:
          `f 16/92/11` is saying to
            - take the 16th element from the [v] vertex array
            - take the 92nd element from the [vt] texture array
            - take the 11th element from the [vn] normal array
          and together they make a unique vertex.
      Using all 3+ unique Vertices from the face line will produce a polygon.
      Now, you could just go through the OBJ file and create a new vertex for
      each face line and WebGL will draw what appears to be the same model.
      However, vertices will be overlapped and duplicated all over the place.
      Consider a cube in 3D space centered about the origin and each side is
      2 units long. The front face (with the positive Z-axis pointing towards
      you) would have a Top Right vertex (looking orthogonal to its normal)
      mapped at (1,1,1) The right face would have a Top Left vertex (looking
      orthogonal to its normal) at (1,1,1) and the top face would have a Bottom
      Right vertex (looking orthogonal to its normal) at (1,1,1). Each face
      has a vertex at the same coordinates, however, three distinct vertices
      will be drawn at the same spot.
      To solve the issue of duplicate Vertices (the `(vertex, [texture], normal)`
      groups), while iterating through the face lines, when a group is encountered
      the whole group string ('16/92/11') is checked to see if it exists in the
      packed.hashindices object, and if it doesn't, the indices it specifies
      are used to look up each attribute in the corresponding attribute arrays
      already created. The values are then copied to the corresponding unpacked
      array (flattened to play nice with WebGL's ELEMENT_ARRAY_BUFFER indexing),
      the group string is added to the hashindices set and the current unpacked
      index is used as this hashindices value so that the group of elements can
      be reused. The unpacked index is incremented. If the group string already
      exists in the hashindices object, its corresponding value is the index of
      that group and is appended to the unpacked indices array.
      */
    var verts = [],
      vertNormals = [],
      textures = [],
      unpacked = {};
    // unpacking stuff
    unpacked.verts = [];
    unpacked.norms = [];
    unpacked.textures = [];
    unpacked.hashindices = {};
    unpacked.indices = [];
    unpacked.index = 0;
    // array of lines separated by the newline
    var lines = objectData.split('\n');

    // update swap orientation
    if (inputArg.swap[0] !== null) {
      swap(inputArg.swap[0], inputArg.swap[1], initOrientation);
    }
    var VERTEX_RE = /^v\s/;
    var NORMAL_RE = /^vn\s/;
    var TEXTURE_RE = /^vt\s/;
    var FACE_RE = /^f\s/;
    var WHITESPACE_RE = /\s+/;
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i].trim();
      var elements = line.split(WHITESPACE_RE);
      elements.shift();
      if (VERTEX_RE.test(line)) {
        // if this is a vertex
        verts.push.apply(verts, elements);
      } else if (NORMAL_RE.test(line)) {
        // if this is a vertex normal
        vertNormals.push.apply(vertNormals, elements);
      } else if (TEXTURE_RE.test(line)) {
        // if this is a texture
        textures.push.apply(textures, elements);
      } else if (FACE_RE.test(line)) {
        // if this is a face
        /*
          split this face into an array of vertex groups
          for example:
            f 16/92/11 14/101/22 1/69/1
          becomes:
            ['16/92/11', '14/101/22', '1/69/1'];
          */
        var quad = false;
        for (var j = 0, eleLen = elements.length; j < eleLen; j++) {
          // Triangulating quads
          // quad: 'f v0/t0/vn0 v1/t1/vn1 v2/t2/vn2 v3/t3/vn3/'
          // corresponding triangles:
          //      'f v0/t0/vn0 v1/t1/vn1 v2/t2/vn2'
          //      'f v2/t2/vn2 v3/t3/vn3 v0/t0/vn0'
          if (j === 3 && !quad) {
            // add v2/t2/vn2 in again before continuing to 3
            j = 2;
            quad = true;
          }
          if (elements[j] in unpacked.hashindices) {
            unpacked.indices.push(unpacked.hashindices[elements[j]]);
          } else {
            /*
                  Each element of the face line array is a vertex which has its
                  attributes delimited by a forward slash. This will separate
                  each attribute into another array:
                      '19/92/11'
                  becomes:
                      vertex = ['19', '92', '11'];
                  where
                      vertex[0] is the vertex index
                      vertex[1] is the texture index
                      vertex[2] is the normal index
                  Think of faces having Vertices which are comprised of the
                  attributes location (v), texture (vt), and normal (vn).
                  */
            var vertex = elements[j].split('/');
            /*
                  The verts, textures, and vertNormals arrays each contain a
                  flattend array of coordinates.
                  Because it gets confusing by referring to vertex and then
                  vertex (both are different in my descriptions) I will explain
                  what's going on using the vertexNormals array:
                  vertex[2] will contain the one-based index of the vertexNormals
                  section (vn). One is subtracted from this index number to play
                  nice with javascript's zero-based array indexing.
                  Because vertexNormal is a flattened array of x, y, z values,
                  simple pointer arithmetic is used to skip to the start of the
                  vertexNormal, then the offset is added to get the correct
                  component: +0 is x, +1 is y, +2 is z.
                  This same process is repeated for verts and textures.
                  */
            // vertex position
            unpacked.verts.push(+verts[(vertex[0] - 1) * 3 + initOrientation[0]] * inputArg.scale[0]);
            unpacked.verts.push(+verts[(vertex[0] - 1) * 3 + initOrientation[1]] * inputArg.scale[1]);
            unpacked.verts.push(+verts[(vertex[0] - 1) * 3 + initOrientation[2]] * inputArg.scale[2]);

            // vertex textures
            if (textures.length) {
              unpacked.textures.push(+textures[(vertex[1] - 1) * 2 + 0]);
              unpacked.textures.push(+textures[(vertex[1] - 1) * 2 + 1]);
            }
            // vertex normals
            unpacked.norms.push(+vertNormals[(vertex[2] - 1) * 3 + 0]);
            unpacked.norms.push(+vertNormals[(vertex[2] - 1) * 3 + 1]);
            unpacked.norms.push(+vertNormals[(vertex[2] - 1) * 3 + 2]);
            // add the newly created vertex to the list of indices
            unpacked.hashindices[elements[j]] = unpacked.index;
            unpacked.indices.push(unpacked.index);
            // increment the counter
            unpacked.index += 1;
          }
          if (j === 3 && quad) {
            // add v0/t0/vn0 onto the second triangle
            unpacked.indices.push(unpacked.hashindices[elements[0]]);
          }
        }
      }
    }
    this.vertices = unpacked.verts;
    this.vertexNormals = unpacked.norms;
    this.textures = unpacked.textures;
    this.indices = unpacked.indices;
    callback();
    return this;
  };
}
exports.constructMesh = constructMesh;
var Ajax = function () {
  // this is just a helper class to ease ajax calls
  var _this = this;
  this.xmlhttp = new XMLHttpRequest();
  this.get = function (url, callback) {
    _this.xmlhttp.onreadystatechange = function () {
      if (_this.xmlhttp.readyState === 4) {
        callback(_this.xmlhttp.responseText, _this.xmlhttp.status);
      }
    };
    _this.xmlhttp.open('GET', url, true);
    _this.xmlhttp.send();
  };
};

/**
 * Takes in an object of `mesh_name`, `'/url/to/OBJ/file'` pairs and a callback
 * function. Each OBJ file will be ajaxed in and automatically converted to
 * an OBJ.Mesh. When all files have successfully downloaded the callback
 * function provided will be called and passed in an object containing
 * the newly created meshes.
 *
 * **Note:** In order to use this function as a way to download meshes, a
 * webserver of some sort must be used.
 *
 * @param {Object} nameAndURLs an object where the key is the name of the mesh and the value is the url to that mesh's OBJ file
 *
 * @param {Function} completionCallback should contain a function that will take one parameter: an object array where the keys will be the unique object name and the value will be a Mesh object
 *
 * @param {Object} meshes In case other meshes are loaded separately or if a previously declared variable is desired to be used, pass in a (possibly empty) json object of the pattern: { '<mesh_name>': OBJ.Mesh }
 *
 */
var downloadMeshes = function (nameAndURLs, completionCallback, inputArg) {
  // the total number of meshes. this is used to implement "blocking"
  var semaphore = Object.keys(nameAndURLs).length;
  // if error is true, an alert will given
  var error = false;
  // this is used to check if all meshes have been downloaded
  // if meshes is supplied, then it will be populated, otherwise
  // a new object is created. this will be passed into the completionCallback
  if (typeof inputArg === 'undefined') {
    var inputArg = {
      scale: [1, 1, 1],
      swap: [null]
    };
  }
  if (typeof inputArg.scale === 'undefined') inputArg.scale = [1, 1, 1];
  if (typeof inputArg.swap === 'undefined') inputArg.swap = [null];
  var meshes = {};

  // loop over the mesh_name,url key,value pairs
  for (var mesh_name in nameAndURLs) {
    if (nameAndURLs.hasOwnProperty(mesh_name)) {
      new Ajax().get(nameAndURLs[mesh_name], function (name) {
        return function (data, status) {
          if (status === 200) {
            meshes[name] = new constructMesh(data, inputArg);
          } else {
            error = true;
            console.error('An error has occurred and the mesh "' + name + '" could not be downloaded.');
          }
          // the request has finished, decrement the counter
          semaphore--;
          if (semaphore === 0) {
            if (error) {
              // if an error has occurred, the user is notified here and the
              // callback is not called
              console.error('An error has occurred and one or meshes has not been ' + 'downloaded. The execution of the script has terminated.');
              throw '';
            }
            // there haven't been any errors in retrieving the meshes
            // call the callback
            completionCallback(meshes, inputArg.scale);
          }
        };
      }(mesh_name));
    }
  }
};

/**
 * Takes in the WebGL context and a Mesh, then creates and appends the buffers
 * to the mesh object as attributes.
 *
 * @param {WebGLRenderingContext} gl the `canvas.getContext('webgl')` context instance
 * @param {Mesh} mesh a single `OBJ.Mesh` instance
 *
 * The newly created mesh attributes are:
 *
 * Attrbute | Description
 * :--- | ---
 * **normalBuffer**       |contains the model&#39;s Vertex Normals
 * normalBuffer.itemSize  |set to 3 items
 * normalBuffer.numItems  |the total number of vertex normals
 * |
 * **textureBuffer**      |contains the model&#39;s Texture Coordinates
 * textureBuffer.itemSize |set to 2 items
 * textureBuffer.numItems |the number of texture coordinates
 * |
 * **vertexBuffer**       |contains the model&#39;s Vertex Position Coordinates (does not include w)
 * vertexBuffer.itemSize  |set to 3 items
 * vertexBuffer.numItems  |the total number of vertices
 * |
 * **indexBuffer**        |contains the indices of the faces
 * indexBuffer.itemSize   |is set to 1
 * indexBuffer.numItems   |the total number of indices
 *
 * A simple example (a lot of steps are missing, so don't copy and paste):
 *
 *     var gl   = canvas.getContext('webgl'),
 *         mesh = OBJ.Mesh(obj_file_data);
 *     // compile the shaders and create a shader program
 *     var shaderProgram = gl.createProgram();
 *     // compilation stuff here
 *     ...
 *     // make sure you have vertex, vertex normal, and texture coordinate
 *     // attributes located in your shaders and attach them to the shader program
 *     shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
 *     gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
 *
 *     shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
 *     gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
 *
 *     shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
 *     gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
 *
 *     // create and initialize the vertex, vertex normal, and texture coordinate buffers
 *     // and save on to the mesh object
 *     OBJ.initMeshBuffers(gl, mesh);
 *
 *     // now to render the mesh
 *     gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
 *     gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, mesh.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
 *     // it's possible that the mesh doesn't contain
 *     // any texture coordinates (e.g. suzanne.obj in the development branch).
 *     // in this case, the texture vertexAttribArray will need to be disabled
 *     // before the call to drawElements
 *     if(!mesh.textures.length){
 *       gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
 *     }
 *     else{
 *       // if the texture vertexAttribArray has been previously
 *       // disabled, then it needs to be re-enabled
 *       gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
 *       gl.bindBuffer(gl.ARRAY_BUFFER, mesh.textureBuffer);
 *       gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, mesh.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
 *     }
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
 *     gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, mesh.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);
 *
 *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.mesh.indexBuffer);
 *     gl.drawElements(gl.TRIANGLES, model.mesh.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
 */
exports.downloadMeshes = downloadMeshes;
var initMeshBuffers = function (gl, mesh) {
  // mesh.vertexNormals
  // mesh.textures
  // mesh.vertices
  // mesh.indices
};

/**
 * @description
 * Construct sequence list argument for downloadMeshes.
 * This is adaptation for blender obj animation export.
 * For example:
 *    matrixEngine.objLoader.downloadMeshes(
      matrixEngine.objLoader.makeObjSeqArg(
        {
          id: objName,
          joinMultiPahts: [
            {
              path: "res/bvh-skeletal-base/swat-guy/seq-walk/low/swat",
              id: objName,
              from: 1, to: 34
            },
            {
              path: "res/bvh-skeletal-base/swat-guy/seq-walk-pistol/low/swat-walk-pistol",
              id: objName,
              from: 35, to: 54
            }
          ]
        }),
      onLoadObj
    );
 */
exports.initMeshBuffers = initMeshBuffers;
const makeObjSeqArg = arg => {
  // Adaptation for blender (animation) obj exporter.
  var local = {};
  function localCalc(arg, noInitial = false) {
    var zeros = '00000';
    var l = {};
    var helper = arg.from;
    for (let j = arg.from, z = 1; j <= arg.to; j++) {
      if (z > 9 && z < 99) {
        zeros = '0000';
      } else if (z > 99 && z < 999) {
        zeros = '000';
      } // no need more then 999

      if (helper == arg.from && noInitial === false) {
        l[arg.id] = arg.path + '_' + zeros + z + '.obj';
      } else {
        l[arg.id + (helper - 1)] = arg.path + '_' + zeros + z + '.obj';
      }
      helper++;
      z++;
    }
    return l;
  }
  if (typeof arg.path === 'string') {
    local = localCalc(arg);
  } else if (typeof arg.path === 'undefined') {
    if (typeof arg.joinMultiPahts !== 'undefined') {
      console.log("ITS joinMultiPahts!");
      var localFinal = {};
      arg.joinMultiPahts.forEach((arg, index) => {
        if (index === 0) {
          localFinal = Object.assign(local, localCalc(arg));
        } else {
          localFinal = Object.assign(local, localCalc(arg, true));
        }
      });
      console.log("joinMultiPahts LOCAL => ", localFinal);
      return localFinal;
    }
  }
  return local;
};

/**
 * @description
 * Switching obj seq animations frames range.
 */
exports.makeObjSeqArg = makeObjSeqArg;
function play(nameAni) {
  this.animations.active = nameAni;
  this.currentAni = this.animations[this.animations.active].from;
  this.playing = true;
}

},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BVHPlayerInstances = void 0;
var _wgpuMatrix = require("wgpu-matrix");
var _webgpuGltf = require("./webgpu-gltf.js");
var _meshObjInstances = _interopRequireDefault(require("../instanced/mesh-obj-instances.js"));
var _utils = require("../utils.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// import MEBvh from "bvh-loader";

// export var animBVH = new MEBvh();
// export let loadBVH = (path) => {
//   return new Promise((resolve, reject) => {
//     animBVH.parse_file(path).then(() => {
//       console.info("plot_hierarchy no function")
//       animBVH.plot_hierarchy();
//       var r = animBVH.frame_pose(0);
//       // Not in use at the moment next feature - change skeletal or indipended new class.
//       // console.log("FINAL P => ", r[0].length)
//       // console.log("FINAL R => ", r[1].length)
//       var KEYS = animBVH.joint_names();
//       for(var x = 0;x < r[0].length;x++) {
//         // console.log("->" + KEYS[x] + "-> position: " + r[0][x] + " rotation: " + r[1][x]);
//       }
//       var all = animBVH.all_frame_poses();
//       // console.log("Final All -> ", all);
//       resolve(animBVH);
//     }).catch((err) => {reject(err)});
//   })
// }

/**
 * @description
 * Skinning basic done animation can be changed with animation index.
 * Holder for GLB model with skinning.
 * @param {GLBModel} glb - Your loaded GLB
 * @param {Object} bvhBones - Mapping of boneName → BVH bone data
 * @param {GPUDevice} device - WebGPU device
 * @credits Chatgpt assist here.
 */
class BVHPlayerInstances extends _meshObjInstances.default {
  constructor(o, bvh, glb, primitiveIndex, skinnedNodeIndex, canvas, device, context, inputHandler, globalAmbient) {
    super(canvas, device, context, o, inputHandler, globalAmbient, glb, primitiveIndex, skinnedNodeIndex);
    // bvh arg not actual at the moment
    this.bvh = {};
    this.glb = glb;
    this.currentFrame = 0;
    this.fps = 30;
    this.timeAccumulator = 0;
    this.trailAnimation = {
      enabled: false,
      delay: 100
    };
    // debug
    this.scaleBoneTest = 1;
    this.primitiveIndex = primitiveIndex;
    if (!this.bvh.sharedState) {
      this.bvh.sharedState = {
        emitAnimationEvent: false,
        animationStarted: false,
        currentFrame: 0,
        timeAccumulator: 0,
        animationFinished: false
      };
    }
    this.MAX_BONES = 100; // predefined
    //cache
    this._boneMatrices = new Float32Array(this.MAX_BONES * 16);
    this._nodeChannels = new Map();
    this.sharedState = this.bvh.sharedState;
    // Reference to the skinned node containing all bones
    this.skinnedNode = this.glb.skinnedMeshNodes[skinnedNodeIndex];
    // console.log('this.skinnedNode', this.skinnedNode)
    this.nodeWorldMatrices = Array.from({
      length: this.glb.nodes.length
    }, () => _wgpuMatrix.mat4.identity());
    this.startTime = performance.now() / 1000; // seconds - anim speed control
    this.skeleton = []; // array of joint node indices
    this.animationSpeed = 1000;
    this.inverseBindMatrices = []; // Float32Array for each joint
    this.initInverseBindMatrices();
    this.makeSkeletal();
    this._finalMat = new Float32Array(this.MAX_BONES * 16);
    this._tempMat = _wgpuMatrix.mat4.create();
  }
  makeSkeletal() {
    let skin = this.glb.skins[0];
    const accessorIndex = skin.inverseBindMatrices;
    if (accessorIndex == null) {
      console.warn("No inverseBindMatrices, using identity matrices");
    }
    // 1. Load all inverse bind matrices once
    const invBindArray = this.inverseBindMatrices; // set earlier by initInverseBindMatrices()
    // 2. Build skeleton array from skin.joints only
    this.skeleton = skin.joints.slice(); // direct copy of indices
    // 3. Assign inverseBindMatrix to each joint node correctly
    for (let i = 0; i < skin.joints.length; i++) {
      const jointIndex = skin.joints[i];
      const jointNode = this.glb.nodes[jointIndex];
      // assign only to bone nodes
      jointNode.inverseBindMatrix = invBindArray.slice(i * 16, (i + 1) * 16);
      // decompose node’s transform once (if not already)
      if (!jointNode.transform) {
        jointNode.transform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      }
      if (!jointNode.translation || !jointNode.rotation || !jointNode.scale) {
        const {
          translation,
          rotation,
          scale
        } = this.decomposeMatrix(jointNode.transform);
        jointNode.translation = translation;
        jointNode.rotation = rotation;
        jointNode.scale = scale;
      }
    }
    // 4. For mesh nodes or armature parent nodes, leave them alone
    // what is animation , check is it more - we look for Armature by defoult 
    // friendly blender
    this.glb.animationIndex = 0;
    for (let j = 0; j < this.glb.glbJsonData.animations.length; j++) {
      if (this.glb.glbJsonData.animations[j].name.indexOf('Armature') !== -1) {
        this.glb.animationIndex = j;
      }
    }
  }
  initInverseBindMatrices(skinIndex = 0) {
    const skin = this.glb.skins[skinIndex];
    const invBindAccessorIndex = skin.inverseBindMatrices; // number
    if (invBindAccessorIndex === undefined || invBindAccessorIndex === null) {
      console.warn('No inverseBindMatrices accessor for skin', skinIndex);
      return;
    }
    const invBindArray = this.getAccessorArray(this.glb, invBindAccessorIndex);
    this.inverseBindMatrices = invBindArray;
  }
  getNumberOfFramesCurAni() {
    const anim = this.glb.glbJsonData.animations[this.glb.animationIndex];
    let maxFrames = 0;
    if (typeof anim == 'undefined') {
      console.log('[anim undefined]', this.name);
      return 1;
    }
    for (const sampler of anim.samplers) {
      const inputAccessor = this.glb.glbJsonData.accessors[sampler.input];
      if (inputAccessor.count > maxFrames) maxFrames = inputAccessor.count;
    }
    return maxFrames;
  }
  getAnimationLength(animation) {
    let maxTime = 0;
    for (const channel of animation.channels) {
      const sampler = animation.samplers[channel.sampler];
      const inputTimes = this.getAccessorArray(this.glb, sampler.input);
      const lastTime = inputTimes[inputTimes.length - 1];
      if (lastTime > maxTime) maxTime = lastTime;
    }
    return maxTime;
  }
  playAnimationByIndex = animationIndex => {
    this.glb.animationIndex = animationIndex;
  };
  playAnimationByName = animationName => {
    const animations = this.glb.glbJsonData.animations;
    const index = animations.findIndex(anim => anim.name === animationName);
    if (index === -1) {
      console.warn(`Animation '${animationName}' not found`);
      return;
    }
    this.glb.animationIndex = index;
  };
  update(deltaTime) {
    const frameTime = 1 / this.fps;
    this.sharedState.timeAccumulator += deltaTime;
    while (this.sharedState.timeAccumulator >= frameTime) {
      this.sharedState.currentFrame = (this.sharedState.currentFrame + 1) % this.getNumberOfFramesCurAni();
      this.sharedState.timeAccumulator -= frameTime;
    }
    // const test = this.getNumberOfFramesCurAni();
    var inTime = this.getAnimationLength(this.glb.glbJsonData.animations[this.glb.animationIndex]);
    if (this.sharedState.animationStarted == false && this.sharedState.emitAnimationEvent == true) {
      this.sharedState.animationStarted = true;
      setTimeout(() => {
        this.sharedState.animationStarted = false;
        if (this.glb.animationIndex == null) this.glb.animationIndex = 0;
        dispatchEvent(new CustomEvent(`animationEnd-${this.name}`, {
          detail: {
            animationName: this.glb.glbJsonData.animations[this.glb.animationIndex].name
          }
        }));
      }, inTime * 1000);
    }
    if (this.glb.glbJsonData.animations && this.glb.glbJsonData.animations.length > 0) {
      if (this.trailAnimation.enabled == true) {
        for (let i = 0; i < this.instanceCount; i++) {
          const timeOffsetMs = i * this.trailAnimation.delay;
          const currentTime = (performance.now() - timeOffsetMs) / this.animationSpeed - this.startTime;
          this.updateSingleBoneCubeAnimation(this.glb.glbJsonData.animations[this.glb.animationIndex], this.glb.nodes,
          // ← same nodes, no clone
          currentTime,
          // ← only this changes per instance
          this._boneMatrices, i // ← writes to correct buffer slot
          );
        }
      } else {
        const currentTime = performance.now() / this.animationSpeed - this.startTime;
        this.updateSingleBoneCubeAnimation(this.glb.glbJsonData.animations[this.glb.animationIndex], this.glb.nodes, currentTime, this._boneMatrices, 0);
        this.updateSingleBoneCubeAnimation(this.glb.glbJsonData.animations[this.glb.animationIndex], this.glb.nodes, currentTime, this._boneMatrices, 1);
      }
    }
  }
  getAccessorArray(glb, accessorIndex) {
    if (!glb._accessorCache) glb._accessorCache = new Map();
    const cached = glb._accessorCache.get(accessorIndex);
    if (cached) return cached;
    const accessor = glb.glbJsonData.accessors[accessorIndex];
    const bufferView = glb.glbJsonData.bufferViews[accessor.bufferView];
    const byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
    const byteLength = accessor.count * this.getNumComponents(accessor.type) * (accessor.componentType === 5126 ? 4 : 2);
    const slice = this.getBufferSlice(glb.glbBinaryBuffer, byteOffset, byteLength);
    let result;
    switch (accessor.componentType) {
      case 5126:
        result = new Float32Array(slice);
        break;
      case 5123:
        result = new Uint16Array(slice);
        break;
      case 5121:
        result = new Uint8Array(slice);
        break;
      default:
        throw new Error("Unsupported componentType: " + accessor.componentType);
    }
    glb._accessorCache.set(accessorIndex, result); // ← AFTER result is created
    return result;
  }
  getAccessorTypeForChannel(path) {
    switch (path) {
      case "translation":
        return "VEC3";
      case "rotation":
        return "VEC4";
      case "scale":
        return "VEC3";
      case "weights":
        return "VECN";
      default:
        throw new Error("Unknown channel path: " + path);
    }
  }
  getNumComponents(type) {
    switch (type) {
      case "SCALAR":
        return 1;
      case "VEC2":
        return 2;
      case "VEC3":
        return 3;
      case "VEC4":
        return 4;
      case "MAT4":
        return 16;
      default:
        throw new Error("Unknown type: " + type);
    }
  }
  getComponentSize(componentType) {
    switch (componentType) {
      case 5126:
        return 4;
      // float32
      case 5123:
        return 2;
      // uint16
      case 5121:
        return 1;
      // uint8
      default:
        throw new Error("Unknown componentType: " + componentType);
    }
  }

  /**
   *  @description
   *  Get a typed slice of the raw binary buffer from glTF buffer definitions.
   * @param {Object} bufferDef - the glTF buffer definition (usually gltfJson.buffers[0])
   * @param {Number} byteOffset - byte offset into the buffer
   * @param {Number} byteLength - byte length to slice
   * @returns {ArrayBuffer} sliced array buffer
   **/
  getBufferSlice(bufferDef, byteOffset, byteLength) {
    // GLTFBuffer instance:
    if (bufferDef instanceof _webgpuGltf.GLTFBuffer) {
      // Use .arrayBuffer + .byteOffset:
      return bufferDef.arrayBuffer.slice(bufferDef.byteOffset + (byteOffset || 0), bufferDef.byteOffset + (byteOffset || 0) + byteLength);
    }
    // Already have a raw ArrayBuffer:
    if (bufferDef instanceof ArrayBuffer) {
      return bufferDef.slice(byteOffset, byteOffset + byteLength);
    }
    // Some loaders store it as .data or ._data:
    if (bufferDef && bufferDef.data instanceof ArrayBuffer) {
      return bufferDef.data.slice(byteOffset, byteOffset + byteLength);
    }
    if (bufferDef && bufferDef._data instanceof ArrayBuffer) {
      return bufferDef._data.slice(byteOffset, byteOffset + byteLength);
    }
    throw new Error("No binary data found in GLB buffer[0]");
  }

  // --- helpers
  lerpVec(a, b, t) {
    return a.map((v, i) => v * (1 - t) + b[i] * t);
  }

  // Example quaternion slerp (a,b = [x,y,z,w])
  quatSlerp(a, b, t) {
    // naive slerp for small demo, normalize result
    let dot = a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    if (dot < 0) {
      b = b.map(v => -v);
      dot = -dot;
    }
    if (dot > 0.9995) return lerpVec(a, b, t);
    const theta0 = Math.acos(dot);
    const theta = theta0 * t;
    const sinTheta = Math.sin(theta);
    const sinTheta0 = Math.sin(theta0);
    const s0 = Math.cos(theta) - dot * sinTheta / sinTheta0;
    const s1 = sinTheta / sinTheta0;
    return a.map((v, i) => s0 * v + s1 * b[i]);
  }

  // naive quaternion to 4x4 matrix
  quatToMat4(q) {
    const [x, y, z, w] = q;
    const xx = x * x,
      yy = y * y,
      zz = z * z;
    const xy = x * y,
      xz = x * z,
      yz = y * z,
      wx = w * x,
      wy = w * y,
      wz = w * z;
    return new Float32Array([1 - 2 * (yy + zz), 2 * (xy + wz), 2 * (xz - wy), 0, 2 * (xy - wz), 1 - 2 * (xx + zz), 2 * (yz + wx), 0, 2 * (xz + wy), 2 * (yz - wx), 1 - 2 * (xx + yy), 0, 0, 0, 0, 1]);
  }

  // Compose TRS to a 4×4
  composeMatrix(translation, rotationQuat, scale) {
    const m = _wgpuMatrix.mat4.identity();
    _wgpuMatrix.mat4.translate(m, translation, m);
    const rot = _wgpuMatrix.mat4.fromQuat(rotationQuat);
    _wgpuMatrix.mat4.multiply(m, rot, m);
    _wgpuMatrix.mat4.scale(m, scale, m);
    return m;
    // const m = mat4.identity();
    // mat4.translate(m, translation, m);
    // const rot = mat4.fromQuat(rotationQuat);
    // mat4.multiply(m, rot, m);
    // mat4.scale(m, scale, m);
    // // Flip Y globally
    // const flipY = mat4.identity();
    // mat4.scale(flipY, [1, 1, -1], flipY);
    // mat4.multiply(m, flipY, m);
    // return m;
  }
  decomposeMatrix(m) {
    // m is column-major: indices:
    // [ m0 m4 m8  m12
    //   m1 m5 m9  m13
    //   m2 m6 m10 m14
    //   m3 m7 m11 m15 ]
    const t = new Float32Array([m[12], m[13], m[14]]);
    // Extract the 3 column vectors (upper-left 3x3)
    const cx = [m[0], m[1], m[2]];
    const cy = [m[4], m[5], m[6]];
    const cz = [m[8], m[9], m[10]];
    // Lengths = scales
    const len = v => Math.hypot(v[0], v[1], v[2]);
    let sx = len(cx),
      sy = len(cy),
      sz = len(cz);
    // If any scale nearly zero, avoid divide-by-zero
    if (sx === 0) sx = 1.0;
    if (sy === 0) sy = 1.0;
    if (sz === 0) sz = 1.0;
    // Normalize columns to produce a pure rotation matrix
    const r00 = m[0] / sx,
      r01 = m[4] / sy,
      r02 = m[8] / sz;
    const r10 = m[1] / sx,
      r11 = m[5] / sy,
      r12 = m[9] / sz;
    const r20 = m[2] / sx,
      r21 = m[6] / sy,
      r22 = m[10] / sz;
    // Fix negative-scale (reflection) case: if determinant < 0, flip sign of one scale and corresponding column
    const det3 = r00 * (r11 * r22 - r12 * r21) - r01 * (r10 * r22 - r12 * r20) + r02 * (r10 * r21 - r11 * r20);
    if (det3 < 0) {
      // flip Z
      sz = -sz;
      // flip third column sign
      // multiply cz by -1 => r02,r12,r22 *= -1
      // recompute normalized r* accordingly:
      // since we only need a valid rotation matrix for quaternion conversion,
      // just invert the third column
      // (alternatively flip sx or sy—this is a convention choice)
      // Here we flip the third column:
      // r02 = -r02; r12 = -r12; r22 = -r22;
    }
    // Build quaternion from rotation matrix (r00..r22)
    // Using standard conversion (column-major rotation)
    const trace = r00 + r11 + r22;
    let qx, qy, qz, qw;
    if (trace > 0.00001) {
      const s = Math.sqrt(trace + 1.0) * 2; // s=4*qw
      qw = 0.25 * s;
      qx = (r21 - r12) / s;
      qy = (r02 - r20) / s;
      qz = (r10 - r01) / s;
    } else if (r00 > r11 && r00 > r22) {
      const s = Math.sqrt(1.0 + r00 - r11 - r22) * 2; // s=4*qx
      qw = (r21 - r12) / s;
      qx = 0.25 * s;
      qy = (r01 + r10) / s;
      qz = (r02 + r20) / s;
    } else if (r11 > r22) {
      const s = Math.sqrt(1.0 + r11 - r00 - r22) * 2; // s=4*qy
      qw = (r02 - r20) / s;
      qx = (r01 + r10) / s;
      qy = 0.25 * s;
      qz = (r12 + r21) / s;
    } else {
      const s = Math.sqrt(1.0 + r22 - r00 - r11) * 2; // s=4*qz
      qw = (r10 - r01) / s;
      qx = (r02 + r20) / s;
      qy = (r12 + r21) / s;
      qz = 0.25 * s;
    }
    const rot = new Float32Array([qx, qy, qz, qw]);
    const scale = new Float32Array([sx, sy, sz]);
    return {
      translation: t,
      rotation: rot,
      scale: scale
    };
  }
  slerp(q0, q1, t, out) {
    let dot = q0[0] * q1[0] + q0[1] * q1[1] + q0[2] * q1[2] + q0[3] * q1[3];
    if (dot < 0) {
      dot = -dot;
      q1 = [-q1[0], -q1[1], -q1[2], -q1[3]];
    }
    if (dot > 0.9995) {
      // linear
      for (let i = 0; i < 4; i++) out[i] = q0[i] + t * (q1[i] - q0[i]);
      // normalize
      const len = Math.hypot(...out);
      for (let i = 0; i < 4; i++) out[i] /= len;
      return;
    }
    const theta0 = Math.acos(dot);
    const theta = theta0 * t;
    const sinTheta = Math.sin(theta);
    const sinTheta0 = Math.sin(theta0);
    const s0 = Math.cos(theta) - dot * sinTheta / sinTheta0;
    const s1 = sinTheta / sinTheta0;
    for (let i = 0; i < 4; i++) {
      out[i] = s0 * q0[i] + s1 * q1[i];
    }
  }
  updateSingleBoneCubeAnimation(glbAnimation, nodes, time, boneMatrices, instanceIndex = 1) {
    const channels = glbAnimation.channels;
    const samplers = glbAnimation.samplers;
    // --- Map channels per node for faster lookup
    this._nodeChannels.clear();
    const anim = this.glb.glbJsonData.animations[this.glb.animationIndex];
    for (const channel of anim.channels) {
      if (!this._nodeChannels.has(channel.target.node)) this._nodeChannels.set(channel.target.node, []);
      this._nodeChannels.get(channel.target.node).push(channel);
    }
    const nodeChannels = this._nodeChannels;
    for (let j = 0; j < this.skeleton.length; j++) {
      const nodeIndex = this.skeleton[j];
      const node = nodes[nodeIndex];
      // --- Initialize node TRS if needed
      if (!node.translation) node.translation = new Float32Array([0, 0, 0]);
      if (!node.rotation) node.rotation = _wgpuMatrix.quat.create();
      if (!node.scale) node.scale = new Float32Array([1, 1, 1]);
      // --- Keep original TRS for additive animation
      if (!node.originalTranslation) node.originalTranslation = node.translation.slice();
      if (!node.originalRotation) node.originalRotation = node.rotation.slice();
      if (!node.originalScale) node.originalScale = node.scale.slice();
      const channelsForNode = nodeChannels.get(nodeIndex) || [];
      for (const channel of channelsForNode) {
        const path = channel.target.path; // "translation" | "rotation" | "scale"
        const sampler = samplers[channel.sampler];
        // --- Get input/output arrays
        const inputTimes = this.getAccessorArray(this.glb, sampler.input);
        const outputArray = this.getAccessorArray(this.glb, sampler.output);
        const numComponents = path === "rotation" ? 4 : 3;
        // --- Find keyframe interval
        const animTime = time % inputTimes[inputTimes.length - 1];
        let i = 0;
        while (i < inputTimes.length - 1 && inputTimes[i + 1] <= animTime) i++;
        const t0 = inputTimes[i];
        const t1 = inputTimes[Math.min(i + 1, inputTimes.length - 1)];
        const factor = t1 !== t0 ? (animTime - t0) / (t1 - t0) : 0;
        // --- Interpolated keyframe values
        const v0 = outputArray.subarray(i * numComponents, (i + 1) * numComponents);
        const v1 = outputArray.subarray(Math.min(i + 1, inputTimes.length - 1) * numComponents, Math.min(i + 2, inputTimes.length) * numComponents);
        // --- Apply animation
        if (path === "translation") {
          for (let k = 0; k < 3; k++) node.translation[k] = v0[k] * (1 - factor) + v1[k] * factor;
        } else if (path === "scale") {
          for (let k = 0; k < 3; k++) node.scale[k] = v0[k] * (1 - factor) + v1[k] * factor;
        } else if (path === "rotation") {
          this.slerp(v0, v1, factor, node.rotation);
        }
      }
      // --- Recompose local transform
      node.transform = this.composeMatrix(node.translation, node.rotation, node.scale);
    }
    const computeWorld = nodeIndex => {
      const node = nodes[nodeIndex];
      if (!node.worldMatrix) node.worldMatrix = _wgpuMatrix.mat4.create();
      let parentWorld = node.parent !== null ? nodes[node.parent].worldMatrix : null;
      if (parentWorld) {
        // multiply parent * local
        _wgpuMatrix.mat4.multiply(parentWorld, node.transform, node.worldMatrix);
      } else {
        _wgpuMatrix.mat4.copy(node.transform, node.worldMatrix);
      }
      _wgpuMatrix.mat4.scale(node.worldMatrix, [this.scaleBoneTest, this.scaleBoneTest, this.scaleBoneTest], node.worldMatrix);
      if (node.children) {
        for (const childIndex of node.children) computeWorld(childIndex);
      }
    };
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].parent === null || nodes[i].parent === undefined) {
        computeWorld(i);
      }
    }
    for (let j = 0; j < this.skeleton.length; j++) {
      const jointNode = nodes[this.skeleton[j]];
      _wgpuMatrix.mat4.multiply(jointNode.worldMatrix, jointNode.inverseBindMatrix, this._tempMat);
      boneMatrices.set(this._tempMat, j * 16);
    }
    const byteOffset = (0, _utils.alignTo256)(64 * this.MAX_BONES) * instanceIndex;
    this.device.queue.writeBuffer(this.bonesBuffer, byteOffset, boneMatrices);
    return boneMatrices;
  }
}
exports.BVHPlayerInstances = BVHPlayerInstances;

},{"../instanced/mesh-obj-instances.js":41,"../utils.js":56,"./webgpu-gltf.js":47,"wgpu-matrix":22}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadBVH = exports.animBVH = exports.BVHPlayer = void 0;
var _bvhLoader = _interopRequireDefault(require("bvh-loader"));
var _meshObj = _interopRequireDefault(require("../mesh-obj"));
var _wgpuMatrix = require("wgpu-matrix");
var _webgpuGltf = require("./webgpu-gltf.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// import {degToRad} from "../utils.js";

var animBVH = exports.animBVH = new _bvhLoader.default();
let loadBVH = path => {
  return new Promise((resolve, reject) => {
    animBVH.parse_file(path).then(() => {
      console.info("plot_hierarchy no function");
      animBVH.plot_hierarchy();
      var r = animBVH.frame_pose(0);
      // Not in use at the moment next feature - change skeletal or indipended new class.
      // console.log("FINAL P => ", r[0].length)
      // console.log("FINAL R => ", r[1].length)
      var KEYS = animBVH.joint_names();
      for (var x = 0; x < r[0].length; x++) {
        // console.log("->" + KEYS[x] + "-> position: " + r[0][x] + " rotation: " + r[1][x]);
      }
      var all = animBVH.all_frame_poses();
      // console.log("Final All -> ", all);
      resolve(animBVH);
    }).catch(err => {
      reject(err);
    });
  });
};

/**
 * @description
 * Skinning basic done animation can be changed with animation index.
 * Holder for GLB model with skinning.
 * @param {GLBModel} glb - Your loaded GLB
 * @param {Object} bvhBones - Mapping of boneName → BVH bone data
 * @param {GPUDevice} device - WebGPU device
 * @credits Chatgpt assist here.
 */
exports.loadBVH = loadBVH;
class BVHPlayer extends _meshObj.default {
  constructor(o, bvh, glb, primitiveIndex, skinnedNodeIndex, canvas, device, context, inputHandler, globalAmbient) {
    super(canvas, device, context, o, inputHandler, globalAmbient, glb, primitiveIndex, skinnedNodeIndex);
    // bvh arg not actula at the moment
    this.bvh = {};
    this.glb = glb;
    this.currentFrame = 0;
    this.fps = 30;
    this.timeAccumulator = 0;
    // debug
    this.scaleBoneTest = 1;
    this.primitiveIndex = primitiveIndex;
    if (!this.bvh.sharedState) {
      this.bvh.sharedState = {
        currentFrame: 0,
        timeAccumulator: 0
      };
    }
    this.sharedState = this.bvh.sharedState;
    // Reference to the skinned node containing all bones
    this.skinnedNode = this.glb.skinnedMeshNodes[skinnedNodeIndex];
    // console.log('this.skinnedNode', this.skinnedNode)
    this.nodeWorldMatrices = Array.from({
      length: this.glb.nodes.length
    }, () => _wgpuMatrix.mat4.identity());
    this.startTime = performance.now() / 1000; // seconds - anim speed control
    this.MAX_BONES = 100; // predefined
    this.skeleton = []; // array of joint node indices
    this.animationSpeed = 1000;
    this.inverseBindMatrices = []; // Float32Array for each joint
    this.initInverseBindMatrices();
    this.makeSkeletal();
    this._nodeChannels = new Map();
    this._finalMat = new Float32Array(this.MAX_BONES * 16);
    this._tempMat = _wgpuMatrix.mat4.create();
  }
  makeSkeletal() {
    let skin = this.glb.skins[0];
    const accessorIndex = skin.inverseBindMatrices;
    if (accessorIndex == null) {
      console.warn("No inverseBindMatrices, using identity matrices");
    }
    // 1. Load all inverse bind matrices once
    const invBindArray = this.inverseBindMatrices; // set earlier by initInverseBindMatrices()
    // 2. Build skeleton array from skin.joints only
    this.skeleton = skin.joints.slice(); // direct copy of indices
    // 3. Assign inverseBindMatrix to each joint node correctly
    for (let i = 0; i < skin.joints.length; i++) {
      const jointIndex = skin.joints[i];
      const jointNode = this.glb.nodes[jointIndex];
      // assign only to bone nodes
      jointNode.inverseBindMatrix = invBindArray.slice(i * 16, (i + 1) * 16);
      // decompose node’s transform once (if not already)
      if (!jointNode.transform) {
        jointNode.transform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      }
      if (!jointNode.translation || !jointNode.rotation || !jointNode.scale) {
        const {
          translation,
          rotation,
          scale
        } = this.decomposeMatrix(jointNode.transform);
        jointNode.translation = translation;
        jointNode.rotation = rotation;
        jointNode.scale = scale;
      }
    }
    // 4. For mesh nodes or armature parent nodes, leave them alone
    // what is animation , check is it more - we look for Armature by defoult 
    // friendly blender
    this.glb.animationIndex = 0;
    for (let j = 0; j < this.glb.glbJsonData.animations.length; j++) {
      if (this.glb.glbJsonData.animations[j].name.indexOf('Armature') !== -1) {
        this.glb.animationIndex = j;
      }
    }
  }
  initInverseBindMatrices(skinIndex = 0) {
    const skin = this.glb.skins[skinIndex];
    const invBindAccessorIndex = skin.inverseBindMatrices; // number
    if (invBindAccessorIndex === undefined || invBindAccessorIndex === null) {
      console.warn('No inverseBindMatrices accessor for skin', skinIndex);
      return;
    }
    const invBindArray = this.getAccessorArray(this.glb, invBindAccessorIndex);
    // ✅ store directly as typed array (one big contiguous Float32Array)
    this.inverseBindMatrices = invBindArray;
  }
  playAnimationByIndex = animationIndex => {
    this.glb.animationIndex = animationIndex;
  };
  playAnimationByName = animationName => {
    const animations = this.glb.glbJsonData.animations;
    const index = animations.findIndex(anim => anim.name === animationName);
    if (index === -1) {
      console.warn(`Animation '${animationName}' not found`);
      return;
    }
    this.glb.animationIndex = index;
  };
  getNumberOfFramesCurAni() {
    let anim = this.glb.glbJsonData.animations[this.glb.animationIndex];
    const sampler = anim.samplers[0];
    const inputAccessor = this.glb.glbJsonData.accessors[sampler.input];
    const numFrames = inputAccessor.count;
    return numFrames;
  }
  update(deltaTime) {
    const frameTime = 1 / this.fps;
    this.sharedState.timeAccumulator += deltaTime;
    while (this.sharedState.timeAccumulator >= frameTime) {
      this.sharedState.currentFrame = (this.sharedState.currentFrame + 1) % this.getNumberOfFramesCurAni();
      this.sharedState.timeAccumulator -= frameTime;
    }
    // const frame = this.sharedState.currentFrame;
    const currentTime = performance.now() / this.animationSpeed - this.startTime;
    const boneMatrices = new Float32Array(this.MAX_BONES * 16);
    if (this.glb.glbJsonData.animations && this.glb.glbJsonData.animations.length > 0) {
      this.updateSingleBoneCubeAnimation(this.glb.glbJsonData.animations[this.glb.animationIndex], this.glb.nodes, currentTime, boneMatrices);
    }
  }
  getAccessorArray(glb, accessorIndex) {
    if (!glb._accessorCache) glb._accessorCache = new Map();
    const cached = glb._accessorCache.get(accessorIndex);
    if (cached) return cached;
    const accessor = glb.glbJsonData.accessors[accessorIndex];
    const bufferView = glb.glbJsonData.bufferViews[accessor.bufferView];
    const byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
    const byteLength = accessor.count * this.getNumComponents(accessor.type) * (accessor.componentType === 5126 ? 4 : 2);
    const slice = this.getBufferSlice(glb.glbBinaryBuffer, byteOffset, byteLength);
    let result;
    switch (accessor.componentType) {
      case 5126:
        result = new Float32Array(slice);
        break;
      case 5123:
        result = new Uint16Array(slice);
        break;
      case 5121:
        result = new Uint8Array(slice);
        break;
      default:
        throw new Error("Unsupported componentType: " + accessor.componentType);
    }
    glb._accessorCache.set(accessorIndex, result); // ← AFTER result is created
    return result;
  }
  getAccessorTypeForChannel(path) {
    switch (path) {
      case "translation":
        return "VEC3";
      case "rotation":
        return "VEC4";
      case "scale":
        return "VEC3";
      case "weights":
        return "VECN";
      // if needed
      default:
        throw new Error("Unknown channel path: " + path);
    }
  }
  getNumComponents(type) {
    switch (type) {
      case "SCALAR":
        return 1;
      case "VEC2":
        return 2;
      case "VEC3":
        return 3;
      case "VEC4":
        return 4;
      case "MAT4":
        return 16;
      default:
        throw new Error("Unknown type: " + type);
    }
  }
  getComponentSize(componentType) {
    switch (componentType) {
      case 5126:
        return 4;
      // float32
      case 5123:
        return 2;
      // uint16
      case 5121:
        return 1;
      // uint8
      default:
        throw new Error("Unknown componentType: " + componentType);
    }
  }

  /**
   *  @description
   *  Get a typed slice of the raw binary buffer from glTF buffer definitions.
   * @param {Object} bufferDef - the glTF buffer definition (usually gltfJson.buffers[0])
   * @param {Number} byteOffset - byte offset into the buffer
   * @param {Number} byteLength - byte length to slice
   * @returns {ArrayBuffer} sliced array buffer
   **/
  getBufferSlice(bufferDef, byteOffset, byteLength) {
    // GLTFBuffer instance:
    if (bufferDef instanceof _webgpuGltf.GLTFBuffer) {
      // Use .arrayBuffer + .byteOffset:
      return bufferDef.arrayBuffer.slice(bufferDef.byteOffset + (byteOffset || 0), bufferDef.byteOffset + (byteOffset || 0) + byteLength);
    }

    // Already have a raw ArrayBuffer:
    if (bufferDef instanceof ArrayBuffer) {
      return bufferDef.slice(byteOffset, byteOffset + byteLength);
    }

    // Some loaders store it as .data or ._data:
    if (bufferDef && bufferDef.data instanceof ArrayBuffer) {
      return bufferDef.data.slice(byteOffset, byteOffset + byteLength);
    }
    if (bufferDef && bufferDef._data instanceof ArrayBuffer) {
      return bufferDef._data.slice(byteOffset, byteOffset + byteLength);
    }
    throw new Error("No binary data found in GLB buffer[0]");
  }

  // --- helpers
  lerpVec(a, b, t) {
    return a.map((v, i) => v * (1 - t) + b[i] * t);
  }

  // Example quaternion slerp (a,b = [x,y,z,w])
  quatSlerp(a, b, t) {
    // naive slerp for small demo, normalize result
    let dot = a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    if (dot < 0) {
      b = b.map(v => -v);
      dot = -dot;
    }
    if (dot > 0.9995) return lerpVec(a, b, t);
    const theta0 = Math.acos(dot);
    const theta = theta0 * t;
    const sinTheta = Math.sin(theta);
    const sinTheta0 = Math.sin(theta0);
    const s0 = Math.cos(theta) - dot * sinTheta / sinTheta0;
    const s1 = sinTheta / sinTheta0;
    return a.map((v, i) => s0 * v + s1 * b[i]);
  }

  // naive quaternion to 4x4 matrix
  quatToMat4(q) {
    const [x, y, z, w] = q;
    const xx = x * x,
      yy = y * y,
      zz = z * z;
    const xy = x * y,
      xz = x * z,
      yz = y * z,
      wx = w * x,
      wy = w * y,
      wz = w * z;
    return new Float32Array([1 - 2 * (yy + zz), 2 * (xy + wz), 2 * (xz - wy), 0, 2 * (xy - wz), 1 - 2 * (xx + zz), 2 * (yz + wx), 0, 2 * (xz + wy), 2 * (yz - wx), 1 - 2 * (xx + yy), 0, 0, 0, 0, 1]);
  }

  // Compose TRS to a 4×4
  composeMatrix(translation, rotationQuat, scale) {
    const m = _wgpuMatrix.mat4.identity();
    _wgpuMatrix.mat4.translate(m, translation, m);
    const rot = _wgpuMatrix.mat4.fromQuat(rotationQuat);
    _wgpuMatrix.mat4.multiply(m, rot, m);
    _wgpuMatrix.mat4.scale(m, scale, m);
    return m;

    // const m = mat4.identity();
    // mat4.translate(m, translation, m);
    // const rot = mat4.fromQuat(rotationQuat);
    // mat4.multiply(m, rot, m);
    // mat4.scale(m, scale, m);

    // // Flip Y globally
    // const flipY = mat4.identity();
    // mat4.scale(flipY, [1, 1, -1], flipY);
    // mat4.multiply(m, flipY, m);

    // return m;
  }
  decomposeMatrix(m) {
    // m is column-major: indices:
    // [ m0 m4 m8  m12
    //   m1 m5 m9  m13
    //   m2 m6 m10 m14
    //   m3 m7 m11 m15 ]
    const t = new Float32Array([m[12], m[13], m[14]]);

    // Extract the 3 column vectors (upper-left 3x3)
    const cx = [m[0], m[1], m[2]];
    const cy = [m[4], m[5], m[6]];
    const cz = [m[8], m[9], m[10]];

    // Lengths = scales
    const len = v => Math.hypot(v[0], v[1], v[2]);
    let sx = len(cx),
      sy = len(cy),
      sz = len(cz);

    // If any scale nearly zero, avoid divide-by-zero
    if (sx === 0) sx = 1.0;
    if (sy === 0) sy = 1.0;
    if (sz === 0) sz = 1.0;

    // Normalize columns to produce a pure rotation matrix
    const r00 = m[0] / sx,
      r01 = m[4] / sy,
      r02 = m[8] / sz;
    const r10 = m[1] / sx,
      r11 = m[5] / sy,
      r12 = m[9] / sz;
    const r20 = m[2] / sx,
      r21 = m[6] / sy,
      r22 = m[10] / sz;

    // Fix negative-scale (reflection) case: if determinant < 0, flip sign of one scale and corresponding column
    const det3 = r00 * (r11 * r22 - r12 * r21) - r01 * (r10 * r22 - r12 * r20) + r02 * (r10 * r21 - r11 * r20);
    if (det3 < 0) {
      // flip Z
      sz = -sz;
      // flip third column sign
      // multiply cz by -1 => r02,r12,r22 *= -1
      // recompute normalized r* accordingly:
      // since we only need a valid rotation matrix for quaternion conversion,
      // just invert the third column
      // (alternatively flip sx or sy—this is a convention choice)
      // Here we flip the third column:
      // r02 = -r02; r12 = -r12; r22 = -r22;
    }

    // Build quaternion from rotation matrix (r00..r22)
    // Using standard conversion (column-major rotation)
    const trace = r00 + r11 + r22;
    let qx, qy, qz, qw;
    if (trace > 0.00001) {
      const s = Math.sqrt(trace + 1.0) * 2; // s=4*qw
      qw = 0.25 * s;
      qx = (r21 - r12) / s;
      qy = (r02 - r20) / s;
      qz = (r10 - r01) / s;
    } else if (r00 > r11 && r00 > r22) {
      const s = Math.sqrt(1.0 + r00 - r11 - r22) * 2; // s=4*qx
      qw = (r21 - r12) / s;
      qx = 0.25 * s;
      qy = (r01 + r10) / s;
      qz = (r02 + r20) / s;
    } else if (r11 > r22) {
      const s = Math.sqrt(1.0 + r11 - r00 - r22) * 2; // s=4*qy
      qw = (r02 - r20) / s;
      qx = (r01 + r10) / s;
      qy = 0.25 * s;
      qz = (r12 + r21) / s;
    } else {
      const s = Math.sqrt(1.0 + r22 - r00 - r11) * 2; // s=4*qz
      qw = (r10 - r01) / s;
      qx = (r02 + r20) / s;
      qy = (r12 + r21) / s;
      qz = 0.25 * s;
    }
    const rot = new Float32Array([qx, qy, qz, qw]);
    const scale = new Float32Array([sx, sy, sz]);
    return {
      translation: t,
      rotation: rot,
      scale: scale
    };
  }
  slerp(q0, q1, t, out) {
    let dot = q0[0] * q1[0] + q0[1] * q1[1] + q0[2] * q1[2] + q0[3] * q1[3];
    if (dot < 0) {
      dot = -dot;
      q1 = [-q1[0], -q1[1], -q1[2], -q1[3]];
    }
    if (dot > 0.9995) {
      // linear
      for (let i = 0; i < 4; i++) out[i] = q0[i] + t * (q1[i] - q0[i]);
      // normalize
      const len = Math.hypot(...out);
      for (let i = 0; i < 4; i++) out[i] /= len;
      return;
    }
    const theta0 = Math.acos(dot);
    const theta = theta0 * t;
    const sinTheta = Math.sin(theta);
    const sinTheta0 = Math.sin(theta0);
    const s0 = Math.cos(theta) - dot * sinTheta / sinTheta0;
    const s1 = sinTheta / sinTheta0;
    for (let i = 0; i < 4; i++) {
      out[i] = s0 * q0[i] + s1 * q1[i];
    }
  }
  updateSingleBoneCubeAnimation(glbAnimation, nodes, time, boneMatrices) {
    // const channels = glbAnimation.channels;
    const samplers = glbAnimation.samplers;
    // --- Map channels per node for faster lookup

    this._nodeChannels.clear();
    const anim = this.glb.glbJsonData.animations[this.glb.animationIndex];
    for (const channel of anim.channels) {
      if (!this._nodeChannels.has(channel.target.node)) this._nodeChannels.set(channel.target.node, []);
      this._nodeChannels.get(channel.target.node).push(channel);
    }
    const nodeChannels = this._nodeChannels;
    for (let j = 0; j < this.skeleton.length; j++) {
      const nodeIndex = this.skeleton[j];
      const node = nodes[nodeIndex];

      // --- Initialize node TRS if needed
      if (!node.translation) node.translation = new Float32Array([0, 0, 0]);
      if (!node.rotation) node.rotation = _wgpuMatrix.quat.create();
      if (!node.scale) node.scale = new Float32Array([1, 1, 1]);

      // --- Keep original TRS for additive animation
      if (!node.originalTranslation) node.originalTranslation = node.translation.slice();
      if (!node.originalRotation) node.originalRotation = node.rotation.slice();
      if (!node.originalScale) node.originalScale = node.scale.slice();
      const channelsForNode = nodeChannels.get(nodeIndex) || [];
      for (const channel of channelsForNode) {
        const path = channel.target.path; // "translation" | "rotation" | "scale"
        const sampler = samplers[channel.sampler];
        // --- Get input/output arrays
        const inputTimes = this.getAccessorArray(this.glb, sampler.input);
        const outputArray = this.getAccessorArray(this.glb, sampler.output);
        const numComponents = path === "rotation" ? 4 : 3;
        // --- Find keyframe interval
        const animTime = time % inputTimes[inputTimes.length - 1];
        let i = 0;
        while (i < inputTimes.length - 1 && inputTimes[i + 1] <= animTime) i++;
        const t0 = inputTimes[i];
        const t1 = inputTimes[Math.min(i + 1, inputTimes.length - 1)];
        const factor = t1 !== t0 ? (animTime - t0) / (t1 - t0) : 0;
        // --- Interpolated keyframe values
        const v0 = outputArray.subarray(i * numComponents, (i + 1) * numComponents);
        const v1 = outputArray.subarray(Math.min(i + 1, inputTimes.length - 1) * numComponents, Math.min(i + 2, inputTimes.length) * numComponents);
        // --- Apply animation
        if (path === "translation") {
          for (let k = 0; k < 3; k++) node.translation[k] = v0[k] * (1 - factor) + v1[k] * factor;
        } else if (path === "scale") {
          for (let k = 0; k < 3; k++) node.scale[k] = v0[k] * (1 - factor) + v1[k] * factor;
        } else if (path === "rotation") {
          this.slerp(v0, v1, factor, node.rotation);
        }
      }
      // --- Recompose local transform
      node.transform = this.composeMatrix(node.translation, node.rotation, node.scale);
    }
    const computeWorld = nodeIndex => {
      const node = nodes[nodeIndex];
      if (!node.worldMatrix) node.worldMatrix = _wgpuMatrix.mat4.create();
      let parentWorld = node.parent !== null ? nodes[node.parent].worldMatrix : null;
      if (parentWorld) {
        // multiply parent * local
        _wgpuMatrix.mat4.multiply(parentWorld, node.transform, node.worldMatrix);
      } else {
        _wgpuMatrix.mat4.copy(node.transform, node.worldMatrix);
      }

      // maybe no need to exist...
      _wgpuMatrix.mat4.scale(node.worldMatrix, [this.scaleBoneTest, this.scaleBoneTest, this.scaleBoneTest], node.worldMatrix);
      if (node.children) {
        for (const childIndex of node.children) computeWorld(childIndex);
      }
    };
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].parent === null || nodes[i].parent === undefined) {
        computeWorld(i);
      }
    }
    for (let j = 0; j < this.skeleton.length; j++) {
      const jointNode = nodes[this.skeleton[j]];
      _wgpuMatrix.mat4.multiply(jointNode.worldMatrix, jointNode.inverseBindMatrix, this._tempMat);
      boneMatrices.set(this._tempMat, j * 16);
    }
    this.device.queue.writeBuffer(this.bonesBuffer, 0, boneMatrices);
    return boneMatrices;
  }
}
exports.BVHPlayer = BVHPlayer;

},{"../mesh-obj":50,"./webgpu-gltf.js":47,"bvh-loader":8,"wgpu-matrix":22}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GLTFTexture = exports.GLTFSampler = exports.GLTFPrimitive = exports.GLTFNode = exports.GLTFMesh = exports.GLTFMaterial = exports.GLTFBufferView = exports.GLTFBuffer = exports.GLTFAccessor = exports.GLBModel = void 0;
exports.uploadGLBModel = uploadGLBModel;
var _glMatrix = require("gl-matrix");
/**
 * @author Nikola Lukic zlatnaspirala
 * @description
 * Importer is adapted for matrix-engine-wgpu.
 * Improved - Fix children empty array.
 * Access to json raw data.
 * @source
 * https://github.com/Twinklebear/webgpu-gltf/blob/main/src/glb_import.js
 */

const GLTFRenderMode = {
  POINTS: 0,
  LINE: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  // Note: fans are not supported in WebGPU, use should be
  // an error or converted into a list/strip
  TRIANGLE_FAN: 6
};
const GLTFComponentType = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
};
const GLTFTextureFilter = {
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987
};
const GLTFTextureWrap = {
  REPEAT: 10497,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648
};
function alignTo(val, align) {
  return Math.floor((val + align - 1) / align) * align;
}
function gltfTypeNumComponents(type) {
  switch (type) {
    case 'SCALAR':
      return 1;
    case 'VEC2':
      return 2;
    case 'VEC3':
      return 3;
    case 'VEC4':
      return 4;
    default:
      alert('Unhandled glTF Type ' + type);
      return null;
  }
}
function gltfTypeSize(componentType, type) {
  var typeSize = 0;
  switch (componentType) {
    case GLTFComponentType.BYTE:
      typeSize = 1;
      break;
    case GLTFComponentType.UNSIGNED_BYTE:
      typeSize = 1;
      break;
    case GLTFComponentType.SHORT:
      typeSize = 2;
      break;
    case GLTFComponentType.UNSIGNED_SHORT:
      typeSize = 2;
      break;
    case GLTFComponentType.INT:
      typeSize = 4;
      break;
    case GLTFComponentType.UNSIGNED_INT:
      typeSize = 4;
      break;
    case GLTFComponentType.FLOAT:
      typeSize = 4;
      break;
    case GLTFComponentType.DOUBLE:
      typeSize = 4;
      break;
    default:
      alert('Unrecognized GLTF Component Type?');
  }
  return gltfTypeNumComponents(type) * typeSize;
}
class GLTFBuffer {
  constructor(buffer, size, offset) {
    this.arrayBuffer = buffer;
    this.size = size;
    this.byteOffset = offset;
  }
}
exports.GLTFBuffer = GLTFBuffer;
class GLTFBufferView {
  constructor(buffer, view) {
    this.length = view['byteLength'];
    this.byteOffset = buffer.byteOffset;
    if (view['byteOffset'] !== undefined) {
      this.byteOffset += view['byteOffset'];
    }
    this.byteStride = 0;
    if (view['byteStride'] !== undefined) {
      this.byteStride = view['byteStride'];
    }
    this.buffer = new Uint8Array(buffer.arrayBuffer, this.byteOffset, this.length);
    this.needsUpload = false;
    this.gpuBuffer = null;
    this.usage = 0;
  }
  addUsage(usage) {
    this.usage = this.usage | usage;
  }
  upload(device) {
    // Note: must align to 4 byte size when mapped at creation is true
    var buf = device.createBuffer({
      size: alignTo(this.buffer.byteLength, 4),
      usage: this.usage,
      mappedAtCreation: true
    });
    new this.buffer.constructor(buf.getMappedRange()).set(this.buffer);
    buf.unmap();
    this.gpuBuffer = buf;
    this.needsUpload = false;
  }
}
exports.GLTFBufferView = GLTFBufferView;
class GLTFAccessor {
  constructor(view, accessor, weightsAccessIndex) {
    this.count = accessor['count'];
    this.componentType = accessor['componentType'];
    this.gltfType = accessor['type'];
    this.numComponents = gltfTypeNumComponents(accessor['type']);
    this.numScalars = this.count * this.numComponents;
    this.view = view;
    this.byteOffset = 0;
    if (accessor['byteOffset'] !== undefined) {
      this.byteOffset = accessor['byteOffset'];
    }
    if (weightsAccessIndex) this.weightsAccessIndex = weightsAccessIndex;
  }
  get byteStride() {
    var elementSize = gltfTypeSize(this.componentType, this.gltfType);
    return Math.max(elementSize, this.view.byteStride);
  }
}
exports.GLTFAccessor = GLTFAccessor;
class GLTFPrimitive {
  constructor(indices, positions, normals, texcoords, material, topology, weights, joints, tangents) {
    this.indices = indices;
    this.positions = positions;
    this.normals = normals;
    this.texcoords = texcoords;
    this.material = material;
    this.topology = topology;
    this.weights = weights;
    this.joints = joints;
    this.tangents = tangents;
  }
}
exports.GLTFPrimitive = GLTFPrimitive;
class GLTFMesh {
  constructor(name, primitives) {
    this.name = name;
    this.primitives = primitives;
  }
}
exports.GLTFMesh = GLTFMesh;
class GLTFNode {
  constructor(name, mesh, transform, n) {
    this.name = name;
    this.mesh = mesh;
    this.transform = transform;
    this.gpuUniforms = null;
    this.bindGroup = null;
    this.children = n.children || [];
  }
  upload(device) {
    var buf = device.createBuffer({
      size: 4 * 4 * 4,
      usage: GPUBufferUsage.UNIFORM,
      mappedAtCreation: true
    });
    new Float32Array(buf.getMappedRange()).set(this.transform);
    buf.unmap();
    this.gpuUniforms = buf;
  }
}
exports.GLTFNode = GLTFNode;
function readNodeTransform(node) {
  if (node['matrix']) {
    var m = node['matrix'];
    // Both glTF and gl matrix are column major
    return _glMatrix.mat4.fromValues(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
  } else {
    var scale = [1, 1, 1];
    var rotation = [0, 0, 0, 1];
    var translation = [0, 0, 0];
    if (node['scale']) {
      scale = node['scale'];
    }
    if (node['rotation']) {
      rotation = node['rotation'];
    }
    if (node['translation']) {
      translation = node['translation'];
    }
    var m = _glMatrix.mat4.create();
    return _glMatrix.mat4.fromRotationTranslationScale(m, rotation, translation, scale);
  }
}

// function flattenGLTFChildren(nodes, node, parent_transform) {
//   var tfm = readNodeTransform(node);
//   var tfm = mat4.mul(tfm, parent_transform, tfm);
//   node['matrix'] = tfm;
//   node['scale'] = undefined;
//   node['rotation'] = undefined;
//   node['translation'] = undefined;
//   if(node['children']) {
//     for(var i = 0;i < node['children'].length;++i) {
//       flattenGLTFChildren(nodes, nodes[node['children'][i]], tfm);
//     }
//     node['children'] = [];
//   }
// }

function flattenGLTFChildren(nodes, node, parent_transform) {
  var tfm = readNodeTransform(node);
  var tfm = _glMatrix.mat4.mul(tfm, parent_transform, tfm);
  node['matrix'] = tfm;
  node['scale'] = undefined;
  node['rotation'] = undefined;
  node['translation'] = undefined;
  if (node['children']) {
    for (var i = 0; i < node['children'].length; ++i) {
      flattenGLTFChildren(nodes, nodes[node['children'][i]], tfm);
    }
    // node['children'] = []; // REMOVE THIS LINE
  }
}
function makeGLTFSingleLevel(nodes) {
  var rootTfm = _glMatrix.mat4.create();
  for (var i = 0; i < nodes.length; ++i) {
    flattenGLTFChildren(nodes, nodes[i], rootTfm);
  }
  return nodes;
}
class GLTFMaterial {
  constructor(material, textures) {
    this.baseColorFactor = [1, 1, 1, 1];
    this.baseColorTexture = null;
    // padded to float4
    this.emissiveFactor = [0, 0, 0, 1];
    this.metallicFactor = 1.0;
    this.roughnessFactor = 1.0;
    if (material['pbrMetallicRoughness'] !== undefined) {
      var pbr = material['pbrMetallicRoughness'];
      if (pbr['baseColorFactor'] !== undefined) {
        this.baseColorFactor = pbr['baseColorFactor'];
      }
      if (pbr['baseColorTexture'] !== undefined) {
        // TODO multiple texcoords
        this.baseColorTexture = textures[pbr['baseColorTexture']['index']];
      }
      if (pbr['metallicFactor'] !== undefined) {
        this.metallicFactor = pbr['metallicFactor'];
      }
      if (pbr['roughnessFactor'] !== undefined) {
        this.roughnessFactor = pbr['roughnessFactor'];
      }
    }
    if (material['emissiveFactor'] !== undefined) {
      this.emissiveFactor[0] = material['emissiveFactor'][0];
      this.emissiveFactor[1] = material['emissiveFactor'][1];
      this.emissiveFactor[2] = material['emissiveFactor'][2];
    }
    this.gpuBuffer = null;
    this.bindGroupLayout = null;
    this.bindGroup = null;
  }
  upload(device) {
    var buf = device.createBuffer({
      size: 3 * 4 * 4,
      usage: GPUBufferUsage.UNIFORM,
      mappedAtCreation: true
    });
    var mappingView = new Float32Array(buf.getMappedRange());
    mappingView.set(this.baseColorFactor);
    mappingView.set(this.emissiveFactor, 4);
    mappingView.set([this.metallicFactor, this.roughnessFactor], 8);
    buf.unmap();
    this.gpuBuffer = buf;
    var layoutEntries = [{
      binding: 0,
      visibility: GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }];
    var bindGroupEntries = [{
      binding: 0,
      resource: {
        buffer: this.gpuBuffer
      }
    }];
    if (this.baseColorTexture) {
      // Defaults for sampler and texture are fine, just make the objects
      // exist to pick them up
      layoutEntries.push({
        binding: 1,
        visibility: GPUShaderStage.FRAGMENT,
        sampler: {}
      });
      layoutEntries.push({
        binding: 2,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {}
      });
      bindGroupEntries.push({
        binding: 1,
        resource: this.baseColorTexture.sampler
      });
      bindGroupEntries.push({
        binding: 2,
        resource: this.baseColorTexture.imageView
      });
    }
    this.bindGroupLayout = device.createBindGroupLayout({
      entries: layoutEntries
    });
    this.bindGroup = device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: bindGroupEntries
    });
  }
}
exports.GLTFMaterial = GLTFMaterial;
class GLTFSampler {
  constructor(sampler, device) {
    var magFilter = sampler['magFilter'] === undefined || sampler['magFilter'] == GLTFTextureFilter.LINEAR ? 'linear' : 'nearest';
    var minFilter = sampler['minFilter'] === undefined || sampler['minFilter'] == GLTFTextureFilter.LINEAR ? 'linear' : 'nearest';
    var wrapS = 'repeat';
    if (sampler['wrapS'] !== undefined) {
      if (sampler['wrapS'] == GLTFTextureFilter.REPEAT) {
        wrapS = 'repeat';
      } else if (sampler['wrapS'] == GLTFTextureFilter.CLAMP_TO_EDGE) {
        wrapS = 'clamp-to-edge';
      } else {
        wrapS = 'mirror-repeat';
      }
    }
    var wrapT = 'repeat';
    if (sampler['wrapT'] !== undefined) {
      if (sampler['wrapT'] == GLTFTextureFilter.REPEAT) {
        wrapT = 'repeat';
      } else if (sampler['wrapT'] == GLTFTextureFilter.CLAMP_TO_EDGE) {
        wrapT = 'clamp-to-edge';
      } else {
        wrapT = 'mirror-repeat';
      }
    }
    this.sampler = device.createSampler({
      magFilter: magFilter,
      minFilter: minFilter,
      addressModeU: wrapS,
      addressModeV: wrapT
    });
  }
}
exports.GLTFSampler = GLTFSampler;
class GLTFTexture {
  constructor(sampler, image) {
    this.gltfsampler = sampler;
    this.sampler = sampler.sampler;
    this.image = image;
    this.imageView = image.createView();
  }
}
exports.GLTFTexture = GLTFTexture;
class GLBModel {
  constructor(nodes, skins, skinnedMeshNodes, glbJsonData, glbBinaryBuffer, noSkinMeshNodes) {
    this.noSkinMeshNodes = noSkinMeshNodes;
    this.nodes = nodes;
    this.skins = skins;
    this.skinnedMeshNodes = skinnedMeshNodes;
    this.bvhToGLBMap = null;
    this.glbJsonData = glbJsonData;
    this.glbBinaryBuffer = glbBinaryBuffer;
  }
}
exports.GLBModel = GLBModel;
;

// function getComponentSize(componentType) {
//   switch(componentType) {
//     case 5126: return 4; // float32
//     case 5123: return 2; // uint16
//     case 5121: return 1; // uint8
//     default: throw new Error("Unknown componentType: " + componentType);
//   }
// }

// Upload a GLB model and return it
async function uploadGLBModel(buffer, device) {
  // 1️⃣ Validate header
  const header = new Uint32Array(buffer, 0, 5);
  if (header[0] !== 0x46546C67) {
    alert('This does not appear to be a glb file?');
    return;
  }

  // 2️⃣ JSON chunk
  const glbJsonData = JSON.parse(new TextDecoder('utf-8').decode(new Uint8Array(buffer, 20, header[3])));

  // 3️⃣ Binary chunk header + buffer
  const binaryHeader = new Uint32Array(buffer, 20 + header[3], 2);
  const glbBuffer = new GLTFBuffer(buffer, binaryHeader[0], 28 + header[3]);

  // 4️⃣ BufferViews
  const bufferViews = glbJsonData.bufferViews.map(v => new GLTFBufferView(glbBuffer, v));
  const binaryOffset = 28 + header[3];
  const binaryLength = binaryHeader[0];

  // ✅ raw ArrayBuffer slice of the binary chunk:
  const glbBinaryBuffer = buffer.slice(binaryOffset, binaryOffset + binaryLength);

  // 5️⃣ Load images
  const images = [];
  if (glbJsonData.images) {
    for (const imgJson of glbJsonData.images) {
      const view = new GLTFBufferView(glbBuffer, glbJsonData.bufferViews[imgJson.bufferView]);
      const blob = new Blob([view.buffer], {
        type: imgJson['mime/type']
      });
      const img = await createImageBitmap(blob);
      const gpuImg = device.createTexture({
        size: [img.width, img.height, 1],
        format: 'rgba8unorm-srgb',
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
      });
      device.queue.copyExternalImageToTexture({
        source: img
      }, {
        texture: gpuImg
      }, [img.width, img.height, 1]);
      images.push(gpuImg);
    }
  }
  glbJsonData.glbTextures = images;
  // console.log('IMAGES FROM GLB: ', images)
  // 6️⃣ Samplers, Textures, Materials
  const defaultSampler = new GLTFSampler({}, device);
  const samplers = (glbJsonData.samplers || []).map(s => new GLTFSampler(s, device));
  const textures = (glbJsonData.textures || []).map(tex => {
    const sampler = tex.sampler !== undefined ? samplers[tex.sampler] : defaultSampler;
    return new GLTFTexture(sampler, images[tex.source]);
  });
  const defaultMaterial = new GLTFMaterial({});
  const materials = (glbJsonData.materials || []).map(m => new GLTFMaterial(m, textures));

  // 7️⃣ Meshes
  const meshes = (glbJsonData.meshes || []).map(mesh => {
    const primitives = mesh.primitives.map(prim => {
      const topology = prim.mode ?? GLTFRenderMode.TRIANGLES;
      // console.log('topology ', topology)
      // Indices
      let indices = null;
      if (prim.indices !== undefined) {
        const accessor = glbJsonData.accessors[prim.indices];
        const viewID = accessor.bufferView;
        bufferViews[viewID].needsUpload = true;
        bufferViews[viewID].addUsage(GPUBufferUsage.INDEX);
        indices = new GLTFAccessor(bufferViews[viewID], accessor);
      }
      // Vertex attributes
      let positions = null,
        normals = null,
        tangents = null,
        texcoords = [];
      let weights = null;
      let joints = null;
      for (const attr in prim.attributes) {
        const accessor = glbJsonData.accessors[prim.attributes[attr]];
        const viewID = accessor.bufferView;
        bufferViews[viewID].needsUpload = true;
        bufferViews[viewID].addUsage(GPUBufferUsage.VERTEX);
        if (attr === 'POSITION') {
          positions = new GLTFAccessor(bufferViews[viewID], accessor);
        } else if (attr === 'NORMAL') {
          normals = new GLTFAccessor(bufferViews[viewID], accessor);
        } else if (attr.startsWith('TEXCOORD')) {
          texcoords.push(new GLTFAccessor(bufferViews[viewID], accessor));
        } else if (attr === 'WEIGHTS_0') {
          weights = new GLTFAccessor(bufferViews[viewID], accessor, prim.attributes['WEIGHTS_0']);
        } else if (attr.startsWith('JOINTS')) {
          joints = new GLTFAccessor(bufferViews[viewID], accessor);
        } else if (attr === 'TANGENT') {
          tangents = new GLTFAccessor(bufferViews[viewID], accessor);
        } else {
          console.log('unknow-attr:', attr);
        }
      }
      const material = prim.material !== undefined ? materials[prim.material] : defaultMaterial;
      return new GLTFPrimitive(indices, positions, normals, texcoords, material, topology, weights, joints, tangents);
    });
    return new GLTFMesh(mesh.name, primitives);
  });

  // Upload buffers & materials
  for (const bv of bufferViews) if (bv.needsUpload) bv.upload(device);
  defaultMaterial.upload(device);
  for (const m of materials) m.upload(device);
  // 8️⃣ Skins (we only store the index of inverseBindMatrices here)
  const skins = (glbJsonData.skins || []).map(skin => ({
    name: skin.name,
    joints: skin.joints,
    inverseBindMatrices: skin.inverseBindMatrices // accessor index
  }));
  // 9️⃣ Nodes
  const nodes = [];
  const gltfNodes = makeGLTFSingleLevel(glbJsonData.nodes);
  for (let i = 0; i < gltfNodes.length; i++) {
    const n = gltfNodes[i];
    const meshObj = n.mesh !== undefined ? meshes[n.mesh] : null;
    const node = new GLTFNode(n.name, meshObj, readNodeTransform(n), n);
    if (n.skin !== undefined) node.skin = n.skin; // skin index
    node.upload(device);
    nodes.push(node);
  }

  // 🟩 Build parent references:
  for (let i = 0; i < gltfNodes.length; i++) {
    const srcNode = gltfNodes[i];
    // srcNode.children is an array of indices
    if (srcNode.children) {
      for (const childIndex of srcNode.children) {
        nodes[childIndex].parent = i; // add .parent to the child node
      }
    }
  }
  // Ensure nodes without parent are root nodes
  for (const node of nodes) {
    if (node.parent === undefined) node.parent = null;
  }
  const skinnedMeshNodes = nodes.filter(n => n.mesh && n.skin !== undefined);
  let noSkinMeshNodes = null;
  if (skinnedMeshNodes.length === 0) {
    console.warn('No skins found — mesh not bound to skeleton');
    noSkinMeshNodes = nodes.filter(n => n.mesh);
  } else {
    skinnedMeshNodes.forEach(n => {
      // console.log('Mesh', n.mesh.name, 'uses skin index', n.skin);
      // Per-mesh uniform buffer (example)
      n.sceneUniformBuffer = device.createBuffer({
        size: 44 * 4,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
    });
  }
  let R = new GLBModel(nodes, skins, skinnedMeshNodes, glbJsonData, glbBinaryBuffer, noSkinMeshNodes);
  return R;
}

},{"gl-matrix":11}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _fragment = require("../shaders/fragment.wgsl");
var _fragmentWgsl = require("../shaders/fragment.wgsl.metal");
var _fragmentWgsl2 = require("../shaders/fragment.wgsl.normalmap");
var _fragmentWgsl3 = require("../shaders/fragment.wgsl.pong");
var _fragmentWgsl4 = require("../shaders/fragment.wgsl.power");
var _fragmentMix = require("../shaders/mixed/fragmentMix1.wgsl");
var _waterC = require("../shaders/water/water-c.wgls");
var _fragmentMirror = require("../shaders/fragment.mirror.wgsl");
var _utils = require("./utils");
/**
 * @description
 * Created for matrix-engine-wgpu project. MeshObj class estends Materials.
 * @variable material is engine meta data variable not real material object.
 * @author Nikola Lukic
 * @email zlatnaspirala@gmail.com
 */
class Materials {
  constructor(device, material, glb, textureCache) {
    this.device = device;
    this.textureCache = textureCache;
    this.glb = glb;
    this.material = material;
    this.isVideo = false;
    this.videoIsReady = 'NONE';
    this.compareSampler = this.device.createSampler({
      compare: 'less-equal',
      // safer for shadow comparison
      addressModeU: 'clamp-to-edge',
      // prevents UV leaking outside
      addressModeV: 'clamp-to-edge',
      magFilter: 'linear',
      // smooth PCF
      minFilter: 'linear'
    });
    // For image textures (standard sampler)
    this.imageSampler = this.device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear',
      addressModeU: "repeat",
      addressModeV: "repeat",
      addressModeW: "repeat"
    });
    // For external video textures (needs to be filtering sampler too!)
    this.videoSampler = this.device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear'
    });
    // FX effect
    this.postFXModeBuffer = this.device.createBuffer({
      size: 4,
      // u32 = 4 bytes
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    // Dymmy buffer
    this.dummySpotlightUniformBuffer = this.device.createBuffer({
      size: 80,
      // Must match size in shader
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(this.dummySpotlightUniformBuffer, 0, new Float32Array(20));
    // Create a 1x1 RGBA texture filled with white
    const mrDummyTex = this.device.createTexture({
      size: [1, 1, 1],
      format: this.getFormat(),
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    // Upload a single pixel
    const pixel = new Uint8Array([255, 255, 255, 255]); // white RGBA
    this.device.queue.writeTexture({
      texture: mrDummyTex
    }, pixel, {
      bytesPerRow: 4
    }, [1, 1, 1]);
    this.metallicRoughnessTextureView = mrDummyTex.createView();
    this.metallicRoughnessSampler = this.device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear'
    });
    // 4 floats for baseColorFactor + 1 metallic + 1 roughness + 2 pad floats = 8 floats
    const materialPBRSize = 8 * 4; // 32 bytes
    this.materialPBRBuffer = this.device.createBuffer({
      size: materialPBRSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    const baseColorFactor = [1.0, 1.0, 1.0, 1.0];
    const metallicFactor = 0.1;
    const roughnessFactor = 0.5;
    const effectMix = 0.0; // NEW: 0.0 = normal PBR, 1.0 = full effect
    const lightingEnabled = 1.0; // NEW: 1.0 = lighting on, 0.0 = effect only
    const materialArray = new Float32Array([...baseColorFactor, metallicFactor, roughnessFactor, effectMix, lightingEnabled]);
    this.device.queue.writeBuffer(this.materialPBRBuffer, 0, materialArray.buffer);
    if (this.material.type == 'normalmap') {
      const normalTexInfo = this.glb.glbJsonData.materials[0].normalTexture;
      if (normalTexInfo) {
        const tex = this.glb.glbJsonData.glbTextures[normalTexInfo.index];
        this.normalTextureView = tex.createView();
        this.normalSampler = this.device.createSampler({
          magFilter: 'linear',
          minFilter: 'linear'
        });
      }
    } else {
      // console.log('>DUMMY>normalTexture>')
      // dummy for normal map 1x1 neutral normal map
      this.normalDummyTex = device.createTexture({
        size: [1, 1, 1],
        format: 'rgba8unorm',
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
      // RGBA value for neutral normal in tangent space
      const neutralNormal = new Uint8Array([128, 128, 255, 255]);
      this.device.queue.writeTexture({
        texture: this.normalDummyTex
      }, neutralNormal, {
        bytesPerRow: 4
      }, [1, 1, 1]);
      // Create texture view & sampler
      this.normalTextureView = this.normalDummyTex.createView();
      this.normalSampler = this.device.createSampler({
        magFilter: 'linear',
        minFilter: 'linear'
      });
    }
    this.createBufferForWater();
  }
  createBufferForWater = () => {
    this.waterBindGroupLayout = this.device.createBindGroupLayout({
      label: '[Water]BindGroupLayout',
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {
          type: 'uniform'
        }
      }]
    });
    this.waterParamsBuffer = this.device.createBuffer({
      label: '[WaterParams]Buffer',
      size: 48,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.waterParamsData = new Float32Array([0.0, 0.2, 0.4,
    // deepColor (vec3f)
    0.5,
    // waveSpeed
    0.0, 0.5, 0.7,
    // shallowColor (vec3f)
    4.0,
    // waveScale
    0.15,
    // waveHeight
    3.0,
    // fresnelPower
    128.0,
    // specularPower
    0.0 // padding
    ]);
    this.device.queue.writeBuffer(this.waterParamsBuffer, 0, this.waterParamsData);
    this.waterBindGroup = this.device.createBindGroup({
      layout: this.waterBindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: this.waterParamsBuffer
        }
      }]
    });
    this.updateWaterParams = (deepColor, shallowColor, waveSpeed, waveScale, waveHeight, fresnelPower, specularPower) => {
      const data = new Float32Array([deepColor[0], deepColor[1], deepColor[2], waveSpeed, shallowColor[0], shallowColor[1], shallowColor[2], waveScale, waveHeight, fresnelPower, specularPower, 0.0 // padding
      ]);
      this.device.queue.writeBuffer(this.waterParamsBuffer, 0, data);
    };
  };
  createDummyTexture(device, size = 256) {
    const data = new Uint8Array(size * size * 4);
    for (let i = 0; i < data.length; i += 4) {
      data[i + 0] = 0;
      data[i + 1] = 255;
      data[i + 2] = 255;
      data[i + 3] = 255;
    }
    const texture = device.createTexture({
      size: [size, size],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    device.queue.writeTexture({
      texture
    }, data, {
      bytesPerRow: size * 4
    }, {
      width: size,
      height: size
    });
    return texture;
  }

  /**
   * @description 
   * Change ONLY base color texture (binding = 3)
   * Does NOT rebuild pipeline or layout
   **/
  changeTexture(newTexture) {
    // Accept GPUTexture OR GPUTextureView
    if (newTexture instanceof GPUTexture) {
      this.texture0 = newTexture;
    } else {
      this.texture0 = {
        createView: () => newTexture
      };
    }
    this.isVideo = false;
    // Recreate bind group only
    this.createBindGroupForRender();
  }
  changeMaterial(newType = 'graph', graphShader) {
    this.material.fromGraph = graphShader;
    this.material.type = newType;
    this.setupPipeline();
  }
  setBlend = alpha => {
    this.material.useBlend = true;
    this.setupMaterialPBR([1, 1, 1, alpha]);
  };
  createMirrorIlluminateBindGroup(mirrorBindGroupLayout, opts) {
    const defaults = {
      mirrorTint: [0.9, 0.95, 1.0],
      // Slight cool tint
      reflectivity: 0.25,
      // 25% reflection blend
      illuminateColor: [0.3, 0.7, 1.0],
      // Soft cyan
      illuminateStrength: 0.4,
      // Gentle rim
      illuminatePulse: 0.0,
      // No pulse (static)
      fresnelPower: 4.0,
      // Medium-sharp edge
      envLodBias: 1.5 // Slightly blurred env
    };
    const cfg = {
      ...defaults,
      ...opts
    };
    const PARAMS_SIZE = 80;
    const paramsBuffer = this.device.createBuffer({
      label: 'MirrorIlluminateParams',
      size: PARAMS_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.writeParamsMirror = o => {
      const data = new Float32Array(16); // Was 12, now 16
      const t = o.mirrorTint ?? cfg.mirrorTint;
      data[0] = t[0];
      data[1] = t[1];
      data[2] = t[2];
      data[3] = o.reflectivity ?? cfg.reflectivity;
      const ic = o.illuminateColor ?? cfg.illuminateColor;
      data[4] = ic[0];
      data[5] = ic[1];
      data[6] = ic[2];
      data[7] = o.illuminateStrength ?? cfg.illuminateStrength;
      data[8] = o.illuminatePulse ?? cfg.illuminatePulse;
      data[9] = o.fresnelPower ?? cfg.fresnelPower;
      data[10] = o.envLodBias ?? cfg.envLodBias;
      data[11] = o.usePlanarReflection ? 1.0 : 0.0;
      data[12] = o.baseColorMix ?? cfg.baseColorMix;
      data[13] = 0; // padding
      data[14] = 0; // padding
      data[15] = 0; // padding
      this.device.queue.writeBuffer(paramsBuffer, 0, data);
    };
    this.writeParamsMirror(cfg);
    const samplerDummy = this.device.createSampler({
      label: 'EnvMap Sampler',
      magFilter: 'linear',
      minFilter: 'linear',
      addressModeU: 'repeat',
      addressModeV: 'clamp-to-edge'
    });
    // ── Dummy 1×1 white env texture (used when no real env map is supplied) ──
    const envTexture = cfg.envTexture instanceof GPUTexture ? cfg.envTexture : cfg.envTexture.texture ?? (() => {
      console.warn('⚠️ No envTexture provided, using white dummy!');
      const tex = this.device.createTexture({
        label: 'MirrorEnvDummy',
        size: [1, 1],
        format: 'rgba8unorm',
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
      this.device.queue.writeTexture({
        texture: tex
      }, new Uint8Array([255, 0, 0, 255]), {
        bytesPerRow: 4
      }, [1, 1]);
      return tex;
    })();
    const bindGroup = this.device.createBindGroup({
      label: 'MirrorIlluminate BindGroup',
      layout: mirrorBindGroupLayout,
      entries: [{
        binding: 0,
        resource: {
          buffer: paramsBuffer
        }
      }, {
        binding: 1,
        resource: envTexture.createView()
      }, {
        binding: 2,
        resource: cfg.envTexture.sampler ?? samplerDummy
      }]
    });
    return {
      bindGroup,
      paramsBuffer,
      /** Call this at runtime to hot-update mirror params without rebuilding. */
      updateParams: o => this.writeParamsMirror(o)
    };
  }
  getMaterial() {
    // console.log('Material TYPE:', this.material.type);
    if (this.material.type == 'standard') {
      return _fragment.fragmentWGSL;
    } else if (this.material.type == 'pong') {
      return _fragmentWgsl3.fragmentWGSLPong;
    } else if (this.material.type == 'power') {
      return _fragmentWgsl4.fragmentWGSLPower;
    } else if (this.material.type == 'metal') {
      return _fragmentWgsl.fragmentWGSLMetal;
    } else if (this.material.type == 'normalmap') {
      return _fragmentWgsl2.fragmentWGSLNormalMap;
    } else if (this.material.type == 'water') {
      return _waterC.fragmentWaterWGSL;
    } else if (this.material.type == 'graph') {
      // console.warn('Unknown material ???????????????:', this.material?.type);
      return this.material.fromGraph;
    } else if (this.material.type == 'mix1') {
      return _fragmentMix.fragmentWGSLMix1; // ?
    } else if (this.material.type === "mirror") {
      return _fragmentMirror.mirrorIlluminateFragmentWGSL;
    }
    console.warn('Unknown material type:', this.material?.type);
    return _fragment.fragmentWGSL;
  }
  getFormat() {
    if (this.material?.format == 'darker') {
      return 'rgba8unorm-srgb';
    } else if (this.material?.format == 'normal') {
      return 'rgba8unorm';
    } else {
      return 'rgba8unorm';
    }
  }
  setupMaterialPBR(baseColorFactor, metallicFactor, roughnessFactor, effectMix = 0.0, lightingEnabled = 1.0) {
    if (!metallicFactor) metallicFactor = 0.5;
    if (!baseColorFactor) baseColorFactor = [1.0, 1.0, 1.0, 0.5];
    if (!roughnessFactor) roughnessFactor = 0.5;
    const materialArray = new Float32Array([...baseColorFactor, metallicFactor, roughnessFactor, effectMix, lightingEnabled]);
    this.device.queue.writeBuffer(this.materialPBRBuffer, 0, materialArray.buffer);
  }
  setMixEffectMode(mode = 'normal') {
    let effectMix = 0.0;
    let lightingEnabled = 1.0;
    switch (mode) {
      case 'normal':
        effectMix = 0.0;
        lightingEnabled = 1.0;
        break;
      case 'subtle':
        effectMix = 0.3;
        lightingEnabled = 1.0;
        break;
      case 'blend':
        effectMix = 0.5;
        lightingEnabled = 1.0;
        break;
      case 'full':
        effectMix = 1.0;
        lightingEnabled = 1.0;
        break;
      case 'pure':
        effectMix = 1.0;
        lightingEnabled = 0.0;
        break;
    }
    const baseColorFactor = this.currentBaseColor || [1.0, 1.0, 1.0, 1.0];
    const metallicFactor = this.currentMetallic || 0.1;
    const roughnessFactor = this.currentRoughness || 0.5;
    this.setupMaterialPBR(baseColorFactor, metallicFactor, roughnessFactor, effectMix, lightingEnabled);
  }
  updatePostFXMode(mode) {
    const arrayBuffer = new Uint32Array([mode]);
    this.device.queue.writeBuffer(this.postFXModeBuffer, 0, arrayBuffer);
  }
  async loadTex0(texturesPaths) {
    const path = texturesPaths[0];
    const {
      texture,
      sampler
    } = await this.textureCache.get(path, this.getFormat());
    this.texture0 = texture;
    this.sampler = sampler;
  }
  async loadEnvMap(texturesPaths, isEnvMap = false) {
    const path = texturesPaths[1] || texturesPaths[0];
    const {
      texture,
      sampler
    } = await this.textureCache.get(path, this.getFormat(), isEnvMap);
    return {
      texture,
      sampler
    };
  }
  async loadVideoTexture(arg) {
    this.videoIsReady = 'MAYBE';
    if (arg.type === 'video') {
      this.video = document.createElement('video');
      this.video.src = arg.src || 'res/videos/tunel.mp4';
      this.video.crossOrigin = 'anonymous';
      this.video.autoplay = true;
      this.video.loop = true;
      document.body.append(this.video);
      this.video.style.display = 'none';
      this.video.style.position = 'absolute';
      this.video.style.top = '750px';
      this.video.style.left = '50px';
      await this.video.play();
      this.isVideo = true;
    } else if (arg.type === 'videoElement') {
      this.video = arg.el;
      await this.video.play();
    } else if (arg.type === 'camera') {
      if (!(0, _utils.byId)(`core-${this.name}`)) {
        this.video = document.createElement('video');
        this.video.id = `core-${this.name}`;
        this.video.autoplay = true;
        this.video.muted = true;
        this.video.playsInline = true;
        this.video.style.display = 'none';
        document.body.append(this.video);
        try {
          const stream = await navigator.mediaDevices?.getUserMedia?.({
            video: {
              width: {
                ideal: 1280
              },
              height: {
                ideal: 720
              }
            },
            audio: false
          });
          this.video.srcObject = stream;
          await this.video.play();
          this.isVideo = true;
        } catch (err) {
          console.info("❌ Failed to access camera:", err);
          // return;
        }
      }
    } else if (arg.type === 'canvas2d') {
      // Existing canvas (arg.el) — assume it's actively drawing
      this.video = document.createElement('video');
      this.video.autoplay = true;
      this.video.muted = true;
      this.video.crossOrigin = 'anonymous';
      this.video.style.display = 'none';
      document.body.append(this.video);
      const stream = arg.el.captureStream?.() || arg.el.mozCaptureStream?.();
      if (!stream) {
        console.error('❌ Cannot capture stream from canvas2d');
        return;
      }
      this.video.srcObject = stream;
      await this.video.play();
      this.isVideo = true;
    } else if (arg.type === 'canvas2d-inline') {
      // console.log('what is arg', arg);
      // Miniature inline-drawn canvas created dynamically
      const canvas = document.createElement('canvas');
      canvas.width = arg.width || 256;
      canvas.height = arg.height || 256;
      canvas.style.position = 'absolute';
      canvas.style.left = '-1000px';
      canvas.style.top = '0';
      // canvas.style.zIndex = '10000';
      document.body.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      if (typeof arg.canvaInlineProgram === 'function') {
        const drawLoop = () => {
          ctx.save();
          ctx.translate(canvas.width, 0);
          ctx.scale(-1, 1);
          arg.canvaInlineProgram(ctx, canvas, arg.specialCanvas2dArg);
          ctx.restore();
          requestAnimationFrame(drawLoop);
        };
        drawLoop();
      } else {
        ctx.fillStyle = '#0ce325ff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      this.video = document.createElement('video');
      this.video.style.position = 'absolute';
      // this.video.style.zIndex = '1';
      this.video.style.left = '0px';
      this.video.style.top = '0';
      this.video.autoplay = true;
      this.video.muted = true;
      this.video.playsInline = true;
      this.video.srcObject = canvas.captureStream(60);
      document.body.append(this.video);
      await this.video.play();
      await new Promise(resolve => {
        const check = () => {
          if (this.video.readyState >= 2) resolve();else requestAnimationFrame(check);
        };
        check();
      });
      // console.log('Canvas video stream READY');
      this.isVideo = true;
    }
    this.sampler = this.device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear'
    });
    // ✅ Now - maybe noT
    this.createLayoutForRender();
    this.createBindGroupForRender();
    // dispatchEvent(new CustomEvent('update-pipeine', {detail: {}}))
  }
  updateVideoTexture() {
    if (!this.video || this.video.readyState < 2) {
      // console.info('this.video.readyState', this.video.readyState)
      return;
    }
    if (!this.externalTexture) {
      // create it once
      this.externalTexture = this.device.importExternalTexture({
        source: this.video
      });
      this.createBindGroupForRender();
      this.videoIsReady = 'YES';
      console.log("%c✅video bind.", _utils.LOG_FUNNY_ARCADE);
    } else {
      this.externalTexture = this.device.importExternalTexture({
        source: this.video
      });
      this.createBindGroupForRender();
    }
  }
  getMaterialTexture(glb, materialIndex) {
    const matDef = glb.glbJsonData.materials[materialIndex];
    if (!matDef) {
      console.warn('[engine] no material in glb...');
      return null;
    }
    if (matDef.pbrMetallicRoughness?.baseColorTexture) {
      const texIndex = matDef.pbrMetallicRoughness.baseColorTexture.index;
      return glb.glbJsonData.glbTextures[texIndex].createView();
    }
    return null;
  }
  getMaterialTextureFromMaterial(material) {
    if (!material || !material.pbrMetallicRoughness) return this.fallbackTextureView;
    const texInfo = material.pbrMetallicRoughness.baseColorTexture;
    if (!texInfo) return this.fallbackTextureView;
    const texIndex = texInfo.index;
    return this.glb.glbTextures[texIndex].createView();
  }
  createBindGroupForRender() {
    let textureResource = this.isVideo ? this.externalTexture : this.texture0.createView();
    // console.log('TEST TEX this.texture0 ', this.texture0);
    if (this.material.useTextureFromGlb === true) {
      // 0 probably always for basicColor
      const material = this.skinnedNode.mesh.primitives[0].material;
      const textureView = material.baseColorTexture.imageView;
      // const sampler = material.baseColorTexture.sampler;
      textureResource = textureView;
    }
    if (!textureResource || !this.sceneUniformBuffer || !this.shadowDepthTextureView) {
      if (!textureResource) console.log("%c❗Missing res texture ", _utils.LOG_FUNNY_ARCADE);
      if (!this.sceneUniformBuffer) console.warn("❗Missing res: this.sceneUniformBuffer: ", this.sceneUniformBuffer);
      // if(!this.shadowDepthTextureView) // console.warn("❗Missing res: this.shadowDepthTextureView: ", this.shadowDepthTextureView);
      if (typeof textureResource === 'undefined') {
        this.updateVideoTexture();
      }
      return;
    }
    if (this.isVideo == true) {
      // console.info("✅ video sceneBindGroupForRender");
      this.sceneBindGroupForRender = this.device.createBindGroup({
        label: 'sceneBindGroupForRender [video]',
        layout: this.bglForRender,
        entries: [{
          binding: 0,
          resource: {
            buffer: this.sceneUniformBuffer
          }
        }, {
          binding: 1,
          resource: this.shadowDepthTextureView
        }, {
          binding: 2,
          resource: this.compareSampler
        }, {
          binding: 3,
          resource: textureResource
        }, {
          binding: 4,
          resource: this.videoSampler
        }, {
          binding: 5,
          resource: {
            buffer: this.postFXModeBuffer
          }
        }]
      });
      // Special case for video maybe better solution exist
      if (this.video.paused == true) this.video.play();
    } else {
      this.sceneBindGroupForRender = this.device.createBindGroup({
        label: 'sceneBindGroupForRender [mesh][materials]',
        layout: this.bglForRender,
        entries: [{
          binding: 0,
          resource: {
            buffer: this.sceneUniformBuffer
          }
        }, {
          binding: 1,
          resource: this.shadowDepthTextureView
        }, {
          binding: 2,
          resource: this.compareSampler
        }, {
          binding: 3,
          resource: textureResource
        }, {
          binding: 4,
          resource: this.imageSampler
        }, {
          binding: 5,
          resource: {
            buffer: !this.spotlightUniformBuffer ? this.dummySpotlightUniformBuffer : this.spotlightUniformBuffer
          }
        }, {
          binding: 6,
          resource: this.metallicRoughnessTextureView
        }, {
          binding: 7,
          resource: this.metallicRoughnessSampler
        }, {
          binding: 8,
          resource: {
            buffer: this.materialPBRBuffer
          }
        },
        // NEW: dummy normal map
        {
          binding: 9,
          resource: this.normalTextureView
        }, {
          binding: 10,
          resource: this.normalSampler
        }]
      });
    }
  }
  createLayoutForRender() {
    let e = [{
      binding: 0,
      visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }, ...(this.isVideo == false ? [{
      binding: 1,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: "depth",
        viewDimension: "2d-array",
        // <- must match shadowMapArray
        multisampled: false
      }
    }] : [{
      binding: 1,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: "depth",
        viewDimension: "2d"
      }
    }]), {
      binding: 2,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'comparison'
      }
    }, ...(this.isVideo ? [
    // VIDEO
    {
      binding: 3,
      visibility: GPUShaderStage.FRAGMENT,
      externalTexture: {}
    }, {
      binding: 4,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'filtering'
      } // for video sampling
    }, {
      binding: 5,
      visibility: GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }] : [
    // IMAGE
    {
      binding: 3,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: 'float',
        viewDimension: '2d'
      }
    }, {
      binding: 4,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'filtering'
      }
    }, {
      binding: 5,
      visibility: GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }, {
      binding: 6,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: 'float',
        viewDimension: '2d'
      }
    }, {
      binding: 7,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'filtering'
      }
    }, {
      binding: 8,
      visibility: GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }, {
      binding: 9,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: 'float',
        viewDimension: '2d'
      }
    }, {
      binding: 10,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'filtering'
      }
    }])];
    // console.log("BG E :  is used normal  ", this.material.type)
    this.bglForRender = this.device.createBindGroupLayout({
      label: 'bglForRender',
      entries: e
    });
  }
}
exports.default = Materials;

},{"../shaders/fragment.mirror.wgsl":63,"../shaders/fragment.wgsl":65,"../shaders/fragment.wgsl.metal":66,"../shaders/fragment.wgsl.normalmap":67,"../shaders/fragment.wgsl.pong":68,"../shaders/fragment.wgsl.power":69,"../shaders/mixed/fragmentMix1.wgsl":75,"../shaders/water/water-c.wgls":83,"./utils":56}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rotation = exports.Position = void 0;
var _utils = require("./utils");
/**
 * @description 
 * Sub classes for matrix-wgpu
 * Base class
 * Position { x, y, z }
 */

class Position {
  constructor(x, y, z) {
    // console.log('TEST TYTPOF ', x)
    this.remoteName = null;
    this.netObject = null;
    this.toRemote = [];
    this.teams = [];
    this.netTolerance = 3;
    this.netTolerance__ = 0;
    if (typeof x == 'undefined') x = 0;
    if (typeof y == 'undefined') y = 0;
    if (typeof z == 'undefined') z = 0;
    this.x = parseFloat(x);
    this.y = parseFloat(y);
    this.z = parseFloat(z);
    this.velY = 0;
    this.velX = 0;
    this.velZ = 0;
    this.inMove = false;
    this.targetX = parseFloat(x);
    this.targetY = parseFloat(y);
    this.targetZ = parseFloat(z);
    this.thrust = 0.01;
    return this;
  }
  getSpeed = () => {
    return this.thrust;
  };
  setSpeed = n => {
    if (typeof n === 'number') {
      this.thrust = n;
    } else {
      console.log('Description: arguments (w, h) must be type of number.');
    }
  };
  translateByX(x) {
    if (parseFloat(x) == this.targetX) return;
    this.inMove = true;
    this.targetX = parseFloat(x);
  }
  translateByY(y) {
    if (parseFloat(y) == this.targetY) return;
    this.inMove = true;
    this.targetY = parseFloat(y);
  }
  translateByZ(z) {
    if (parseFloat(z) == this.targetZ) return;
    this.inMove = true;
    this.targetZ = parseFloat(z);
  }
  translateByXY(x, y) {
    if (parseFloat(y) == this.targetY && parseFloat(x) == this.targetX) return;
    this.inMove = true;
    this.targetX = parseFloat(x);
    this.targetY = parseFloat(y);
  }
  translateByXZ(x, z) {
    if (parseFloat(z) == this.targetZ && parseFloat(x) == this.targetX) return;
    this.inMove = true;
    this.targetX = parseFloat(x);
    this.targetZ = parseFloat(z);
  }
  translateByYZ(y, z) {
    if (parseFloat(y) == this.targetY && parseFloat(z) == this.targetZ) return;
    this.inMove = true;
    this.targetY = parseFloat(y);
    this.targetZ = parseFloat(z);
  }
  onTargetPositionReach() {}
  update() {
    var tx = parseFloat(this.targetX) - parseFloat(this.x),
      ty = parseFloat(this.targetY) - parseFloat(this.y),
      tz = parseFloat(this.targetZ) - parseFloat(this.z),
      dist = Math.sqrt(tx * tx + ty * ty + tz * tz);
    this.velX = tx / dist * this.thrust;
    this.velY = ty / dist * this.thrust;
    this.velZ = tz / dist * this.thrust;
    if (this.inMove == true) {
      if (dist > this.thrust) {
        this.x += this.velX;
        this.y += this.velY;
        this.z += this.velZ;
        if (this.netObject != null) {
          if (this.netTolerance__ > this.netTolerance) {
            if (this.teams.length == 0) {
              app.net.send({
                toRemote: this.toRemote,
                // default null
                remoteName: this.remoteName,
                // default null
                sceneName: this.netObject,
                netPos: {
                  x: this.x,
                  y: this.y,
                  z: this.z
                }
              });
            } else {
              // logic is only for two team - index 0 is local !!!
              if (this.teams.length > 0) if (this.teams[0].length > 0) app.net.send({
                toRemote: this.teams[0],
                // default null remote conns
                sceneName: this.netObject,
                // origin scene name to receive
                netPos: {
                  x: this.x,
                  y: this.y,
                  z: this.z
                }
              });
              // remove if (this.teams[1].length > 0)  after alll this is only for CASE OF SUM PLAYER 3 FOR TEST ONLY
              if (this.teams.length > 0) if (this.teams[1].length > 0) app.net.send({
                toRemote: this.teams[1],
                // default null remote conns
                remoteName: this.remoteName,
                // to enemy players
                sceneName: this.netObject,
                // now not important
                netPos: {
                  x: this.x,
                  y: this.y,
                  z: this.z
                }
              });
            }
            this.netTolerance__ = 0;
          } else {
            this.netTolerance__++;
          }
        }
      } else {
        this.x = this.targetX;
        this.y = this.targetY;
        this.z = this.targetZ;
        this.inMove = false;
        this.onTargetPositionReach();
        if (this.netObject != null) {
          if (this.netTolerance__ > this.netTolerance) {
            // 
            if (this.teams.length == 0) {
              app.net.send({
                toRemote: this.toRemote,
                // default null
                remoteName: this.remoteName,
                // default null
                sceneName: this.netObject,
                netPos: {
                  x: this.x,
                  y: this.y,
                  z: this.z
                }
              });
            } else {
              // logic is only for two team - index 0 is local !
              if (this.teams[0].length > 0) app.net.send({
                toRemote: this.teams[0],
                sceneName: this.netObject,
                netPos: {
                  x: this.x,
                  y: this.y,
                  z: this.z
                }
              });
              if (this.teams[1].length > 0) app.net.send({
                // team: this.teams[1],
                toRemote: this.teams[1],
                // default null remote conns
                remoteName: this.remoteName,
                // to enemy players
                sceneName: this.netObject,
                // now not important
                netPos: {
                  x: this.x,
                  y: this.y,
                  z: this.z
                }
              });
            }
            this.netTolerance__ = 0;
          } else {
            this.netTolerance__++;
          }
        }
      }
    }
  }
  get worldLocation() {
    return [parseFloat(this.x), parseFloat(this.y), parseFloat(this.z)];
  }
  SetX(newx, em) {
    this.x = newx;
    this.targetX = newx;
    this.inMove = false;
  }
  SetY(newy, em) {
    this.y = newy;
    this.targetY = newy;
    this.inMove = false;
  }
  SetZ(newz, em) {
    this.z = newz;
    this.targetZ = newz;
    this.inMove = false;
  }
  get X() {
    return parseFloat(this.x);
  }
  get Y() {
    return parseFloat(this.y);
  }
  get Z() {
    return parseFloat(this.z);
  }
  setPosition(newx, newy, newz) {
    this.x = newx;
    this.y = newy;
    this.z = newz;
    this.targetX = newx;
    this.targetY = newy;
    this.targetZ = newz;
    this.inMove = false;
  }
}
exports.Position = Position;
class Rotation {
  constructor(x, y, z) {
    this.toRemote = [];
    this.teams = [];
    this.remoteName = null;
    this.emitX = null;
    this.emitY = null;
    this.emitZ = null;
    if (typeof x == 'undefined') x = 0;
    if (typeof y == 'undefined') y = 0;
    if (typeof z == 'undefined') z = 0;
    this.x = x;
    this.y = y;
    this.z = z;
    this.netx = x;
    this.nety = y;
    this.netz = z;
    this.rotationSpeed = {
      x: 0,
      y: 0,
      z: 0
    };
    this.angle = 0;
    this.axis = {
      x: 0,
      y: 0,
      z: 0
    };
    // not in use good for exstend logic
    this.matrixRotation = null;
  }
  setRotate = (x, y, z) => {
    this.rotationSpeed = {
      x: x,
      y: y,
      z: z
    };
  };
  setRotateX = x => {
    this.rotationSpeed.x = x;
  };
  setRotateY = y => {
    this.rotationSpeed.y = y;
  };
  setRotateZ = z => {
    this.rotationSpeed.z = z;
  };
  setRotation = (x, y, z) => {
    this.x = x;
    this.y = y;
    this.z = z;
  };
  setRotationX = x => {
    this.x = x;
  };
  setRotationY = y => {
    this.y = y;
  };
  setRotationZ = z => {
    this.z = z;
  };
  toDegree = () => {
    /*
    heading = atan2(y * sin(angle)- x * z * (1 - cos(angle)) , 1 - (y2 + z2 ) * (1 - cos(angle)))
    attitude = asin(x * y * (1 - cos(angle)) + z * sin(angle))
    bank = atan2(x * sin(angle)-y * z * (1 - cos(angle)) , 1 - (x2 + z2) * (1 - cos(angle)))
    */
    return [(0, _utils.radToDeg)(this.axis.x), (0, _utils.radToDeg)(this.axis.y), (0, _utils.radToDeg)(this.axis.z)];
  };
  toDegreeX = () => {
    return Math.cos((0, _utils.radToDeg)(this.axis.x) / 2);
  };
  toDegreeY = () => {
    return Math.cos((0, _utils.radToDeg)(this.axis.z) / 2);
  };
  toDegreeZ = () => {
    return Math.cos((0, _utils.radToDeg)(this.axis.y) / 2);
  };
  getRotX = () => {
    if (this.rotationSpeed.x == 0) {
      if (this.netx != this.x && this.emitX) {
        app.net.send({
          remoteName: this.remoteName,
          sceneName: this.emitX,
          netRotX: this.x
        });
      }
      this.netx = this.x;
      return (0, _utils.degToRad)(this.x);
    } else {
      this.x = this.x + this.rotationSpeed.x * 0.001;
      return (0, _utils.degToRad)(this.x);
    }
  };
  getRotY = () => {
    if (this.rotationSpeed.y == 0) {
      if (this.nety != this.y && this.emitY) {
        // ---------------------------------------
        if (this.teams.length == 0) {
          app.net.send({
            toRemote: this.toRemote,
            remoteName: this.remoteName,
            sceneName: this.emitY,
            netRotY: this.y
          });
          this.nety = this.y;
        } else {
          if (this.teams[0].length > 0) app.net.send({
            toRemote: this.teams[0],
            sceneName: this.emitY,
            netRotY: this.y
          });
          if (this.teams[1].length > 0) app.net.send({
            toRemote: this.teams[1],
            remoteName: this.remoteName,
            sceneName: this.emitY,
            netRotY: this.y
          });
          this.nety = this.y;
        }
      }
      return (0, _utils.degToRad)(this.y);
    } else {
      this.y = this.y + this.rotationSpeed.y * 0.001;
      return (0, _utils.degToRad)(this.y);
    }
  };
  getRotZ = () => {
    if (this.rotationSpeed.z == 0) {
      if (this.netz != this.z && this.emitZ) {
        app.net.send({
          remoteName: this.remoteName,
          sceneName: this.emitZ,
          netRotZ: this.z
        });
      }
      this.netz = this.z;
      return (0, _utils.degToRad)(this.z);
    } else {
      this.z = this.z + this.rotationSpeed.z * 0.001;
      return (0, _utils.degToRad)(this.z);
    }
  };
}
exports.Rotation = Rotation;

},{"./utils":56}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _wgpuMatrix = require("wgpu-matrix");
var _matrixClass = require("./matrix-class");
var _vertex = require("../shaders/vertex.wgsl");
var _utils = require("./utils");
var _materials = _interopRequireDefault(require("./materials"));
var _fragmentVideo = require("../shaders/fragment.video.wgsl");
var _vertexWgsl = require("../shaders/vertex.wgsl.normalmap");
var _topologyPoint = require("./effects/topology-point");
var _gizmo = require("./effects/gizmo");
var _destruction = require("./effects/destruction");
var _flame = require("./effects/flame");
var _flameEmmiter = require("./effects/flame-emmiter");
var _literals = require("./literals");
var _proceduralTextures = require("./procedures/procedural-textures");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// import {PointerEffect} from './effects/pointerEffect';

class MEMeshObj extends _materials.default {
  constructor(canvas, device, context, o, inputHandler, globalAmbient, _glbFile = null, primitiveIndex = null, skinnedNodeIndex = null) {
    super(device, o.material, _glbFile, o.textureCache);
    if (typeof o.name === 'undefined') o.name = (0, _utils.genName)(3);
    if (typeof o.raycast === 'undefined') {
      this.raycast = {
        enabled: false,
        radius: 2
      };
    } else {
      this.raycast = o.raycast;
    }
    if (typeof o.pointerEffect === 'undefined') {
      this.pointerEffect = {
        enabled: false
      };
    }
    this.pointerEffect = o.pointerEffect;
    this.name = o.name;
    this.done = false;
    this.canvas = canvas;
    this.device = device;
    this.context = context;
    this.entityArgPass = o.entityArgPass;
    this.clearColor = "red";
    this.video = null;
    this.FINISH_VIDIO_INIT = false;
    this.globalAmbient = [...globalAmbient];
    if (typeof o.material.useTextureFromGlb === 'undefined' || typeof o.material.useTextureFromGlb !== "boolean") {
      o.material.useTextureFromGlb = false;
    }
    if (typeof o.material.useBlend === 'undefined' || typeof o.material.useBlend !== "boolean") {
      o.material.useBlend = false;
    }
    if (o.envMapParams !== null) {
      this.envMapParams = o.envMapParams;
    }
    this.useScale = o.useScale || false;
    this.material = o.material;
    this.time = 0;
    this.deltaTimeAdapter = 10;
    addEventListener('update-pipeine', () => {
      this.setupPipeline();
      // console.info('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UIPDATE P')
    });
    // Mesh stuff - for single mesh or t-posed (fiktive-first in loading order)        
    this.mesh = o.mesh;
    if (_glbFile != null) {
      if (typeof this.mesh == 'undefined') {
        this.mesh = {};
        this.mesh.feedFromRealGlb = true;
      }
      // V
      const verView = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].positions.view;
      const byteOffsetV = verView.byteOffset || 0;
      const byteLengthV = verView.buffer.byteLength;
      const vertices = new Float32Array(verView.buffer.buffer, byteOffsetV, byteLengthV / 4);
      this.mesh.vertices = vertices;
      //N
      const norView = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].normals.view;
      const normalsUint8 = norView.buffer;
      const byteOffsetN = norView.byteOffset || 0; // if your loader provides it
      const byteLengthN = normalsUint8.byteLength;
      const normals = new Float32Array(normalsUint8.buffer, byteOffsetN, byteLengthN / 4);
      this.mesh.vertexNormals = normals;
      //UV
      let accessor = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].texcoords[0];
      const bufferView = accessor.view;
      const byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
      const count = accessor.count * 2; // VEC2 = 2 floats per vertex
      const uvFloatArray = new Float32Array(bufferView.buffer.buffer, byteOffset, count);
      this.mesh.uvs = uvFloatArray;
      this.mesh.textures = uvFloatArray;
      // I
      let binaryI = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].indices;
      const indicesView = binaryI.view;
      const indicesUint8 = indicesView.buffer;
      const byteOffsetI = indicesView.byteOffset || 0;
      const byteLengthI = indicesUint8.byteLength;
      // Decide on type from accessor.componentType
      // (5121 = UNSIGNED_BYTE, 5123 = UNSIGNED_SHORT, 5125 = UNSIGNED_INT)
      let indicesArray;
      switch (binaryI.componentType) {
        case 5121:
          // UNSIGNED_BYTE
          indicesArray = new Uint8Array(indicesUint8.buffer, byteOffsetI, byteLengthI);
          break;
        case 5123:
          // UNSIGNED_SHORT
          indicesArray = new Uint16Array(indicesUint8.buffer, byteOffsetI, byteLengthI / 2);
          break;
        case 5125:
          // UNSIGNED_INT
          indicesArray = new Uint32Array(indicesUint8.buffer, byteOffsetI, byteLengthI / 4);
          break;
        default:
          throw new Error("Unknown index componentType");
      }
      this.mesh.indices = indicesArray;
      // W
      let weightsView = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].weights.view;
      this.mesh.weightsView = weightsView;
      let primitive = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex];
      let finalRoundedWeights = this.getAccessorArray(_glbFile, primitive.weights.weightsAccessIndex);
      const weightsArray = finalRoundedWeights;
      // Normalize each group of 4
      for (let i = 0; i < weightsArray.length; i += 4) {
        const sum = weightsArray[i] + weightsArray[i + 1] + weightsArray[i + 2] + weightsArray[i + 3];
        if (sum > 0) {
          const inv = 1 / sum;
          weightsArray[i] *= inv;
          weightsArray[i + 1] *= inv;
          weightsArray[i + 2] *= inv;
          weightsArray[i + 3] *= inv;
        } else {
          weightsArray[i] = 1;
          weightsArray[i + 1] = 0;
          weightsArray[i + 2] = 0;
          weightsArray[i + 3] = 0;
        }
      }
      for (let i = 0; i < weightsArray.length; i += 4) {
        const s = weightsArray[i] + weightsArray[i + 1] + weightsArray[i + 2] + weightsArray[i + 3];
        if (Math.abs(s - 1.0) > 0.001) console.warn("Weight not normalized!", i, s);
      }
      this.mesh.weightsBuffer = this.device.createBuffer({
        label: "weightsBuffer real data",
        size: weightsArray.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Float32Array(this.mesh.weightsBuffer.getMappedRange()).set(weightsArray);
      this.mesh.weightsBuffer.unmap();
      let jointsView = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].joints.view;
      this.mesh.jointsView = jointsView;
      // Create typed array from the buffer (Uint16Array or Uint8Array depending on GLB)
      let jointsArray16 = new Uint16Array(jointsView.buffer, jointsView.byteOffset || 0, jointsView.byteLength / 2 // in Uint16 elements
      );
      const jointsArray32 = new Uint32Array(jointsArray16.length);
      for (let i = 0; i < jointsArray16.length; i++) {
        jointsArray32[i] = jointsArray16[i];
      }
      // Create GPU buffer for joints
      this.mesh.jointsBuffer = this.device.createBuffer({
        label: "jointsBuffer[real-data]",
        size: jointsArray32.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      // Upload the data to GPU
      new Uint32Array(this.mesh.jointsBuffer.getMappedRange()).set(jointsArray32);
      this.mesh.jointsBuffer.unmap();

      // TANGENTS
      let tangentArray = null;
      if (_glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].tangents) {
        const tangentView = _glbFile.skinnedMeshNodes[skinnedNodeIndex].mesh.primitives[primitiveIndex].tangents.view;
        const byteOffsetT = tangentView.byteOffset || 0;
        const byteLengthT = tangentView.buffer.byteLength;
        tangentArray = new Float32Array(tangentView.buffer, byteOffsetT, byteLengthT / 4);
        this.mesh.tangents = tangentArray;
        this.mesh.tangentsBuffer = this.device.createBuffer({
          label: "tangentsBuffer[real-data]",
          size: tangentArray.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          mappedAtCreation: true
        });
        new Float32Array(this.mesh.tangentsBuffer.getMappedRange()).set(tangentArray);
        this.mesh.tangentsBuffer.unmap();
      } else {
        // 🟢 dummy fallback
        const dummyTangents = new Float32Array(this.mesh.vertices.length / 3 * 4);
        for (let i = 0; i < dummyTangents.length; i += 4) {
          dummyTangents[i + 0] = 1.0; // T = (1,0,0)
          dummyTangents[i + 1] = 0.0;
          dummyTangents[i + 2] = 0.0;
          dummyTangents[i + 3] = 1.0; // handedness
        }
        this.mesh.tangentsBuffer = this.device.createBuffer({
          label: "tangentsBuffer dummy",
          size: dummyTangents.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          mappedAtCreation: true
        });
        new Float32Array(this.mesh.tangentsBuffer.getMappedRange()).set(dummyTangents);
        this.mesh.tangentsBuffer.unmap();
        console.warn("GLTF primitive has no TANGENT attribute (normal map won’t work properly).");
      }

      // if(this.material.useTextureFromGlb == true) {
      //   console.log('get glb images ', _glbFile.glbJsonData.materials);
      //   _glbFile.glbJsonData.materials.forEach(material => {
      //     console.log('get material :', material);
      //   });

      //   _glbFile.glbJsonData.images.forEach(imgGpuTexture => {
      //     console.log('get images :', imgGpuTexture);
      //   });

      //   _glbFile.glbJsonData.glbTextures.forEach(glbTexture => {
      //     console.log('get glbTextures :', glbTexture);
      //   });
      // }
    } else {
      // obj files flow
      this.mesh.uvs = this.mesh.textures;
    }
    console.log(`%cMesh loaded: ${o.name}`, _utils.LOG_FUNNY_ARCADE);
    // ObjSequence animation
    if (typeof o.objAnim !== 'undefined' && o.objAnim != null) {
      this.objAnim = o.objAnim;
      for (var key in this.objAnim.animations) {
        if (key != 'active') this.objAnim.animations[key].speedCounter = 0;
      }
      console.log(`%c Mesh objAnim exist: ${o.objAnim}`, _utils.LOG_FUNNY_SMALL);
      this.drawElements = this.drawElementsAnim;
    }
    this.inputHandler = inputHandler;
    this.cameras = o.cameras;
    this.mainCameraParams = {
      type: o.mainCameraParams.type,
      responseCoef: o.mainCameraParams.responseCoef
    };
    this.lastFrameMS = 0;
    this.texturesPaths = [];
    o.texturesPaths.forEach(t => {
      this.texturesPaths.push(t);
    });
    this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
    this.position = new _matrixClass.Position(o.position.x, o.position.y, o.position.z);
    this.rotation = new _matrixClass.Rotation(o.rotation.x, o.rotation.y, o.rotation.z);
    this.rotation.rotationSpeed.x = o.rotationSpeed.x;
    this.rotation.rotationSpeed.y = o.rotationSpeed.y;
    this.rotation.rotationSpeed.z = o.rotationSpeed.z;
    this.scale = o.scale;
    // new dummy for skin mesh
    if (!this.joints) {
      const jointsData = new Uint32Array(this.mesh.vertices.length / 3 * 4);
      const jointsBuffer = this.device.createBuffer({
        label: "jointsBuffer",
        size: jointsData.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Uint32Array(jointsBuffer.getMappedRange()).set(jointsData);
      jointsBuffer.unmap();
      this.joints = {
        data: jointsData,
        buffer: jointsBuffer,
        stride: 16 // vec4<u32>
      };
      const numVerts = this.mesh.vertices.length / 3;
      // Weights data (vec4<f32>) – default all weight to bone 0
      const weightsData = new Float32Array(numVerts * 4);
      for (let i = 0; i < numVerts; i++) {
        weightsData[i * 4 + 0] = 1.0; // 100% influence of bone 0
        weightsData[i * 4 + 1] = 0.0;
        weightsData[i * 4 + 2] = 0.0;
        weightsData[i * 4 + 3] = 0.0;
      }
      // GPU buffer
      const weightsBuffer = this.device.createBuffer({
        label: "weightsBuffer dummy",
        size: weightsData.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Float32Array(weightsBuffer.getMappedRange()).set(weightsData);
      weightsBuffer.unmap();
      this.weights = {
        data: weightsData,
        buffer: weightsBuffer,
        stride: 16 // vec4<f32>
      };
    }
    this.runProgram = () => {
      return new Promise(async resolve => {
        this.shadowDepthTextureSize = 1024;
        this.modelViewProjectionMatrix = _wgpuMatrix.mat4.create();
        this.loadTex0(this.texturesPaths).then(() => {
          resolve();
        });
      });
    };
    this.runProgram().then(() => {
      this.context.configure({
        device: this.device,
        format: this.presentationFormat,
        alphaMode: 'premultiplied'
      });

      // Create the model vertex buffer.
      this.vertexBuffer = this.device.createBuffer({
        size: this.mesh.vertices.length * Float32Array.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      {
        new Float32Array(this.vertexBuffer.getMappedRange()).set(this.mesh.vertices);
        this.vertexBuffer.unmap();
      }

      // Create the model vertex buffer.
      this.vertexNormalsBuffer = this.device.createBuffer({
        size: this.mesh.vertexNormals.length * Float32Array.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      {
        new Float32Array(this.vertexNormalsBuffer.getMappedRange()).set(this.mesh.vertexNormals);
        this.vertexNormalsBuffer.unmap();
      }
      this.vertexTexCoordsBuffer = this.device.createBuffer({
        size: this.mesh.textures.length * Float32Array.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      {
        new Float32Array(this.vertexTexCoordsBuffer.getMappedRange()).set(this.mesh.textures);
        this.vertexTexCoordsBuffer.unmap();
      }

      // Create the model index buffer.
      this.indexCount = this.mesh.indices.length;
      const indexCount = this.mesh.indices.length;
      const size = Math.ceil(indexCount * Uint16Array.BYTES_PER_ELEMENT / 4) * 4;
      this.indexBuffer = this.device.createBuffer({
        size,
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Uint16Array(this.indexBuffer.getMappedRange()).set(this.mesh.indices);
      this.indexBuffer.unmap();
      this.indexCount = indexCount;
      let glbInfo = {
        arrayStride: 4 * 4,
        // vec4<f32> = 4 * 4 bytes
        attributes: [{
          format: 'float32x4',
          offset: 0,
          shaderLocation: 4
        }]
      };
      this.vertexBuffers = [{
        arrayStride: Float32Array.BYTES_PER_ELEMENT * 3,
        attributes: [{
          shaderLocation: 0,
          offset: 0,
          format: "float32x3"
        }]
      }, {
        arrayStride: Float32Array.BYTES_PER_ELEMENT * 3,
        attributes: [{
          shaderLocation: 1,
          offset: 0,
          format: "float32x3"
        }]
      }, {
        arrayStride: Float32Array.BYTES_PER_ELEMENT * 2,
        attributes: [{
          shaderLocation: 2,
          offset: 0,
          format: "float32x2"
        }]
      },
      // joint indices
      {
        arrayStride: 4 * 4,
        // vec4<u32> = 4 * 4 bytes
        attributes: [{
          format: 'uint32x4',
          offset: 0,
          shaderLocation: 3
        }]
      },
      // weights
      glbInfo];
      if (this.mesh.tangentsBuffer) {
        this.vertexBuffers.push({
          arrayStride: 4 * 4,
          // vec4<f32> = 16 bytes
          attributes: [{
            shaderLocation: 5,
            format: "float32x4",
            offset: 0
          }]
        });
      }
      // Note: The frontFace and cullMode values have no effect on the 
      // 'triangle-list'   // standard meshes
      // 'triangle-strip' // terrain, strips
      // 'line-list'      // wireframe (manual index gen)
      // 'line-strip'     // outlines
      // 'point-list'     // particles
      this.topology = 'triangle-list';
      this.setTopology = t => {
        const isStrip = t === 'triangle-strip' || t === 'line-strip';
        if (isStrip) {
          this.primitive = {
            topology: t,
            stripIndexFormat: 'uint16',
            cullMode: 'none',
            frontFace: 'ccw'
          };
        } else {
          this.primitive = {
            topology: t,
            cullMode: 'none',
            frontFace: 'ccw'
          };
        }
        this.setupPipeline();
      };

      // 'back' typical for shadow passes
      this.primitive = {
        topology: this.topology,
        cullMode: 'none',
        frontFace: 'ccw'
      };
      this.mirrorBindGroupLayout = device.createBindGroupLayout({
        label: 'mirrorBindGroupLayout',
        entries: [{
          binding: 0,
          visibility: GPUShaderStage.FRAGMENT,
          buffer: {
            type: 'uniform',
            minBindingSize: 80
          }
        }, {
          binding: 1,
          visibility: GPUShaderStage.FRAGMENT,
          texture: {
            sampleType: 'float',
            viewDimension: '2d',
            multisampled: false
          }
        }, {
          binding: 2,
          visibility: GPUShaderStage.FRAGMENT,
          sampler: {
            type: 'filtering'
          }
        }]
      });

      // Selected effect
      // this.selectedBuffer = device.createBuffer({size: 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST});
      // this.selectedBindGroupLayout = device.createBindGroupLayout({
      //   label: 'selectedBindGroupLayout mesh',
      //   entries: [
      //     {binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: {}},
      //   ],
      // });
      // this.selectedBindGroup = device.createBindGroup({
      //   label: 'selectedBindGroup mesh',
      //   layout: this.selectedBindGroupLayout,
      //   entries: [{binding: 0, resource: {buffer: this.selectedBuffer}}],
      // });
      // this.setSelectedEffect = (selected = false) => {
      //   this.device.queue.writeBuffer(this.selectedBuffer, 0, new Float32Array([selected ? 1.0 : 0.0]));
      // };
      // // 0 default
      // this.setSelectedEffect();

      // Create a bind group layout which holds the scene uniforms and
      // the texture+sampler for depth. We create it manually because the WebPU
      // implementation doesn't infer this from the shader (yet).
      this.createLayoutForRender();
      this.modelUniformBuffer = this.device.createBuffer({
        size: 4 * 16,
        // 4x4 matrix
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      this.sceneUniformBuffer = this.device.createBuffer({
        label: 'sceneUniformBuffer per mesh',
        size: 192,
        //192, // ⬅️ was 176
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      this.uniformBufferBindGroupLayout = this.device.createBindGroupLayout({
        label: 'uniformBufferBindGroupLayout in mesh regular',
        entries: [{
          binding: 0,
          visibility: GPUShaderStage.VERTEX,
          buffer: {
            type: 'uniform'
          }
        }, {
          binding: 1,
          visibility: GPUShaderStage.VERTEX,
          buffer: {
            type: 'uniform'
          }
        }, {
          binding: 2,
          visibility: GPUShaderStage.VERTEX,
          buffer: {
            type: 'uniform'
          }
        }]
      });
      function alignTo256(n) {
        return Math.ceil(n / 256) * 256;
      }
      let MAX_BONES = 100;
      this.MAX_BONES = MAX_BONES;
      this.bonesBuffer = device.createBuffer({
        label: "bonesBuffer",
        size: alignTo256(64 * MAX_BONES),
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      const bones = new Float32Array(this.MAX_BONES * 16);
      for (let i = 0; i < this.MAX_BONES; i++) {
        bones.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], i * 16);
      }
      this.device.queue.writeBuffer(this.bonesBuffer, 0, bones);

      // vertex Anim
      this.vertexAnimParams = new Float32Array([0.0, 0.0, 0.0, 0.0, 2.0, 0.1, 2.0, 0.0, 1.5, 0.3, 2.0, 0.5, 1.0, 0.1, 0.0, 0.0, 1.0, 0.5, 0.0, 0.0, 1.0, 0.05, 0.5, 0.0, 1.0, 0.05, 2.0, 0.0, 1.0, 0.1, 0.0, 0.0]);
      this.vertexAnimBuffer = this.device.createBuffer({
        label: "Vertex Animation Params",
        size: this.vertexAnimParams.byteLength,
        // 128 bytes
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      this.vertexAnim = {
        enableWave: () => {
          this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS.WAVE;
          this.updateVertexAnimBuffer();
        },
        disableWave: () => {
          this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS.WAVE;
          this.updateVertexAnimBuffer();
        },
        enableWind: () => {
          this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS.WIND;
          this.updateVertexAnimBuffer();
        },
        disableWind: () => {
          this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS.WIND;
          this.updateVertexAnimBuffer();
        },
        enablePulse: () => {
          this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS.PULSE;
          this.updateVertexAnimBuffer();
        },
        disablePulse: () => {
          this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS.PULSE;
          this.updateVertexAnimBuffer();
        },
        enableTwist: () => {
          this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS.TWIST;
          this.updateVertexAnimBuffer();
        },
        disableTwist: () => {
          this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS.TWIST;
          this.updateVertexAnimBuffer();
        },
        enableNoise: () => {
          this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS.NOISE;
          this.updateVertexAnimBuffer();
        },
        disableNoise: () => {
          this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS.NOISE;
          this.updateVertexAnimBuffer();
        },
        enableOcean: () => {
          this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS.OCEAN;
          this.updateVertexAnimBuffer();
        },
        disableOcean: () => {
          this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS.OCEAN;
          this.updateVertexAnimBuffer();
        },
        enable: (...effects) => {
          effects.forEach(effect => {
            this.vertexAnimParams[1] |= _literals.VERTEX_ANIM_FLAGS[effect.toUpperCase()];
          });
          this.updateVertexAnimBuffer();
        },
        disable: (...effects) => {
          effects.forEach(effect => {
            this.vertexAnimParams[1] &= ~_literals.VERTEX_ANIM_FLAGS[effect.toUpperCase()];
          });
          this.updateVertexAnimBuffer();
        },
        disableAll: () => {
          this.vertexAnimParams[1] = 0;
          this.updateVertexAnimBuffer();
        },
        isEnabled: effect => {
          return (this.vertexAnimParams[1] & _literals.VERTEX_ANIM_FLAGS[effect.toUpperCase()]) !== 0;
        },
        setWaveParams: (speed, amplitude, frequency) => {
          this.vertexAnimParams[4] = speed;
          this.vertexAnimParams[5] = amplitude;
          this.vertexAnimParams[6] = frequency;
          this.updateVertexAnimBuffer();
        },
        setWindParams: (speed, strength, heightInfluence, turbulence) => {
          this.vertexAnimParams[8] = speed;
          this.vertexAnimParams[9] = strength;
          this.vertexAnimParams[10] = heightInfluence;
          this.vertexAnimParams[11] = turbulence;
          this.updateVertexAnimBuffer();
        },
        setPulseParams: (speed, amount, centerX = 0, centerY = 0) => {
          this.vertexAnimParams[12] = speed;
          this.vertexAnimParams[13] = amount;
          this.vertexAnimParams[14] = centerX;
          this.vertexAnimParams[15] = centerY;
          this.updateVertexAnimBuffer();
        },
        setTwistParams: (speed, amount) => {
          this.vertexAnimParams[16] = speed;
          this.vertexAnimParams[17] = amount;
          this.updateVertexAnimBuffer();
        },
        setNoiseParams: (scale, strength, speed) => {
          this.vertexAnimParams[20] = scale;
          this.vertexAnimParams[21] = strength;
          this.vertexAnimParams[22] = speed;
          this.updateVertexAnimBuffer();
        },
        setOceanParams: (scale, height, speed) => {
          this.vertexAnimParams[24] = scale;
          this.vertexAnimParams[25] = height;
          this.vertexAnimParams[26] = speed;
          this.updateVertexAnimBuffer();
        },
        setIntensity: value => {
          this.vertexAnimParams[2] = Math.max(0, Math.min(1, value));
          this.updateVertexAnimBuffer();
        },
        getIntensity: () => {
          return this.vertexAnimParams[2];
        }
      };
      this.updateVertexAnimBuffer = () => {
        this.device.queue.writeBuffer(this.vertexAnimBuffer, 0, this.vertexAnimParams);
      };

      // globalIntensity
      this.vertexAnimParams[2] = 1.0;
      this.updateVertexAnimBuffer();
      this.updateTime = time => {
        this.time += time * this.deltaTimeAdapter;
        this.vertexAnimParams[0] = this.time;
        this.device.queue.writeBuffer(this.vertexAnimBuffer, 0, this.vertexAnimParams);
        // const effectMix = 0.5 + 0.5 * Math.sin(this.time * 0.5);
        // this.setupMaterialPBR([1.0, 1.0, 1.0, 0.5], false, false, effectMix, 1.0);
      };
      this.modelBindGroup = this.device.createBindGroup({
        label: 'modelBindGroup in mesh',
        layout: this.uniformBufferBindGroupLayout,
        entries: [{
          binding: 0,
          resource: {
            buffer: this.modelUniformBuffer
          }
        }, {
          binding: 1,
          resource: {
            buffer: this.bonesBuffer
          }
        }, {
          binding: 2,
          resource: {
            buffer: this.vertexAnimBuffer
          }
        }]
      });
      this.mainPassBindGroupLayout = this.device.createBindGroupLayout({
        label: '[mainPass]BindGroupLayout mesh',
        entries: [{
          binding: 0,
          visibility: GPUShaderStage.FRAGMENT,
          texture: {
            sampleType: 'depth'
          }
        }, {
          binding: 1,
          visibility: GPUShaderStage.FRAGMENT,
          sampler: {
            type: 'comparison'
          }
        }]
      });
      this._sceneData = new Float32Array(48);
      this.effects = {};
      if (this.pointerEffect && this.pointerEffect.enabled === true) {
        let pf = navigator.gpu.getPreferredCanvasFormat();
        if (typeof this.pointerEffect.pointEffect !== 'undefined' && this.pointerEffect.pointEffect == true) {
          this.effects.pointEffect = new _topologyPoint.PointEffect(device, 'rgba16float');
        }
        if (typeof this.pointerEffect.gizmoEffect !== 'undefined' && this.pointerEffect.gizmoEffect == true) {
          this.effects.gizmoEffect = new _gizmo.GizmoEffect(device, 'rgba16float');
        }
        if (typeof this.pointerEffect.flameEffect !== 'undefined' && this.pointerEffect.flameEffect == true) {
          this.effects.flameEffect = new _flame.FlameEffect(device, pf, "rgba16float", 'torch');
        }
        if (typeof this.pointerEffect.flameEmitter !== 'undefined' && this.pointerEffect.flameEmitter == true) {
          this.effects.flameEmitter = new _flameEmmiter.FlameEmitter(device, "rgba16float");
        }
        if (typeof this.pointerEffect.destructionEffect !== 'undefined' && this.pointerEffect.destructionEffect == true) {
          this.effects.destructionEffect = new _destruction.DestructionEffect(device, 'rgba16float', {
            particleCount: 100,
            duration: 2.5,
            color: [0.6, 0.5, 0.4, 1.0]
          });
        }
      }
      this.getTransformationMatrix = (mainRenderBundle, spotLight, index) => {
        const now = Date.now();
        const dt = (now - this.lastFrameMS) / this.mainCameraParams.responseCoef;
        this.lastFrameMS = now;
        const camera = this.cameras[this.mainCameraParams.type];
        if (index == 0) camera.update(dt, inputHandler());
        const camVP = _wgpuMatrix.mat4.multiply(camera.projectionMatrix, camera.view);
        this._sceneData.set(spotLight.viewProjMatrix, 0);
        this._sceneData.set(camVP, 16);
        this._sceneData[32] = camera.position[0];
        this._sceneData[33] = camera.position[1];
        this._sceneData[34] = camera.position[2];
        this._sceneData[35] = 0.0;
        this._sceneData[36] = spotLight.position[0];
        this._sceneData[37] = spotLight.position[1];
        this._sceneData[38] = spotLight.position[2];
        this._sceneData[39] = 0.0;
        this._sceneData[40] = this.globalAmbient[0];
        this._sceneData[41] = this.globalAmbient[1];
        this._sceneData[42] = this.globalAmbient[2];
        this._sceneData[43] = 0.0;
        this._sceneData[44] = this.time;
        this._sceneData[45] = dt;
        this._sceneData[46] = 0;
        this._sceneData[47] = 0;
        device.queue.writeBuffer(this.sceneUniformBuffer, 0, this._sceneData.buffer, this._sceneData.byteOffset, this._sceneData.byteLength);
      };
      this.getModelMatrix = (pos, useScale = false) => {
        let modelMatrix = _wgpuMatrix.mat4.identity();
        _wgpuMatrix.mat4.translate(modelMatrix, [pos.x, pos.y, pos.z], modelMatrix);
        if (this.itIsPhysicsBody) {
          _wgpuMatrix.mat4.rotate(modelMatrix, [this.rotation.axis.x, this.rotation.axis.y, this.rotation.axis.z], (0, _utils.degToRad)(this.rotation.angle), modelMatrix);
        } else {
          _wgpuMatrix.mat4.rotateX(modelMatrix, this.rotation.getRotX(), modelMatrix);
          _wgpuMatrix.mat4.rotateY(modelMatrix, this.rotation.getRotY(), modelMatrix);
          _wgpuMatrix.mat4.rotateZ(modelMatrix, this.rotation.getRotZ(), modelMatrix);
        }
        if (useScale == true) _wgpuMatrix.mat4.scale(modelMatrix, [this.scale[0], this.scale[1], this.scale[2]], modelMatrix);
        return modelMatrix;
      };

      // looks like affect on transformations for now const 0
      const modelMatrix = _wgpuMatrix.mat4.translation([0, 0, 0]);
      const modelData = modelMatrix;
      this.device.queue.writeBuffer(this.modelUniformBuffer, 0, modelData.buffer, modelData.byteOffset, modelData.byteLength);
      this.done = true;
      if (this.texturesPaths.length > 1) {
        this.loadEnvMap(this.texturesPaths, true).then(envTexture => {
          try {
            this.envMapParams.envTexture = envTexture;
          } catch (err) {
            console.warn(`%cYou forgot to put envMapParams in args...`, _utils.LOG_FUNNY_ARCADE);
            return;
          }
          this.mirrorBindGroup = this.createMirrorIlluminateBindGroup(this.mirrorBindGroupLayout, this.envMapParams).bindGroup;
          try {
            this.setupPipeline();
          } catch (err) {
            console.log('Err[create pipeline]:', err);
          }
        });
      } else {
        try {
          this.setupPipeline();
        } catch (err) {
          console.log('Err[create pipeline]:', err);
        }
      }
    }).then(() => {
      if (typeof this.objAnim !== 'undefined' && this.objAnim !== null) {
        console.log('After all updateMeshListBuffers...');
        this.updateMeshListBuffers();
      }
    });
  }
  setupPipeline = () => {
    this.createBindGroupForRender();
    this.pipeline = this.device.createRenderPipeline({
      label: 'Main [Mesh] Pipeline ✅[OPAQUE]',
      layout: this.device.createPipelineLayout({
        label: 'PipelineLayout Opaque',
        bindGroupLayouts: [this.bglForRender, this.uniformBufferBindGroupLayout, this.material.type === 'mirror' ? this.mirrorBindGroupLayout : null, this.waterBindGroupLayout]
      }),
      vertex: {
        entryPoint: 'main',
        module: this.device.createShaderModule({
          code: this.material.type === 'normalmap' ? _vertexWgsl.vertexWGSL_NM : _vertex.vertexWGSL
        }),
        buffers: this.vertexBuffers
      },
      fragment: {
        entryPoint: 'main',
        module: this.device.createShaderModule({
          code: this.isVideo === true ? _fragmentVideo.fragmentVideoWGSL : this.getMaterial()
        }),
        targets: [{
          format: 'rgba16float',
          blend: undefined
        }],
        constants: {
          shadowDepthTextureSize: this.shadowDepthTextureSize
        }
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: 'less',
        format: 'depth24plus'
      },
      primitive: this.primitive
    });
    this.pipelineTransparent = this.device.createRenderPipeline({
      label: 'Main [Mesh] Pipeline ✅[Transparent]',
      layout: this.device.createPipelineLayout({
        label: 'Main PipelineLayout Transparent',
        bindGroupLayouts: [this.bglForRender, this.uniformBufferBindGroupLayout, this.material.type === 'mirror' ? this.mirrorBindGroupLayout : null, this.waterBindGroupLayout]
      }),
      vertex: {
        entryPoint: 'main',
        module: this.device.createShaderModule({
          code: this.material.type === 'normalmap' ? _vertexWgsl.vertexWGSL_NM : _vertex.vertexWGSL
        }),
        buffers: this.vertexBuffers
      },
      fragment: {
        entryPoint: 'main',
        module: this.device.createShaderModule({
          code: this.isVideo === true ? _fragmentVideo.fragmentVideoWGSL : this.getMaterial()
        }),
        targets: [{
          format: 'rgba16float',
          blend: {
            color: {
              srcFactor: 'src-alpha',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add'
            },
            alpha: {
              srcFactor: 'one',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add'
            }
          }
        }],
        constants: {
          shadowDepthTextureSize: this.shadowDepthTextureSize
        }
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: 'less',
        format: 'depth24plus'
      },
      primitive: this.primitive
    });
  };
  getMainPipeline = () => {
    return this.pipeline;
  };
  updateModelUniformBuffer = () => {
    if (this.done == false) return;
    // Per-object model matrix only
    const modelMatrix = this.getModelMatrix(this.position, this.useScale);
    this.device.queue.writeBuffer(this.modelUniformBuffer, 0, modelMatrix.buffer, modelMatrix.byteOffset, modelMatrix.byteLength);
  };
  createGPUBuffer(dataArray, usage) {
    if (!dataArray || typeof dataArray.length !== 'number') {
      throw new Error('Invalid data array passed to createGPUBuffer');
    }
    const size = dataArray.length * dataArray.BYTES_PER_ELEMENT;
    if (!Number.isFinite(size) || size <= 0) {
      throw new Error(`Invalid buffer size: ${size}`);
    }
    const buffer = this.device.createBuffer({
      size,
      usage,
      mappedAtCreation: true
    });
    const writeArray = dataArray.constructor === Float32Array ? new Float32Array(buffer.getMappedRange()) : new Uint16Array(buffer.getMappedRange());
    writeArray.set(dataArray);
    buffer.unmap();
    return buffer;
  }
  updateMeshListBuffers() {
    for (const key in this.objAnim.meshList) {
      const mesh = this.objAnim.meshList[key];
      mesh.vertexBuffer = this.device.createBuffer({
        size: mesh.vertices.length * Float32Array.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      new Float32Array(mesh.vertexBuffer.getMappedRange()).set(mesh.vertices);
      mesh.vertexBuffer.unmap();
      // Normals
      mesh.vertexNormalsBuffer = this.device.createBuffer({
        size: mesh.vertexNormals.length * Float32Array.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      new Float32Array(mesh.vertexNormalsBuffer.getMappedRange()).set(mesh.vertexNormals);
      mesh.vertexNormalsBuffer.unmap();
      // UVs
      mesh.vertexTexCoordsBuffer = this.device.createBuffer({
        size: mesh.textures.length * Float32Array.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      new Float32Array(mesh.vertexTexCoordsBuffer.getMappedRange()).set(mesh.textures);
      mesh.vertexTexCoordsBuffer.unmap();
      // Indices
      const indexCount = mesh.indices.length;
      const indexSize = Math.ceil(indexCount * Uint16Array.BYTES_PER_ELEMENT / 4) * 4;
      mesh.indexBuffer = this.device.createBuffer({
        size: indexSize,
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Uint16Array(mesh.indexBuffer.getMappedRange()).set(mesh.indices);
      mesh.indexBuffer.unmap();
      mesh.indexCount = indexCount;
    }
  }
  drawElements = (pass, lightContainer) => {
    if (this.isVideo) {
      this.updateVideoTexture();
    }
    // Bind per-mesh uniforms
    pass.setBindGroup(0, this.sceneBindGroupForRender);
    pass.setBindGroup(1, this.modelBindGroup);
    if (this.isVideo == false) {
      if (this.material.type === "mirror" && this.mirrorBindGroup) {
        pass.setBindGroup(2, this.mirrorBindGroup);
      } else if (this.isVideo == false) {
        let bindIndex = 2;
        for (const light of lightContainer) {
          pass.setBindGroup(bindIndex++, light.getMainPassBindGroup(this));
        }
      }
    }
    pass.setBindGroup(3, this.waterBindGroup);
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setVertexBuffer(1, this.vertexNormalsBuffer);
    pass.setVertexBuffer(2, this.vertexTexCoordsBuffer);
    if (this.joints) {
      if (this.constructor.name === "BVHPlayer") {
        pass.setVertexBuffer(3, this.mesh.jointsBuffer); // real
        pass.setVertexBuffer(4, this.mesh.weightsBuffer);
      } else {
        // dummy
        pass.setVertexBuffer(3, this.joints.buffer);
        pass.setVertexBuffer(4, this.weights.buffer);
      }
    }
    if (this.mesh.tangentsBuffer) {
      pass.setVertexBuffer(5, this.mesh.tangentsBuffer);
    }
    pass.setIndexBuffer(this.indexBuffer, 'uint16');
    pass.drawIndexed(this.indexCount);
  };
  drawElementsAnim = (renderPass, lightContainer) => {
    if (!this.sceneBindGroupForRender || !this.modelBindGroup) {
      console.log('NULL1');
      return;
    }
    if (!this.objAnim.meshList[this.objAnim.id + this.objAnim.currentAni]) {
      console.log('NULL2');
      return;
    }
    renderPass.setBindGroup(0, this.sceneBindGroupForRender);
    renderPass.setBindGroup(1, this.modelBindGroup);
    const mesh = this.objAnim.meshList[this.objAnim.id + this.objAnim.currentAni];
    if (this.isVideo == false) {
      if (this.material.type === "mirror" && this.mirrorBindGroup) {
        renderPass.setBindGroup(2, this.mirrorBindGroup);
      } else if (this.isVideo == false) {
        let bindIndex = 2;
        for (const light of lightContainer) {
          renderPass.setBindGroup(bindIndex++, light.getMainPassBindGroup(this));
        }
      }
    }
    renderPass.setBindGroup(3, this.waterBindGroup);
    renderPass.setVertexBuffer(0, mesh.vertexBuffer);
    renderPass.setVertexBuffer(1, mesh.vertexNormalsBuffer);
    renderPass.setVertexBuffer(2, mesh.vertexTexCoordsBuffer);
    if (this.constructor.name === "BVHPlayer") {
      // real
      renderPass.setVertexBuffer(3, this.mesh.jointsBuffer);
      renderPass.setVertexBuffer(4, this.mesh.weightsBuffer);
    } else {
      // dummy
      renderPass.setVertexBuffer(3, this.joints.buffer);
      renderPass.setVertexBuffer(4, this.weights.buffer);
    }
    if (this.mesh.tangentsBuffer) {
      renderPass.setVertexBuffer(5, this.mesh.tangentsBuffer);
    }
    renderPass.setIndexBuffer(mesh.indexBuffer, 'uint16');
    renderPass.drawIndexed(mesh.indexCount);
    if (this.objAnim.playing == true) {
      if (this.objAnim.animations[this.objAnim.animations.active].speedCounter >= this.objAnim.animations[this.objAnim.animations.active].speed) {
        this.objAnim.currentAni++;
        this.objAnim.animations[this.objAnim.animations.active].speedCounter = 0;
      } else {
        this.objAnim.animations[this.objAnim.animations.active].speedCounter++;
      }
      if (this.objAnim.currentAni >= this.objAnim.animations[this.objAnim.animations.active].to) {
        this.objAnim.currentAni = this.objAnim.animations[this.objAnim.animations.active].from;
      }
    }
  };
  drawShadows = shadowPass => {
    shadowPass.setVertexBuffer(0, this.vertexBuffer);
    shadowPass.setVertexBuffer(1, this.vertexNormalsBuffer);
    shadowPass.setVertexBuffer(2, this.vertexTexCoordsBuffer);
    shadowPass.setVertexBuffer(3, this.joints.buffer);
    shadowPass.setVertexBuffer(4, this.weights.buffer);
    shadowPass.setIndexBuffer(this.indexBuffer, 'uint16');
    shadowPass.drawIndexed(this.indexCount);
  };
  destroy = () => {
    if (this._destroyed) return;
    this._destroyed = true;
    // --- GPU Buffers ---
    this.vertexBuffer?.destroy();
    this.vertexNormalsBuffer?.destroy();
    this.vertexTexCoordsBuffer?.destroy();
    this.indexBuffer?.destroy();
    this.modelUniformBuffer?.destroy();
    this.sceneUniformBuffer?.destroy();
    this.bonesBuffer?.destroy();
    this.selectedBuffer?.destroy();
    // Skinning
    this.mesh?.weightsBuffer?.destroy();
    this.mesh?.jointsBuffer?.destroy();
    this.mesh?.tangentsBuffer?.destroy();
    // Dummy skin buffers
    this.joints?.buffer?.destroy();
    this.weights?.buffer?.destroy();
    // Obj sequence animation buffers
    if (this.objAnim?.meshList) {
      for (const k in this.objAnim.meshList) {
        const m = this.objAnim.meshList[k];
        m.vertexBuffer?.destroy();
        m.vertexNormalsBuffer?.destroy();
        m.vertexTexCoordsBuffer?.destroy();
        m.indexBuffer?.destroy();
      }
    }
    if (this.effects?.pointer?.destroy) {
      this.effects.pointer.destroy();
    }
    this.pipeline = null;
    this.modelBindGroup = null;
    this.sceneBindGroupForRender = null;
    this.selectedBindGroup = null;
    this.material = null;
    this.mesh = null;
    this.objAnim = null;
    this.drawElements = () => {};
    this.drawElementsAnim = () => {};
    this.drawShadows = () => {};
    let testPB = app.matrixAmmo.getBodyByName(this.name);
    if (testPB !== null) {
      try {
        app.matrixAmmo.dynamicsWorld.removeRigidBody(testPB);
      } catch (e) {
        console.warn("Physics cleanup err:", e);
      }
    }
    console.info(`🧹Destroyed: ${this.name}`);
  };
}
exports.default = MEMeshObj;

},{"../shaders/fragment.video.wgsl":64,"../shaders/vertex.wgsl":80,"../shaders/vertex.wgsl.normalmap":81,"./effects/destruction":26,"./effects/flame":29,"./effects/flame-emmiter":28,"./effects/gizmo":33,"./effects/topology-point":36,"./literals":43,"./materials":48,"./matrix-class":49,"./procedures/procedural-textures":54,"./utils":56,"wgpu-matrix":22}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.METoolTip = void 0;
class METoolTip {
  constructor() {
    // --- Tooltip system ---
    const tooltip = document.createElement('div');
    tooltip.style.position = 'fixed';
    tooltip.style.padding = '6px 10px';
    tooltip.style.background = 'rgba(0,0,0,0.8)';
    tooltip.style.color = '#fff';
    tooltip.style.borderRadius = '6px';
    tooltip.style.fontFamily = 'Arial';
    tooltip.style.fontSize = '12px';
    tooltip.style.pointerEvents = 'none';
    tooltip.style.opacity = '0';
    tooltip.style.transition = 'opacity 0.2s ease';
    tooltip.style.zIndex = '9999';
    tooltip.style.whiteSpace = 'pre-line';
    document.body.appendChild(tooltip);
    this.tooltip = tooltip;
  }
  attachTooltip(element, text) {
    element.addEventListener('mouseenter', e => {
      this.tooltip.textContent = text;
      this.tooltip.style.opacity = '1';
    });
    element.addEventListener('mousemove', e => {
      this.tooltip.style.left = e.clientX + 12 + 'px';
      this.tooltip.style.top = e.clientY + 12 + 'px';
    });
    element.addEventListener('mouseleave', () => {
      this.tooltip.style.opacity = '0';
    });
  }
}
exports.METoolTip = METoolTip;

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BloomPass = void 0;
exports.fullscreenQuadWGSL = fullscreenQuadWGSL;
/**
 * @description 
 * Bloom class for matrix-engine-wgpu
 * @public 
 * 
 * @setKnee
 * @setIntensity
 * @setThreshold
 * @setBlurRadius
 */

class BloomPass {
  constructor(width, height, device, intensity = 1.5) {
    this.enabled = false;
    this.device = device;
    this.width = width;
    this.height = height;
    this.brightTex = this._createTexture();
    this.blurTexA = this._createTexture();
    this.blurTexB = this._createTexture();
    this.sampler = device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear'
    });
    this.intensityBuffer = this._createUniformBuffer([intensity]);
    this.blurDirX = this._createUniformBuffer([1, 0]);
    this.blurDirY = this._createUniformBuffer([0, 1]);
    this.params = {
      intensity: intensity,
      threshold: 0.6,
      knee: 0.5,
      blurRadius: 6.0
    };
    this.paramBuffer = this.device.createBuffer({
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this._updateParams();
    this.brightPipeline = this._createPipeline(brightPassWGSL(), [{
      binding: 0,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: 'float'
      }
    }, {
      binding: 1,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'filtering'
      }
    }, {
      binding: 2,
      visibility: GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }]);
    this.blurPipeline = this._createPipeline(blurPassWGSL(), [{
      binding: 0,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: 'float'
      }
    }, {
      binding: 1,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'filtering'
      }
    }, {
      binding: 2,
      visibility: GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }, {
      binding: 3,
      visibility: GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }]);
    this.combinePipeline = this._createPipeline(combinePassWGSL(), [{
      binding: 0,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: 'float'
      }
    }, {
      binding: 1,
      visibility: GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: 'float'
      }
    }, {
      binding: 2,
      visibility: GPUShaderStage.FRAGMENT,
      sampler: {
        type: 'filtering'
      }
    }, {
      binding: 3,
      visibility: GPUShaderStage.FRAGMENT,
      buffer: {
        type: 'uniform'
      }
    }]);
  }
  _createTexture() {
    return this.device.createTexture({
      size: [this.width, this.height],
      format: 'rgba16float',
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
  }
  _createPipeline(fragmentWGSL, bindGroupLayoutEntries) {
    const bindGroupLayout = this.device.createBindGroupLayout({
      entries: bindGroupLayoutEntries
    });
    return this.device.createRenderPipeline({
      label: 'bloom pipeline',
      layout: this.device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
      }),
      vertex: {
        module: this.device.createShaderModule({
          code: fullscreenQuadWGSL()
        }),
        entryPoint: 'vert'
      },
      fragment: {
        module: this.device.createShaderModule({
          code: fragmentWGSL
        }),
        entryPoint: 'main',
        targets: [{
          format: 'rgba16float'
        }]
      },
      primitive: {
        topology: 'triangle-list'
      }
    });
  }
  _updateParams() {
    this.device.queue.writeBuffer(this.paramBuffer, 0, new Float32Array([this.params.intensity, this.params.threshold, this.params.knee, this.params.blurRadius]));
  }
  setIntensity = v => {
    this.params.intensity = v;
    this._updateParams();
  };
  setThreshold = v => {
    this.params.threshold = v;
    this._updateParams();
  };
  setKnee = v => {
    this.params.knee = v;
    this._updateParams();
  };
  setBlurRadius = v => {
    this.params.blurRadius = v;
    this._updateParams();
  };
  _createUniformBuffer(data) {
    const buffer = this.device.createBuffer({
      size: 16,
      // std140 safe
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.device.queue.writeBuffer(buffer, 0, new Float32Array(data));
    return buffer;
  }
  _brightBindGroup(view) {
    return this.device.createBindGroup({
      layout: this.brightPipeline.getBindGroupLayout(0),
      entries: [{
        binding: 0,
        resource: view
      }, {
        binding: 1,
        resource: this.sampler
      }, {
        binding: 2,
        resource: {
          buffer: this.paramBuffer
        }
      }]
    });
  }
  _blurBindGroup(view, dirBuffer) {
    return this.device.createBindGroup({
      layout: this.blurPipeline.getBindGroupLayout(0),
      entries: [{
        binding: 0,
        resource: view
      }, {
        binding: 1,
        resource: this.sampler
      }, {
        binding: 2,
        resource: {
          buffer: dirBuffer
        }
      }, {
        binding: 3,
        resource: {
          buffer: this.paramBuffer
        }
      }]
    });
  }
  _combineBindGroup(sceneView, bloomView) {
    return this.device.createBindGroup({
      layout: this.combinePipeline.getBindGroupLayout(0),
      entries: [{
        binding: 0,
        resource: sceneView
      }, {
        binding: 1,
        resource: bloomView
      }, {
        binding: 2,
        resource: this.sampler
      }, {
        binding: 3,
        resource: {
          buffer: this.paramBuffer
        }
      }]
    });
  }
  _beginFullscreenPass(encoder, targetView) {
    return encoder.beginRenderPass({
      colorAttachments: [{
        view: targetView,
        loadOp: 'clear',
        storeOp: 'store',
        clearValue: {
          r: 0,
          g: 0,
          b: 0,
          a: 1
        }
      }]
    });
  }
  render(encoder, sceneView, finalTargetView) {
    // ----- Bright pass -----
    {
      const pass = this._beginFullscreenPass(encoder, this.brightTex.createView());
      pass.setPipeline(this.brightPipeline);
      pass.setBindGroup(0, this._brightBindGroup(sceneView));
      pass.draw(6);
      pass.end();
    }
    // ----- Blur X -----
    {
      const pass = this._beginFullscreenPass(encoder, this.blurTexA.createView());
      pass.setPipeline(this.blurPipeline);
      pass.setBindGroup(0, this._blurBindGroup(this.brightTex.createView(), this.blurDirX));
      pass.draw(6);
      pass.end();
    }
    // ----- Blur Y -----
    {
      const pass = this._beginFullscreenPass(encoder, this.blurTexB.createView());
      pass.setPipeline(this.blurPipeline);
      pass.setBindGroup(0, this._blurBindGroup(this.blurTexA.createView(), this.blurDirY));
      pass.draw(6);
      pass.end();
    }
    // ----- Combine -----
    {
      const pass = this._beginFullscreenPass(encoder, finalTargetView);
      pass.setPipeline(this.combinePipeline);
      pass.setBindGroup(0, this._combineBindGroup(sceneView, this.blurTexB.createView()));
      pass.draw(6);
      pass.end();
    }
  }
}
exports.BloomPass = BloomPass;
function fullscreenQuadWGSL() {
  return `
    @vertex
    fn vert(@builtin(vertex_index) i : u32) -> @builtin(position) vec4<f32> {
      var pos = array<vec2<f32>, 6>(
        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
        vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0)
      );
      return vec4(pos[i], 0.0, 1.0);
    }
  `;
}
function brightPassWGSL() {
  return `
    struct BloomParams {
    intensity: f32,
    threshold: f32,
    knee: f32,
    radius: f32,
  };
    @group(0) @binding(0) var tex: texture_2d<f32>;
    @group(0) @binding(1) var samp: sampler;
    @group(0) @binding(2) var<uniform> bloom: BloomParams;
    @fragment
    fn main(@builtin(position) p: vec4<f32>) -> @location(0) vec4<f32> {
      let size = vec2<f32>(textureDimensions(tex));
      let uv = p.xy / size;
      let c = textureSample(tex, samp, uv).rgb;
      let lum = dot(c, vec3<f32>(0.2126,0.7152,0.0722));
      let x = max(lum - bloom.threshold, 0.0);
      let w = x * x / (x + bloom.knee);
      return vec4(c * w, 1.0);
    }
  `;
}
function blurPassWGSL() {
  return `
   struct BloomParams {
    intensity: f32,
    threshold: f32,
    knee: f32,
    radius: f32,
  };

  @group(0) @binding(0) var tex: texture_2d<f32>;
  @group(0) @binding(1) var samp: sampler;
  @group(0) @binding(2) var<uniform> dir: vec2<f32>;
  @group(0) @binding(3) var<uniform> bloom: BloomParams;

  @fragment
  fn main(@builtin(position) p: vec4<f32>) -> @location(0) vec4<f32> {
    let size = vec2<f32>(textureDimensions(tex));
    let uv = p.xy / size;
    let r = bloom.radius;
    let o = array<f32,5>(-r, -r*0.5, 0.0, r*0.5, r);
    let w = array<f32,5>(0.1,0.2,0.4,0.2,0.1);
    var col = vec3(0.0);
    for(var i=0;i<5;i++){
      col += textureSample(tex, samp, uv + o[i]*dir/size).rgb * w[i];
    }
    return vec4(col,1.0);
  }
`;
}
function combinePassWGSL() {
  return `
  struct BloomParams {
    intensity: f32,
    threshold: f32,
    knee: f32,
    radius: f32,
  };
  @group(0) @binding(0) var origTex: texture_2d<f32>;
  @group(0) @binding(1) var bloomTex: texture_2d<f32>;
  @group(0) @binding(2) var samp: sampler;
  @group(0) @binding(3) var<uniform> bloom: BloomParams;

  @fragment
  fn main(@builtin(position) p: vec4<f32>) -> @location(0) vec4<f32> {
    let size = vec2<f32>(textureDimensions(origTex));
    let uv = p.xy / size;

    let origColor = textureSample(origTex, samp, uv).rgb;
    let bloomColor = textureSample(bloomTex, samp, uv).rgb;

    // additive bloom
    let color = origColor + bloomColor * bloom.intensity;

    return vec4(color, 1.0);
  }
`;
}

},{}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VolumetricPass = void 0;
exports.fullscreenVertWGSL = fullscreenVertWGSL;
/**
 * @description
 * VolumetricPass class for matrix-engine-wgpu
 * Matches BloomPass architecture — drop-in standalone pass.
 *
 * Insert in frame loop after transPass.end(), before bloom:
 *   volumetricPass.render(encoder, sceneTextureView, mainDepthView, shadowArrayView, camera, light)
 *   bloomPass.render(encoder, volumetricPass.compositeOutputTex.createView(), bloomOutputTex)
 *
 * @setDensity         - fog density (default 0.03)
 * @setSteps           - ray march steps (default 32)
 * @setLightColor      - RGB light scattering color
 * @setScatterStrength - how bright the scattering is
 * @setHeightFalloff   - how fast fog fades with height
 */

class VolumetricPass {
  constructor(width, height, device, options = {}) {
    this.enabled = false;
    this.device = device;
    this.width = width;
    this.height = height;
    this.volumetricTex = this._createTexture(width, height);

    // Linear sampler — composite pass
    this.sampler = device.createSampler({
      label: 'VolumetricPass.linearSampler',
      magFilter: 'linear',
      minFilter: 'linear',
      addressModeU: 'clamp-to-edge',
      addressModeV: 'clamp-to-edge'
    });

    // Comparison sampler — ALL THREE must agree:
    //   device sampler:  { compare: 'less-equal' }
    //   layout entry:    { type: 'comparison' }
    //   WGSL type:       sampler_comparison
    this.depthSampler = device.createSampler({
      label: 'VolumetricPass.comparisonSampler',
      compare: 'less-equal'
    });
    this.params = {
      density: options.density ?? 0.03,
      steps: options.steps ?? 32,
      scatterStrength: options.scatterStrength ?? 1.0,
      heightFalloff: options.heightFalloff ?? 0.1
    };
    this.lightParams = {
      color: options.lightColor ?? [1.0, 0.85, 0.6],
      direction: [0.0, -1.0, 0.5]
    };
    this.paramsBuffer = device.createBuffer({
      label: 'VolumetricPass.paramsBuffer',
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.invViewProjBuffer = device.createBuffer({
      label: 'VolumetricPass.invViewProjBuffer',
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.lightViewProjBuffer = device.createBuffer({
      label: 'VolumetricPass.lightViewProjBuffer',
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.lightDirBuffer = device.createBuffer({
      label: 'VolumetricPass.lightDirBuffer',
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.lightColorBuffer = device.createBuffer({
      label: 'VolumetricPass.lightColorBuffer',
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this._updateParams();
    this._updateLightColor();
    this.marchPipeline = this._createMarchPipeline();
    this.compositePipeline = this._createCompositePipeline();
  }

  // ─── Public setters ────────────────────────────────────────────────────────

  setDensity = v => {
    this.params.density = v;
    this._updateParams();
  };
  setSteps = v => {
    this.params.steps = v;
    this._updateParams();
  };
  setScatterStrength = v => {
    this.params.scatterStrength = v;
    this._updateParams();
  };
  setHeightFalloff = v => {
    this.params.heightFalloff = v;
    this._updateParams();
  };
  setLightColor = (r, g, b) => {
    this.lightParams.color = [r, g, b];
    this._updateLightColor();
  };
  setLightDirection = (x, y, z) => {
    this.lightParams.direction = [x, y, z];
    this.device.queue.writeBuffer(this.lightDirBuffer, 0, new Float32Array([x, y, z, 0.0]));
  };

  // ─── Internal ─────────────────────────────────────────────────────────────

  _updateParams() {
    this.device.queue.writeBuffer(this.paramsBuffer, 0, new Float32Array([this.params.density, this.params.steps, this.params.scatterStrength, this.params.heightFalloff]));
  }
  _updateLightColor() {
    this.device.queue.writeBuffer(this.lightColorBuffer, 0, new Float32Array([...this.lightParams.color, 0.0]));
  }
  _createTexture(w, h) {
    return this.device.createTexture({
      label: 'VolumetricPass.texture',
      size: [w, h],
      format: 'rgba16float',
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
  }
  _beginPass(encoder, targetView, label) {
    return encoder.beginRenderPass({
      label,
      colorAttachments: [{
        view: targetView,
        loadOp: 'clear',
        storeOp: 'store',
        clearValue: {
          r: 0,
          g: 0,
          b: 0,
          a: 0
        }
      }]
    });
  }

  // ─── Pipelines ─────────────────────────────────────────────────────────────

  _createMarchPipeline() {
    const bgl = this.device.createBindGroupLayout({
      label: 'VolumetricPass.marchBGL',
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {
          sampleType: 'depth'
        }
      }, {
        binding: 1,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {
          sampleType: 'depth',
          viewDimension: '2d-array'
        }
      }, {
        binding: 2,
        visibility: GPUShaderStage.FRAGMENT,
        sampler: {
          type: 'comparison'
        }
      },
      // ← must be 'comparison'
      {
        binding: 3,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {
          type: 'uniform'
        }
      }, {
        binding: 4,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {
          type: 'uniform'
        }
      }, {
        binding: 5,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {
          type: 'uniform'
        }
      }, {
        binding: 6,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {
          type: 'uniform'
        }
      }, {
        binding: 7,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {
          type: 'uniform'
        }
      }]
    });
    return this.device.createRenderPipeline({
      label: 'Volumetric Pipeline',
      layout: this.device.createPipelineLayout({
        label: 'VolumetricPass.marchPipelineLayout',
        bindGroupLayouts: [bgl]
      }),
      vertex: {
        module: this.device.createShaderModule({
          label: 'VolumetricPass.vert',
          code: fullscreenVertWGSL()
        }),
        entryPoint: 'vert'
      },
      fragment: {
        module: this.device.createShaderModule({
          label: 'VolumetricPass.marchFrag',
          code: marchFragWGSL()
        }),
        entryPoint: 'main',
        targets: [{
          format: 'rgba16float'
        }]
      },
      primitive: {
        topology: 'triangle-list'
      }
    });
  }
  _createCompositePipeline() {
    const bgl = this.device.createBindGroupLayout({
      label: 'VolumetricPass.compositeBGL',
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {
          sampleType: 'float'
        }
      }, {
        binding: 1,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {
          sampleType: 'float'
        }
      }, {
        binding: 2,
        visibility: GPUShaderStage.FRAGMENT,
        sampler: {
          type: 'filtering'
        }
      }, {
        binding: 3,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {
          type: 'uniform'
        }
      }]
    });
    return this.device.createRenderPipeline({
      label: 'VolumetricCompose Pipeline',
      layout: this.device.createPipelineLayout({
        label: 'VolumetricPass.compositePipelineLayout',
        bindGroupLayouts: [bgl]
      }),
      vertex: {
        module: this.device.createShaderModule({
          label: 'VolumetricPass.compositeVert',
          code: fullscreenVertWGSL()
        }),
        entryPoint: 'vert'
      },
      fragment: {
        module: this.device.createShaderModule({
          label: 'VolumetricPass.compositeFrag',
          code: compositeFragWGSL()
        }),
        entryPoint: 'main',
        targets: [{
          format: 'rgba16float'
        }]
      },
      primitive: {
        topology: 'triangle-list'
      }
    });
  }

  // ─── Bind Groups ───────────────────────────────────────────────────────────

  _marchBindGroup(depthView, shadowArrayView) {
    return this.device.createBindGroup({
      label: 'VolumetricPass.marchBindGroup',
      layout: this.marchPipeline.getBindGroupLayout(0),
      entries: [{
        binding: 0,
        resource: depthView
      }, {
        binding: 1,
        resource: shadowArrayView
      }, {
        binding: 2,
        resource: this.depthSampler
      },
      // comparison sampler
      {
        binding: 3,
        resource: {
          buffer: this.invViewProjBuffer
        }
      }, {
        binding: 4,
        resource: {
          buffer: this.lightViewProjBuffer
        }
      }, {
        binding: 5,
        resource: {
          buffer: this.lightDirBuffer
        }
      }, {
        binding: 6,
        resource: {
          buffer: this.lightColorBuffer
        }
      }, {
        binding: 7,
        resource: {
          buffer: this.paramsBuffer
        }
      }]
    });
  }
  _compositeBindGroup(sceneView) {
    return this.device.createBindGroup({
      label: 'VolumetricPass.compositeBindGroup',
      layout: this.compositePipeline.getBindGroupLayout(0),
      entries: [{
        binding: 0,
        resource: sceneView
      }, {
        binding: 1,
        resource: this.volumetricTex.createView()
      }, {
        binding: 2,
        resource: this.sampler
      }, {
        binding: 3,
        resource: {
          buffer: this.paramsBuffer
        }
      }]
    });
  }

  // ─── Render ────────────────────────────────────────────────────────────────
  /**
   * @param {GPUCommandEncoder} encoder
   * @param {GPUTextureView} sceneView        — your sceneTextureView
   * @param {GPUTextureView} depthView        — your mainDepthView
   * @param {GPUTextureView} shadowArrayView  — your shadowArrayView
   * @param {object} camera  — { invViewProjectionMatrix: Float32Array(16) }
   * @param {object} light   — { viewProjectionMatrix: Float32Array(16), direction: [x,y,z] }
   */
  render(encoder, sceneView, depthView, shadowArrayView, camera, light) {
    this.device.queue.writeBuffer(this.invViewProjBuffer, 0, camera.invViewProjectionMatrix);
    this.device.queue.writeBuffer(this.lightViewProjBuffer, 0, light.viewProjectionMatrix);
    this.device.queue.writeBuffer(this.lightDirBuffer, 0, new Float32Array([...light.direction, 0.0]));

    // Pass 1 — ray march → volumetricTex
    {
      const pass = this._beginPass(encoder, this.volumetricTex.createView(), 'VolumetricPass.marchPass');
      pass.setPipeline(this.marchPipeline);
      pass.setBindGroup(0, this._marchBindGroup(depthView, shadowArrayView));
      pass.draw(6);
      pass.end();
    }

    // Pass 2 — composite → compositeOutputTex (feed this to bloomPass instead of sceneTextureView)
    {
      const pass = this._beginPass(encoder, this.compositeOutputTex.createView(), 'VolumetricPass.compositePass');
      pass.setPipeline(this.compositePipeline);
      pass.setBindGroup(0, this._compositeBindGroup(sceneView));
      pass.draw(6);
      pass.end();
    }
  }

  /** Call once after constructor. Chainable: new VolumetricPass(...).init() */
  init() {
    this.compositeOutputTex = this._createTexture(this.width, this.height);
    return this;
  }

  /** Call on canvas resize */
  resize(width, height) {
    this.width = width;
    this.height = height;
    this.volumetricTex = this._createTexture(width, height);
    this.compositeOutputTex = this._createTexture(width, height);
  }
}

// ─── WGSL Shaders ─────────────────────────────────────────────────────────────
exports.VolumetricPass = VolumetricPass;
function fullscreenVertWGSL() {
  return /* wgsl */`
    @vertex
    fn vert(@builtin(vertex_index) i: u32) -> @builtin(position) vec4<f32> {
      var pos = array<vec2<f32>, 6>(
        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0,  1.0),
        vec2(-1.0,  1.0), vec2(1.0, -1.0), vec2(1.0,  1.0)
      );
      return vec4(pos[i], 0.0, 1.0);
    }
  `;
}
function marchFragWGSL() {
  return /* wgsl */`

  @group(0) @binding(0) var depthTex:   texture_depth_2d;
  @group(0) @binding(1) var shadowTex:  texture_depth_2d_array;
  @group(0) @binding(2) var cmpSamp:    sampler_comparison;
  @group(0) @binding(3) var<uniform> invViewProj:   mat4x4<f32>;
  @group(0) @binding(4) var<uniform> lightViewProj: mat4x4<f32>;
  @group(0) @binding(5) var<uniform> lightDir:      vec4<f32>;
  @group(0) @binding(6) var<uniform> lightColor:    vec4<f32>;

  struct Params { density: f32, steps: f32, scatterStrength: f32, heightFalloff: f32 }
  @group(0) @binding(7) var<uniform> params: Params;

  fn worldPos(uv: vec2<f32>, depth: f32) -> vec3<f32> {
    let ndc   = vec4(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0, depth, 1.0);
    let world = invViewProj * ndc;
    return world.xyz / world.w;
  }

  fn fogDensity(p: vec3<f32>) -> f32 {
    return params.density * exp(-max(p.y, 0.0) * params.heightFalloff);
  }

  @fragment
  fn main(@builtin(position) fc: vec4<f32>) -> @location(0) vec4<f32> {
    let sz    = vec2<f32>(textureDimensions(depthTex));
    let uv    = fc.xy / sz;
    let depth = textureLoad(depthTex, vec2<i32>(fc.xy), 0);

    let ro    = worldPos(uv, 0.0);
    let rt    = worldPos(uv, depth);
    let rlen  = length(rt - ro);
    let rdir  = normalize(rt - ro);
    let steps = max(i32(params.steps), 8);
    let step  = rlen / f32(steps);

    var accum = vec3<f32>(0.0);
    var trans = 1.0;

    for (var i = 0; i < steps; i++) {
      let p = ro + rdir * ((f32(i) + 0.5) * step);

      // ── textureSampleCompare MUST be in uniform control flow ─────────────
      // Compute shadow coords for every sample unconditionally.
      // Gate the contribution with branchless math — never use if/continue/break above this call.
      let ls  = lightViewProj * vec4(p, 1.0);
      let lp  = ls.xyz / ls.w;
      let suv = lp.xy * 0.5 + 0.5;

      let shadow   = textureSampleCompare(shadowTex, cmpSamp, suv, 0, lp.z - 0.002);
      let inBounds = f32(suv.x >= 0.0 && suv.x <= 1.0 && suv.y >= 0.0 && suv.y <= 1.0);
      let lit      = shadow * inBounds;

      let d   = fogDensity(p) * step;
      let ext = exp(-d);
      let s   = trans * (1.0 - ext) * lit * params.scatterStrength * f32(d > 0.0001);

      accum += s * lightColor.rgb;
      trans *= select(1.0, ext, d > 0.0001);
    }

    return vec4<f32>(accum, 1.0 - trans);
  }
  `;
}
function compositeFragWGSL() {
  return /* wgsl */`

  @group(0) @binding(0) var sceneTex: texture_2d<f32>;
  @group(0) @binding(1) var volTex:   texture_2d<f32>;
  @group(0) @binding(2) var samp:     sampler;
  struct Params { density: f32, steps: f32, scatterStrength: f32, heightFalloff: f32 }
  @group(0) @binding(3) var<uniform> params: Params;

  @fragment
  fn main(@builtin(position) fc: vec4<f32>) -> @location(0) vec4<f32> {
    let uv    = fc.xy / vec2<f32>(textureDimensions(sceneTex));
    let scene = textureSample(sceneTex, samp, uv);
    let vol   = textureSample(volTex, samp, uv);
    // vol.rgb = scattered light | vol.a = fog opacity
    return vec4<f32>(scene.rgb * (1.0 - vol.a) + vol.rgb, scene.a);
  }
  `;
}

},{}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGroundTexture = createGroundTexture;
function createGroundTexture(device, size = 512) {
  const data = new Uint8Array(size * size * 4);
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const i = (y * size + x) * 4;

      // Grid pattern
      const gridX = x % 64 < 4;
      const gridY = y % 64 < 4;
      const isLine = gridX || gridY;

      // Dark gray tiles with lighter grout lines
      const val = isLine ? 100 : 60;
      data[i] = val; // R
      data[i + 1] = val; // G
      data[i + 2] = val; // B
      data[i + 3] = 255; // A
    }
  }
  const texture = device.createTexture({
    size: [size, size],
    format: 'rgba8unorm',
    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
  });
  device.queue.writeTexture({
    texture
  }, data, {
    bytesPerRow: size * 4
  }, [size, size]);
  return texture;
}

},{}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addRaycastsAABBListener = addRaycastsAABBListener;
exports.addRaycastsListener = addRaycastsListener;
exports.computeAABB = computeAABB;
exports.computeWorldVertsAndAABB = computeWorldVertsAndAABB;
exports.getRayFromMouse = getRayFromMouse;
exports.getRayFromMouse2 = void 0;
exports.rayIntersectsAABB = rayIntersectsAABB;
exports.rayIntersectsSphere = rayIntersectsSphere;
exports.touchCoordinate = void 0;
var _wgpuMatrix = require("wgpu-matrix");
/**
* MatrixEngine Raycaster (improved)
* Author: Nikola Lukić
* Version: 2.0
*/

let touchCoordinate = exports.touchCoordinate = {
  enabled: false,
  x: 0,
  y: 0,
  stopOnFirstDetectedHit: false
};
function multiplyMatrixVector(matrix, vector) {
  return _wgpuMatrix.vec4.transformMat4(vector, matrix);
}
function getRayFromMouse(event, canvas, camera) {
  const rect = canvas.getBoundingClientRect();
  const x = (event.clientX - rect.left) / rect.width * 2 - 1;
  const y = -((event.clientY - rect.top) / rect.height * 2 - 1); // flip Y (WebGPU NDC)

  // Use precomputed projection if available
  const invProjection = _wgpuMatrix.mat4.inverse(camera.projectionMatrix);
  const invView = _wgpuMatrix.mat4.inverse(camera.view);
  const clip = [x, y, 1, 1];
  let eye = _wgpuMatrix.vec4.transformMat4(clip, invProjection);
  eye = [eye[0], eye[1], -1, 0];
  const worldDir4 = _wgpuMatrix.vec4.transformMat4(eye, invView);
  const rayDirection = _wgpuMatrix.vec3.normalize([worldDir4[0], worldDir4[1], worldDir4[2]]);
  const rayOrigin = [...camera.position];
  return {
    rayOrigin,
    rayDirection,
    screen: {
      x,
      y
    }
  };
}

// Backward compatibility alias
const getRayFromMouse2 = exports.getRayFromMouse2 = getRayFromMouse;
function rayIntersectsSphere(rayOrigin, rayDirection, sphereCenter, sphereRadius) {
  const center = [sphereCenter.x, sphereCenter.y, sphereCenter.z];
  const oc = _wgpuMatrix.vec3.subtract(rayOrigin, center);
  const a = _wgpuMatrix.vec3.dot(rayDirection, rayDirection);
  const b = 2.0 * _wgpuMatrix.vec3.dot(oc, rayDirection);
  const c = _wgpuMatrix.vec3.dot(oc, oc) - sphereRadius * sphereRadius;
  const discriminant = b * b - 4 * a * c;
  if (discriminant < 0) return null;
  const t = (-b - Math.sqrt(discriminant)) / (2.0 * a);
  if (t < 0) return null;
  const hitPoint = _wgpuMatrix.vec3.add(rayOrigin, _wgpuMatrix.vec3.mulScalar(rayDirection, t));
  const hitNormal = _wgpuMatrix.vec3.normalize(_wgpuMatrix.vec3.subtract(hitPoint, center));
  return {
    t,
    hitPoint,
    hitNormal
  };
}
function computeAABB(vertices) {
  const min = [Infinity, Infinity, Infinity];
  const max = [-Infinity, -Infinity, -Infinity];
  for (let i = 0; i < vertices.length; i += 3) {
    min[0] = Math.min(min[0], vertices[i]);
    min[1] = Math.min(min[1], vertices[i + 1]);
    min[2] = Math.min(min[2], vertices[i + 2]);
    max[0] = Math.max(max[0], vertices[i]);
    max[1] = Math.max(max[1], vertices[i + 1]);
    max[2] = Math.max(max[2], vertices[i + 2]);
  }
  return [min, max];
}

// Ray-AABB intersection returning distance (slab method)
function rayIntersectsAABB(rayOrigin, rayDirection, boxMin, boxMax) {
  let tmin = (boxMin[0] - rayOrigin[0]) / rayDirection[0];
  let tmax = (boxMax[0] - rayOrigin[0]) / rayDirection[0];
  if (tmin > tmax) [tmin, tmax] = [tmax, tmin];
  let tymin = (boxMin[1] - rayOrigin[1]) / rayDirection[1];
  let tymax = (boxMax[1] - rayOrigin[1]) / rayDirection[1];
  if (tymin > tymax) [tymin, tymax] = [tymax, tymin];
  if (tmin > tymax || tymin > tmax) return null;
  if (tymin > tmin) tmin = tymin;
  if (tymax < tmax) tmax = tymax;
  let tzmin = (boxMin[2] - rayOrigin[2]) / rayDirection[2];
  let tzmax = (boxMax[2] - rayOrigin[2]) / rayDirection[2];
  if (tzmin > tzmax) [tzmin, tzmax] = [tzmax, tzmin];
  if (tmin > tzmax || tzmin > tmax) return null;
  const t = Math.max(tmin, 0.0);
  const hitPoint = _wgpuMatrix.vec3.add(rayOrigin, _wgpuMatrix.vec3.mulScalar(rayDirection, t));
  return {
    t,
    hitPoint
  };
}
function computeWorldVertsAndAABB(object) {
  const modelMatrix = object.getModelMatrix(object.position);
  const worldVerts = [];
  for (let i = 0; i < object.mesh.vertices.length; i += 3) {
    const local = [object.mesh.vertices[i], object.mesh.vertices[i + 1], object.mesh.vertices[i + 2]];
    const world = _wgpuMatrix.vec3.transformMat4(local, modelMatrix);
    worldVerts.push(...world);
  }
  const [boxMin, boxMax] = computeAABB(worldVerts);
  return {
    modelMatrix,
    worldVerts,
    boxMin,
    boxMax
  };
}

// 🧠 Dispatch rich event
function dispatchRayHitEvent(canvas, data) {
  if (data.eventName == 'click') {
    canvas.dispatchEvent(new CustomEvent("ray.hit.event", {
      detail: data
    }));
  } else if (data.eventName == 'mousedown') {
    canvas.dispatchEvent(new CustomEvent("ray.hit.mousedown", {
      detail: data
    }));
  } else {
    canvas.dispatchEvent(new CustomEvent("ray.hit.event.mm", {
      detail: data
    }));
  }
}
function addRaycastsListener(canvasId = "canvas1", eventName = 'click') {
  const canvas = document.getElementById(canvasId);
  if (!canvas) {
    console.warn(`[Raycaster] Canvas with id '${canvasId}' not found.`);
    return;
  }
  canvas.addEventListener(eventName, event => {
    const camera = app.cameras[app.mainCameraParams.type];
    const {
      rayOrigin,
      rayDirection,
      screen
    } = getRayFromMouse(event, canvas, camera);
    let closestHit = null;
    for (const object of app.mainRenderBundle) {
      if (!object.raycast?.enabled) continue;
      const {
        boxMin,
        boxMax
      } = computeWorldVertsAndAABB(object);
      const hitAABB = rayIntersectsAABB(rayOrigin, rayDirection, boxMin, boxMax);
      if (!hitAABB) continue;
      const sphereHit = rayIntersectsSphere(rayOrigin, rayDirection, object.position, object.raycast.radius);
      const hit = sphereHit || hitAABB;
      if (hit && (!closestHit || hit.t < closestHit.t)) {
        closestHit = {
          ...hit,
          hitObject: object
        };
        if (touchCoordinate.stopOnFirstDetectedHit) break;
      }
    }
    if (closestHit) {
      dispatchRayHitEvent(canvas, {
        hitObject: closestHit.hitObject,
        hitPoint: closestHit.hitPoint,
        hitNormal: closestHit.hitNormal || null,
        hitDistance: closestHit.t,
        rayOrigin,
        rayDirection,
        screenCoords: screen,
        camera,
        timestamp: performance.now(),
        button: event.button,
        eventName: eventName
      });
    }
  });
}
function addRaycastsAABBListener(canvasId = "canvas1", eventName = 'click') {
  const canvas = document.getElementById(canvasId);
  if (!canvas) {
    console.warn(`[Raycaster] Canvas with id '${canvasId}' not found.`);
    return;
  }
  canvas.addEventListener(eventName, event => {
    const camera = app.cameras[app.mainCameraParams.type];
    const {
      rayOrigin,
      rayDirection,
      screen
    } = getRayFromMouse(event, canvas, camera);
    let closestHit = null;
    for (const object of app.mainRenderBundle) {
      if (!object.raycast?.enabled) continue;
      const {
        boxMin,
        boxMax
      } = computeWorldVertsAndAABB(object);
      const hitAABB = rayIntersectsAABB(rayOrigin, rayDirection, boxMin, boxMax);
      if (!hitAABB) continue;
      const hit = hitAABB;
      if (hit && (!closestHit || hit.t < closestHit.t)) {
        closestHit = {
          ...hit,
          hitObject: object
        };
        if (touchCoordinate.stopOnFirstDetectedHit) break;
      }
    }
    if (closestHit) {
      dispatchRayHitEvent(canvas, {
        hitObject: closestHit.hitObject,
        hitPoint: closestHit.hitPoint,
        hitNormal: closestHit.hitNormal || null,
        hitDistance: closestHit.t,
        rayOrigin,
        rayDirection,
        screenCoords: screen,
        camera,
        timestamp: performance.now(),
        button: event.button,
        eventName: eventName
      });
    }
  });
}

},{"wgpu-matrix":22}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LS = exports.LOG_WARN = exports.LOG_MATRIX = exports.LOG_INFO = exports.LOG_FUNNY_SMALL = exports.LOG_FUNNY_EXTRABIG = exports.LOG_FUNNY_BIG_TERMINAL = exports.LOG_FUNNY_BIG_NEON = exports.LOG_FUNNY_BIG_ARCADE = exports.LOG_FUNNY_ARCADE = exports.LOG_FUNNY = exports.LOGO_FRAMES = exports.FullscreenManagerElement = exports.FullscreenManager = void 0;
exports.ORBIT = ORBIT;
exports.ORBIT_FROM_ARRAY = ORBIT_FROM_ARRAY;
exports.OSCILLATOR = OSCILLATOR;
exports.SS = void 0;
exports.SWITCHER = SWITCHER;
exports.alignTo256 = alignTo256;
exports.byId = void 0;
exports.createAppEvent = createAppEvent;
exports.degToRad = degToRad;
exports.genName = genName;
exports.getAxisRot = getAxisRot;
exports.getAxisRot2 = getAxisRot2;
exports.getAxisRot3 = getAxisRot3;
exports.htmlHeader = void 0;
exports.isEven = isEven;
exports.isMobile = isMobile;
exports.isOdd = isOdd;
exports.mb = exports.mat4 = exports.jsonHeaders = void 0;
exports.quaternion_rotation_matrix = quaternion_rotation_matrix;
exports.radToDeg = radToDeg;
exports.randomFloatFromTo = randomFloatFromTo;
exports.randomIntFromTo = randomIntFromTo;
exports.scriptManager = void 0;
exports.setupCanvasFilters = setupCanvasFilters;
exports.supportsTouch = void 0;
exports.typeText = typeText;
exports.vec3 = exports.urlQuery = void 0;
var supportsTouch = exports.supportsTouch = 'ontouchstart' in window || navigator.msMaxTouchPoints;
function isMobile() {
  if (supportsTouch == true) return true;
  const toMatch = [/Android/i, /webOS/i, /iPhone/i, /iPad/i, /iPod/i, /BlackBerry/i, /Windows Phone/i];
  return toMatch.some(toMatchItem => {
    return navigator.userAgent.match(toMatchItem);
  });
}
;
const vec3 = exports.vec3 = {
  cross(a, b, dst) {
    dst = dst || new Float32Array(3);
    const t0 = a[1] * b[2] - a[2] * b[1];
    const t1 = a[2] * b[0] - a[0] * b[2];
    const t2 = a[0] * b[1] - a[1] * b[0];
    dst[0] = t0;
    dst[1] = t1;
    dst[2] = t2;
    return dst;
  },
  subtract(a, b, dst) {
    dst = dst || new Float32Array(3);
    dst[0] = a[0] - b[0];
    dst[1] = a[1] - b[1];
    dst[2] = a[2] - b[2];
    return dst;
  },
  normalize(v, dst) {
    dst = dst || new Float32Array(3);
    const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    // make sure we don't divide by 0.
    if (length > 0.00001) {
      dst[0] = v[0] / length;
      dst[1] = v[1] / length;
      dst[2] = v[2] / length;
    } else {
      dst[0] = 0;
      dst[1] = 0;
      dst[2] = 0;
    }
    return dst;
  }
};
const mat4 = exports.mat4 = {
  projection(width, height, depth, dst) {
    // Note: This matrix flips the Y axis so that 0 is at the top.
    return mat4.ortho(0, width, height, 0, depth, -depth, dst);
  },
  perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
    dst = dst || new Float32Array(16);
    const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
    const rangeInv = 1 / (zNear - zFar);
    dst[0] = f / aspect;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = f;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = zFar * rangeInv;
    dst[11] = -1;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = zNear * zFar * rangeInv;
    dst[15] = 0;
    return dst;
  },
  ortho(left, right, bottom, top, near, far, dst) {
    dst = dst || new Float32Array(16);
    dst[0] = 2 / (right - left);
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = 2 / (top - bottom);
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = 1 / (near - far);
    dst[11] = 0;
    dst[12] = (right + left) / (left - right);
    dst[13] = (top + bottom) / (bottom - top);
    dst[14] = near / (near - far);
    dst[15] = 1;
    return dst;
  },
  identity(dst) {
    dst = dst || new Float32Array(16);
    dst[0] = 1;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = 1;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = 1;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;
    return dst;
  },
  multiply(a, b, dst) {
    dst = dst || new Float32Array(16);
    const b00 = b[0 * 4 + 0];
    const b01 = b[0 * 4 + 1];
    const b02 = b[0 * 4 + 2];
    const b03 = b[0 * 4 + 3];
    const b10 = b[1 * 4 + 0];
    const b11 = b[1 * 4 + 1];
    const b12 = b[1 * 4 + 2];
    const b13 = b[1 * 4 + 3];
    const b20 = b[2 * 4 + 0];
    const b21 = b[2 * 4 + 1];
    const b22 = b[2 * 4 + 2];
    const b23 = b[2 * 4 + 3];
    const b30 = b[3 * 4 + 0];
    const b31 = b[3 * 4 + 1];
    const b32 = b[3 * 4 + 2];
    const b33 = b[3 * 4 + 3];
    const a00 = a[0 * 4 + 0];
    const a01 = a[0 * 4 + 1];
    const a02 = a[0 * 4 + 2];
    const a03 = a[0 * 4 + 3];
    const a10 = a[1 * 4 + 0];
    const a11 = a[1 * 4 + 1];
    const a12 = a[1 * 4 + 2];
    const a13 = a[1 * 4 + 3];
    const a20 = a[2 * 4 + 0];
    const a21 = a[2 * 4 + 1];
    const a22 = a[2 * 4 + 2];
    const a23 = a[2 * 4 + 3];
    const a30 = a[3 * 4 + 0];
    const a31 = a[3 * 4 + 1];
    const a32 = a[3 * 4 + 2];
    const a33 = a[3 * 4 + 3];
    dst[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
    dst[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
    dst[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
    dst[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
    dst[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
    dst[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
    dst[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
    dst[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
    dst[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
    dst[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
    dst[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
    dst[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
    dst[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
    dst[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
    dst[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
    dst[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
    return dst;
  },
  cameraAim(eye, target, up, dst) {
    dst = dst || new Float32Array(16);
    const zAxis = vec3.normalize(vec3.subtract(eye, target));
    const xAxis = vec3.normalize(vec3.cross(up, zAxis));
    const yAxis = vec3.normalize(vec3.cross(zAxis, xAxis));
    dst[0] = xAxis[0];
    dst[1] = xAxis[1];
    dst[2] = xAxis[2];
    dst[3] = 0;
    dst[4] = yAxis[0];
    dst[5] = yAxis[1];
    dst[6] = yAxis[2];
    dst[7] = 0;
    dst[8] = zAxis[0];
    dst[9] = zAxis[1];
    dst[10] = zAxis[2];
    dst[11] = 0;
    dst[12] = eye[0];
    dst[13] = eye[1];
    dst[14] = eye[2];
    dst[15] = 1;
    return dst;
  },
  inverse(m, dst) {
    dst = dst || new Float32Array(16);
    const m00 = m[0 * 4 + 0];
    const m01 = m[0 * 4 + 1];
    const m02 = m[0 * 4 + 2];
    const m03 = m[0 * 4 + 3];
    const m10 = m[1 * 4 + 0];
    const m11 = m[1 * 4 + 1];
    const m12 = m[1 * 4 + 2];
    const m13 = m[1 * 4 + 3];
    const m20 = m[2 * 4 + 0];
    const m21 = m[2 * 4 + 1];
    const m22 = m[2 * 4 + 2];
    const m23 = m[2 * 4 + 3];
    const m30 = m[3 * 4 + 0];
    const m31 = m[3 * 4 + 1];
    const m32 = m[3 * 4 + 2];
    const m33 = m[3 * 4 + 3];
    const tmp0 = m22 * m33;
    const tmp1 = m32 * m23;
    const tmp2 = m12 * m33;
    const tmp3 = m32 * m13;
    const tmp4 = m12 * m23;
    const tmp5 = m22 * m13;
    const tmp6 = m02 * m33;
    const tmp7 = m32 * m03;
    const tmp8 = m02 * m23;
    const tmp9 = m22 * m03;
    const tmp10 = m02 * m13;
    const tmp11 = m12 * m03;
    const tmp12 = m20 * m31;
    const tmp13 = m30 * m21;
    const tmp14 = m10 * m31;
    const tmp15 = m30 * m11;
    const tmp16 = m10 * m21;
    const tmp17 = m20 * m11;
    const tmp18 = m00 * m31;
    const tmp19 = m30 * m01;
    const tmp20 = m00 * m21;
    const tmp21 = m20 * m01;
    const tmp22 = m00 * m11;
    const tmp23 = m10 * m01;
    const t0 = tmp0 * m11 + tmp3 * m21 + tmp4 * m31 - (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
    const t1 = tmp1 * m01 + tmp6 * m21 + tmp9 * m31 - (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
    const t2 = tmp2 * m01 + tmp7 * m11 + tmp10 * m31 - (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
    const t3 = tmp5 * m01 + tmp8 * m11 + tmp11 * m21 - (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
    const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
    dst[0] = d * t0;
    dst[1] = d * t1;
    dst[2] = d * t2;
    dst[3] = d * t3;
    dst[4] = d * (tmp1 * m10 + tmp2 * m20 + tmp5 * m30 - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));
    dst[5] = d * (tmp0 * m00 + tmp7 * m20 + tmp8 * m30 - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));
    dst[6] = d * (tmp3 * m00 + tmp6 * m10 + tmp11 * m30 - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));
    dst[7] = d * (tmp4 * m00 + tmp9 * m10 + tmp10 * m20 - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));
    dst[8] = d * (tmp12 * m13 + tmp15 * m23 + tmp16 * m33 - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));
    dst[9] = d * (tmp13 * m03 + tmp18 * m23 + tmp21 * m33 - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));
    dst[10] = d * (tmp14 * m03 + tmp19 * m13 + tmp22 * m33 - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));
    dst[11] = d * (tmp17 * m03 + tmp20 * m13 + tmp23 * m23 - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));
    dst[12] = d * (tmp14 * m22 + tmp17 * m32 + tmp13 * m12 - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));
    dst[13] = d * (tmp20 * m32 + tmp12 * m02 + tmp19 * m22 - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));
    dst[14] = d * (tmp18 * m12 + tmp23 * m32 + tmp15 * m02 - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));
    dst[15] = d * (tmp22 * m22 + tmp16 * m02 + tmp21 * m12 - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));
    return dst;
  },
  lookAt(eye, target, up, dst) {
    return mat4.inverse(mat4.cameraAim(eye, target, up, dst), dst);
  },
  translation([tx, ty, tz], dst) {
    dst = dst || new Float32Array(16);
    dst[0] = 1;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = 1;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = 1;
    dst[11] = 0;
    dst[12] = tx;
    dst[13] = ty;
    dst[14] = tz;
    dst[15] = 1;
    return dst;
  },
  rotationX(angleInRadians, dst) {
    const c = Math.cos(angleInRadians);
    const s = Math.sin(angleInRadians);
    dst = dst || new Float32Array(16);
    dst[0] = 1;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = c;
    dst[6] = s;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = -s;
    dst[10] = c;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;
    return dst;
  },
  rotationY(angleInRadians, dst) {
    const c = Math.cos(angleInRadians);
    const s = Math.sin(angleInRadians);
    dst = dst || new Float32Array(16);
    dst[0] = c;
    dst[1] = 0;
    dst[2] = -s;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = 1;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = s;
    dst[9] = 0;
    dst[10] = c;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;
    return dst;
  },
  rotationZ(angleInRadians, dst) {
    const c = Math.cos(angleInRadians);
    const s = Math.sin(angleInRadians);
    dst = dst || new Float32Array(16);
    dst[0] = c;
    dst[1] = s;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = -s;
    dst[5] = c;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = 1;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;
    return dst;
  },
  scaling([sx, sy, sz], dst) {
    dst = dst || new Float32Array(16);
    dst[0] = sx;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = sy;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = sz;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;
    return dst;
  },
  translate(m, translation, dst) {
    return mat4.multiply(m, mat4.translation(translation), dst);
  },
  rotateX(m, angleInRadians, dst) {
    return mat4.multiply(m, mat4.rotationX(angleInRadians), dst);
  },
  rotateY(m, angleInRadians, dst) {
    return mat4.multiply(m, mat4.rotationY(angleInRadians), dst);
  },
  rotateZ(m, angleInRadians, dst) {
    return mat4.multiply(m, mat4.rotationZ(angleInRadians), dst);
  },
  scale(m, scale, dst) {
    return mat4.multiply(m, mat4.scaling(scale), dst);
  }
};
function degToRad(degrees) {
  return degrees * Math.PI / 180;
}
;
function radToDeg(r) {
  var pi = Math.PI;
  return r * (180 / pi);
}
;
function createAppEvent(name, myDetails) {
  return new CustomEvent(name, {
    detail: {
      eventName: name,
      data: myDetails
    },
    bubbles: true
  });
}

/**
 * @description
 * Load script in runtime.
 */
var scriptManager = exports.scriptManager = {
  SCRIPT_ID: 0,
  LOAD: function addScript(src, id, type, parent, callback) {
    var s = document.createElement('script');
    s.onload = function () {
      // console.log('Script id loaded [src]: ' + this.src);
      if (typeof callback != 'undefined') callback();
    };
    if (typeof type !== 'undefined') {
      s.setAttribute('type', type);
      s.innerHTML = src;
    } else {
      s.setAttribute('src', src);
    }
    if (typeof id !== 'undefined') {
      s.setAttribute('id', id);
    }
    if (typeof parent !== 'undefined') {
      document.getElementById(parent).appendChild(s);
      if (typeof callback != 'undefined') callback();
    } else {
      document.body.appendChild(s);
    }
  },
  loadModule: function addScript(src, id, type, parent) {
    console.log('Script id load called ');
    var s = document.createElement('script');
    s.onload = function () {
      scriptManager.SCRIPT_ID++;
    };
    if (typeof type === 'undefined') {
      s.setAttribute('type', 'module');
      s.setAttribute('src', src);
    } else {
      s.setAttribute('type', type);
      s.innerHTML = src;
    }
    s.setAttribute('src', src);
    if (typeof id !== 'undefined') {
      s.setAttribute('id', id);
    }
    if (typeof parent !== 'undefined') {
      document.getElementById(parent).appendChild(s);
    } else {
      document.body.appendChild(s);
    }
  },
  loadGLSL: function (src) {
    return new Promise(resolve => {
      fetch(src).then(data => {
        resolve(data.text());
      });
    });
  }
};

// GET PULSE VALUES IN REAL TIME
function OSCILLATOR(min, max, step, options) {
  if (min == null || max == null || step == null) {
    console.log("OSCILLATOR ERROR");
    return;
  }
  var ROOT = this;

  // ---- core values ----
  this.min0 = parseFloat(min);
  this.max0 = parseFloat(max);
  this.min = this.min0;
  this.max = this.max0;
  this.step = parseFloat(step);
  this.value_ = this.min;
  this.status = 0; // 0 up, 1 down

  // ---- options ----
  options = options || {};
  this.regime = options.regime || "pingpong";
  this.resist = parseFloat(options.resist) || 0; // 0 = infinite
  this.resistMode = options.resistMode || "linear"; // linear | exp
  this.stopEpsilon = options.stopEpsilon || 0; // 0 = never stop
  this.useDelta = options.useDelta || false;

  // ---- events ----
  this.on_maximum_value = function () {};
  this.on_minimum_value = function () {};
  this.on_stop = function () {};

  // ---- helpers ----
  this._applyResist = function () {
    if (this.resist <= 0) return;
    var range = this.max - this.min;
    if (range <= 0) return;
    var shrink;
    if (this.resistMode === "exp") {
      shrink = range * this.resist;
    } else {
      shrink = (this.max0 - this.min0) * this.resist;
    }
    this.min += shrink;
    this.max -= shrink;
    if (this.min > this.max) {
      var c = (this.min + this.max) * 0.5;
      this.min = this.max = c;
    }
  };

  // ---- UPDATE ----
  this.UPDATE = function (delta) {
    var s = this.step;
    if (this.useDelta && delta !== undefined) {
      s = s * delta;
    }
    // ---------- REGIMES ----------
    switch (this.regime) {
      // ===== PING-PONG =====
      case "pingpong":
        if (this.status === 0) {
          this.value_ += s;
          if (this.value_ >= this.max) {
            this.value_ = this.max;
            this.status = 1;
            ROOT.on_maximum_value();
          }
        } else {
          this.value_ -= s;
          if (this.value_ <= this.min) {
            this.value_ = this.min;
            this.status = 0;
            this._applyResist();
            ROOT.on_minimum_value();
          }
        }
        break;

      // ===== ONLY MIN → MAX =====
      case "onlyFromMinToMax":
        this.value_ += s;
        if (this.value_ >= this.max) {
          this.value_ = this.min;
          this._applyResist();
          ROOT.on_maximum_value();
        }
        break;

      // ===== MAX → MIN =====
      case "fromMaxToMin":
        this.value_ -= s;
        if (this.value_ <= this.min) {
          this.value_ = this.max;
          this._applyResist();
          ROOT.on_minimum_value();
        }
        break;

      // ===== ONE SHOT =====
      case "oneShot":
        this.value_ += s;
        if (this.value_ >= this.max) {
          this.value_ = this.max;
          ROOT.on_stop();
        }
        break;

      // ===== SPRING TO CENTER =====
      case "springCenter":
        var center = (this.min + this.max) * 0.5;
        var force = (center - this.value_) * this.resist;
        this.value_ += force + s;
        if (Math.abs(center - this.value_) < this.stopEpsilon) {
          this.value_ = center;
          ROOT.on_stop();
        }
        break;
    }

    // ---- AUTO STOP ----
    if (this.stopEpsilon > 0) {
      if (this.max - this.min < this.stopEpsilon) {
        ROOT.on_stop();
      }
    }
    return this.value_;
  };
}

// this is class not func ecma5
function SWITCHER() {
  var ROOT = this;
  ROOT.VALUE = 1;
  ROOT.GET = function () {
    ROOT.VALUE = ROOT.VALUE * -1;
    return ROOT.VALUE;
  };
}
function ORBIT(cx, cy, angle, p) {
  var s = Math.sin(angle);
  var c = Math.cos(angle);
  p.x -= cx;
  p.y -= cy;
  var xnew = p.x * c - p.y * s;
  var ynew = p.x * s + p.y * c;
  p.x = xnew + cx;
  p.y = ynew + cy;
  return p;
}
function ORBIT_FROM_ARRAY(cx, cy, angle, p, byIndexs) {
  var s = Math.sin(angle);
  var c = Math.cos(angle);
  p[byIndexs[0]] -= cx;
  p[byIndexs[1]] -= cy;
  var xnew = p[byIndexs[0]] * c - p[byIndexs[1]] * s;
  var ynew = p[byIndexs[0]] * s + p[byIndexs[1]] * c;
  p[byIndexs[0]] = xnew + cx;
  p[byIndexs[1]] = ynew + cy;
  return p;
}
var byId = function (id) {
  return document.getElementById(id);
};
exports.byId = byId;
function randomFloatFromTo(min, max) {
  return Math.random() * (max - min) + min;
}
function randomIntFromTo(min, max) {
  if (typeof min === 'object' || typeof max === 'object') {
    console.log("SYS : warning Desciption : Replace object with string , this >> " + typeof min + ' and ' + typeof min + ' << must be string or number.');
  } else if (typeof min === 'undefined' || typeof max === 'undefined') {
    console.log("SYS : warning Desciption : arguments (min, max) cant be undefined , this >> " + typeof min + ' and ' + typeof min + ' << must be string or number.');
  } else {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
}
var urlQuery = exports.urlQuery = function () {
  var query_string = {};
  var query = window.location.search.substring(1);
  var vars = query.split('&');
  for (var i = 0; i < vars.length; i++) {
    var pair = vars[i].split('=');
    if (typeof query_string[pair[0]] === 'undefined') {
      query_string[pair[0]] = decodeURIComponent(pair[1]);
    } else if (typeof query_string[pair[0]] === 'string') {
      var arr = [query_string[pair[0]], decodeURIComponent(pair[1])];
      query_string[pair[0]] = arr;
    } else {
      query_string[pair[0]].push(decodeURIComponent(pair[1]));
    }
  }
  return query_string;
}();
function getAxisRot(q1) {
  var x, y, z;

  // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
  if (q1.w > 1) q1.normalise();
  var angle = 2 * Math.acos(q1.w);
  // assuming quaternion normalised then w is less than 1, so term always positive.
  var s = Math.sqrt(1 - q1.w * q1.w);
  // test to avoid divide by zero, s is always positive due to sqrt
  if (s < 0.001) {
    // if s close to zero then direction of axis not important
    // if it is important that axis is normalised then replace with x=1; y=z=0;

    x = q1.x;
    y = q1.y;
    z = q1.z;
  } else {
    x = q1.x / s; // normalise axis
    y = q1.y / s;
    z = q1.z / s;
  }
  return [radToDeg(x), radToDeg(y), radToDeg(z)];
}
function getAxisRot2(targetAxis, Q) {
  Q.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
  var angle = 2 * Math.acos(Q.w());
  var s = Math.sqrt(1 - Q.w() * Q.w()); // assuming quaternion normalised then w is less than 1, so term always positive.
  if (s < 0.001) {
    // test to avoid divide by zero, s is always positive due to sqrt
    // if s close to zero then direction of axis not important
    // if it is important that axis is normalised then replace with x=1; y=z=0;
    // targetAxis.x = 1;
    // targetAxis.y = 0;
    // targetAxis.z = 0;
    targetAxis.x = Q.x();
    targetAxis.y = Q.y();
    targetAxis.z = Q.z();
  } else {
    targetAxis.x = Q.x() / s; // normalise axis
    targetAxis.y = Q.y() / s;
    targetAxis.z = Q.z() / s;
  }
  return [targetAxis, angle];
}
function getAxisRot3(Q) {
  var angle = Math.acos(Q.w) * 2;
  var axis = {};
  if (Math.sin(Math.acos(angle)) > 0) {
    axis.x = Q.x / Math.sin(Math.acos(angle / 2));
    axis.y = Q.y / Math.sin(Math.acos(angle / 2));
    axis.z = Q.z / Math.sin(Math.acos(angle / 2));
  } else {
    axis.x = 0;
    axis.y = 0;
    axis.z = 0;
  }
  return axis;
}

// NTO TESTED
function quaternion_rotation_matrix(Q) {
  // Covert a quaternion into a full three-dimensional rotation matrix.

  // Input
  // :param Q: A 4 element array representing the quaternion (q0,q1,q2,q3) 

  // Output
  // :return: A 3x3 element matrix representing the full 3D rotation matrix. 
  //          This rotation matrix converts a point in the local reference 
  //          frame to a point in the global reference frame.
  // """
  // # Extract the values from Q
  var q0 = Q[0];
  var q1 = Q[1];
  var q2 = Q[2];
  var q3 = Q[3];

  // # First row of the rotation matrix
  var r00 = 2 * (q0 * q0 + q1 * q1) - 1;
  var r01 = 2 * (q1 * q2 - q0 * q3);
  var r02 = 2 * (q1 * q3 + q0 * q2);

  // # Second row of the rotation matrix
  var r10 = 2 * (q1 * q2 + q0 * q3);
  var r11 = 2 * (q0 * q0 + q2 * q2) - 1;
  var r12 = 2 * (q2 * q3 - q0 * q1);

  // # Third row of the rotation matrix
  var r20 = 2 * (q1 * q3 - q0 * q2);
  var r21 = 2 * (q2 * q3 + q0 * q1);
  var r22 = 2 * (q0 * q0 + q3 * q3) - 1;

  // # 3x3 rotation matrix
  var rot_matrix = [[r00, r01, r02], [r10, r11, r12], [r20, r21, r22]];
  return rot_matrix;
}

// copnsole log graphics
const LOG_WARN = exports.LOG_WARN = 'background: gray; color: yellow; font-size:10px';
const LOG_INFO = exports.LOG_INFO = 'background: green; color: white; font-size:11px';
const LOG_MATRIX = exports.LOG_MATRIX = "font-family: stormfaze;color: #lime; font-size:11px;text-shadow: 2px 2px 4px orangered;background: black;";
const LOG_FUNNY = exports.LOG_FUNNY = "font-family: stormfaze;color: #f1f033; font-size:18px;text-shadow: 2px 2px 4px #f335f4, 4px 4px 4px #d64444, 2px 2px 4px #c160a6, 6px 2px 0px #123de3;background: black;";
const LOG_FUNNY_SMALL = exports.LOG_FUNNY_SMALL = "font-family: stormfaze;color: #f1f033; font-size:10px;text-shadow: 2px 2px 4px #f335f4, 4px 4px 4px #d64444, 1px 1px 2px #c160a6, 3px 1px 0px #123de3;background: black;";
const LOG_FUNNY_BIG_TERMINAL = exports.LOG_FUNNY_BIG_TERMINAL = "font-family: monospace; font-size:15px; font-weight:bold;" + "color:#33ff33;" + "text-shadow: 2px 2px 0 #003300;" + "background:#000; padding:10px 14px;";
const LOG_FUNNY_ARCADE = exports.LOG_FUNNY_ARCADE = "font-family: system-ui; font-size:16px; font-weight:400;" + "color:#ffffff;" + "text-shadow: 2px 2px 6px #000;" + "background:linear-gradient(90deg,#111,#222); padding:12px 18px;";
const LOG_FUNNY_BIG_ARCADE = exports.LOG_FUNNY_BIG_ARCADE = "font-family: system-ui; font-size:24px; font-weight:600;" + "color:#ffffff;" + "text-shadow: 2px 2px 6px #000;" + "background:linear-gradient(90deg,#111,#222); padding:12px 18px;";
const LOG_FUNNY_BIG_NEON = exports.LOG_FUNNY_BIG_NEON = "font-family: stormfaze; font-size:30px; font-weight:900;" + "color:#00ffff;" + "text-shadow: 0 0 5px #01d6d6ff, 0 0 10px #00ffff, 4px 4px 0 #ff00ff;" + "background:black; padding:14px 18px;";
const LOG_FUNNY_EXTRABIG = exports.LOG_FUNNY_EXTRABIG = "font-family: stormfaze; font-size:230px; font-weight:900;" + "color:#00ffff;" + "text-shadow: 0 0 5px #01d6d6ff, 0 0 10px #00ffff, 4px 4px 0 #ff00ff;" + "background:black; padding:14px 18px;";
const LOGO_FRAMES = exports.LOGO_FRAMES = [` M                 `, ` MA                 `, ` MAT                `, ` MATR               `, ` MATRI              `, ` MATRIX             `, ` MATRIX-E           `, ` MATRIX-ENG         `, ` MATRIX-ENGI        `, ` MATRIX-ENGIN       `, ` MATRIX-ENGINE      `, ` MATRIX-ENGINE-     `, ` MATRIX-ENGINE-W    `, ` MATRIX-ENGINE-WG   `, ` MATRIX-ENGINE-WGPU `];
function genName(length) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}
let mb = exports.mb = {
  root: () => byId('msgBox'),
  pContent: () => byId('not-content'),
  copy: function () {
    navigator.clipboard.writeText(mb.root().children[0].innerText);
  },
  c: 0,
  ic: 0,
  t: {},
  setContent: function (content, t) {
    var iMsg = document.createElement('div');
    iMsg.innerHTML = content;
    iMsg.id = `msgbox-loc-${mb.c}`;
    mb.root().appendChild(iMsg);
    iMsg.classList.add('animate1');
    if (t == 'ok') {
      iMsg.style = 'font-family: stormfaze;color:white;padding:7px;margin:2px';
    } else {
      iMsg.style = 'font-family: stormfaze;color:white;padding:7px;margin:2px';
    }
  },
  kill: function () {
    mb.root().remove();
  },
  show: function (content, t) {
    mb.setContent(content, t);
    mb.root().style.display = "block";
    var loc2 = mb.c;
    setTimeout(function () {
      byId(`msgbox-loc-${loc2}`).classList.remove("fadeInDown");
      byId(`msgbox-loc-${loc2}`).classList.add("fadeOut");
      setTimeout(function () {
        byId(`msgbox-loc-${loc2}`).style.display = "none";
        byId(`msgbox-loc-${loc2}`).classList.remove("fadeOut");
        byId(`msgbox-loc-${loc2}`).remove();
        mb.ic++;
        if (mb.c == mb.ic) {
          mb.root().style.display = 'none';
        }
      }, 1000);
    }, 3000);
    mb.c++;
  },
  error: function (content) {
    if (mb.root() == null) return;
    mb.root().classList.remove("success");
    mb.root().classList.add("error");
    mb.root().classList.add("fadeInDown");
    mb.show(content, 'err');
  },
  success: function (content) {
    if (mb.root() == null) return;
    mb.root().classList.remove("error");
    mb.root().classList.add("success");
    mb.root().classList.add("fadeInDown");
    mb.show(content, 'ok');
  }
};

// Registry to track running animations per element
const typingStates = new Map();
function typeText(elementId, htmlString, delay = 50) {
  const el = document.getElementById(elementId);
  if (!el) return;

  // If an existing typing is running for this element, cancel it
  if (typingStates.has(elementId)) {
    clearTimeout(typingStates.get(elementId).timeoutId);
    typingStates.delete(elementId);
  }
  el.innerHTML = ''; // Clear previous content

  const tempEl = document.createElement('div');
  tempEl.innerHTML = htmlString;
  const queue = [];
  function flatten(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      queue.push({
        type: 'text',
        text: node.textContent
      });
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      if (node.tagName.toLowerCase() === 'img') {
        queue.push({
          type: 'img',
          src: node.getAttribute('src'),
          alt: node.getAttribute('alt') || ''
        });
      } else {
        queue.push({
          type: 'element',
          tag: node.tagName.toLowerCase(),
          attributes: Object.fromEntries([...node.attributes].map(attr => [attr.name, attr.value]))
        });
        for (const child of node.childNodes) flatten(child);
        queue.push({
          type: 'end'
        });
      }
    }
  }
  for (const node of tempEl.childNodes) flatten(node);
  let stack = [];
  let currentElement = el;
  function typeNextChar() {
    if (queue.length === 0) {
      typingStates.delete(elementId); // Cleanup after finish
      return;
    }
    const item = queue[0];
    if (item.type === 'text') {
      if (!item.index) item.index = 0;
      const ch = item.text[item.index];
      if (ch === '\n') {
        currentElement.appendChild(document.createElement('br'));
      } else {
        currentElement.appendChild(document.createTextNode(ch));
      }
      item.index++;
      if (item.index >= item.text.length) queue.shift();
    } else if (item.type === 'element') {
      const newEl = document.createElement(item.tag);
      if (item.attributes) {
        for (let [key, val] of Object.entries(item.attributes)) {
          newEl.setAttribute(key, val);
        }
      }
      currentElement.appendChild(newEl);
      stack.push(currentElement);
      currentElement = newEl;
      queue.shift();
    } else if (item.type === 'end') {
      currentElement = stack.pop();
      queue.shift();
    } else if (item.type === 'img') {
      const img = document.createElement('img');
      img.src = item.src;
      img.alt = item.alt;
      img.style.maxWidth = '100px';
      img.style.verticalAlign = 'middle';
      currentElement.appendChild(img);
      queue.shift();
    }

    // Schedule next step and store timeoutId for control
    const timeoutId = setTimeout(typeNextChar, delay);
    typingStates.set(elementId, {
      timeoutId
    });
  }
  typeNextChar();
}
function setupCanvasFilters(canvasId) {
  let canvas = document.getElementById(canvasId);
  if (canvas == null) {
    canvas = document.getElementsByTagName('canvas')[0];
  }
  const filterState = {
    blur: "0px",
    grayscale: "0%",
    brightness: "100%",
    contrast: "100%",
    saturate: "100%",
    sepia: "0%",
    invert: "0%",
    hueRotate: "0deg"
  };
  function updateFilter() {
    const filterString = `
      blur(${filterState.blur}) 
      grayscale(${filterState.grayscale}) 
      brightness(${filterState.brightness}) 
      contrast(${filterState.contrast}) 
      saturate(${filterState.saturate}) 
      sepia(${filterState.sepia}) 
      invert(${filterState.invert}) 
      hue-rotate(${filterState.hueRotate})
    `.trim();
    canvas.style.filter = filterString;
  }
  const bindings = {
    blurControl: "blur",
    grayscaleControl: "grayscale",
    brightnessControl: "brightness",
    contrastControl: "contrast",
    saturateControl: "saturate",
    sepiaControl: "sepia",
    invertControl: "invert",
    hueControl: "hueRotate"
  };
  Object.entries(bindings).forEach(([selectId, key]) => {
    const el = document.getElementById(selectId);
    el.addEventListener("change", e => {
      filterState[key] = e.target.value;
      updateFilter();
    });
  });
  updateFilter(); // Initial
}

/**
 * @description
 * // Save an object
    Storage.set('playerData', { name: 'Slayzer', hp: 120, mana: 80 });

    // Load it back
    const player = Storage.get('playerData');
    console.log(player.name); // "Slayzer"

    // Check if exists
    if (Storage.has('playerData')) console.log('Found!');

    // Remove one
    Storage.remove('playerData');

    // Clear all localStorage
    Storage.clear();
 */
const LS = exports.LS = {
  set(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
  },
  get(key, defaultValue = null) {
    const item = localStorage.getItem(key);
    try {
      return item ? JSON.parse(item) : defaultValue;
    } catch (e) {
      console.warn(`Error parsing localStorage key "${key}"`, e);
      return defaultValue;
    }
  },
  has(key) {
    return localStorage.getItem(key) !== null;
  },
  remove(key) {
    localStorage.removeItem(key);
  },
  clear() {
    localStorage.clear();
  }
};
const SS = exports.SS = {
  set(key, value) {
    sessionStorage.setItem(key, JSON.stringify(value));
  },
  get(key, defaultValue = null) {
    const item = sessionStorage.getItem(key);
    try {
      return item ? JSON.parse(item) : defaultValue;
    } catch (e) {
      console.warn(`Error parsing sessionStorage key "${key}"`, e);
      return defaultValue;
    }
  },
  has(key) {
    return sessionStorage.getItem(key) !== null;
  },
  remove(key) {
    sessionStorage.removeItem(key);
  },
  clear() {
    sessionStorage.clear();
  }
};
const jsonHeaders = exports.jsonHeaders = new Headers({
  "Content-Type": "application/json",
  "Accept": "application/json"
});
const htmlHeader = exports.htmlHeader = new Headers({
  "Content-Type": "text/html",
  "Accept": "text/plain"
});
function isEven(n) {
  return n % 2 === 0;
}
function isOdd(n) {
  return n % 2 !== 0;
}
class FullscreenManagerElement {
  constructor(targetElement = document.documentElement) {
    this.target = targetElement;
  }
  isFullscreen() {
    return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
  }
  request() {
    const el = this.target;
    return el.requestFullscreen?.() || el.webkitRequestFullscreen?.() || el.mozRequestFullScreen?.() || el.msRequestFullscreen?.();
  }
  exit() {
    return document.exitFullscreen?.() || document.webkitExitFullscreen?.() || document.mozCancelFullScreen?.() || document.msExitFullscreen?.();
  }
  toggle() {
    if (this.isFullscreen()) return this.exit();
    return this.request();
  }
  onChange(callback) {
    ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"].forEach(evt => document.addEventListener(evt, () => {
      callback(this.isFullscreen(), this.target);
    }));
  }
}
exports.FullscreenManagerElement = FullscreenManagerElement;
class FullscreenManager {
  constructor() {
    this.target = document.documentElement; // fullscreen whole page / window
  }
  isFullscreen() {
    return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
  }
  request() {
    const el = this.target;
    return el.requestFullscreen?.() || el.webkitRequestFullscreen?.() || el.mozRequestFullScreen?.() || el.msRequestFullscreen?.();
  }
  exit() {
    return document.exitFullscreen?.() || document.webkitExitFullscreen?.() || document.mozCancelFullScreen?.() || document.msExitFullscreen?.();
  }
  toggle() {
    return this.isFullscreen() ? this.exit() : this.request();
  }
  onChange(callback) {
    ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"].forEach(evt => document.addEventListener(evt, () => {
      callback(this.isFullscreen());
    }));
  }
}
exports.FullscreenManager = FullscreenManager;
function alignTo256(n) {
  return Math.ceil(n / 256) * 256;
}

// export let ADDITIVE_BLEND_CONFIGURATIONS = {
//   color: {
//                 srcFactor: 'src-alpha', // This makes intensity scale correctly
//                 dstFactor: 'one',       // This is the "Additive" part
//                 operation: 'add',
//               },
//               alpha: {
//                 srcFactor: 'zero',
//                 dstFactor: 'one',
//                 operation: 'add',
//               },
//               color: {
//                 // Result = (ShaderColor * ShaderAlpha) + (DestColor * 1)
//                 operation: 'add',
//                 srcFactor: 'src-alpha',
//                 dstFactor: 'one',
//               },
//               alpha: {
//                 // Keeps the background alpha as is
//                 operation: 'add',
//                 srcFactor: 'zero',
//                 dstFactor: 'one',
//               }
//               color: {
//                 operation: 'add',
//                 srcFactor: 'one',
//                 dstFactor: 'one-minus-src-alpha',
//               },
//               alpha: {
//                 operation: 'add',
//                 srcFactor: 'one',
//                 dstFactor: 'one-minus-src-alpha',
//               }
//               color: {
//                 operation: 'add',
//                 srcFactor: 'one-minus-dst-color',
//                 dstFactor: 'one',
//               },
//               alpha: {
//                 operation: 'add',
//                 srcFactor: 'zero',
//                 dstFactor: 'one',
//               }
//               color: {
//                 operation: 'max', // Take whichever is brighter
//                 srcFactor: 'one',
//                 dstFactor: 'one',
//               },
//               alpha: {
//                 operation: 'max',
//                 srcFactor: 'one',
//                 dstFactor: 'one',
//               }
// }

},{}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MultiLang = void 0;
var _enBackup = require("../../public/res/multilang/en-backup");
var _utils = require("../engine/utils");
class MultiLang {
  constructor() {
    addEventListener('updateLang', () => {
      console.log('Multilang updated.');
      this.update();
    });
  }
  update = function () {
    var allTranDoms = document.querySelectorAll('[data-label]');
    allTranDoms.forEach(i => {
      i.innerHTML = this.get[i.getAttribute('data-label')];
    });
  };
  loadMultilang = async function (lang = 'en') {
    if (lang == 'rs') lang = 'sr'; // exc
    lang = 'res/multilang/' + lang + '.json';
    console.info(`%cMultilang: ${lang}`, _utils.LOG_FUNNY_ARCADE);
    try {
      const r = await fetch(lang, {
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      });
      return await r.json();
    } catch (err) {
      console.warn('Not possible to access multilang json asset! Err => ', err, '. Use backup lang predefinited object. Only english avaible.');
      return _enBackup.en;
    }
  };
}
exports.MultiLang = MultiLang;

},{"../../public/res/multilang/en-backup":23,"../engine/utils":56}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = require("../engine/utils");
class MatrixAmmo {
  constructor(options = {
    roundDimension: 100,
    gravity: 10
  }) {
    // THIS PATH IS PATH FROM PUBLIC FINAL FOLDER
    this.options = options;
    // scriptManager.LOAD("https://maximumroulette.com/apps/megpu/ammo.js", "ammojs",
    _utils.scriptManager.LOAD("ammojs/ammo.js", "ammojs", undefined, undefined, this.init);
    this.lastRoll = '';
    this.presentScore = '';
    this.speedUpSimulation = 1;
  }
  init = () => {
    Ammo().then(Ammo => {
      // Physics variables
      this.dynamicsWorld = null;
      this.rigidBodies = [];
      this.Ammo = Ammo;
      this.lastUpdate = 0;
      console.log("%c Ammo core loaded.", _utils.LOG_FUNNY_ARCADE);
      this.initPhysics();
      // simulate async
      setTimeout(() => {
        dispatchEvent(new CustomEvent('AmmoReady', {}));
      }, 200);
    });
  };
  initPhysics() {
    let Ammo = this.Ammo;
    // Physics configuration
    var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration(),
      dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration),
      overlappingPairCache = new Ammo.btDbvtBroadphase(),
      solver = new Ammo.btSequentialImpulseConstraintSolver();
    this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
    this.dynamicsWorld.setGravity(new Ammo.btVector3(0, -10, 0));
    var groundShape = new Ammo.btBoxShape(new Ammo.btVector3(this.options.roundDimension, 1, this.options.roundDimension)),
      groundTransform = new Ammo.btTransform();
    groundTransform.setIdentity();
    groundTransform.setOrigin(new Ammo.btVector3(0, -4.45, 0));
    var mass = 0,
      isDynamic = mass !== 0,
      localInertia = new Ammo.btVector3(0, 0, 0);
    if (isDynamic) groundShape.calculateLocalInertia(mass, localInertia);
    var myMotionState = new Ammo.btDefaultMotionState(groundTransform),
      rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, myMotionState, groundShape, localInertia),
      body = new Ammo.btRigidBody(rbInfo);
    body.name = 'ground';
    this.ground = body;
    this.dynamicsWorld.addRigidBody(body);
    this.detectCollision();
  }
  addPhysics(MEObject, pOptions) {
    if (pOptions.geometry == "Sphere") {
      this.addPhysicsSphere(MEObject, pOptions);
    } else if (pOptions.geometry == "Cube") {
      this.addPhysicsBox(MEObject, pOptions);
    }
  }
  addPhysicsSphere(MEObject, pOptions) {
    const FLAGS = {
      TEST_NIDZA: 3,
      CF_KINEMATIC_OBJECT: 2
    };
    let Ammo = this.Ammo;
    var colShape = new Ammo.btSphereShape(Array.isArray(pOptions.radius) ? pOptions.radius[0] : pOptions.radius),
      startTransform = new Ammo.btTransform();
    startTransform.setIdentity();
    var mass = 1;
    var localInertia = new Ammo.btVector3(0, 0, 0);
    colShape.calculateLocalInertia(mass, localInertia);
    startTransform.setOrigin(new Ammo.btVector3(pOptions.position.x, pOptions.position.y, pOptions.position.z));
    var myMotionState = new Ammo.btDefaultMotionState(startTransform),
      rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia),
      body = new Ammo.btRigidBody(rbInfo);
    if (pOptions.mass == 0 && typeof pOptions.state == 'undefined' && typeof pOptions.collide == 'undefined') {
      body.setActivationState(2);
      body.setCollisionFlags(FLAGS.CF_KINEMATIC_OBJECT);
      // console.log('what is pOptions.mass and state is 2 ....', pOptions.mass)
    } else if (typeof pOptions.collide != 'undefined' && pOptions.collide == false) {
      // idea not work for now - eliminate collide effect
      body.setActivationState(4);
      body.setCollisionFlags(FLAGS.TEST_NIDZA);
    } else {
      body.setActivationState(4);
    }
    body.name = pOptions.name;
    MEObject.itIsPhysicsBody = true;
    body.MEObject = MEObject;
    this.dynamicsWorld.addRigidBody(body);
    this.rigidBodies.push(body);
    return body;
  }
  addPhysicsBox(MEObject, pOptions) {
    const FLAGS = {
      TEST_NIDZA: 3,
      CF_KINEMATIC_OBJECT: 2
    };
    let Ammo = this.Ammo;
    // improve this - scale by comp
    var colShape = new Ammo.btBoxShape(new Ammo.btVector3(pOptions.scale[0], pOptions.scale[1], pOptions.scale[2])),
      startTransform = new Ammo.btTransform();
    startTransform.setIdentity();
    var mass = pOptions.mass;
    var localInertia = new Ammo.btVector3(0, 0, 0);
    colShape.calculateLocalInertia(mass, localInertia);
    startTransform.setOrigin(new Ammo.btVector3(pOptions.position.x, pOptions.position.y, pOptions.position.z));
    // console.log('startTransform.setRotation', startTransform.setRotation)
    var t = startTransform.getRotation();
    t.setX((0, _utils.degToRad)(pOptions.rotation.x));
    t.setY((0, _utils.degToRad)(pOptions.rotation.y));
    t.setZ((0, _utils.degToRad)(pOptions.rotation.z));
    startTransform.setRotation(t);
    var myMotionState = new Ammo.btDefaultMotionState(startTransform),
      rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia),
      body = new Ammo.btRigidBody(rbInfo);
    if (pOptions.mass == 0 && typeof pOptions.state == 'undefined' && typeof pOptions.collide == 'undefined') {
      body.setActivationState(2);
      body.setCollisionFlags(FLAGS.CF_KINEMATIC_OBJECT);
      // console.log('what is pOptions.mass and state is 2 ....', pOptions.mass)
    } else if (typeof pOptions.collide != 'undefined' && pOptions.collide == false) {
      // idea not work for now - eliminate collide effect
      body.setActivationState(4);
      body.setCollisionFlags(FLAGS.TEST_NIDZA);
    } else {
      body.setActivationState(4);
    }
    body.name = pOptions.name;
    MEObject.itIsPhysicsBody = true;
    body.MEObject = MEObject;
    this.dynamicsWorld.addRigidBody(body);
    this.rigidBodies.push(body);
    return body;
  }
  setBodyVelocity = (body, x, y, z) => {
    var tbv30 = new Ammo.btVector3();
    tbv30.setValue(x, y, z);
    body.setLinearVelocity(tbv30);
  };
  setKinematicTransform = (body, x, y, z, rx, ry, rz) => {
    if (typeof rx == 'undefined') {
      var rx = 0;
    }
    if (typeof ry == 'undefined') {
      var ry = 0;
    }
    if (typeof rz == 'undefined') {
      var rz = 0;
    }
    let pos = new Ammo.btVector3();
    // let quat = new Ammo.btQuaternion();
    pos = body.getWorldTransform().getOrigin();
    let localRot = body.getWorldTransform().getRotation();
    // console.log('pre pos x:', pos.x(), " y : ", pos.y(), " z:", pos.z())
    pos.setX(pos.x() + x);
    pos.setY(pos.y() + y);
    pos.setZ(pos.z() + z);
    localRot.setX(rx);
    localRot.setY(ry);
    localRot.setZ(rz);
    let physicsBody = body;
    let ms = physicsBody.getMotionState();
    if (ms) {
      var tmpTrans = new Ammo.btTransform();
      tmpTrans.setIdentity();
      tmpTrans.setOrigin(pos);
      tmpTrans.setRotation(localRot);
      ms.setWorldTransform(tmpTrans);
    }
  };
  getBodyByName = name => {
    var b = null;
    this.rigidBodies.forEach((item, index, array) => {
      if (item.name == name) {
        b = array[index];
      }
    });
    return b;
  };
  getNameByBody = body => {
    var b = null;
    this.rigidBodies.forEach((item, index, array) => {
      if (item.kB == body.kB) {
        b = array[index].name;
      }
    });
    return b;
  };
  deactivatePhysics = body => {
    const CF_KINEMATIC_OBJECT = 2;
    const DISABLE_DEACTIVATION = 4;
    // 1. Remove from world
    this.dynamicsWorld.removeRigidBody(body);
    // 2. Set body to kinematic
    const flags = body.getCollisionFlags();
    body.setCollisionFlags(flags | CF_KINEMATIC_OBJECT);
    body.setActivationState(DISABLE_DEACTIVATION); // no auto-wakeup
    // 3. Clear motion
    const zero = new Ammo.btVector3(0, 0, 0);
    body.setLinearVelocity(zero);
    body.setAngularVelocity(zero);
    // 4. Reset transform to current position (optional — preserves pose)
    const currentTransform = body.getWorldTransform();
    body.setWorldTransform(currentTransform);
    body.getMotionState().setWorldTransform(currentTransform);
    // 5. Add back to physics world
    this.matrixAmmo.dynamicsWorld.addRigidBody(body);
    // 6. Mark it manually (logic flag)
    body.isKinematic = true;
  };
  detectCollision() {
    // console.log('override this')
    return;
    this.lastRoll = '';
    this.presentScore = '';
    let dispatcher = this.dynamicsWorld.getDispatcher();
    let numManifolds = dispatcher.getNumManifolds();
    for (let i = 0; i < numManifolds; i++) {
      let contactManifold = dispatcher.getManifoldByIndexInternal(i);
      // let numContacts = contactManifold.getNumContacts();
      // this.rigidBodies.forEach((item) => {
      //   if(item.kB == contactManifold.getBody0().kB) {
      //     // console.log('Detected body0 =', item.name)
      //   }
      if (this.ground.kB == contactManifold.getBody0().kB && this.getNameByBody(contactManifold.getBody1()) == 'CubePhysics1') {
        // console.log(this.ground ,'GROUND IS IN CONTACT WHO IS BODY1 ', contactManifold.getBody1())
        // console.log('GROUND IS IN CONTACT WHO IS BODY1 getNameByBody  ', this.getNameByBody(contactManifold.getBody1()))
        // CHECK ROTATION
        var testR = contactManifold.getBody1().getWorldTransform().getRotation();
        console.log('this.lastRoll = ', this.lastRoll, ' presentScore = ', this.presentScore);
      }
    }
  }
  updatePhysics() {
    if (typeof Ammo === 'undefined') return;
    const trans = new Ammo.btTransform();
    const transform = new Ammo.btTransform();
    this.rigidBodies.forEach(function (body) {
      if (body.isKinematic) {
        transform.setIdentity();
        transform.setOrigin(new Ammo.btVector3(body.MEObject.position.x, body.MEObject.position.y, body.MEObject.position.z));
        const quat = new Ammo.btQuaternion();
        quat.setRotation(new Ammo.btVector3(body.MEObject.rotation.axis.x, body.MEObject.rotation.axis.y, body.MEObject.rotation.axis.z), (0, _utils.degToRad)(body.MEObject.rotation.angle));
        transform.setRotation(quat);
        body.setWorldTransform(transform);
        const ms = body.getMotionState();
        if (ms) ms.setWorldTransform(transform);
      }
    });
    Ammo.destroy(transform);

    // Step simulation AFTER setting kinematic transforms
    const timeStep = 1 / 60;
    const maxSubSteps = 10;
    for (let i = 0; i < this.speedUpSimulation; i++) {
      this.dynamicsWorld.stepSimulation(timeStep, maxSubSteps);
    }
    this.rigidBodies.forEach(function (body) {
      if (!body.isKinematic && body.getMotionState()) {
        body.getMotionState().getWorldTransform(trans);
        const _x = +trans.getOrigin().x().toFixed(2);
        const _y = +trans.getOrigin().y().toFixed(2);
        const _z = +trans.getOrigin().z().toFixed(2);
        body.MEObject.position.setPosition(_x, _y, _z);
        const rot = trans.getRotation();
        const rotAxis = rot.getAxis();
        rot.normalize();
        body.MEObject.rotation.axis.x = rotAxis.x();
        body.MEObject.rotation.axis.y = rotAxis.y();
        body.MEObject.rotation.axis.z = rotAxis.z();
        body.MEObject.rotation.matrixRotation = (0, _utils.quaternion_rotation_matrix)(rot);
        body.MEObject.rotation.angle = (0, _utils.radToDeg)(parseFloat(rot.getAngle().toFixed(2)));
      }
    });
    Ammo.destroy(trans);
    this.detectCollision();
  }
}
exports.default = MatrixAmmo;

},{"../engine/utils":56}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dustShader = void 0;
/**
 * @description
 * Dust/Smoke Particle Shader (WGSL)
 * For Matrix-Engine-WGPU DestructionEffect
 * 
 * Features:
 * - Billboarded quads (always face camera)
 * - Soft particles with smooth fade
 * - GPU instancing for performance
 * - Procedural noise for organic look
 */
const dustShader = exports.dustShader = `

// Uniforms
struct Camera {
  viewProj: mat4x4<f32>,
};

struct Model {
  world: mat4x4<f32>,
  time: f32,
  intensity: f32,
  _padding1: f32,
  _padding2: f32,
};

@group(0) @binding(0) var<uniform> camera: Camera;
@group(0) @binding(1) var<uniform> model: Model;

// Vertex input (shared quad)
struct VertexInput {
  @location(0) position: vec3<f32>,      // Quad corner position
  @location(1) uv: vec2<f32>,            // UV coordinates
};

// Instance input (per-particle data)
struct InstanceInput {
  @location(2) posSize: vec4<f32>,       // xyz = position, w = size
  @location(3) velLife: vec4<f32>,       // xyz = velocity, w = life
  @location(4) color: vec4<f32>,         // rgba = color
};

// Vertex output
struct VertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @location(2) life: f32,
  @location(3) worldPos: vec3<f32>,
};

// Vertex shader - Billboard particles to face camera
@vertex
fn vsMain(
  input: VertexInput,
  instance: InstanceInput,
  @builtin(instance_index) instanceIdx: u32
) -> VertexOutput {
  var output: VertexOutput;
  
  // Get particle world position
  let particleWorldPos = (model.world * vec4<f32>(instance.posSize.xyz, 1.0)).xyz;
  
  // Extract camera right and up vectors from view matrix
  // Since viewProj = projection * view, we need to extract view
  // For billboarding, we'll use a simplified approach:
  // Right = (1, 0, 0) in view space
  // Up = (0, 1, 0) in view space
  
  // Simple billboarding: offset quad corners in screen space
  let size = instance.posSize.w;
  let quadOffset = input.position.xy * size;
  
  // Billboard quad (face camera)
  // Extract camera right and up from inverse view
  let right = normalize(vec3<f32>(camera.viewProj[0][0], camera.viewProj[1][0], camera.viewProj[2][0]));
  let up = normalize(vec3<f32>(camera.viewProj[0][1], camera.viewProj[1][1], camera.viewProj[2][1]));
  
  // Compute final world position
  let worldPos = particleWorldPos + right * quadOffset.x + up * quadOffset.y;
  
  // Project to clip space
  output.position = camera.viewProj * vec4<f32>(worldPos, 1.0);
  output.uv = input.uv;
  output.color = instance.color;
  output.life = instance.velLife.w;
  output.worldPos = worldPos;
  
  return output;
}

// Procedural noise function (for organic particle appearance)
fn hash(p: vec2<f32>) -> f32 {
  var p2 = fract(p * vec2<f32>(123.34, 456.21));
  p2 += dot(p2, p2 + 45.32);
  return fract(p2.x * p2.y);
}

fn noise(p: vec2<f32>) -> f32 {
  let i = floor(p);
  let f = fract(p);
  
  let a = hash(i);
  let b = hash(i + vec2<f32>(1.0, 0.0));
  let c = hash(i + vec2<f32>(0.0, 1.0));
  let d = hash(i + vec2<f32>(1.0, 1.0));
  
  let u = f * f * (3.0 - 2.0 * f);
  
  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

// Fractal Brownian Motion (multi-octave noise)
fn fbm(p: vec2<f32>) -> f32 {
  var value = 0.0;
  var amplitude = 0.5;
  var frequency = 1.0;
  var p2 = p;
  
  for (var i = 0; i < 4; i++) {
    value += amplitude * noise(p2 * frequency);
    frequency *= 2.0;
    amplitude *= 0.5;
  }
  
  return value;
}

// Fragment shader - Soft particle with noise
@fragment
fn fsMain(input: VertexOutput) -> @location(0) vec4<f32> {
  // Distance from center (for radial fade)
  let center = vec2<f32>(0.5, 0.5);
  let dist = length(input.uv - center);
  
  // Radial gradient (soft circular particle)
  var alpha = 1.0 - smoothstep(0.0, 0.5, dist);
  
  // Apply noise for organic look
  let noiseScale = 3.0;
  let noiseUV = input.uv * noiseScale + vec2<f32>(model.time * 0.1);
  let noiseValue = fbm(noiseUV);
  
  // Modulate alpha with noise
  alpha *= noiseValue * 1.5;
  
  // Fade based on particle life
  let lifeFade = clamp(input.life / 0.5, 0.0, 1.0); // Fade in last 0.5s
  alpha *= lifeFade;
  
  // Apply instance color
  var finalColor = input.color;
  finalColor.a *= alpha * model.intensity;
  
  // Discard fully transparent fragments
  if (finalColor.a < 0.01) {
    discard;
  }
  
  return finalColor;
}
`;

},{}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hpBarEffectShaders = void 0;
const hpBarEffectShaders = exports.hpBarEffectShaders = `
struct Camera {
  viewProj : mat4x4f
};
struct Model {
  model : mat4x4f,
  color : vec4f,
  progress : f32,
};

@group(0) @binding(0) var<uniform> camera : Camera;
@group(0) @binding(1) var<uniform> model : Model;

struct VertexOutput {
  @builtin(position) position : vec4f,
  @location(0) uv : vec2f,
};

@vertex
fn vsMain(
  @location(0) position : vec3f,
  @location(1) uv : vec2f
) -> VertexOutput {
  var output : VertexOutput;
  output.position = camera.viewProj * model.model * vec4f(position, 1.0);
  output.uv = uv;
  return output;
}

@fragment
fn fsMain(in : VertexOutput) -> @location(0) vec4f {
  // simple left-to-right fill based on progress
  if (in.uv.x > model.progress) {
    return vec4f(0.1, 0.1, 0.1, 0.3); // empty (transparent gray)
  }
  return model.color; // filled
}
`;

},{}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flameEffectInstance = void 0;
const flameEffectInstance = exports.flameEffectInstance = `
struct Camera {
    viewProj : mat4x4<f32>
};
@group(0) @binding(0) var<uniform> camera : Camera;

// Exact same layout as the working shader, but in a storage array
struct ModelData {
    model     : mat4x4<f32>,
    timeSpeed : vec4<f32>,
    params    : vec4<f32>,
    tint      : vec4<f32>,
};
@group(0) @binding(1) var<storage, read> modelDataArray : array<ModelData>;

struct VSIn {
    @location(0) position : vec3<f32>,
    @location(1) uv : vec2<f32>,
    @builtin(instance_index) instanceIdx : u32,
};

struct VSOut {
    @builtin(position) position : vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) p0 : vec4<f32>,
    @location(2) p1 : vec4<f32>,
    @location(3) tintColor : vec3<f32>,
};

@vertex
fn vsMain(input : VSIn) -> VSOut {
    var output : VSOut;
    let modelData = modelDataArray[input.instanceIdx];

    let worldPos = modelData.model * vec4<f32>(input.position, 1.0);
    output.position = camera.viewProj * worldPos;
    output.uv = input.uv;

    // Pass data to fragment exactly like the working shader
    output.p0 = vec4<f32>(
        modelData.timeSpeed.x, // time
        modelData.timeSpeed.y, // speed
        modelData.params.x,    // intensity
        modelData.params.y     // turbulence
    );
    output.p1 = vec4<f32>(
        modelData.params.z,    // stretch
        modelData.tint.w,      // tintStrength
        0.0, 0.0
    );
    output.tintColor = modelData.tint.xyz;

    return output;
}

fn hash2(n : vec2<f32>) -> f32 {
    return fract(sin(dot(n, vec2<f32>(12.9898, 78.233))) * 43758.5453);
}

fn noise(p : vec2<f32>) -> f32 {
    let i = floor(p); let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f);
    return mix(
        mix(hash2(i + vec2<f32>(0.0, 0.0)), hash2(i + vec2<f32>(1.0, 0.0)), u.x),
        mix(hash2(i + vec2<f32>(0.0, 1.0)), hash2(i + vec2<f32>(1.0, 1.0)), u.x),
        u.y
    );
}

fn fbm(p : vec2<f32>) -> f32 {
    var v = 0.0; var a = 0.5; var pos = p;
    for (var i = 0; i < 2; i = i + 1) {
        v += a * noise(pos);
        pos = pos * 2.1 + vec2<f32>(1.7, 9.2);
        a *= 0.5;
    }
    return v;
}

@fragment
fn fsMain(input : VSOut) -> @location(0) vec4<f32> {
    let time       = input.p0.x;
    let speed      = input.p0.y;
    let intensity  = input.p0.z;
    let turbulence = input.p0.w;
    let stretch    = input.p1.x;
    let tintStr    = input.p1.y;
    let tintColor  = input.tintColor;

    let t = time * speed * 2.0;
    var uv = input.uv;
    uv.y = uv.y / max(stretch, 0.01);

    let warpAmt = turbulence * 0.18;
    let warpX   = noise(uv * 3.0 + vec2<f32>(0.0, t * 0.6)) - 0.5;
    let warpY   = noise(uv * 3.0 + vec2<f32>(5.2, t * 0.4)) - 0.5;
    var warpedUV = uv + vec2<f32>(warpX, warpY) * warpAmt;

    warpedUV.y += t * 0.4;
    warpedUV.x += sin(t * 0.7) * 0.08 * turbulence;

    var n = fbm(warpedUV * 6.0 + vec2<f32>(0.0, t * 0.8));
    n = pow(n, 3.0 - turbulence * 1.2);

    let hotColor  = vec3<f32>(1.0, 0.92, 0.35);
    let midColor  = vec3<f32>(1.0, 0.38, 0.04);
    let coolColor = vec3<f32>(0.55, 0.04, 0.0 );

    let g1 = smoothstep(0.0, 0.5, n);
    let g2 = smoothstep(0.5, 1.0, n);
    var baseColor = mix(mix(coolColor, midColor, g1), hotColor, g2);

    let tintMask = smoothstep(0.0, 0.5, n);
    baseColor = mix(baseColor, baseColor * tintColor * 2.0, tintStr * tintMask);

    let finalColor = baseColor * n * intensity;
    let edgeMask = smoothstep(0.0, 0.15, input.uv.x) * smoothstep(0.0, 0.15, 1.0 - input.uv.x);
    let fadeStart = clamp(0.25 / max(stretch, 0.1), 0.1, 0.6);
    let topFade = 1.0 - smoothstep(fadeStart, 1.0, input.uv.y);

    // let alpha = smoothstep(0.25, 0.9, n) * edgeMask * topFade;
    let alpha = smoothstep(0.01, 0.4, n) * edgeMask * topFade;

    return vec4<f32>(finalColor * alpha, alpha);
}
`;

},{}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flameEffect = void 0;
const flameEffect = exports.flameEffect = /* wgsl */`

struct Camera {
  viewProj : mat4x4<f32>
};
@group(0) @binding(0) var<uniform> camera : Camera;

// Uniform buffer layout (112 bytes, all vec4-aligned):
//   offset   0 : model        mat4x4<f32>   (64 bytes)
//   offset  64 : timeSpeed    vec4<f32>     (.x = time, .y = speed)
//   offset  80 : params       vec4<f32>     (.x = intensity, .y = turbulence, .z = stretch)
//   offset  96 : tint         vec4<f32>     (.xyz = rgb tint colour, .w = tint strength 0..1)
struct ModelData {
  model     : mat4x4<f32>,
  timeSpeed : vec4<f32>,
  params    : vec4<f32>,
  tint      : vec4<f32>,
};
@group(0) @binding(1) var<uniform> modelData : ModelData;

struct VSIn {
  @location(0) position : vec3<f32>,
  @location(1) uv       : vec2<f32>,
};

struct VSOut {
  @builtin(position) position  : vec4<f32>,
  @location(0)       uv        : vec2<f32>,
  // Pack all scalar params into two interpolants to stay within limits
  @location(1)       p0        : vec4<f32>, // .x=time .y=speed .z=intensity .w=turbulence
  @location(2)       p1        : vec4<f32>, // .x=stretch .y=tintStrength
  @location(3)       tintColor : vec3<f32>,
};

@vertex
fn vsMain(input : VSIn) -> VSOut {
  var output : VSOut;

  let worldPos     = modelData.model * vec4<f32>(input.position, 1.0);
  output.position  = camera.viewProj * worldPos;
  output.uv        = input.uv;

  output.p0 = vec4<f32>(
    modelData.timeSpeed.x,  // time
    modelData.timeSpeed.y,  // speed
    modelData.params.x,     // intensity
    modelData.params.y      // turbulence
  );
  output.p1 = vec4<f32>(
    modelData.params.z,     // stretch
    modelData.tint.w,       // tintStrength
    0.0, 0.0
  );
  output.tintColor = modelData.tint.xyz;

  return output;
}

// ---------------------------------------------------------------------------
// Noise helpers
// ---------------------------------------------------------------------------
fn hash2(n : vec2<f32>) -> f32 {
  return fract(sin(dot(n, vec2<f32>(12.9898, 78.233))) * 43758.5453);
}

fn noise(p : vec2<f32>) -> f32 {
  let i = floor(p);
  let f = fract(p);
  let u = f * f * (3.0 - 2.0 * f);
  return mix(
    mix(hash2(i + vec2<f32>(0.0, 0.0)), hash2(i + vec2<f32>(1.0, 0.0)), u.x),
    mix(hash2(i + vec2<f32>(0.0, 1.0)), hash2(i + vec2<f32>(1.0, 1.0)), u.x),
    u.y
  );
}

// Two-octave fBm for richer turbulence shape
fn fbm(p : vec2<f32>) -> f32 {
  var v   = 0.0;
  var a   = 0.5;
  var pos = p;
  for (var i = 0; i < 2; i++) {
    v   += a * noise(pos);
    pos  = pos * 2.1 + vec2<f32>(1.7, 9.2);
    a   *= 0.5;
  }
  return v;
}

// ---------------------------------------------------------------------------
// Fragment
// ---------------------------------------------------------------------------
@fragment
fn fsMain(input : VSOut) -> @location(0) vec4<f32> {
  // Unpack
  let time       = input.p0.x;
  let speed      = input.p0.y;
  let intensity  = input.p0.z;
  let turbulence = input.p0.w;   // 0 = calm, 1 = chaotic
  let stretch    = input.p1.x;   // 1 = normal, >1 = tall/thin, <1 = short/wide
  let tintStr    = input.p1.y;   // 0 = natural fire colours, 1 = full tint
  let tintColor  = input.tintColor;

  let t = time * speed * 2.0;

  // --- UV: apply stretch then turbulence warp ---
  var uv = input.uv;
  // Compress v-range so flame occupies more of the quad when stretch > 1
  uv.y = uv.y / max(stretch, 0.01);

  let warpAmt = turbulence * 0.18;
  let warpX   = noise(uv * 3.0 + vec2<f32>(0.0, t * 0.6)) - 0.5;
  let warpY   = noise(uv * 3.0 + vec2<f32>(5.2, t * 0.4)) - 0.5;
  var warpedUV = uv + vec2<f32>(warpX, warpY) * warpAmt;

  // Upward scroll + sideways sway scaled by turbulence
  warpedUV.y += t * 0.4;
  warpedUV.x += sin(t * 0.7) * 0.08 * turbulence;

  // --- Flame density ---
  var n = fbm(warpedUV * 6.0 + vec2<f32>(0.0, t * 0.8));
  // Higher turbulence softens the exponent → wilder, fluffier edges
  n = pow(n, 3.0 - turbulence * 1.2);

  // --- Base flame palette (dark core → orange → hot yellow) ---
  let hotColor  = vec3<f32>(1.0,  0.92, 0.35);
  let midColor  = vec3<f32>(1.0,  0.38, 0.04);
  let coolColor = vec3<f32>(0.55, 0.04, 0.0 );

  let g1 = smoothstep(0.0, 0.5, n);
  let g2 = smoothstep(0.5, 1.0, n);
  var baseColor = mix(mix(coolColor, midColor, g1), hotColor, g2);

  // --- Tint: blend base palette toward tintColor in the bright parts only ---
  // tintStr = 0 → pure natural fire;  tintStr = 1 → fully tinted flame
  let tintMask  = smoothstep(0.0, 0.5, n);
  baseColor = mix(baseColor, baseColor * tintColor * 2.0, tintStr * tintMask);

  let finalColor = baseColor * n * intensity;

  // --- Alpha mask: soft edges + top fade that respects stretch ---
  let edgeMask  = smoothstep(0.0, 0.15, input.uv.x)
                * smoothstep(0.0, 0.15, 1.0 - input.uv.x);
  let fadeStart = clamp(0.25 / max(stretch, 0.1), 0.1, 0.6);
  let topFade   = 1.0 - smoothstep(fadeStart, 1.0, input.uv.y);

  let alpha = smoothstep(0.08, 0.65, n) * edgeMask * topFade;

  // Premultiplied alpha for additive blending
  return vec4<f32>(finalColor * alpha, alpha);
}
`;

},{}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mirrorIlluminateFragmentWGSL = void 0;
const mirrorIlluminateFragmentWGSL = exports.mirrorIlluminateFragmentWGSL = `
override shadowDepthTextureSize: f32 = 1024.0;
const PI: f32 = 3.141592653589793;

struct Scene {
    lightViewProjMatrix  : mat4x4f,
    cameraViewProjMatrix : mat4x4f,
    cameraPos            : vec3f,
    padding2             : f32,
    lightPos             : vec3f,
    padding              : f32,
    globalAmbient        : vec3f,
    padding3             : f32,
    time                 : f32,
    deltaTime            : f32,
    padding4             : vec2f,
};

struct SpotLight {
    position      : vec3f,
    _pad1         : f32,
    direction     : vec3f,
    _pad2         : f32,
    innerCutoff   : f32,
    outerCutoff   : f32,
    intensity     : f32,
    _pad3         : f32,
    color         : vec3f,
    _pad4         : f32,
    range         : f32,
    ambientFactor : f32,
    shadowBias    : f32,
    _pad5         : f32,
    lightViewProj : mat4x4<f32>,
};

struct MaterialPBR {
    baseColorFactor : vec4f,
    metallicFactor  : f32,
    roughnessFactor : f32,
    _pad1           : f32,
    _pad2           : f32,
};

struct PBRMaterialData {
    baseColor : vec3f,
    metallic  : f32,
    roughness : f32,
    alpha     : f32,
};

struct MirrorIlluminateParams {
    mirrorTint        : vec3f,   // tint applied to the specular/env reflection  (default: 1,1,1)
    reflectivity      : f32,     // 0 = no mirror effect, 1 = full mirror        (default: 0.9)
    illuminateColor   : vec3f,   // colour of the rim/illuminate glow             (default: 0.4, 0.8, 1.0)
    illuminateStrength: f32,     // 0..1 master intensity of illuminate           (default: 1.0)
    illuminatePulse   : f32,     // pulse speed (Hz). 0 = static                  (default: 1.2)
    fresnelPower      : f32,     // Fresnel exponent for rim sharpness            (default: 4.0)
    envLodBias        : f32,     // mip bias for env sample (blur ≈ roughness)    (default: 0.0)
    usePlanarReflection: f32,  // ✅ NEW: 0 = env map, 1 = planar/screen-space
    baseColorMix       : f32,  // ✅ NEW: 0=pure env, 1=normal material mix
    _pad2              : vec3f, // ✅ Padding to maintain alignment
};

const MAX_SPOTLIGHTS = 20u;

@group(0) @binding(0) var<uniform> scene                  : Scene;
@group(0) @binding(1) var          shadowMapArray         : texture_depth_2d_array;
@group(0) @binding(2) var          shadowSampler          : sampler_comparison;
@group(0) @binding(3) var          meshTexture            : texture_2d<f32>;
@group(0) @binding(4) var          meshSampler            : sampler;
@group(0) @binding(5) var<uniform> spotlights             : array<SpotLight, MAX_SPOTLIGHTS>;
@group(0) @binding(6) var          metallicRoughnessTex   : texture_2d<f32>;
@group(0) @binding(7) var          metallicRoughnessSampler : sampler;
@group(0) @binding(8) var<uniform> material               : MaterialPBR;

@group(2) @binding(0) var<uniform> mirrorParams    : MirrorIlluminateParams;
@group(2) @binding(1) var          mirrorEnvTex    : texture_2d<f32>;
@group(2) @binding(2) var          mirrorEnvSampler: sampler;

struct FragmentInput {
    @location(0) shadowPos : vec4f,
    @location(1) fragPos   : vec3f,
    @location(2) fragNorm  : vec3f,
    @location(3) uv        : vec2f,
};

fn getPBRMaterial(uv: vec2f) -> PBRMaterialData {
    let texColor  = textureSample(meshTexture, meshSampler, uv);
    let baseColor = texColor.rgb * material.baseColorFactor.rgb;
    let mrTex     = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);
    let metallic  = mrTex.b * material.metallicFactor;
    let roughness = mrTex.g * material.roughnessFactor;
    let alpha     = material.baseColorFactor.a;
    return PBRMaterialData(baseColor, metallic, roughness, alpha);
}

fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
    let a      = roughness * roughness;
    let a2     = a * a;
    let NdotH  = max(dot(N, H), 0.0);
    let NdotH2 = NdotH * NdotH;
    let denom  = (NdotH2 * (a2 - 1.0) + 1.0);
    return a2 / (PI * denom * denom);
}

fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
    let r = (roughness + 1.0);
    let k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
    let NdotV = max(dot(N, V), 0.0);
    let NdotL = max(dot(N, L), 0.0);
    return geometrySchlickGGX(NdotV, roughness) * geometrySchlickGGX(NdotL, roughness);
}

fn calculateSpotlightFactor(light: SpotLight, fragPos: vec3f) -> f32 {
    let L     = normalize(light.position - fragPos);
    let theta = dot(L, normalize(-light.direction));
    let eps   = light.innerCutoff - light.outerCutoff;
    return clamp((theta - light.outerCutoff) / eps, 0.0, 1.0);
}

fn computeSpotLight(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, mat: PBRMaterialData) -> vec3f {
    let L    = normalize(light.position - fragPos);
    let NdotL = max(dot(N, L), 0.0);
    let theta = dot(L, normalize(-light.direction));
    let eps   = light.innerCutoff - light.outerCutoff;
    var coneAtten = clamp((theta - light.outerCutoff) / eps, 0.0, 1.0);
    if (coneAtten <= 0.0 || NdotL <= 0.0) { return vec3f(0.0); }

    let F0    = mix(vec3f(0.04), mat.baseColor.rgb, vec3f(mat.metallic));
    let H     = normalize(L + V);
    let alpha  = mat.roughness * mat.roughness;
    let alpha2 = alpha * alpha;
    let NdotH  = max(dot(N, H), 0.0);
    let denom  = (NdotH * NdotH * (alpha2 - 1.0) + 1.0);
    let D      = alpha2 / (PI * denom * denom + 1e-5);
    let k      = (alpha + 1.0) * (alpha + 1.0) / 8.0;
    let NdotV  = max(dot(N, V), 0.0);
    let Gv     = NdotV / (NdotV * (1.0 - k) + k);
    let Gl     = NdotL / (NdotL * (1.0 - k) + k);
    let G      = Gv * Gl;
    let F      = F0 + (1.0 - F0) * pow(1.0 - max(dot(H, V), 0.0), 5.0);
    return mat.baseColor * light.color * light.intensity * NdotL * coneAtten;
}

fn sampleShadow(shadowUV: vec2f, layer: i32, depthRef: f32, normal: vec3f, lightDir: vec3f) -> f32 {
    var visibility: f32 = 0.0;
    let biasConstant: f32 = 0.001;
    let slopeBias = max(0.002 * (1.0 - dot(normal, lightDir)), 0.0);
    let bias      = biasConstant + slopeBias;
    let oneOverSize = 1.0 / (shadowDepthTextureSize * 0.5);
    let offsets: array<vec2f, 9> = array<vec2f, 9>(
        vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),
        vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),
        vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0)
    );
    for (var i: u32 = 0u; i < 9u; i++) {
        visibility += textureSampleCompare(
            shadowMapArray, shadowSampler,
            shadowUV + offsets[i] * oneOverSize,
            layer, depthRef - bias
        );
    }
    return visibility / 9.0;
}

// ─── NEW: Mirror Illuminate helpers ──────────────────────────────────────────
fn reflectToEnvUV(R: vec3f, fragPos: vec3f) -> vec2f {
    let dir = normalize(R);
    let phi = atan2(dir.x, dir.z);     // Horizontal angle
    let theta = acos(clamp(dir.y, -1.0, 1.0));  // Vertical angle
    let u = phi / (2.0 * PI) + 0.5;
    let v = theta / PI;
    return vec2f(u, v);
    // let dir = normalize(R);
    // let phi = atan2(-dir.z, dir.x);  // Note the negative
    // let theta = acos(clamp(dir.y, -1.0, 1.0));
    // let u = phi / (2.0 * PI) + 0.5;
    // let v = theta / PI;
    // return vec2f(u, 1.0 - v);  // Try flipping V
}

// Planar mirror UV (screen-space)
fn reflectToPlanarUV(fragPos: vec3f, N: vec3f, V: vec3f) -> vec2f {
    // Project to clip space using camera view-proj
    let clipPos = scene.cameraViewProjMatrix * vec4f(fragPos, 1.0);
    let ndc = clipPos.xy / clipPos.w;
    // Flip Y for texture coordinates
    return vec2f(ndc.x * 0.5 + 0.5, -ndc.y * 0.5 + 0.5);
}

// ✅ UNIFIED: Sample mirror texture (auto-detects mode)
fn sampleMirrorEnv(R: vec3f, fragPos: vec3f, N: vec3f, V: vec3f, roughness: f32) -> vec3f {
    var uv: vec2f;
    if (mirrorParams.usePlanarReflection > 0.5) {
        uv = reflectToPlanarUV(fragPos, N, V);
    } else {
        uv = reflectToEnvUV(R , fragPos);
    }
    return textureSample(mirrorEnvTex, mirrorEnvSampler, uv).rgb;
}

// Animated illuminate rim — pulsing Fresnel edge glow
fn computeMirrorIlluminate(N: vec3f, V: vec3f, fragPos: vec3f) -> vec3f {
    // Fresnel rim
    let NdotV = max(dot(N, V), 0.0);
    let rim   = pow(1.0 - NdotV, mirrorParams.fresnelPower);

    // Pulse: smoothly oscillate between [0.3, 1.0] so it never fully dies
    let pulse = mix(0.3, 1.0,
        (sin(scene.time * mirrorParams.illuminatePulse * 2.0 * PI) * 0.5 + 0.5)
    );

    // Spatial shimmer along Y: gives a "light sweep" feel on the surface
    let shimmer = sin(fragPos.y * 3.0 + scene.time * 2.0) * 0.15 + 0.85;

    return mirrorParams.illuminateColor
        * mirrorParams.illuminateStrength
        * rim * pulse * shimmer;
}

// Mirror specular: sharp GGX lobe biased toward near-zero roughness
fn computeMirrorSpecular(N: vec3f, V: vec3f, lightDir: vec3f, lightColor: vec3f) -> vec3f {
    let H       = normalize(lightDir + V);
    // clamp roughness to a low value so mirrors stay crisp
    let mirrorR = max(0.02, material.roughnessFactor * 0.15);
    let D       = distributionGGX(N, H, mirrorR);
    let G       = geometrySmith(N, V, lightDir, mirrorR);
    let F0      = mix(vec3f(0.9), mirrorParams.mirrorTint, vec3f(material.metallicFactor));
    let F       = fresnelSchlick(max(dot(H, V), 0.0), F0);
    let NdotL   = max(dot(N, lightDir), 0.0);
    let NdotV   = max(dot(N, V),        0.0);
    let spec    = (D * G * F) / (4.0 * NdotV * NdotL + 1e-5);
    return spec * lightColor * NdotL * mirrorParams.reflectivity;
}

fn worldPosToEquirectUV(worldPos: vec3f) -> vec2f {
    // Normalize position relative to object center
    let dir = normalize(worldPos);
    
    // Convert to spherical coordinates
    let u = atan2(dir.z, dir.x) / (2.0 * PI) + 0.5;
    let v = asin(clamp(dir.y, -1.0, 1.0)) / PI + 0.5;
    
    return vec2f(u, v);
}

// ─── Main ────────────────────────────────────────────────────────────────────
@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {

    let N = normalize(input.fragNorm);
    let V = normalize(scene.cameraPos - input.fragPos);

    let materialData = getPBRMaterial(input.uv);
    if (materialData.alpha < 0.01) { discard; }

    // ── Shadow + existing spotlight loop (unchanged logic) ────────────────
    var lightContribution = vec3f(0.0);

    for (var i: u32 = 0u; i < MAX_SPOTLIGHTS; i++) {
        let sc       = spotlights[i].lightViewProj * vec4<f32>(input.fragPos, 1.0);
        let p        = sc.xyz / sc.w;
        let shadowUV = clamp(p.xy * 0.5 + vec2<f32>(0.5), vec2<f32>(0.0), vec2<f32>(1.0));
        let depthRef = p.z * 0.5 + 0.5;
        let lightDir = normalize(spotlights[i].position - input.fragPos);
        let vis      = sampleShadow(shadowUV, i32(i), depthRef - spotlights[i].shadowBias, N, lightDir);
        let contrib  = computeSpotLight(spotlights[i], N, input.fragPos, V, materialData);
        lightContribution += contrib * vis;

        // ── Mirror: sharp specular from each spotlight ────────────────────
        let mirrorSpec = computeMirrorSpecular(N, V, lightDir, spotlights[i].color * spotlights[i].intensity);
        let coneFactor = calculateSpotlightFactor(spotlights[i], input.fragPos);
        lightContribution += mirrorSpec * coneFactor * vis;
    }

    // ── Env reflection ───────────────────────────────────────────────────
    let R = reflect(-V, N);
    var envColor: vec3f;
    if (mirrorParams.baseColorMix < 0.01) {
        // Sky/background objects: use mesh UV (requires proper UV unwrap)
        envColor = textureSample(mirrorEnvTex, mirrorEnvSampler, input.uv).rgb;
    } else {
        // Reflective objects: use reflection vector
        //  let worldUV = worldPosToEquirectUV(normalize(input.fragPos));
        //  envColor = textureSample(mirrorEnvTex, mirrorEnvSampler, worldUV).rgb * mirrorParams.mirrorTint;

        envColor = sampleMirrorEnv(R, input.fragPos, N, V, materialData.roughness) * mirrorParams.mirrorTint;
    }
    let envFresn = fresnelSchlick(max(dot(N, V), 0.0), 
                   mix(vec3f(0.04), vec3f(1.0), vec3f(materialData.metallic)));

    let texColor = textureSample(meshTexture, meshSampler, input.uv);
    var finalColor = texColor.rgb * (scene.globalAmbient + lightContribution);
    finalColor = mix(
        envColor,                    // Pure env (for sky objects)
        finalColor,                  // Normal lit material
        mirrorParams.baseColorMix    // 0=pure env, 1=normal material
    );

    // Add Fresnel reflection on top
    finalColor = mix(finalColor, envColor, envFresn * mirrorParams.reflectivity);
    let illuminate = computeMirrorIlluminate(N, V, input.fragPos);
    finalColor += illuminate;
    let alpha = mix(materialData.alpha, 1.0, 0.5);
    return vec4f(finalColor, alpha);
}
`;

},{}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fragmentVideoWGSL = void 0;
let fragmentVideoWGSL = exports.fragmentVideoWGSL = `override shadowDepthTextureSize: f32 = 1024.0;

struct Scene {
  lightViewProjMatrix : mat4x4f,
  cameraViewProjMatrix : mat4x4f,
  lightPos : vec3f,
}

@group(0) @binding(0) var<uniform> scene : Scene;
@group(0) @binding(1) var shadowMap: texture_depth_2d;
@group(0) @binding(2) var shadowSampler: sampler_comparison;
@group(0) @binding(3) var meshTexture: texture_external;
@group(0) @binding(4) var meshSampler: sampler;
@group(0) @binding(5) var<uniform> postFXMode: u32;

struct FragmentInput {
  @location(0) shadowPos : vec4f,
  @location(1) fragPos : vec3f,
  @location(2) fragNorm : vec3f,
  @location(3) uv : vec2f,
}

const albedo = vec3f(0.9);
const ambientFactor = 0.7;

@fragment
fn main(input : FragmentInput) -> @location(0) vec4f {
  // Shadow filtering
  var visibility = 0.0;
  let oneOverShadowDepthTextureSize = 1.0 / shadowDepthTextureSize;
  for (var y = -1; y <= 1; y++) {
    for (var x = -1; x <= 1; x++) {
      let offset = vec2f(vec2(x, y)) * oneOverShadowDepthTextureSize;
      visibility += textureSampleCompare(
        shadowMap, shadowSampler,
        input.shadowPos.xy + offset, input.shadowPos.z - 0.007
      );
    }
  }
  visibility /= 9.0;

  let lambertFactor = max(dot(normalize(scene.lightPos - input.fragPos), normalize(input.fragNorm)), 0.0);
  let lightingFactor = min(ambientFactor + visibility * lambertFactor, 1.0);

  // ✅ Sample video texture
  let textureColor = textureSampleBaseClampToEdge(meshTexture, meshSampler, input.uv);
  let color: vec4f = vec4(textureColor.rgb * lightingFactor * albedo, 1.0);

   switch (postFXMode) {
    case 0: {
      // Default
      return color;
    }
    case 1: {
      // Invert
      return vec4f(1.0 - color.rgb, color.a);
    }
    case 2: {
      // Grayscale
      let gray = dot(color.rgb, vec3f(0.299, 0.587, 0.114));
      return vec4f(vec3f(gray), color.a);
    }
    case 3: {
      // Chroma Key
      let keyColor = vec3f(0.0, 1.0, 0.0);
      let threshold = 0.3;
      let diff = distance(color.rgb, keyColor);
      if (diff < threshold) {
        return vec4f(0.0, 0.0, 0.0, 0.0);
      }
      return color;
    }
    default: {
      return color;
    }
  }

  // return color;
}
`;

},{}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fragmentWGSL = void 0;
let fragmentWGSL = exports.fragmentWGSL = `
override shadowDepthTextureSize: f32 = 1024.0;
const PI: f32 = 3.141592653589793;

struct Scene {
    lightViewProjMatrix  : mat4x4f,
    cameraViewProjMatrix : mat4x4f,
    cameraPos            : vec3f,
    padding2             : f32,
    lightPos             : vec3f,
    padding              : f32,
    globalAmbient        : vec3f,
    padding3             : f32,
    time                 : f32,
    deltaTime            : f32,
    padding4             : vec2f,
};

struct SpotLight {
    position      : vec3f,
    _pad1         : f32,
    direction     : vec3f,
    _pad2         : f32,
    innerCutoff   : f32,
    outerCutoff   : f32,
    intensity     : f32,
    _pad3         : f32,
    color         : vec3f,
    _pad4         : f32,
    range         : f32,
    ambientFactor : f32,
    shadowBias    : f32,
    _pad5         : f32,
    lightViewProj : mat4x4<f32>,
};

struct MaterialPBR {
    baseColorFactor : vec4f,
    metallicFactor  : f32,
    roughnessFactor : f32,
    _pad1           : f32,
    _pad2           : f32,
};

struct PBRMaterialData {
    baseColor : vec3f,
    metallic  : f32,
    roughness : f32,
    alpha     : f32,
};

const MAX_SPOTLIGHTS = 20u;

@group(0) @binding(0) var<uniform> scene : Scene;
@group(0) @binding(1) var shadowMapArray: texture_depth_2d_array;
@group(0) @binding(2) var shadowSampler: sampler_comparison;
@group(0) @binding(3) var meshTexture: texture_2d<f32>;
@group(0) @binding(4) var meshSampler: sampler;
@group(0) @binding(5) var<uniform> spotlights: array<SpotLight, MAX_SPOTLIGHTS>;

// PBR textures
@group(0) @binding(6) var metallicRoughnessTex: texture_2d<f32>;
@group(0) @binding(7) var metallicRoughnessSampler: sampler;
@group(0) @binding(8) var<uniform> material: MaterialPBR;

// @group(2) @binding(0) var<uniform> mirrorParams    : MirrorIlluminateParams;
// @group(2) @binding(1) var          mirrorEnvTex    : texture_2d<f32>;
// @group(2) @binding(2) var          mirrorEnvSampler: sampler;

struct FragmentInput {
    @location(0) shadowPos : vec4f,
    @location(1) fragPos   : vec3f,
    @location(2) fragNorm  : vec3f,
    @location(3) uv        : vec2f,
};

fn getPBRMaterial(uv: vec2f) -> PBRMaterialData {
    let texColor = textureSample(meshTexture, meshSampler, uv);
    let baseColor = texColor.rgb * material.baseColorFactor.rgb;
    let mrTex = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);
    let metallic = mrTex.b * material.metallicFactor;
    let roughness = mrTex.g * material.roughnessFactor;
    
    // ✅ Get alpha from texture and material factor
    // let alpha = texColor.a * material.baseColorFactor.a;
    let alpha = material.baseColorFactor.a;
    
    return PBRMaterialData(baseColor, metallic, roughness, alpha);
}

fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
    let a = roughness * roughness;
    let a2 = a * a;
    let NdotH = max(dot(N, H), 0.0);
    let NdotH2 = NdotH * NdotH;
    let denom = (NdotH2 * (a2 - 1.0) + 1.0);
    return a2 / (PI * denom * denom);
}

fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
    let r = (roughness + 1.0);
    let k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
    let NdotV = max(dot(N, V), 0.0);
    let NdotL = max(dot(N, L), 0.0);
    return geometrySchlickGGX(NdotV, roughness) * geometrySchlickGGX(NdotL, roughness);
}

fn calculateSpotlightFactor(light: SpotLight, fragPos: vec3f) -> f32 {
    let L = normalize(light.position - fragPos);
    let theta = dot(L, normalize(-light.direction));
    let epsilon = light.innerCutoff - light.outerCutoff;
    return clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);
}

fn computeSpotLight2(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, material: PBRMaterialData) -> vec3f {
    let L = normalize(light.position - fragPos);
    let NdotL = max(dot(N, L), 0.0);
    if (NdotL <= 0.0) {
        return vec3f(0.0);
    }
    return material.baseColor * light.color * light.intensity * NdotL;
}

fn computeSpotLight(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, material: PBRMaterialData) -> vec3f {
    let L = normalize(light.position - fragPos);
    let NdotL = max(dot(N, L), 0.0);

    let theta = dot(L, normalize(-light.direction));
    let epsilon = light.innerCutoff - light.outerCutoff;
    var coneAtten = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);

    if (coneAtten <= 0.0 || NdotL <= 0.0) {
        return vec3f(0.0);
    }

    let F0 = mix(vec3f(0.04), material.baseColor.rgb, vec3f(material.metallic));
    let H = normalize(L + V);
    let F = F0 + (1.0 - F0) * pow(1.0 - max(dot(H, V), 0.0), 5.0);

    let alpha = material.roughness * material.roughness;
    let NdotH = max(dot(N, H), 0.0);
    let alpha2 = alpha * alpha;
    let denom = (NdotH * NdotH * (alpha2 - 1.0) + 1.0);
    let D = alpha2 / (PI * denom * denom + 1e-5);

    let k = (alpha + 1.0) * (alpha + 1.0) / 8.0;
    let NdotV = max(dot(N, V), 0.0);
    let Gv = NdotV / (NdotV * (1.0 - k) + k);
    let Gl = NdotL / (NdotL * (1.0 - k) + k);
    let G = Gv * Gl;

    let numerator = D * G * F;
    let denominator = 4.0 * NdotV * NdotL + 1e-5;
    let specular = numerator / denominator;

    let kS = F;
    let kD = (vec3f(1.0) - kS) * (1.0 - material.metallic);
    let diffuse = kD * material.baseColor.rgb / PI;

    let radiance = light.color * light.intensity;
    return material.baseColor * light.color * light.intensity * NdotL * coneAtten;
}

fn sampleShadow(shadowUV: vec2f, layer: i32, depthRef: f32, normal: vec3f, lightDir: vec3f) -> f32 {
    var visibility: f32 = 0.0;
    let biasConstant: f32 = 0.001;
    let slopeBias = max(0.002 * (1.0 - dot(normal, lightDir)), 0.0);
    let bias = biasConstant + slopeBias;
    let oneOverSize = 1.0 / (shadowDepthTextureSize * 0.5);
    let offsets: array<vec2f, 9> = array<vec2f, 9>(
        vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),
        vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),
        vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0)
    );
    for(var i: u32 = 0u; i < 9u; i = i + 1u) {
        visibility += textureSampleCompare(
            shadowMapArray, shadowSampler,
            shadowUV + offsets[i] * oneOverSize,
            layer, depthRef - bias
        );
    }
    return visibility / 9.0;
}

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
    let norm = normalize(input.fragNorm);
    let viewDir = normalize(scene.cameraPos - input.fragPos);

    // ✅ Get material with alpha
    let materialData = getPBRMaterial(input.uv);
    
    // ✅ Early discard for fully transparent pixels (alpha cutoff)
    if (materialData.alpha < 0.01) {
        discard;
    }

    var lightContribution = vec3f(0.0);

    for (var i: u32 = 0u; i < MAX_SPOTLIGHTS; i = i + 1u) {
        let sc = spotlights[i].lightViewProj * vec4<f32>(input.fragPos, 1.0);
        let p  = sc.xyz / sc.w;
        let uv = clamp(p.xy * 0.5 + vec2<f32>(0.5), vec2<f32>(0.0), vec2<f32>(1.0));
        let depthRef = p.z * 0.5 + 0.5;

        let lightDir = normalize(spotlights[i].position - input.fragPos);
        let bias = spotlights[i].shadowBias;
        let visibility = sampleShadow(uv, i32(i), depthRef - bias, norm, lightDir);
        let contrib = computeSpotLight(spotlights[i], norm, input.fragPos, viewDir, materialData);
        lightContribution += contrib * visibility;
    }

    let texColor = textureSample(meshTexture, meshSampler, input.uv);
    var finalColor = texColor.rgb * (scene.globalAmbient + lightContribution);

    let N = normalize(input.fragNorm);
    let V = normalize(scene.cameraPos - input.fragPos);
    let fresnel = pow(1.0 - max(dot(N, V), 0.0), 3.0);

    // if (uSelected > 0.5) {
    //     let glowColor = vec3f(0.2, 0.8, 1.0);
    //     finalColor += glowColor * fresnel * 0.1;
    // }

    let alpha = mix(materialData.alpha, 1.0 , 0.5); 
    // ✅ Return color with alpha from material
    return vec4f(finalColor, alpha);
}`;

},{}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fragmentWGSLMetal = void 0;
let fragmentWGSLMetal = exports.fragmentWGSLMetal = `override shadowDepthTextureSize: f32 = 1024.0;
const PI: f32 = 3.141592653589793;

struct Scene {
    lightViewProjMatrix  : mat4x4f,
    cameraViewProjMatrix : mat4x4f,
    cameraPos            : vec3f,
    padding2             : f32,
    lightPos             : vec3f,
    padding              : f32,
    globalAmbient        : vec3f,
    padding3             : f32,
    time                 : f32,
    deltaTime            : f32,
    padding4             : vec2f,
};

struct SpotLight {
    position      : vec3f,
    _pad1         : f32,
    direction     : vec3f,
    _pad2         : f32,
    innerCutoff   : f32,
    outerCutoff   : f32,
    intensity     : f32,
    _pad3         : f32,
    color         : vec3f,
    _pad4         : f32,
    range         : f32,
    ambientFactor : f32,
    shadowBias    : f32,
    _pad5         : f32,
    lightViewProj : mat4x4<f32>,
};

struct MaterialPBR {
    baseColorFactor : vec4f,
    metallicFactor  : f32,
    roughnessFactor : f32,
    _pad1           : f32,
    _pad2           : f32,
};

struct PBRMaterialData {
    baseColor : vec3f,
    metallic  : f32,
    roughness : f32,
    alpha     : f32,  // ✅ Added alpha
};

const MAX_SPOTLIGHTS = 20u;

@group(0) @binding(0) var<uniform> scene : Scene;
@group(0) @binding(1) var shadowMapArray: texture_depth_2d_array;
@group(0) @binding(2) var shadowSampler: sampler_comparison;
@group(0) @binding(3) var meshTexture: texture_2d<f32>;
@group(0) @binding(4) var meshSampler: sampler;
@group(0) @binding(5) var<uniform> spotlights: array<SpotLight, MAX_SPOTLIGHTS>;

// PBR textures
@group(0) @binding(6) var metallicRoughnessTex: texture_2d<f32>;
@group(0) @binding(7) var metallicRoughnessSampler: sampler;
@group(0) @binding(8) var<uniform> material: MaterialPBR;

struct FragmentInput {
    @location(0) shadowPos : vec4f,
    @location(1) fragPos   : vec3f,
    @location(2) fragNorm  : vec3f,
    @location(3) uv        : vec2f,
};

fn getPBRMaterial(uv: vec2f) -> PBRMaterialData {
    let texColor = textureSample(meshTexture, meshSampler, uv);
    let baseColor = texColor.rgb * material.baseColorFactor.rgb;
    let mrTex = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);
    let metallic = material.metallicFactor;
    let roughness = material.roughnessFactor;
    // ✅ Get alpha from texture and material factor
    let alpha = texColor.a * material.baseColorFactor.a;
    return PBRMaterialData(baseColor, metallic, roughness, alpha);
}

fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
    let a = roughness * roughness;
    let a2 = a * a;
    let NdotH = max(dot(N, H), 0.0);
    let NdotH2 = NdotH * NdotH;
    let denom = (NdotH2 * (a2 - 1.0) + 1.0);
    return a2 / (PI * denom * denom);
}

fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
    let r = (roughness + 1.0);
    let k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
    let NdotV = max(dot(N, V), 0.0);
    let NdotL = max(dot(N, L), 0.0);
    return geometrySchlickGGX(NdotV, roughness) * geometrySchlickGGX(NdotL, roughness);
}

fn calculateSpotlightFactor(light: SpotLight, fragPos: vec3f) -> f32 {
    let L = normalize(light.position - fragPos);
    let theta = dot(L, normalize(-light.direction));
    let epsilon = light.innerCutoff - light.outerCutoff;
    return clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);
}

// PCF shadow sampling
fn sampleShadow(shadowUV: vec2f, layer: i32, depthRef: f32, normal: vec3f, lightDir: vec3f) -> f32 {
    var visibility: f32 = 0.0;
    let biasConstant: f32 = 0.001;
    let slopeBias = max(0.002 * (1.0 - dot(normal, lightDir)), 0.0);
    let bias = biasConstant + slopeBias;
    let oneOverSize = 1.0 / (shadowDepthTextureSize * 0.5);
    let offsets: array<vec2f, 9> = array<vec2f, 9>(
        vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),
        vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),
        vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0)
    );
    for(var i: u32 = 0u; i < 9u; i = i + 1u) {
        visibility += textureSampleCompare(shadowMapArray, shadowSampler, shadowUV + offsets[i] * oneOverSize, layer, depthRef - bias);
    }
    return visibility / 9.0;
}

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
    let materialData = getPBRMaterial(input.uv);
    
    // ✅ Early discard for fully transparent pixels
    if (materialData.alpha < 0.01) {
        discard;
    }
    
    let N = normalize(input.fragNorm);
    let V = normalize(scene.cameraPos - input.fragPos);
    var Lo = vec3f(0.0);
    
    for(var i: u32 = 0u; i < MAX_SPOTLIGHTS; i = i + 1u) {
        let L = normalize(spotlights[i].position - input.fragPos);
        let H = normalize(V + L);
        let distance = length(spotlights[i].position - input.fragPos);
        let attenuation = clamp(1.0 - (distance / spotlights[i].range), 0.0, 1.0);

        let NdotL = max(dot(N, L), 0.0);

        let radiance = spotlights[i].color * spotlights[i].intensity * attenuation;

        let NDF = distributionGGX(N, H, materialData.roughness);
        let G   = geometrySmith(N, V, L, materialData.roughness);
        let F0 = mix(vec3f(0.04), materialData.baseColor, materialData.metallic);
        let F  = fresnelSchlick(max(dot(H, V), 0.0), F0);

        let kS = F;
        let kD = (vec3f(1.0) - kS) * (1.0 - materialData.metallic);

        let diffuse  = kD * materialData.baseColor / PI;
        let specular = (NDF * G * F) / (4.0 * max(dot(N, V), 0.0) * NdotL + 0.001);

        // Combine diffuse + specular and multiply by NdotL and radiance
        Lo += (diffuse + specular) * radiance * NdotL;
    }

    let ambient = scene.globalAmbient * materialData.baseColor;
    var color = ambient + Lo;
    
    // ✅ Return color with alpha from material
    return vec4f(color, materialData.alpha);
}
`;

},{}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fragmentWGSLNormalMap = void 0;
let fragmentWGSLNormalMap = exports.fragmentWGSLNormalMap = `
override shadowDepthTextureSize: f32 = 1024.0;
const PI: f32 = 3.141592653589793;

struct Scene {
    lightViewProjMatrix  : mat4x4f,
    cameraViewProjMatrix : mat4x4f,
    cameraPos            : vec3f,
    padding2             : f32,
    lightPos             : vec3f,
    padding              : f32,
    globalAmbient        : vec3f,
    padding3             : f32,
    time                 : f32,
    deltaTime            : f32,
    padding4             : vec2f,
};

struct SpotLight {
    position      : vec3f,
    _pad1         : f32,
    direction     : vec3f,
    _pad2         : f32,
    innerCutoff   : f32,
    outerCutoff   : f32,
    intensity     : f32,
    _pad3         : f32,
    color         : vec3f,
    _pad4         : f32,
    range         : f32,
    ambientFactor : f32,
    shadowBias    : f32,
    _pad5         : f32,
    lightViewProj : mat4x4<f32>,
};

struct MaterialPBR {
    baseColorFactor : vec4f,
    metallicFactor  : f32,
    roughnessFactor : f32,
    _pad1           : f32,
    _pad2           : f32,
};

struct PBRMaterialData {
    baseColor : vec3f,
    metallic  : f32,
    roughness : f32,
};

const MAX_SPOTLIGHTS = 20u;

@group(0) @binding(0) var<uniform> scene : Scene;
@group(0) @binding(1) var shadowMapArray: texture_depth_2d_array;
@group(0) @binding(2) var shadowSampler: sampler_comparison;
@group(0) @binding(3) var meshTexture: texture_2d<f32>;
@group(0) @binding(4) var meshSampler: sampler;
@group(0) @binding(5) var<uniform> spotlights: array<SpotLight, MAX_SPOTLIGHTS>;

// PBR textures
@group(0) @binding(6) var metallicRoughnessTex: texture_2d<f32>;
@group(0) @binding(7) var metallicRoughnessSampler: sampler;
@group(0) @binding(8) var<uniform> material: MaterialPBR;
// PBR normalmap
@group(0) @binding(9) var normalTex: texture_2d<f32>;
@group(0) @binding(10) var normalSampler: sampler;

struct FragmentInput {
  @location(0) shadowPos : vec4f,
  @location(1) fragPos   : vec3f,
  @location(2) fragNorm  : vec3f,
  @location(3) uv        : vec2f,
  @location(4) tangent   : vec4f, // new
};

fn getNormalMap(uv: vec2f, N: vec3f) -> vec3f {
    // Sample normal map
    let nSample = textureSample(normalTex, normalSampler, uv).rgb;
    // Convert from [0,1] → [-1,1]
    let nTangent = nSample * 2.0 - vec3f(1.0);
    
    // TODO: if you have TBN matrix, convert tangent-space → world-space
    // For now, assume fragNorm is already aligned (simple approx)
    return normalize(nTangent);
}

fn getNormalMap2(uv: vec2f, N: vec3f, T: vec3f, B: vec3f) -> vec3f {
    let nSample = textureSample(normalTex, normalSampler, uv).rgb;
    let nTangent = nSample * 2.0 - vec3f(1.0);
    let worldNormal = normalize(T * nTangent.x + B * nTangent.y + N * nTangent.z);
    return worldNormal;
}
    
fn getPBRMaterial(uv: vec2f) -> PBRMaterialData {
    let texColor = textureSample(meshTexture, meshSampler, uv);
    let baseColor = texColor.rgb * material.baseColorFactor.rgb;
    let mrTex = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);
    let metallic = mrTex.b * material.metallicFactor;
    let roughness = mrTex.g * material.roughnessFactor;
    return PBRMaterialData(baseColor, metallic, roughness);
}

fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
    let a = roughness * roughness;
    let a2 = a * a;
    let NdotH = max(dot(N, H), 0.0);
    let NdotH2 = NdotH * NdotH;
    let denom = (NdotH2 * (a2 - 1.0) + 1.0);
    return a2 / (PI * denom * denom);
}

fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
    let r = (roughness + 1.0);
    let k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
    let NdotV = max(dot(N, V), 0.0);
    let NdotL = max(dot(N, L), 0.0);
    return geometrySchlickGGX(NdotV, roughness) * geometrySchlickGGX(NdotL, roughness);
}

fn calculateSpotlightFactor(light: SpotLight, fragPos: vec3f) -> f32 {
    let L = normalize(light.position - fragPos);
    let theta = dot(L, normalize(-light.direction));
    let epsilon = light.innerCutoff - light.outerCutoff;
    return clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);
}

fn computeSpotLight2(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, material: PBRMaterialData) -> vec3f {
    let L = normalize(light.position - fragPos);
    let NdotL = max(dot(N, L), 0.0);
    if (NdotL <= 0.0) {
        return vec3f(0.0);
    }
    return material.baseColor * light.color * light.intensity * NdotL;
    // return material.baseColor * light.color * light.intensity * NdotL;
}

fn computeSpotLight(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, material: PBRMaterialData) -> vec3f {
    let L = normalize(light.position - fragPos);
    let NdotL = max(dot(N, L), 0.0);

    let theta = dot(L, normalize(-light.direction));
    let epsilon = light.innerCutoff - light.outerCutoff;
    var coneAtten = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);

    // coneAtten = 1.0;
    if (coneAtten <= 0.0 || NdotL <= 0.0) {
        return vec3f(0.0);
    }

    let F0 = mix(vec3f(0.04), material.baseColor.rgb, vec3f(material.metallic));
    let H = normalize(L + V);
    let F = F0 + (1.0 - F0) * pow(1.0 - max(dot(H, V), 0.0), 5.0);

    let alpha = material.roughness * material.roughness;
    let NdotH = max(dot(N, H), 0.0);
    let alpha2 = alpha * alpha;
    let denom = (NdotH * NdotH * (alpha2 - 1.0) + 1.0);
    let D = alpha2 / (PI * denom * denom + 1e-5);

    let k = (alpha + 1.0) * (alpha + 1.0) / 8.0;
    let NdotV = max(dot(N, V), 0.0);
    let Gv = NdotV / (NdotV * (1.0 - k) + k);
    let Gl = NdotL / (NdotL * (1.0 - k) + k);
    let G = Gv * Gl;

    let numerator = D * G * F;
    let denominator = 4.0 * NdotV * NdotL + 1e-5;
    let specular = numerator / denominator;

    let kS = F;
    let kD = (vec3f(1.0) - kS) * (1.0 - material.metallic);
    let diffuse = kD * material.baseColor.rgb / PI;

    let radiance = light.color * light.intensity;
    // return (diffuse + specular) * radiance * NdotL * coneAtten;
    return material.baseColor * light.color * light.intensity * NdotL * coneAtten;
}

fn sampleShadow(shadowUV: vec2f, layer: i32, depthRef: f32, normal: vec3f, lightDir: vec3f) -> f32 {
    var visibility: f32 = 0.0;
    let biasConstant: f32 = 0.001;
    let slopeBias = max(0.002 * (1.0 - dot(normal, lightDir)), 0.0);
    let bias = biasConstant + slopeBias;
    let oneOverSize = 1.0 / (shadowDepthTextureSize * 0.5);
    let offsets: array<vec2f, 9> = array<vec2f, 9>(
        vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),
        vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),
        vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0)
    );
    for(var i: u32 = 0u; i < 9u; i = i + 1u) {
        visibility += textureSampleCompare(
            shadowMapArray, shadowSampler,
            shadowUV + offsets[i] * oneOverSize,
            layer, depthRef - bias
        );
    }
    return visibility / 9.0;
}

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
    // let norm = normalize(input.fragNorm);
    let N = normalize(input.fragNorm);
    let T = normalize(input.tangent.xyz);
    let B = cross(N, T) * input.tangent.w; // handedness
    let norm = getNormalMap2(input.uv, N, T, B);

    let viewDir = normalize(scene.cameraPos - input.fragPos);

    // ✅ now we declare materialData
    let materialData = getPBRMaterial(input.uv);

    var lightContribution = vec3f(0.0);

    for (var i: u32 = 0u; i < MAX_SPOTLIGHTS; i = i + 1u) {
        let sc = spotlights[i].lightViewProj * vec4<f32>(input.fragPos, 1.0);
        let p  = sc.xyz / sc.w;
        let uv = clamp(p.xy * 0.5 + vec2<f32>(0.5), vec2<f32>(0.0), vec2<f32>(1.0));
        let depthRef = p.z * 0.5 + 0.5;

        let lightDir = normalize(spotlights[i].position - input.fragPos);
        let bias = spotlights[i].shadowBias;
        let visibility = sampleShadow(uv, i32(i), depthRef - bias, norm, lightDir);
        // let visibility = 1.0;
        let contrib = computeSpotLight(spotlights[i], norm, input.fragPos, viewDir, materialData);
        lightContribution += contrib * visibility;
    }

    let texColor = textureSample(meshTexture, meshSampler, input.uv);
    let finalColor = texColor.rgb * (scene.globalAmbient + lightContribution);
    return vec4f(finalColor, 1.0);
}`;

},{}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fragmentWGSLPong = void 0;
let fragmentWGSLPong = exports.fragmentWGSLPong = `
override shadowDepthTextureSize: f32 = 1024.0;
const PI: f32 = 3.141592653589793;

struct Scene {
    lightViewProjMatrix  : mat4x4f,
    cameraViewProjMatrix : mat4x4f,
    cameraPos            : vec3f,
    padding2             : f32,
    lightPos             : vec3f,
    padding              : f32,
    globalAmbient        : vec3f,
    padding3             : f32,
    time                 : f32,
    deltaTime            : f32,
    padding4             : vec2f,
};

struct SpotLight {
    position      : vec3f,
    _pad1         : f32,
    direction     : vec3f,
    _pad2         : f32,
    innerCutoff   : f32,
    outerCutoff   : f32,
    intensity     : f32,
    _pad3         : f32,
    color         : vec3f,
    _pad4         : f32,
    range         : f32,
    ambientFactor : f32,
    shadowBias    : f32,
    _pad5         : f32,
    lightViewProj : mat4x4<f32>,
};

struct MaterialPBR {
    baseColorFactor : vec4f,
    metallicFactor  : f32,
    roughnessFactor : f32,
    _pad1           : f32,
    _pad2           : f32,
};

struct PBRMaterialData {
    baseColor : vec3f,
    metallic  : f32,
    roughness : f32,
};

const MAX_SPOTLIGHTS = 20u;

@group(0) @binding(0) var<uniform> scene : Scene;
@group(0) @binding(1) var shadowMapArray: texture_depth_2d_array;
@group(0) @binding(2) var shadowSampler: sampler_comparison;
@group(0) @binding(3) var meshTexture: texture_2d<f32>;
@group(0) @binding(4) var meshSampler: sampler;
@group(0) @binding(5) var<uniform> spotlights: array<SpotLight, MAX_SPOTLIGHTS>;

// PBR textures
@group(0) @binding(6) var metallicRoughnessTex: texture_2d<f32>;
@group(0) @binding(7) var metallicRoughnessSampler: sampler;
@group(0) @binding(8) var<uniform> material: MaterialPBR;

struct FragmentInput {
    @location(0) shadowPos : vec4f,
    @location(1) fragPos   : vec3f,
    @location(2) fragNorm  : vec3f,
    @location(3) uv        : vec2f,
};

fn getPBRMaterial(uv: vec2f) -> PBRMaterialData {
    let texColor = textureSample(meshTexture, meshSampler, uv);
    let baseColor = texColor.rgb * material.baseColorFactor.rgb;
    let mrTex = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);
    let metallic = mrTex.b * material.metallicFactor;
    let roughness = mrTex.g * material.roughnessFactor;
    return PBRMaterialData(baseColor, metallic, roughness);
}

fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
    let a = roughness * roughness;
    let a2 = a * a;
    let NdotH = max(dot(N, H), 0.0);
    let NdotH2 = NdotH * NdotH;
    let denom = (NdotH2 * (a2 - 1.0) + 1.0);
    return a2 / (PI * denom * denom);
}

fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
    let r = (roughness + 1.0);
    let k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
    let NdotV = max(dot(N, V), 0.0);
    let NdotL = max(dot(N, L), 0.0);
    return geometrySchlickGGX(NdotV, roughness) * geometrySchlickGGX(NdotL, roughness);
}

fn calculateSpotlightFactor(light: SpotLight, fragPos: vec3f) -> f32 {
    let L = normalize(light.position - fragPos);
    let theta = dot(L, normalize(-light.direction));
    let epsilon = light.innerCutoff - light.outerCutoff;
    return clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);
}

fn computeSpotLight2(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, material: PBRMaterialData) -> vec3f {
    let L = normalize(light.position - fragPos);
    let NdotL = max(dot(N, L), 0.0);
    if (NdotL <= 0.0) {
        return vec3f(0.0);
    }

    let theta = dot(L, normalize(-light.direction));
    let epsilon = light.innerCutoff - light.outerCutoff;
    let coneAtten = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);
    if (coneAtten <= 0.0) {
        return vec3f(0.0);
    }

    // --- diffuse controlled by metallic ---
    let kD = 1.0 - material.metallic;  // 1.0 → full diffuse, 0.0 → fully metallic
    let lambert = kD * material.baseColor * light.color * light.intensity * NdotL;

    // --- simple specular controlled by roughness ---
    let H = normalize(L + V);
    let shininess = mix(2.0, 128.0, 1.0 - material.roughness); // map roughness → exponent
    let spec = pow(max(dot(N, H), 0.0), shininess);
    let specular = light.color * spec * material.metallic; // only strong if metallic > 0

    return (lambert + specular) * coneAtten;
}
// Debug hybrid spotlight
fn computeSpotLight3(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, material: PBRMaterialData) -> vec3f {
    let L = normalize(light.position - fragPos);
    let NdotL = max(dot(N, L), 0.0);
    if (NdotL <= 0.0) {
        return vec3f(0.0);
    }

    let theta = dot(L, normalize(-light.direction));
    let epsilon = light.innerCutoff - light.outerCutoff;
    let coneAtten = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);

    if (coneAtten <= 0.0) {
        return vec3f(0.0);
    }

    // ---- baseline lambert ----
    let lambert = material.baseColor * light.color * light.intensity * NdotL;

    // ---- add a bit of specular safely ----
    let H = normalize(L + V);
    let spec = pow(max(dot(N, H), 0.0), 32.0); // simple Blinn-Phong
    let specular = light.color * spec * 0.2;   // scaled so it doesn’t kill diffuse

    // final mix
    return (lambert + specular) * coneAtten;
}

fn sampleShadow(shadowUV: vec2f, layer: i32, depthRef: f32, normal: vec3f, lightDir: vec3f) -> f32 {
    var visibility: f32 = 0.0;
    let biasConstant: f32 = 0.001;
    let slopeBias = max(0.002 * (1.0 - dot(normal, lightDir)), 0.0);
    let bias = biasConstant + slopeBias;
    let oneOverSize = 1.0 / (shadowDepthTextureSize * 0.5);
    let offsets: array<vec2f, 9> = array<vec2f, 9>(
        vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),
        vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),
        vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0)
    );
    for(var i: u32 = 0u; i < 9u; i = i + 1u) {
        visibility += textureSampleCompare(
            shadowMapArray, shadowSampler,
            shadowUV + offsets[i] * oneOverSize,
            layer, depthRef - bias
        );
    }
    return visibility / 9.0;
}

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
    let norm = normalize(input.fragNorm);
    let viewDir = normalize(scene.cameraPos - input.fragPos);

    // ✅ now we declare materialData
    let materialData = getPBRMaterial(input.uv);

    var lightContribution = vec3f(0.0);

    for (var i: u32 = 0u; i < MAX_SPOTLIGHTS; i = i + 1u) {
        let sc = spotlights[i].lightViewProj * vec4<f32>(input.fragPos, 1.0);
        let p  = sc.xyz / sc.w;
        let uv = clamp(p.xy * 0.5 + vec2<f32>(0.5), vec2<f32>(0.0), vec2<f32>(1.0));
        let depthRef = p.z * 0.5 + 0.5;

        let lightDir = normalize(spotlights[i].position - input.fragPos);
        let bias = spotlights[i].shadowBias;
        let visibility = sampleShadow(uv, i32(i), depthRef - bias, norm, lightDir);
        // let visibility = 1.0;
        let contrib = computeSpotLight2(spotlights[i], norm, input.fragPos, viewDir, materialData);
        lightContribution += contrib * visibility;
    }

    let texColor = textureSample(meshTexture, meshSampler, input.uv);
    let finalColor = texColor.rgb * (scene.globalAmbient + lightContribution);
    return vec4f(finalColor, 1.0);
}`;

},{}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fragmentWGSLPower = void 0;
let fragmentWGSLPower = exports.fragmentWGSLPower = `override shadowDepthTextureSize: f32 = 1024.0;
const PI: f32 = 3.141592653589793;

struct Scene {
    lightViewProjMatrix  : mat4x4f,
    cameraViewProjMatrix : mat4x4f,
    cameraPos            : vec3f,
    padding2             : f32,
    lightPos             : vec3f,
    padding              : f32,
    globalAmbient        : vec3f,
    padding3             : f32,
    time                 : f32,
    deltaTime            : f32,
    padding4             : vec2f,
};

struct SpotLight {
    position      : vec3f,
    _pad1         : f32,
    direction     : vec3f,
    _pad2         : f32,
    innerCutoff   : f32,
    outerCutoff   : f32,
    intensity     : f32,
    _pad3         : f32,
    color         : vec3f,
    _pad4         : f32,
    range         : f32,
    ambientFactor : f32,
    shadowBias    : f32,
    _pad5         : f32,
    lightViewProj : mat4x4<f32>,
};

struct MaterialPBR {
    baseColorFactor : vec4f,
    metallicFactor  : f32,
    roughnessFactor : f32,
    _pad1           : f32,
    _pad2           : f32,
};

struct PBRMaterialData {
    baseColor : vec3f,
    metallic  : f32,
    roughness : f32,
};

const MAX_SPOTLIGHTS = 20u;

@group(0) @binding(0) var<uniform> scene : Scene;
@group(0) @binding(1) var shadowMapArray: texture_depth_2d_array;
@group(0) @binding(2) var shadowSampler: sampler_comparison;
@group(0) @binding(3) var meshTexture: texture_2d<f32>;
@group(0) @binding(4) var meshSampler: sampler;
@group(0) @binding(5) var<uniform> spotlights: array<SpotLight, MAX_SPOTLIGHTS>;

// PBR textures
@group(0) @binding(6) var metallicRoughnessTex: texture_2d<f32>;
@group(0) @binding(7) var metallicRoughnessSampler: sampler;
@group(0) @binding(8) var<uniform> material: MaterialPBR;

struct FragmentInput {
    @location(0) shadowPos : vec4f,
    @location(1) fragPos   : vec3f,
    @location(2) fragNorm  : vec3f,
    @location(3) uv        : vec2f,
};

fn getPBRMaterial(uv: vec2f) -> PBRMaterialData {
    let texColor = textureSample(meshTexture, meshSampler, uv);
    let baseColor = texColor.rgb * material.baseColorFactor.rgb;
    let mrTex = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);
    let metallic = mrTex.b * material.metallicFactor;
    let roughness = mrTex.g * material.roughnessFactor;
    return PBRMaterialData(baseColor, metallic, roughness);
}

fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
    let a = roughness * roughness;
    let a2 = a * a;
    let NdotH = max(dot(N, H), 0.0);
    let NdotH2 = NdotH * NdotH;
    let denom = (NdotH2 * (a2 - 1.0) + 1.0);
    return a2 / (PI * denom * denom);
}

fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
    let r = (roughness + 1.0);
    let k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
    let NdotV = max(dot(N, V), 0.0);
    let NdotL = max(dot(N, L), 0.0);
    return geometrySchlickGGX(NdotV, roughness) * geometrySchlickGGX(NdotL, roughness);
}

fn calculateSpotlightFactor(light: SpotLight, fragPos: vec3f) -> f32 {
    let L = normalize(light.position - fragPos);
    let theta = dot(L, normalize(-light.direction));
    let epsilon = light.innerCutoff - light.outerCutoff;
    return clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);
}

// PCF shadow sampling
fn sampleShadow(shadowUV: vec2f, layer: i32, depthRef: f32, normal: vec3f, lightDir: vec3f) -> f32 {
    var visibility: f32 = 0.0;
    let biasConstant: f32 = 0.001;
    let slopeBias = max(0.002 * (1.0 - dot(normal, lightDir)), 0.0);
    let bias = biasConstant + slopeBias;
    let oneOverSize = 1.0 / (shadowDepthTextureSize * 0.5);
    let offsets: array<vec2f, 9> = array<vec2f, 9>(
        vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),
        vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),
        vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0)
    );
    for(var i: u32 = 0u; i < 9u; i = i + 1u) {
        visibility += textureSampleCompare(shadowMapArray, shadowSampler, shadowUV + offsets[i] * oneOverSize, layer, depthRef - bias);
    }
    return visibility / 9.0;
}

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
    let materialData = getPBRMaterial(input.uv);
    let N = normalize(input.fragNorm);
    let V = normalize(scene.cameraPos - input.fragPos);
    var Lo = vec3f(0.0);
    for(var i: u32 = 0u; i < MAX_SPOTLIGHTS; i = i + 1u) {
        let L = normalize(spotlights[i].position - input.fragPos);
        let H = normalize(V + L);
        let distance = length(spotlights[i].position - input.fragPos);
        let attenuation = clamp(1.0 - (distance / spotlights[i].range), 0.0, 1.0);
        let radiance = spotlights[i].color * spotlights[i].intensity * attenuation;
        let NDF = distributionGGX(N, H, materialData.roughness);
        let G   = geometrySmith(N, V, L, materialData.roughness);
        let F0 = mix(vec3f(0.04), materialData.baseColor, materialData.metallic);
        let F  = fresnelSchlick(max(dot(H, V), 0.0), F0);
        let kS = F;
        let kD = (vec3f(1.0) - kS) * (1.0 - materialData.metallic);
        let diffuse  = kD * materialData.baseColor / PI; // Lambertian diffuse // ??
        let NdotL = max(dot(N, L), 0.0);
        let specular = (NDF * G * F) / (4.0 * max(dot(N, V), 0.0) * NdotL + 0.001);
        Lo += NdotL * spotlights[i].color * spotlights[i].intensity;
    }
    let ambient = scene.globalAmbient * materialData.baseColor;
    var color = ambient + Lo;
    return vec4f(color, 1.0);
}
`;

// let N = normalize(input.fragNorm);
// let L = normalize(spotlights[0].position - input.fragPos);
// let NdotL = max(dot(N,L),0.0);
// let radiance = spotlights[0].color * 10.0; // test high intensity
// Lo += materialData.baseColor * radiance * NdotL;

},{}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gizmoEffect = void 0;
const gizmoEffect = exports.gizmoEffect = `
struct Camera {
  viewProj : mat4x4<f32>
};
@group(0) @binding(0) var<uniform> camera : Camera;

struct ModelData {
  model : mat4x4<f32>,
};
@group(0) @binding(1) var<uniform> modelData : ModelData;

struct GizmoSettings {
  mode : u32,
  size : f32,
  selectedAxis : u32,
  lineThickness : f32,
};
@group(0) @binding(2) var<uniform> gizmoSettings : GizmoSettings;

struct VSIn {
  @location(0) position : vec3<f32>,
  @location(1) color : vec3<f32>,
};

struct VSOut {
  @builtin(position) position : vec4<f32>,
  @location(0) color : vec3<f32>,
  @location(1) worldPos : vec3<f32>,
  @location(2) axisId : f32,
};

@vertex
fn vsMain(input : VSIn) -> VSOut {
  var output : VSOut;
  
  let worldPos = modelData.model * vec4<f32>(input.position * gizmoSettings.size, 1.0);
  output.position = camera.viewProj * worldPos;
  output.worldPos = worldPos.xyz;
  
  // Determine which axis based on color
  var axisId = 0.0;
  if (input.color.r > 0.9) { axisId = 1.0; } // X axis
  else if (input.color.g > 0.9) { axisId = 2.0; } // Y axis
  else if (input.color.b > 0.9) { axisId = 3.0; } // Z axis
  
  output.axisId = axisId;
  
  // Highlight selected axis
  var finalColor = input.color;
  if (gizmoSettings.selectedAxis > 0u && u32(axisId) == gizmoSettings.selectedAxis) {
    finalColor = vec3<f32>(1.0, 1.0, 0.0); // Yellow when selected
  }
  
  output.color = finalColor;
  return output;
}

@fragment
fn fsMain(input : VSOut) -> @location(0) vec4<f32> {
  return vec4<f32>(input.color, 1.0);
}`;

},{}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fragmentWGSLInstanced = void 0;
let fragmentWGSLInstanced = exports.fragmentWGSLInstanced = `
override shadowDepthTextureSize: f32 = 1024.0;
const PI: f32 = 3.141592653589793;

struct Scene {
    lightViewProjMatrix  : mat4x4f,
    cameraViewProjMatrix : mat4x4f,
    cameraPos            : vec3f,
    padding2             : f32,
    lightPos             : vec3f,
    padding              : f32,
    globalAmbient        : vec3f,
    padding3             : f32,
};

struct SpotLight {
    position      : vec3f,
    _pad1         : f32,
    direction     : vec3f,
    _pad2         : f32,
    innerCutoff   : f32,
    outerCutoff   : f32,
    intensity     : f32,
    _pad3         : f32,
    color         : vec3f,
    _pad4         : f32,
    range         : f32,
    ambientFactor : f32,
    shadowBias    : f32,
    _pad5         : f32,
    lightViewProj : mat4x4<f32>,
};

struct MaterialPBR {
    baseColorFactor : vec4f,
    metallicFactor  : f32,
    roughnessFactor : f32,
    _pad1           : f32,
    _pad2           : f32,
};

struct PBRMaterialData {
    baseColor : vec3f,
    metallic  : f32,
    roughness : f32,
    alpha     : f32,
};

const MAX_SPOTLIGHTS = 20u;

@group(0) @binding(0) var<uniform> scene : Scene;
@group(0) @binding(1) var shadowMapArray: texture_depth_2d_array;
@group(0) @binding(2) var shadowSampler: sampler_comparison;
@group(0) @binding(3) var meshTexture: texture_2d<f32>;
@group(0) @binding(4) var meshSampler: sampler;
@group(0) @binding(5) var<uniform> spotlights: array<SpotLight, MAX_SPOTLIGHTS>;

// PBR textures
@group(0) @binding(6) var metallicRoughnessTex: texture_2d<f32>;
@group(0) @binding(7) var metallicRoughnessSampler: sampler;
@group(0) @binding(8) var<uniform> material: MaterialPBR;

// RPG or any other usage [selected obj effect]
// @group(2) @binding(0) var<uniform> uSelected : f32;

struct FragmentInput {
    @location(0) shadowPos : vec4f,
    @location(1) fragPos   : vec3f,
    @location(2) fragNorm  : vec3f,
    @location(3) uv        : vec2f,
    @location(4) colorMult : vec4f,
};

fn getPBRMaterial(uv: vec2f) -> PBRMaterialData {
    let texColor = textureSample(meshTexture, meshSampler, uv);
    let baseColor = texColor.rgb * material.baseColorFactor.rgb;
    let mrTex = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);
    let metallic = mrTex.b * material.metallicFactor;
    let roughness = mrTex.g * material.roughnessFactor;
    
    // ✅ Get alpha from texture and material factor
    // let alpha = texColor.a * material.baseColorFactor.a;
    let alpha = material.baseColorFactor.a;
    
    return PBRMaterialData(baseColor, metallic, roughness, alpha);
}

fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
    let a = roughness * roughness;
    let a2 = a * a;
    let NdotH = max(dot(N, H), 0.0);
    let NdotH2 = NdotH * NdotH;
    let denom = (NdotH2 * (a2 - 1.0) + 1.0);
    return a2 / (PI * denom * denom);
}

fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
    let r = (roughness + 1.0);
    let k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
    let NdotV = max(dot(N, V), 0.0);
    let NdotL = max(dot(N, L), 0.0);
    return geometrySchlickGGX(NdotV, roughness) * geometrySchlickGGX(NdotL, roughness);
}

fn calculateSpotlightFactor(light: SpotLight, fragPos: vec3f) -> f32 {
    let L = normalize(light.position - fragPos);
    let theta = dot(L, normalize(-light.direction));
    let epsilon = light.innerCutoff - light.outerCutoff;
    return clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);
}

fn computeSpotLight2(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, material: PBRMaterialData) -> vec3f {
    let L = normalize(light.position - fragPos);
    let NdotL = max(dot(N, L), 0.0);
    if (NdotL <= 0.0) {
        return vec3f(0.0);
    }
    return material.baseColor * light.color * light.intensity * NdotL;
    // return material.baseColor * light.color * light.intensity * NdotL;
}

fn computeSpotLight(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, material: PBRMaterialData) -> vec3f {
    let L = normalize(light.position - fragPos);
    let NdotL = max(dot(N, L), 0.0);

    let theta = dot(L, normalize(-light.direction));
    let epsilon = light.innerCutoff - light.outerCutoff;
    var coneAtten = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);

    // coneAtten = 1.0;
    if (coneAtten <= 0.0 || NdotL <= 0.0) {
        return vec3f(0.0);
    }

    let F0 = mix(vec3f(0.04), material.baseColor.rgb, vec3f(material.metallic));
    let H = normalize(L + V);
    let F = F0 + (1.0 - F0) * pow(1.0 - max(dot(H, V), 0.0), 5.0);

    let alpha = material.roughness * material.roughness;
    let NdotH = max(dot(N, H), 0.0);
    let alpha2 = alpha * alpha;
    let denom = (NdotH * NdotH * (alpha2 - 1.0) + 1.0);
    let D = alpha2 / (PI * denom * denom + 1e-5);

    let k = (alpha + 1.0) * (alpha + 1.0) / 8.0;
    let NdotV = max(dot(N, V), 0.0);
    let Gv = NdotV / (NdotV * (1.0 - k) + k);
    let Gl = NdotL / (NdotL * (1.0 - k) + k);
    let G = Gv * Gl;

    let numerator = D * G * F;
    let denominator = 4.0 * NdotV * NdotL + 1e-5;
    let specular = numerator / denominator;

    let kS = F;
    let kD = (vec3f(1.0) - kS) * (1.0 - material.metallic);
    let diffuse = kD * material.baseColor.rgb / PI;

    let radiance = light.color * light.intensity;
    // return (diffuse + specular) * radiance * NdotL * coneAtten;
    return material.baseColor * light.color * light.intensity * NdotL * coneAtten;
}

fn sampleShadow(shadowUV: vec2f, layer: i32, depthRef: f32, normal: vec3f, lightDir: vec3f) -> f32 {
    var visibility: f32 = 0.0;
    let biasConstant: f32 = 0.001;
    let slopeBias = max(0.002 * (1.0 - dot(normal, lightDir)), 0.0);
    let bias = biasConstant + slopeBias;
    let oneOverSize = 1.0 / (shadowDepthTextureSize * 0.5);
    let offsets: array<vec2f, 9> = array<vec2f, 9>(
        vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),
        vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),
        vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0)
    );
    for(var i: u32 = 0u; i < 9u; i = i + 1u) {
        visibility += textureSampleCompare(
            shadowMapArray, shadowSampler,
            shadowUV + offsets[i] * oneOverSize,
            layer, depthRef - bias
        );
    }
    return visibility / 9.0;
}

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
    let norm = normalize(input.fragNorm);
    let viewDir = normalize(scene.cameraPos - input.fragPos);

    // ✅ now we declare materialData
    let materialData = getPBRMaterial(input.uv);

    // ✅ Early discard for fully transparent pixels (alpha cutoff)
    if (materialData.alpha < 0.01) {
        discard;
    }

    var lightContribution = vec3f(0.0);

    for (var i: u32 = 0u; i < MAX_SPOTLIGHTS; i = i + 1u) {
        let sc = spotlights[i].lightViewProj * vec4<f32>(input.fragPos, 1.0);
        let p  = sc.xyz / sc.w;
        let uv = clamp(p.xy * 0.5 + vec2<f32>(0.5), vec2<f32>(0.0), vec2<f32>(1.0));
        let depthRef = p.z * 0.5 + 0.5;

        let lightDir = normalize(spotlights[i].position - input.fragPos);
        let bias = spotlights[i].shadowBias;
        let visibility = sampleShadow(uv, i32(i), depthRef - bias, norm, lightDir);
        // let visibility = 1.0;
        let contrib = computeSpotLight(spotlights[i], norm, input.fragPos, viewDir, materialData);
        lightContribution += contrib * visibility;
    }

    let texColor = textureSample(meshTexture, meshSampler, input.uv);
    var finalColor = texColor.rgb * (scene.globalAmbient + lightContribution);

    // Apply per-instance tint
    finalColor *= input.colorMult.rgb;

    let N = normalize(input.fragNorm);
    let V = normalize(scene.cameraPos - input.fragPos);
    let fresnel = pow(1.0 - max(dot(N, V), 0.0), 3.0);

    // if (uSelected > 0.5) {
    //     let glowColor = vec3f(0.2, 0.8, 1.0);
    //     finalColor += glowColor * fresnel * 0.1;
    // }

    // let alpha = input.colorMult.a; // use alpha for blending
    // return vec4f(finalColor, alpha);

    let alpha = materialData.alpha;
    return vec4f(finalColor, alpha);
    // return vec4f(1.0, 0.0, 0.0, 0.1);
}`;

},{}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fragmentMirrorWGSLInstanced = void 0;
const fragmentMirrorWGSLInstanced = exports.fragmentMirrorWGSLInstanced = `
override shadowDepthTextureSize: f32 = 1024.0;
const PI: f32 = 3.141592653589793;

struct Scene {
    lightViewProjMatrix  : mat4x4f,
    cameraViewProjMatrix : mat4x4f,
    cameraPos            : vec3f,
    padding2             : f32,
    lightPos             : vec3f,
    padding              : f32,
    globalAmbient        : vec3f,
    padding3             : f32,
    time                 : f32,
    deltaTime            : f32,
    padding4             : vec2f,
};

struct SpotLight {
    position      : vec3f,
    _pad1         : f32,
    direction     : vec3f,
    _pad2         : f32,
    innerCutoff   : f32,
    outerCutoff   : f32,
    intensity     : f32,
    _pad3         : f32,
    color         : vec3f,
    _pad4         : f32,
    range         : f32,
    ambientFactor : f32,
    shadowBias    : f32,
    _pad5         : f32,
    lightViewProj : mat4x4<f32>,
};

struct MaterialPBR {
    baseColorFactor : vec4f,
    metallicFactor  : f32,
    roughnessFactor : f32,
    _pad1           : f32,
    _pad2           : f32,
};

struct PBRMaterialData {
    baseColor : vec3f,
    metallic  : f32,
    roughness : f32,
    alpha     : f32,
};

struct MirrorIlluminateParams {
    mirrorTint         : vec3f,
    reflectivity       : f32,
    illuminateColor    : vec3f,
    illuminateStrength : f32,
    illuminatePulse    : f32,
    fresnelPower       : f32,
    envLodBias         : f32,
    usePlanarReflection: f32,
    baseColorMix       : f32,
    _pad2              : vec3f,
};

const MAX_SPOTLIGHTS = 20u;

@group(0) @binding(0) var<uniform> scene                   : Scene;
@group(0) @binding(1) var          shadowMapArray          : texture_depth_2d_array;
@group(0) @binding(2) var          shadowSampler           : sampler_comparison;
@group(0) @binding(3) var          meshTexture             : texture_2d<f32>;
@group(0) @binding(4) var          meshSampler             : sampler;
@group(0) @binding(5) var<uniform> spotlights              : array<SpotLight, MAX_SPOTLIGHTS>;
@group(0) @binding(6) var          metallicRoughnessTex    : texture_2d<f32>;
@group(0) @binding(7) var          metallicRoughnessSampler: sampler;
@group(0) @binding(8) var<uniform> material                : MaterialPBR;

@group(2) @binding(0) var<uniform> mirrorParams    : MirrorIlluminateParams;
@group(2) @binding(1) var          mirrorEnvTex    : texture_2d<f32>;
@group(2) @binding(2) var          mirrorEnvSampler: sampler;

// ── INSTANCED: adds colorMult at location(4) ──────────────────────────────
struct FragmentInput {
    @location(0) shadowPos : vec4f,
    @location(1) fragPos   : vec3f,
    @location(2) fragNorm  : vec3f,
    @location(3) uv        : vec2f,
    @location(4) colorMult : vec4f,  // ← instanced only
};

fn getPBRMaterial(uv: vec2f) -> PBRMaterialData {
    let texColor  = textureSample(meshTexture, meshSampler, uv);
    let baseColor = texColor.rgb * material.baseColorFactor.rgb;
    let mrTex     = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);
    let metallic  = mrTex.b * material.metallicFactor;
    let roughness = mrTex.g * material.roughnessFactor;
    let alpha     = material.baseColorFactor.a;
    return PBRMaterialData(baseColor, metallic, roughness, alpha);
}

fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
    let a      = roughness * roughness;
    let a2     = a * a;
    let NdotH  = max(dot(N, H), 0.0);
    let NdotH2 = NdotH * NdotH;
    let denom  = (NdotH2 * (a2 - 1.0) + 1.0);
    return a2 / (PI * denom * denom);
}

fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
    let r = (roughness + 1.0);
    let k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
    let NdotV = max(dot(N, V), 0.0);
    let NdotL = max(dot(N, L), 0.0);
    return geometrySchlickGGX(NdotV, roughness) * geometrySchlickGGX(NdotL, roughness);
}

fn calculateSpotlightFactor(light: SpotLight, fragPos: vec3f) -> f32 {
    let L     = normalize(light.position - fragPos);
    let theta = dot(L, normalize(-light.direction));
    let eps   = light.innerCutoff - light.outerCutoff;
    return clamp((theta - light.outerCutoff) / eps, 0.0, 1.0);
}

fn computeSpotLight(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, mat: PBRMaterialData) -> vec3f {
    let L     = normalize(light.position - fragPos);
    let NdotL = max(dot(N, L), 0.0);
    let theta = dot(L, normalize(-light.direction));
    let eps   = light.innerCutoff - light.outerCutoff;
    var coneAtten = clamp((theta - light.outerCutoff) / eps, 0.0, 1.0);
    if (coneAtten <= 0.0 || NdotL <= 0.0) { return vec3f(0.0); }
    let F0    = mix(vec3f(0.04), mat.baseColor.rgb, vec3f(mat.metallic));
    let H     = normalize(L + V);
    let alpha  = mat.roughness * mat.roughness;
    let alpha2 = alpha * alpha;
    let NdotH  = max(dot(N, H), 0.0);
    let denom  = (NdotH * NdotH * (alpha2 - 1.0) + 1.0);
    let D      = alpha2 / (PI * denom * denom + 1e-5);
    let k      = (alpha + 1.0) * (alpha + 1.0) / 8.0;
    let NdotV  = max(dot(N, V), 0.0);
    let Gv     = NdotV / (NdotV * (1.0 - k) + k);
    let Gl     = NdotL / (NdotL * (1.0 - k) + k);
    let G      = Gv * Gl;
    let F      = F0 + (1.0 - F0) * pow(1.0 - max(dot(H, V), 0.0), 5.0);
    return mat.baseColor * light.color * light.intensity * NdotL * coneAtten;
}

fn computeMirrorSpecular(N: vec3f, V: vec3f, lightDir: vec3f, lightColor: vec3f) -> vec3f {
    let H       = normalize(lightDir + V);
    let mirrorR = max(0.02, material.roughnessFactor * 0.15);
    let D       = distributionGGX(N, H, mirrorR);
    let G       = geometrySmith(N, V, lightDir, mirrorR);
    let F0      = mix(vec3f(0.9), mirrorParams.mirrorTint, vec3f(material.metallicFactor));
    let F       = fresnelSchlick(max(dot(H, V), 0.0), F0);
    let NdotL   = max(dot(N, lightDir), 0.0);
    let NdotV   = max(dot(N, V), 0.0);
    let spec    = (D * G * F) / (4.0 * NdotV * NdotL + 1e-5);
    return spec * lightColor * NdotL * mirrorParams.reflectivity;
}

fn sampleShadow(shadowUV: vec2f, layer: i32, depthRef: f32, normal: vec3f, lightDir: vec3f) -> f32 {
    var visibility: f32 = 0.0;
    let biasConstant: f32 = 0.001;
    let slopeBias   = max(0.002 * (1.0 - dot(normal, lightDir)), 0.0);
    let bias        = biasConstant + slopeBias;
    let oneOverSize = 1.0 / (shadowDepthTextureSize * 0.5);
    let offsets: array<vec2f, 9> = array<vec2f, 9>(
        vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),
        vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),
        vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0)
    );
    for (var i: u32 = 0u; i < 9u; i++) {
        visibility += textureSampleCompare(
            shadowMapArray, shadowSampler,
            shadowUV + offsets[i] * oneOverSize,
            layer, depthRef - bias
        );
    }
    return visibility / 9.0;
}

fn reflectToEnvUV(R: vec3f, fragPos: vec3f) -> vec2f {
    let dir   = normalize(R);
    let phi   = atan2(dir.x, dir.z);
    let theta = acos(clamp(dir.y, -1.0, 1.0));
    let u     = phi / (2.0 * PI) + 0.5;
    let v     = theta / PI;
    return vec2f(u, v);
}

fn reflectToPlanarUV(fragPos: vec3f, N: vec3f, V: vec3f) -> vec2f {
    let clipPos = scene.cameraViewProjMatrix * vec4f(fragPos, 1.0);
    let ndc     = clipPos.xy / clipPos.w;
    return vec2f(ndc.x * 0.5 + 0.5, -ndc.y * 0.5 + 0.5);
}

fn sampleMirrorEnv(R: vec3f, fragPos: vec3f, N: vec3f, V: vec3f, roughness: f32) -> vec3f {
    var uv: vec2f;
    if (mirrorParams.usePlanarReflection > 0.5) {
        uv = reflectToPlanarUV(fragPos, N, V);
    } else {
        uv = reflectToEnvUV(R, fragPos);
    }
    return textureSample(mirrorEnvTex, mirrorEnvSampler, uv).rgb;
}

fn computeMirrorIlluminate(N: vec3f, V: vec3f, fragPos: vec3f) -> vec3f {
    // let NdotV = max(dot(N, V), 0.0);
    // let rim   = pow(1.0 - NdotV, mirrorParams.fresnelPower);
    // let pulse = mix(0.3, 1.0,
    //     (sin(scene.time * mirrorParams.illuminatePulse * 2.0 * PI) * 0.5 + 0.5)
    // );
    // let shimmer = sin(fragPos.y * 3.0 + scene.time * 2.0) * 0.15 + 0.85;
    // return mirrorParams.illuminateColor
    //      * mirrorParams.illuminateStrength
    //      * rim * pulse * shimmer;

     let NdotV = max(dot(N, V), 0.0);
    let rim   = pow(1.0 - NdotV, mirrorParams.fresnelPower);
    // NO scene.time — static version
    return mirrorParams.illuminateColor
         * mirrorParams.illuminateStrength
         * rim;
}

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {

    let N = normalize(input.fragNorm);
    let V = normalize(scene.cameraPos - input.fragPos);

    let materialData = getPBRMaterial(input.uv);
    if (materialData.alpha < 0.01) { discard; }

    var lightContribution = vec3f(0.0);

    for (var i: u32 = 0u; i < MAX_SPOTLIGHTS; i++) {
        let sc       = spotlights[i].lightViewProj * vec4<f32>(input.fragPos, 1.0);
        let p        = sc.xyz / sc.w;
        let shadowUV = clamp(p.xy * 0.5 + vec2<f32>(0.5), vec2<f32>(0.0), vec2<f32>(1.0));
        let depthRef = p.z * 0.5 + 0.5;
        let lightDir = normalize(spotlights[i].position - input.fragPos);
        let vis      = sampleShadow(shadowUV, i32(i), depthRef - spotlights[i].shadowBias, N, lightDir);
        let contrib  = computeSpotLight(spotlights[i], N, input.fragPos, V, materialData);
        lightContribution += contrib * vis;
        let mirrorSpec = computeMirrorSpecular(N, V, lightDir, spotlights[i].color * spotlights[i].intensity);
        let coneFactor = calculateSpotlightFactor(spotlights[i], input.fragPos);
        lightContribution += mirrorSpec * coneFactor * vis;
    }

    let R = reflect(-V, N);
    var envColor: vec3f;
    if (mirrorParams.baseColorMix < 0.01) {
        envColor = textureSample(mirrorEnvTex, mirrorEnvSampler, input.uv).rgb;
    } else {
        envColor = sampleMirrorEnv(R, input.fragPos, N, V, materialData.roughness) * mirrorParams.mirrorTint;
    }

    let envFresn   = fresnelSchlick(max(dot(N, V), 0.0),
                     mix(vec3f(0.04), vec3f(1.0), vec3f(materialData.metallic)));
    let texColor   = textureSample(meshTexture, meshSampler, input.uv);
    var finalColor = texColor.rgb * (scene.globalAmbient + lightContribution);

    finalColor = mix(envColor, finalColor, mirrorParams.baseColorMix);
    finalColor = mix(finalColor, envColor, envFresn * mirrorParams.reflectivity);

    finalColor *= input.colorMult.rgb;

    let illuminate = computeMirrorIlluminate(N, V, input.fragPos);
    finalColor += illuminate;

    let alpha = mix(materialData.alpha, 1.0, 0.5);
    return vec4f(finalColor, alpha);
}
`;

},{}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vertexWGSLInstanced = void 0;
let vertexWGSLInstanced = exports.vertexWGSLInstanced = `const MAX_BONES = 100u;
const MAX_INSTANCES = 10u; 

struct Scene {
  lightViewProjMatrix: mat4x4f,
  cameraViewProjMatrix: mat4x4f,
  lightPos: vec3f,
}

struct Model {
  modelMatrix: mat4x4f,
}

struct Bones {
  boneMatrices : array<mat4x4f, 1000u>
}

struct SkinResult {
  position : vec4f,
  normal   : vec3f,
};

struct InstanceData {
    model     : mat4x4<f32>,
    colorMult : vec4<f32>,
};

struct VertexAnimParams {
  time: f32,
  flags: f32,
  globalIntensity: f32,
  _pad0: f32,
  waveSpeed: f32,
  waveAmplitude: f32,
  waveFrequency: f32,
  _pad1: f32,
  windSpeed: f32,
  windStrength: f32,
  windHeightInfluence: f32,
  windTurbulence: f32,
  pulseSpeed: f32,
  pulseAmount: f32,
  pulseCenterX: f32,
  pulseCenterY: f32,
  twistSpeed: f32,
  twistAmount: f32,
  _pad2: f32,
  _pad3: f32,
  noiseScale: f32,
  noiseStrength: f32,
  noiseSpeed: f32,
  _pad4: f32,
  oceanWaveScale: f32,
  oceanWaveHeight: f32,
  oceanWaveSpeed: f32,
  _pad5: f32,
  displacementStrength: f32,
  displacementSpeed: f32,
  _pad6: f32,
  _pad7: f32,
}

@group(0) @binding(0) var<uniform> scene : Scene;
@group(1) @binding(0) var<storage, read> instances : array<InstanceData>;
@group(1) @binding(1) var<uniform> bones : Bones;
@group(1) @binding(2) var<uniform> vertexAnim : VertexAnimParams;

const ANIM_WAVE: u32  = 1u;
const ANIM_WIND: u32  = 2u;
const ANIM_PULSE: u32 = 4u;
const ANIM_TWIST: u32 = 8u;
const ANIM_NOISE: u32 = 16u;
const ANIM_OCEAN: u32 = 32u;

struct VertexOutput {
  @location(0) shadowPos: vec4f,
  @location(1) fragPos: vec3f,
  @location(2) fragNorm: vec3f,
  @location(3) uv: vec2f,
  @location(4) colorMult: vec4f,
  @builtin(position) Position: vec4f,
}

// fn skinVertex(pos: vec4f, nrm: vec3f, joints: vec4<u32>, weights: vec4f) -> SkinResult {
//     var skinnedPos  = vec4f(0.0);
//     var skinnedNorm = vec3f(0.0);
//     for (var i: u32 = 0u; i < 4u; i = i + 1u) {
//         let jointIndex = joints[i];
//         let w = weights[i];
//         if (w > 0.0) {
//           let boneMat  = bones.boneMatrices[jointIndex];
//           skinnedPos  += (boneMat * pos) * w;
//           let boneMat3 = mat3x3f(
//             boneMat[0].xyz,
//             boneMat[1].xyz,
//             boneMat[2].xyz
//           );
//           skinnedNorm += (boneMat3 * nrm) * w;
//         }
//     }
//     return SkinResult(skinnedPos, skinnedNorm);
// }

// 2. skinVertex gets instId passed in
fn skinVertex(pos: vec4f, nrm: vec3f, joints: vec4<u32>, weights: vec4f, instId: u32) -> SkinResult {
    var skinnedPos  = vec4f(0.0);
    var skinnedNorm = vec3f(0.0);
    for (var i: u32 = 0u; i < 4u; i = i + 1u) {
        let jointIndex = joints[i];
        let w = weights[i];
        if (w > 0.0) {
            let boneMat = bones.boneMatrices[instId * MAX_BONES + jointIndex]; // ← offset by instance
            skinnedPos  += (boneMat * pos) * w;
            let boneMat3 = mat3x3f(
                boneMat[0].xyz,
                boneMat[1].xyz,
                boneMat[2].xyz
            );
            skinnedNorm += (boneMat3 * nrm) * w;
        }
    }
    return SkinResult(skinnedPos, skinnedNorm);
}

fn hash(p: vec2f) -> f32 {
  var p3 = fract(vec3f(p.x, p.y, p.x) * 0.13);
  p3 += dot(p3, vec3f(p3.y, p3.z, p3.x) + 3.333);
  return fract((p3.x + p3.y) * p3.z);
}

fn noise(p: vec2f) -> f32 {
  let i = floor(p);
  let f = fract(p);
  let u = f * f * (3.0 - 2.0 * f);
  return mix(
    mix(hash(i + vec2f(0.0, 0.0)), hash(i + vec2f(1.0, 0.0)), u.x),
    mix(hash(i + vec2f(0.0, 1.0)), hash(i + vec2f(1.0, 1.0)), u.x),
    u.y
  );
}

fn applyWave(pos: vec3f) -> vec3f {
  let wave = sin(pos.x * vertexAnim.waveFrequency + vertexAnim.time * vertexAnim.waveSpeed) *
             cos(pos.z * vertexAnim.waveFrequency + vertexAnim.time * vertexAnim.waveSpeed);
  return vec3f(pos.x, pos.y + wave * vertexAnim.waveAmplitude, pos.z);
}

fn applyWind(pos: vec3f, normal: vec3f) -> vec3f {
  let heightFactor = max(0.0, pos.y) * vertexAnim.windHeightInfluence;
  let windDir = vec2f(
    sin(vertexAnim.time * vertexAnim.windSpeed),
    cos(vertexAnim.time * vertexAnim.windSpeed * 0.7)
  ) * vertexAnim.windStrength;
  let turbulence = noise(vec2f(pos.x, pos.z) * 0.5 + vertexAnim.time * 0.3)
                   * vertexAnim.windTurbulence;
  return vec3f(
    pos.x + windDir.x * heightFactor * (1.0 + turbulence),
    pos.y,
    pos.z + windDir.y * heightFactor * (1.0 + turbulence)
  );
}

fn applyPulse(pos: vec3f) -> vec3f {
  let pulse = sin(vertexAnim.time * vertexAnim.pulseSpeed) * vertexAnim.pulseAmount;
  let scale  = 1.0 + pulse;
  let center = vec3f(vertexAnim.pulseCenterX, 0.0, vertexAnim.pulseCenterY);
  return center + (pos - center) * scale;
}

fn applyTwist(pos: vec3f) -> vec3f {
  let angle = pos.y * vertexAnim.twistAmount * sin(vertexAnim.time * vertexAnim.twistSpeed);
  let cosA  = cos(angle);
  let sinA  = sin(angle);
  return vec3f(
    pos.x * cosA - pos.z * sinA,
    pos.y,
    pos.x * sinA + pos.z * cosA
  );
}

fn applyNoiseDisplacement(pos: vec3f) -> vec3f {
  let noiseVal    = noise(vec2f(pos.x, pos.z) * vertexAnim.noiseScale
                         + vertexAnim.time * vertexAnim.noiseSpeed);
  let displacement = (noiseVal - 0.5) * vertexAnim.noiseStrength;
  return vec3f(pos.x, pos.y + displacement, pos.z);
}

fn applyOcean(pos: vec3f) -> vec3f {
  let t     = vertexAnim.time * vertexAnim.oceanWaveSpeed;
  let scale = vertexAnim.oceanWaveScale;
  let wave1 = sin(dot(pos.xz, vec2f(1.0, 0.0)) * scale + t)             * vertexAnim.oceanWaveHeight;
  let wave2 = sin(dot(pos.xz, vec2f(0.7, 0.7)) * scale * 1.2 + t * 1.3) * vertexAnim.oceanWaveHeight * 0.7;
  let wave3 = sin(dot(pos.xz, vec2f(0.0, 1.0)) * scale * 0.8 + t * 0.9) * vertexAnim.oceanWaveHeight * 0.5;
  return vec3f(pos.x, pos.y + wave1 + wave2 + wave3, pos.z);
}

fn applyVertexAnimation(pos: vec3f, normal: vec3f) -> SkinResult {
  var animatedPos  = pos;
  var animatedNorm = normal;
  let flags = u32(vertexAnim.flags);

  if ((flags & ANIM_WAVE)  != 0u) { animatedPos = applyWave(animatedPos); }
  if ((flags & ANIM_WIND)  != 0u) { animatedPos = applyWind(animatedPos, animatedNorm); }
  if ((flags & ANIM_NOISE) != 0u) { animatedPos = applyNoiseDisplacement(animatedPos); }
  if ((flags & ANIM_OCEAN) != 0u) { animatedPos = applyOcean(animatedPos); }
  if ((flags & ANIM_PULSE) != 0u) { animatedPos = applyPulse(animatedPos); }
  if ((flags & ANIM_TWIST) != 0u) { animatedPos = applyTwist(animatedPos); }

  animatedPos = mix(pos, animatedPos, vertexAnim.globalIntensity);

  if (flags != 0u) {
    let offset  = 0.01;
    let posX    = applyWave(applyNoiseDisplacement(pos + vec3f(offset, 0.0, 0.0)));
    let posZ    = applyWave(applyNoiseDisplacement(pos + vec3f(0.0, 0.0, offset)));
    let tangentX = normalize(posX - animatedPos);
    let tangentZ = normalize(posZ - animatedPos);
    animatedNorm = normalize(cross(tangentZ, tangentX));
  }

  return SkinResult(vec4f(animatedPos, 1.0), animatedNorm);
}

@vertex
fn main(
  @location(0) position : vec3f,
  @location(1) normal   : vec3f,
  @location(2) uv       : vec2f,
  @location(3) joints   : vec4<u32>,
  @location(4) weights  : vec4<f32>,
  @builtin(instance_index) instId: u32
) -> VertexOutput {

  let inst = instances[instId];

  var output : VertexOutput;
  let skinned  = skinVertex(vec4(position, 1.0), normal, joints, weights, instId);
  let animated = applyVertexAnimation(skinned.position.xyz, skinned.normal);

  let worldPos = inst.model * animated.position;

  let normalMatrix = mat3x3f(
    inst.model[0].xyz,
    inst.model[1].xyz,
    inst.model[2].xyz
  );

  output.Position  = scene.cameraViewProjMatrix * worldPos;
  output.fragPos   = worldPos.xyz;
  output.shadowPos = scene.lightViewProjMatrix * worldPos;
  output.fragNorm  = normalize(normalMatrix * animated.normal);
  output.uv        = uv;
  output.colorMult = inst.colorMult;
  return output;
}`;

},{}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vertexShadowWGSLInstanced = void 0;
let vertexShadowWGSLInstanced = exports.vertexShadowWGSLInstanced = `
const MAX_BONES = 100u;

struct Scene {
  lightViewProjMatrix:  mat4x4f,
  cameraViewProjMatrix: mat4x4f,
  lightPos:             vec3f,
}

struct InstanceData {
  model: mat4x4<f32>,
};

struct Bones {
  boneMatrices: array<mat4x4f, MAX_BONES>
}

struct VertexAnimParams {
  time:                f32,
  flags:               f32,
  globalIntensity:     f32,
  _pad0:               f32,
  waveSpeed:           f32,
  waveAmplitude:       f32,
  waveFrequency:       f32,
  _pad1:               f32,
  windSpeed:           f32,
  windStrength:        f32,
  windHeightInfluence: f32,
  windTurbulence:      f32,
  pulseSpeed:          f32,
  pulseAmount:         f32,
  pulseCenterX:        f32,
  pulseCenterY:        f32,
  twistSpeed:          f32,
  twistAmount:         f32,
  _pad2:               f32,
  _pad3:               f32,
  noiseScale:          f32,
  noiseStrength:       f32,
  noiseSpeed:          f32,
  _pad4:               f32,
  oceanWaveScale:      f32,
  oceanWaveHeight:     f32,
  oceanWaveSpeed:      f32,
  _pad5:               f32,
  displacementStrength: f32,
  displacementSpeed:   f32,
  _pad6:               f32,
  _pad7:               f32,
}

@group(0) @binding(0) var<uniform>      scene      : Scene;
@group(1) @binding(0) var<storage,read> instances  : array<InstanceData>;
@group(1) @binding(1) var<uniform>      bones      : Bones;
@group(1) @binding(2) var<uniform>      vertexAnim : VertexAnimParams;

const ANIM_WAVE:  u32 = 1u;
const ANIM_WIND:  u32 = 2u;
const ANIM_PULSE: u32 = 4u;
const ANIM_TWIST: u32 = 8u;
const ANIM_NOISE: u32 = 16u;
const ANIM_OCEAN: u32 = 32u;

struct SkinResult {
  position: vec4f,
  normal:   vec3f,
};

fn hash(p: vec2f) -> f32 {
  var p3 = fract(vec3f(p.x, p.y, p.x) * 0.13);
  p3 += dot(p3, vec3f(p3.y, p3.z, p3.x) + 3.333);
  return fract((p3.x + p3.y) * p3.z);
}

fn noise(p: vec2f) -> f32 {
  let i = floor(p);
  let f = fract(p);
  let u = f * f * (3.0 - 2.0 * f);
  return mix(
    mix(hash(i + vec2f(0.0,0.0)), hash(i + vec2f(1.0,0.0)), u.x),
    mix(hash(i + vec2f(0.0,1.0)), hash(i + vec2f(1.0,1.0)), u.x),
    u.y
  );
}

fn skinVertex(pos: vec4f, nrm: vec3f, joints: vec4<u32>, weights: vec4f) -> SkinResult {
  var skinnedPos  = vec4f(0.0);
  var skinnedNorm = vec3f(0.0);
  for (var i: u32 = 0u; i < 4u; i++) {
    let w = weights[i];
    if (w > 0.0) {
      let boneMat  = bones.boneMatrices[joints[i]];
      skinnedPos  += (boneMat * pos) * w;
      skinnedNorm += (mat3x3f(boneMat[0].xyz, boneMat[1].xyz, boneMat[2].xyz) * nrm) * w;
    }
  }
  return SkinResult(skinnedPos, skinnedNorm);
}

fn applyWave(pos: vec3f) -> vec3f {
  let wave = sin(pos.x * vertexAnim.waveFrequency + vertexAnim.time * vertexAnim.waveSpeed) *
             cos(pos.z * vertexAnim.waveFrequency + vertexAnim.time * vertexAnim.waveSpeed);
  return vec3f(pos.x, pos.y + wave * vertexAnim.waveAmplitude, pos.z);
}

fn applyWind(pos: vec3f, normal: vec3f) -> vec3f {
  let heightFactor = max(0.0, pos.y) * vertexAnim.windHeightInfluence;
  let windDir = vec2f(
    sin(vertexAnim.time * vertexAnim.windSpeed),
    cos(vertexAnim.time * vertexAnim.windSpeed * 0.7)
  ) * vertexAnim.windStrength;
  let turbulence = noise(vec2f(pos.x, pos.z) * 0.5 + vertexAnim.time * 0.3) * vertexAnim.windTurbulence;
  return vec3f(
    pos.x + windDir.x * heightFactor * (1.0 + turbulence),
    pos.y,
    pos.z + windDir.y * heightFactor * (1.0 + turbulence)
  );
}

fn applyPulse(pos: vec3f) -> vec3f {
  let pulse = sin(vertexAnim.time * vertexAnim.pulseSpeed) * vertexAnim.pulseAmount;
  let center = vec3f(vertexAnim.pulseCenterX, 0.0, vertexAnim.pulseCenterY);
  return center + (pos - center) * (1.0 + pulse);
}

fn applyTwist(pos: vec3f) -> vec3f {
  let angle = pos.y * vertexAnim.twistAmount * sin(vertexAnim.time * vertexAnim.twistSpeed);
  let cosA = cos(angle); let sinA = sin(angle);
  return vec3f(pos.x * cosA - pos.z * sinA, pos.y, pos.x * sinA + pos.z * cosA);
}

fn applyNoiseDisplacement(pos: vec3f) -> vec3f {
  let noiseVal = noise(vec2f(pos.x, pos.z) * vertexAnim.noiseScale + vertexAnim.time * vertexAnim.noiseSpeed);
  return vec3f(pos.x, pos.y + (noiseVal - 0.5) * vertexAnim.noiseStrength, pos.z);
}

fn applyOcean(pos: vec3f) -> vec3f {
  let t = vertexAnim.time * vertexAnim.oceanWaveSpeed;
  let s = vertexAnim.oceanWaveScale;
  let w1 = sin(dot(pos.xz, vec2f(1.0, 0.0)) * s + t)           * vertexAnim.oceanWaveHeight;
  let w2 = sin(dot(pos.xz, vec2f(0.7, 0.7)) * s * 1.2 + t*1.3) * vertexAnim.oceanWaveHeight * 0.7;
  let w3 = sin(dot(pos.xz, vec2f(0.0, 1.0)) * s * 0.8 + t*0.9) * vertexAnim.oceanWaveHeight * 0.5;
  return vec3f(pos.x, pos.y + w1 + w2 + w3, pos.z);
}

fn applyVertexAnimation(pos: vec3f, normal: vec3f) -> SkinResult {
  var p = pos;
  let flags = u32(vertexAnim.flags);
  if ((flags & ANIM_WAVE)  != 0u) { p = applyWave(p); }
  if ((flags & ANIM_WIND)  != 0u) { p = applyWind(p, normal); }
  if ((flags & ANIM_NOISE) != 0u) { p = applyNoiseDisplacement(p); }
  if ((flags & ANIM_OCEAN) != 0u) { p = applyOcean(p); }
  if ((flags & ANIM_PULSE) != 0u) { p = applyPulse(p); }
  if ((flags & ANIM_TWIST) != 0u) { p = applyTwist(p); }
  p = mix(pos, p, vertexAnim.globalIntensity);
  return SkinResult(vec4f(p, 1.0), normal);
}

@vertex
fn main(
  @location(0) position: vec3f,
  @location(1) normal:   vec3f,
  @location(2) uv:       vec2f,
  @location(3) joints:   vec4<u32>,
  @location(4) weights:  vec4<f32>,
  @builtin(instance_index) instId: u32
) -> @builtin(position) vec4f {

  // Skinning
  let skinned  = skinVertex(vec4f(position, 1.0), normal, joints, weights);
  var finalPos = skinned.position.xyz;

  // Vertex animation
  if (u32(vertexAnim.flags) != 0u && vertexAnim.globalIntensity > 0.0) {
    let animated = applyVertexAnimation(finalPos, skinned.normal);
    finalPos = animated.position.xyz;
  }

  // Per-instance model matrix from storage buffer
  let worldPos = instances[instId].model * vec4f(finalPos, 1.0);
  return scene.lightViewProjMatrix * worldPos;
}
`;

},{}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fragmentWGSLMix1 = void 0;
let fragmentWGSLMix1 = exports.fragmentWGSLMix1 = `override shadowDepthTextureSize: f32 = 1024.0;
const PI: f32 = 3.141592653589793;

struct Scene {
    lightViewProjMatrix  : mat4x4f,
    cameraViewProjMatrix : mat4x4f,
    cameraPos            : vec3f,
    padding2             : f32,
    lightPos             : vec3f,
    padding              : f32,
    globalAmbient        : vec3f,
    padding3             : f32,
    time                 : f32,
    deltaTime            : f32,
    padding4             : vec2f,
};

struct SpotLight {
    position      : vec3f,
    _pad1         : f32,
    direction     : vec3f,
    _pad2         : f32,
    innerCutoff   : f32,
    outerCutoff   : f32,
    intensity     : f32,
    _pad3         : f32,
    color         : vec3f,
    _pad4         : f32,
    range         : f32,
    ambientFactor : f32,
    shadowBias    : f32,
    _pad5         : f32,
    lightViewProj : mat4x4<f32>,
};

struct MaterialPBR {
    baseColorFactor : vec4f,
    metallicFactor  : f32,
    roughnessFactor : f32,
    effectMix       : f32,
    lightingEnabled : f32,
};

struct PBRMaterialData {
    baseColor : vec3f,
    metallic  : f32,
    roughness : f32,
};

const MAX_SPOTLIGHTS = 20u;

@group(0) @binding(0) var<uniform> scene : Scene;
@group(0) @binding(1) var shadowMapArray: texture_depth_2d_array;
@group(0) @binding(2) var shadowSampler: sampler_comparison;
@group(0) @binding(3) var meshTexture: texture_2d<f32>;
@group(0) @binding(4) var meshSampler: sampler;
@group(0) @binding(5) var<uniform> spotlights: array<SpotLight, MAX_SPOTLIGHTS>;
@group(0) @binding(6) var metallicRoughnessTex: texture_2d<f32>;
@group(0) @binding(7) var metallicRoughnessSampler: sampler;
@group(0) @binding(8) var<uniform> material: MaterialPBR;
@group(0) @binding(9) var normalTexture: texture_2d<f32>;
@group(0) @binding(10) var normalSampler: sampler;

struct FragmentInput {
    @location(0) shadowPos : vec4f,
    @location(1) fragPos   : vec3f,
    @location(2) fragNorm  : vec3f,
    @location(3) uv        : vec2f,
    @builtin(position) position : vec4f,
};

fn getPBRMaterial(uv: vec2f) -> PBRMaterialData {
    let texColor = textureSample(meshTexture, meshSampler, uv);
    let baseColor = texColor.rgb * material.baseColorFactor.rgb;
    let mrTex = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);
    let metallic = mrTex.b * material.metallicFactor;
    let roughness = mrTex.g * material.roughnessFactor;
    return PBRMaterialData(baseColor, metallic, roughness);
}

fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
    let a = roughness * roughness;
    let a2 = a * a;
    let NdotH = max(dot(N, H), 0.0);
    let NdotH2 = NdotH * NdotH;
    let denom = (NdotH2 * (a2 - 1.0) + 1.0);
    return a2 / max(PI * denom * denom, 0.0001);
}

fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
    let r = (roughness + 1.0);
    let k = (r * r) / 8.0;
    return NdotV / max(NdotV * (1.0 - k) + k, 0.0001);
}

fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
    let NdotV = max(dot(N, V), 0.0);
    let NdotL = max(dot(N, L), 0.0);
    return geometrySchlickGGX(NdotV, roughness) * geometrySchlickGGX(NdotL, roughness);
}

// ===== SIMPLIFIED WORKING EFFECT =====

fn calculateEffect(fragCoord: vec2f, resolution: vec2f, time: f32) -> vec3f {
    // Normalize coordinates
    let uv = fragCoord.xy / resolution;
    let aspect = resolution.x / resolution.y;
    let p = (uv * 2.0 - 1.0) * vec2f(aspect, 1.0);
    
    var color = vec3f(0.0);
    
    // Simplified version - 5 iterations instead of 9x7
    for(var i: f32 = 0.0; i < 5.0; i = i + 1.0) {
        // Rotating coordinates
        let angle = time * 0.1 + i * 0.5;
        let c = cos(angle);
        let s = sin(angle);
        var pos = vec2f(
            p.x * c - p.y * s,
            p.x * s + p.y * c
        );
        
        // Add some warping
        pos += sin(pos.yx * 3.0 + time * 0.5) * 0.1;
        
        // Distance field
        let dist = length(pos) - 0.5 - i * 0.15;
        let rings = sin(dist * 10.0 - time * 2.0) * 0.5 + 0.5;
        
        // Color based on iteration and distance
        let hue = i / 5.0 + time * 0.1;
        color += vec3f(
            0.5 + 0.5 * sin(hue * 6.28),
            0.5 + 0.5 * sin(hue * 6.28 + 2.09),
            0.5 + 0.5 * sin(hue * 6.28 + 4.18)
        ) * rings * 0.3;
    }
    
    // Add some glow
    let centerDist = length(p);
    color += vec3f(0.1) / (centerDist * centerDist + 0.1);
    
    return clamp(color, vec3f(0.0), vec3f(1.0));
}

// ===== STANDARD PBR LIGHTING =====

fn calculatePBRLighting(materialData: PBRMaterialData, N: vec3f, V: vec3f, fragPos: vec3f) -> vec3f {
    var Lo = vec3f(0.0);
    
    for(var i: u32 = 0u; i < MAX_SPOTLIGHTS; i = i + 1u) {
        let L = normalize(spotlights[i].position - fragPos);
        let H = normalize(V + L);
        let distance = length(spotlights[i].position - fragPos);
        let attenuation = clamp(1.0 - (distance / max(spotlights[i].range, 0.1)), 0.0, 1.0);
        let radiance = spotlights[i].color * spotlights[i].intensity * attenuation;
        
        let NDF = distributionGGX(N, H, materialData.roughness);
        let G   = geometrySmith(N, V, L, materialData.roughness);
        let F0 = mix(vec3f(0.04), materialData.baseColor, materialData.metallic);
        let F  = fresnelSchlick(max(dot(H, V), 0.0), F0);
        
        let kS = F;
        let kD = (vec3f(1.0) - kS) * (1.0 - materialData.metallic);
        let diffuse  = kD * materialData.baseColor / PI;
        let NdotL = max(dot(N, L), 0.0);
        let specular = (NDF * G * F) / max(4.0 * max(dot(N, V), 0.0) * NdotL + 0.001, 0.001);
        
        Lo += (diffuse + specular) * radiance * NdotL;
    }
    
    return Lo;
}

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
    let materialData = getPBRMaterial(input.uv);
    let N = normalize(input.fragNorm);
    let V = normalize(scene.cameraPos - input.fragPos);
    
    let resolution = vec2f(1080.0, 687.0);
    
    var finalColor = vec3f(0.0);
    
    if (material.lightingEnabled > 0.5) {
        // Lighting enabled - calculate PBR
        let Lo = calculatePBRLighting(materialData, N, V, input.fragPos);
        let ambient = scene.globalAmbient * materialData.baseColor;
        let litColor = ambient + Lo;
        
        if (material.effectMix > 0.01) {
            // Blend with effect
            let effectColor = calculateEffect(input.position.xy, resolution, scene.time);
            finalColor = mix(litColor, effectColor, material.effectMix);
        } else {
            // Pure PBR
            finalColor = litColor;
        }
    } else {
        // Pure effect mode
        let effectColor = calculateEffect(input.position.xy, resolution, scene.time);
        // Modulate slightly by material color
        finalColor = effectColor * mix(vec3f(1.0), materialData.baseColor, 0.2);
    }
    
    return vec4f(finalColor, 1.0);
}
`;

},{}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.geoInstancedEffect = void 0;
const geoInstancedEffect = exports.geoInstancedEffect = `struct Camera {
  viewProjMatrix : mat4x4<f32>,
};
@group(0) @binding(0) var<uniform> camera : Camera;

// --- INSTANCE STORAGE BUFFER ----------------------------------------------
struct InstanceData {
  model : mat4x4<f32>,
  color : vec4<f32>,
};
@group(0) @binding(1) var<storage, read> instances : array<InstanceData>;

struct VertexInput {
  @location(0) position : vec3<f32>,
  @location(1) uv       : vec2<f32>,
};

struct VSOut {
  @builtin(position) Position : vec4<f32>,
  @location(0) v_uv : vec2<f32>,
  @location(1) v_color : vec4<f32>,
};

@vertex
fn vsMain(input : VertexInput, @builtin(instance_index) instanceIndex: u32) -> VSOut {
  var out : VSOut;

  // Use per-instance model matrix & color
  let modelMatrix = instances[instanceIndex].model;
  let color = instances[instanceIndex].color;

  let worldPos = modelMatrix * vec4<f32>(input.position,1.0);
  out.Position = camera.viewProjMatrix * worldPos;
  out.v_uv = input.uv;
  out.v_color = color;
  return out;
}

@fragment
fn fsMain(input : VSOut) -> @location(0) vec4<f32> {
  let uv = input.v_uv * 2.0 - vec2<f32>(1.0, 1.0);
  let dist = length(uv);
  let glow = exp(-dist * 1.0);
  let baseColor = vec3<f32>(0.2, 0.7, 1.0);
  let glowColor = vec3<f32>(0.7, 0.9, 1.0);
  let color = mix(baseColor, glowColor, glow) * glow * input.v_color.rgb;
  let alpha = input.v_color.a;
  return vec4<f32>(color, alpha);
}
`;

},{}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.geoInstancedTexEffect = void 0;
const geoInstancedTexEffect = exports.geoInstancedTexEffect = `
// === CAMERA & INSTANCE BUFFERS ============================================
struct Camera {
  viewProjMatrix : mat4x4<f32>,
};
@group(0) @binding(0) var<uniform> camera : Camera;

struct InstanceData {
  model : mat4x4<f32>,
  color : vec4<f32>,
};
@group(0) @binding(1) var<storage, read> instances : array<InstanceData>;

// === TEXTURE & SAMPLER ====================================================
@group(0) @binding(2) var mySampler : sampler;
@group(0) @binding(3) var myTexture : texture_2d<f32>;

// === VERTEX STAGE =========================================================
struct VertexInput {
  @location(0) position : vec3<f32>,
  @location(1) uv       : vec2<f32>,
};

struct VSOut {
  @builtin(position) Position : vec4<f32>,
  @location(0) v_uv : vec2<f32>,
  @location(1) v_color : vec4<f32>,
};

@vertex
fn vsMain(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> VSOut {
  var out : VSOut;
  let inst = instances[instanceIndex];

  let worldPos = inst.model * vec4<f32>(input.position, 1.0);
  out.Position = camera.viewProjMatrix * worldPos;
  out.v_uv = input.uv;
  out.v_color = inst.color;
  return out;
}

// === FRAGMENT STAGE =======================================================
@fragment
fn fsMain(input : VSOut) -> @location(0) vec4<f32> {

 // Adjust UV scaling and offset here
  let uvScale = vec2<f32>(1.3, 1.3);   // < 1.0 = zoom out (more texture visible)
  let uvOffset = vec2<f32>(0.01, 0.01); // move the texture slightly
  
  let adjustedUV = input.v_uv; // * uvScale + uvOffset; // make it like ring !

  let texColor = textureSample(myTexture, mySampler, adjustedUV);

  let uv = input.v_uv * 2.0 - vec2<f32>(1.0, 1.0);
  let dist = length(uv);
  let glow = exp(-dist * 1.2);
  let glowColor = mix(vec3<f32>(0.2, 0.7, 1.0), vec3<f32>(0.8, 0.95, 1.0), glow);

  let baseRGB = texColor.rgb * glowColor;
  let tintedRGB = mix(baseRGB, input.v_color.rgb, 0.8);
  let finalAlpha = texColor.a * input.v_color.a * glow;

  return vec4<f32>(tintedRGB, finalAlpha);

  // let texColor = textureSample(myTexture, mySampler, input.v_uv);

  // let uv = input.v_uv * 2.0 - vec2<f32>(1.0, 1.0);
  // let dist = length(uv);
  // let glow = exp(-dist * 1.2);
  // let glowColor = mix(vec3<f32>(0.2, 0.7, 1.0), vec3<f32>(0.8, 0.95, 1.0), glow);

  // // More balanced color blending:
  // let baseRGB = texColor.rgb * glowColor;
  // let tintedRGB = mix(baseRGB, input.v_color.rgb, 0.8); // 0.8 gives strong tint influence
  // let finalAlpha = texColor.a * input.v_color.a * glow;

  // return vec4<f32>(tintedRGB, finalAlpha);
}
`;

},{}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pointerEffect = void 0;
const pointerEffect = exports.pointerEffect = `
struct Camera {
  viewProjMatrix : mat4x4<f32>,
};
@group(0) @binding(0) var<uniform> camera : Camera;

struct Model {
  modelMatrix : mat4x4<f32>,
};
@group(0) @binding(1) var<uniform> model : Model;

struct VertexInput {
  @location(0) position : vec3<f32>,
  @location(1) uv       : vec2<f32>,
};

struct VSOut {
  @builtin(position) Position : vec4<f32>,
  @location(0) v_uv : vec2<f32>,
};

@vertex
fn vsMain(input : VertexInput) -> VSOut {
  var out : VSOut;
  let worldPos = model.modelMatrix * vec4<f32>(input.position,1.0);
  out.Position = camera.viewProjMatrix * worldPos;
  out.v_uv = input.uv;
  return out;
}

@fragment
fn fsMain(input : VSOut) -> @location(0) vec4<f32> {
  // Center the UVs (0.0–1.0 → -1.0–1.0)
  let uv = input.v_uv * 2.0 - vec2<f32>(1.0, 1.0);

  // Distance from center
  let dist = length(uv);

  // Glow falloff
  let glow = exp(-dist * 1.0); // try values 3.0–6.0 for tighter glow

  // Gradient color (inner bright → outer dim)
  let baseColor = vec3<f32>(0.2, 0.7, 1.0);
  let glowColor = vec3<f32>(0.7, 0.9, 1.0);

  // Blend based on glow strength
  let color = mix(baseColor, glowColor, glow) * glow;

  return vec4<f32>(color, 1.0);
}`;

},{}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pointEffectShader = void 0;
const pointEffectShader = exports.pointEffectShader = `struct Camera {
  viewProj : mat4x4<f32>
};
@group(0) @binding(0) var<uniform> camera : Camera;

struct ModelData {
  model : mat4x4<f32>,  // ✅ ADD MODEL MATRIX
};
@group(0) @binding(1) var<uniform> modelData : ModelData;

struct PointSettings {
  pointSize : f32,
  _padding : vec3<f32>,
};
@group(0) @binding(2) var<uniform> pointSettings : PointSettings;  // ✅ Move to binding 2

struct VSIn {
  @location(0) centerPos : vec3<f32>,
  @location(1) color : vec3<f32>,
  @builtin(vertex_index) vertexIdx : u32,
  @builtin(instance_index) instanceIdx : u32,
};

struct VSOut {
  @builtin(position) position : vec4<f32>,
  @location(0) color : vec3<f32>,
  @location(1) uv : vec2<f32>
};

@vertex
fn vsMain(input : VSIn) -> VSOut {
  var output : VSOut;
  
  let worldPos = modelData.model * vec4<f32>(input.centerPos, 1.0);
  let clipPos = camera.viewProj * worldPos;
  
  let corners = array<vec2<f32>, 4>(
    vec2(-1.0, -1.0),
    vec2( 1.0, -1.0),
    vec2(-1.0,  1.0),
    vec2( 1.0,  1.0)
  );
  
  // ✅ Generate UV coordinates (0-1 range)
  let uvs = array<vec2<f32>, 4>(
    vec2(0.0, 0.0),
    vec2(1.0, 0.0),
    vec2(0.0, 1.0),
    vec2(1.0, 1.0)
  );
  
  let offset = corners[input.vertexIdx] * pointSettings.pointSize;
  
  let viewportSize = vec2<f32>(1920.0, 1080.0);
  let ndcOffset = offset / viewportSize * 2.0;
  
  output.position = vec4<f32>(
    clipPos.xy + ndcOffset * clipPos.w,
    clipPos.z,
    clipPos.w
  );
  
  output.color = input.color;
  output.uv = uvs[input.vertexIdx];  // ✅ Pass UV
  return output;
}

@fragment
fn fsMain(input : VSOut) -> @location(0) vec4<f32> {
  let color = input.color * 0.5 + 0.5;
  
  // ✅ Circular point using UV
  let center = vec2<f32>(0.5, 0.5);
  let dist = length(input.uv - center);
  let alpha = 1.0 - smoothstep(0.4, 0.5, dist);
  
  // Discard pixels outside circle
  if (alpha < 0.01) {
    discard;
  }
  
  return vec4<f32>(color * alpha, alpha);
}`;

},{}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vertexWGSL = void 0;
let vertexWGSL = exports.vertexWGSL = `const MAX_BONES = 100u;

struct Scene {
  lightViewProjMatrix: mat4x4f,
  cameraViewProjMatrix: mat4x4f,
  lightPos: vec3f,
}

struct Model {
  modelMatrix: mat4x4f,
}

struct Bones {
  boneMatrices : array<mat4x4f, MAX_BONES>
}

struct SkinResult {
  position : vec4f,
  normal   : vec3f,
};

@group(0) @binding(0) var<uniform> scene : Scene;
@group(1) @binding(0) var<uniform> model : Model;
@group(1) @binding(1) var<uniform> bones : Bones;

struct VertexOutput {
  @location(0) shadowPos: vec4f,
  @location(1) fragPos: vec3f,
  @location(2) fragNorm: vec3f,
  @location(3) uv: vec2f,
  @builtin(position) Position: vec4f,
}

fn skinVertex(pos: vec4f, nrm: vec3f, joints: vec4<u32>, weights: vec4f) -> SkinResult {
    var skinnedPos = vec4f(0.0);
    var skinnedNorm = vec3f(0.0);
    for (var i: u32 = 0u; i < 4u; i = i + 1u) {
        let jointIndex = joints[i];
        let w = weights[i];
        if (w > 0.0) {
          let boneMat = bones.boneMatrices[jointIndex];
          skinnedPos  += (boneMat * pos) * w;
          let boneMat3 = mat3x3f(
            boneMat[0].xyz,
            boneMat[1].xyz,
            boneMat[2].xyz
          );
          skinnedNorm += (boneMat3 * nrm) * w;
        }
    }
    return SkinResult(skinnedPos, skinnedNorm);
}

// Add to your uniform structs at the top
struct VertexAnimParams {
  time: f32,
  flags: f32,
  globalIntensity: f32,
  _pad0: f32,
  
  // Wave [4-7]
  waveSpeed: f32,
  waveAmplitude: f32,
  waveFrequency: f32,
  _pad1: f32,
  
  // Wind [8-11]
  windSpeed: f32,
  windStrength: f32,
  windHeightInfluence: f32,
  windTurbulence: f32,
  
  // Pulse [12-15]
  pulseSpeed: f32,
  pulseAmount: f32,
  pulseCenterX: f32,
  pulseCenterY: f32,
  
  // Twist [16-19]
  twistSpeed: f32,
  twistAmount: f32,
  _pad2: f32,
  _pad3: f32,
  
  // Noise [20-23]
  noiseScale: f32,
  noiseStrength: f32,
  noiseSpeed: f32,
  _pad4: f32,
  
  // Ocean [24-27]
  oceanWaveScale: f32,
  oceanWaveHeight: f32,
  oceanWaveSpeed: f32,
  _pad5: f32,
  
  // Displacement [28-31]
  displacementStrength: f32,
  displacementSpeed: f32,
  _pad6: f32,
  _pad7: f32,
}

@group(1) @binding(2) var<uniform> vertexAnim : VertexAnimParams;

const ANIM_WAVE: u32 = 1u;
const ANIM_WIND: u32 = 2u;
const ANIM_PULSE: u32 = 4u;
const ANIM_TWIST: u32 = 8u;
const ANIM_NOISE: u32 = 16u;
const ANIM_OCEAN: u32 = 32u;

// Basic wave function - good starting point
fn applyWave(pos: vec3f) -> vec3f {
  let wave = sin(pos.x * vertexAnim.waveFrequency + vertexAnim.time * vertexAnim.waveSpeed) * 
             cos(pos.z * vertexAnim.waveFrequency + vertexAnim.time * vertexAnim.waveSpeed);
  return vec3f(pos.x, pos.y + wave * vertexAnim.waveAmplitude, pos.z);
}

fn applyWind(pos: vec3f, normal: vec3f) -> vec3f {
  let heightFactor = max(0.0, pos.y) * vertexAnim.windHeightInfluence;
  
  let windDir = vec2f(
    sin(vertexAnim.time * vertexAnim.windSpeed),
    cos(vertexAnim.time * vertexAnim.windSpeed * 0.7)
  ) * vertexAnim.windStrength;
  
  let turbulence = noise(vec2f(pos.x, pos.z) * 0.5 + vertexAnim.time * 0.3) 
                   * vertexAnim.windTurbulence;
  
  return vec3f(
    pos.x + windDir.x * heightFactor * (1.0 + turbulence),
    pos.y,
    pos.z + windDir.y * heightFactor * (1.0 + turbulence)
  );
}

fn applyPulse(pos: vec3f) -> vec3f {
  let pulse = sin(vertexAnim.time * vertexAnim.pulseSpeed) * vertexAnim.pulseAmount;
  let scale = 1.0 + pulse;
  
  let center = vec3f(vertexAnim.pulseCenterX, 0.0, vertexAnim.pulseCenterY);
  return center + (pos - center) * scale;
}

fn applyTwist(pos: vec3f) -> vec3f {
  let angle = pos.y * vertexAnim.twistAmount * sin(vertexAnim.time * vertexAnim.twistSpeed);
  
  let cosA = cos(angle);
  let sinA = sin(angle);
  
  return vec3f(
    pos.x * cosA - pos.z * sinA,
    pos.y,
    pos.x * sinA + pos.z * cosA
  );
}

// Simple noise function (you can replace with texture sampling later)
fn hash(p: vec2f) -> f32 {
  var p3 = fract(vec3f(p.x, p.y, p.x) * 0.13);
  p3 += dot(p3, vec3f(p3.y, p3.z, p3.x) + 3.333);
  return fract((p3.x + p3.y) * p3.z);
}

fn noise(p: vec2f) -> f32 {
  let i = floor(p);
  let f = fract(p);
  let u = f * f * (3.0 - 2.0 * f);
  return mix(
    mix(hash(i + vec2f(0.0, 0.0)), hash(i + vec2f(1.0, 0.0)), u.x),
    mix(hash(i + vec2f(0.0, 1.0)), hash(i + vec2f(1.0, 1.0)), u.x),
    u.y
  );
}

fn applyNoiseDisplacement(pos: vec3f) -> vec3f {
  let noiseVal = noise(vec2f(pos.x, pos.z) * vertexAnim.noiseScale 
                      + vertexAnim.time * vertexAnim.noiseSpeed);
  let displacement = (noiseVal - 0.5) * vertexAnim.noiseStrength;
  return vec3f(pos.x, pos.y + displacement, pos.z);
}

fn applyOcean(pos: vec3f) -> vec3f {
  let t = vertexAnim.time * vertexAnim.oceanWaveSpeed;
  let scale = vertexAnim.oceanWaveScale;
  
  let wave1 = sin(dot(pos.xz, vec2f(1.0, 0.0)) * scale + t) * vertexAnim.oceanWaveHeight;
  let wave2 = sin(dot(pos.xz, vec2f(0.7, 0.7)) * scale * 1.2 + t * 1.3) * vertexAnim.oceanWaveHeight * 0.7;
  let wave3 = sin(dot(pos.xz, vec2f(0.0, 1.0)) * scale * 0.8 + t * 0.9) * vertexAnim.oceanWaveHeight * 0.5;
  
  return vec3f(pos.x, pos.y + wave1 + wave2 + wave3, pos.z);
}

fn applyVertexAnimation(pos: vec3f, normal: vec3f) -> SkinResult {
  var animatedPos = pos;
  var animatedNorm = normal;
  let flags = u32(vertexAnim.flags);
  // Apply effects in order
  if ((flags & ANIM_WAVE) != 0u) {
    animatedPos = applyWave(animatedPos);
  }
  if ((flags & ANIM_WIND) != 0u) {
    animatedPos = applyWind(animatedPos, animatedNorm);
  }
  if ((flags & ANIM_NOISE) != 0u) {
    animatedPos = applyNoiseDisplacement(animatedPos);
  }
  if ((flags & ANIM_OCEAN) != 0u) {
    animatedPos = applyOcean(animatedPos);
  }
  if ((flags & ANIM_PULSE) != 0u) {
    animatedPos = applyPulse(animatedPos);
  }
  if ((flags & ANIM_TWIST) != 0u) {
    animatedPos = applyTwist(animatedPos);
  }
  // Apply global intensity (master volume control)
  animatedPos = mix(pos, animatedPos, vertexAnim.globalIntensity);
  // Recalculate normal
  if (flags != 0u) {
    let offset = 0.01;
    let posX = applyWave(applyNoiseDisplacement(pos + vec3f(offset, 0.0, 0.0)));
    let posZ = applyWave(applyNoiseDisplacement(pos + vec3f(0.0, 0.0, offset)));
    let tangentX = normalize(posX - animatedPos);
    let tangentZ = normalize(posZ - animatedPos);
    animatedNorm = normalize(cross(tangentZ, tangentX));
  }
  return SkinResult(vec4f(animatedPos, 1.0), animatedNorm);
}

@vertex
fn main(
  @location(0) position: vec3f,
  @location(1) normal: vec3f,
  @location(2) uv: vec2f,
  @location(3) joints: vec4<u32>,
  @location(4) weights: vec4<f32>
) -> VertexOutput {
  var output : VertexOutput;

  // 1. Skin first
  let skinned = skinVertex(vec4(position, 1.0), normal, joints, weights);

  // 2. Animate once, conditionally
  var finalPos  = skinned.position.xyz;
  var finalNorm = skinned.normal;

  if (u32(vertexAnim.flags) != 0u && vertexAnim.globalIntensity > 0.0) {
    let animated = applyVertexAnimation(finalPos, finalNorm);
    finalPos  = animated.position.xyz;
    finalNorm = animated.normal;
  }

  // 3. World-space transform
  let worldPos = model.modelMatrix * vec4f(finalPos, 1.0);
  let normalMatrix = mat3x3f(
    model.modelMatrix[0].xyz,
    model.modelMatrix[1].xyz,
    model.modelMatrix[2].xyz
  );

  output.Position  = scene.cameraViewProjMatrix * worldPos;
  output.fragPos   = worldPos.xyz;
  output.shadowPos = scene.lightViewProjMatrix * worldPos;
  output.fragNorm  = normalize(normalMatrix * finalNorm);
  output.uv        = uv;
  return output;
}`;

},{}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vertexWGSL_NM = void 0;
let vertexWGSL_NM = exports.vertexWGSL_NM = `const MAX_BONES = 100u;

struct Scene {
  lightViewProjMatrix: mat4x4f,
  cameraViewProjMatrix: mat4x4f,
  lightPos: vec3f,
}

struct Model {
  modelMatrix: mat4x4f,
}

struct Bones {
  boneMatrices : array<mat4x4f, MAX_BONES>
}

struct SkinResult {
  position : vec4f,
  normal   : vec3f,
};

@group(0) @binding(0) var<uniform> scene : Scene;
@group(1) @binding(0) var<uniform> model : Model;
@group(1) @binding(1) var<uniform> bones : Bones;

struct VertexOutput {
  @location(0) shadowPos: vec4f,
  @location(1) fragPos: vec3f,
  @location(2) fragNorm: vec3f,
  @location(3) uv: vec2f,
  @location(4) tangent: vec4f,      // NEW
  @builtin(position) Position: vec4f,
}

fn skinVertex(pos: vec4f, nrm: vec3f, joints: vec4<u32>, weights: vec4f) -> SkinResult {
    var skinnedPos = vec4f(0.0);
    var skinnedNorm = vec3f(0.0);
    for (var i: u32 = 0u; i < 4u; i = i + 1u) {
        let jointIndex = joints[i];
        let w = weights[i];
        if (w > 0.0) {
          let boneMat = bones.boneMatrices[jointIndex];
          skinnedPos  += (boneMat * pos) * w;
          let boneMat3 = mat3x3f(
            boneMat[0].xyz,
            boneMat[1].xyz,
            boneMat[2].xyz
          );
          skinnedNorm += (boneMat3 * nrm) * w;
        }
    }
    return SkinResult(skinnedPos, skinnedNorm);
}

@vertex
fn main(
  @location(0) position: vec3f,
  @location(1) normal: vec3f,
  @location(2) uv: vec2f,
  @location(3) joints: vec4<u32>,
  @location(4) weights: vec4<f32>,
  @location(5) tangent: vec4f               // NEW
) -> VertexOutput {
  var output : VertexOutput;
  
  // Skin positions & normals
  var pos = vec4(position, 1.0);
  var nrm = normal;
  let skinned = skinVertex(pos, nrm, joints, weights);

  // Skin tangent
  var skinnedTangent = vec3f(tangent.xyz);
  for (var i: u32 = 0u; i < 4u; i = i + 1u) {
      let jointIndex = joints[i];
      let w = weights[i];
      if (w > 0.0) {
          let boneMat = bones.boneMatrices[jointIndex];
          let boneMat3 = mat3x3f(
              boneMat[0].xyz,
              boneMat[1].xyz,
              boneMat[2].xyz
          );
          skinnedTangent += (boneMat3 * tangent.xyz) * w;
      }
  }

  // Transform to world space
  let worldPos = model.modelMatrix * skinned.position;
  let normalMatrix = mat3x3f(
      model.modelMatrix[0].xyz,
      model.modelMatrix[1].xyz,
      model.modelMatrix[2].xyz
  );

  output.Position = scene.cameraViewProjMatrix * worldPos;
  output.fragPos = worldPos.xyz;
  output.shadowPos = scene.lightViewProjMatrix * worldPos;
  output.fragNorm = normalize(normalMatrix * skinned.normal);
  output.uv = uv;
  output.tangent = vec4(normalize(skinnedTangent), tangent.w);  // OUTPUT tangent

  return output;
}`;

},{}],82:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vertexShadowWGSL = void 0;
let vertexShadowWGSL = exports.vertexShadowWGSL = `
const MAX_BONES = 100u;

struct Scene {
  lightViewProjMatrix: mat4x4f,
  cameraViewProjMatrix: mat4x4f,
  lightPos: vec3f,
}

struct Model {
  modelMatrix: mat4x4f,
}

struct Bones {
  boneMatrices : array<mat4x4f, MAX_BONES>
}

struct VertexAnimParams {
  time: f32,
  flags: f32,
  globalIntensity: f32,
  _pad0: f32,
  
  // Wave [4-7]
  waveSpeed: f32,
  waveAmplitude: f32,
  waveFrequency: f32,
  _pad1: f32,
  
  // Wind [8-11]
  windSpeed: f32,
  windStrength: f32,
  windHeightInfluence: f32,
  windTurbulence: f32,
  
  // Pulse [12-15]
  pulseSpeed: f32,
  pulseAmount: f32,
  pulseCenterX: f32,
  pulseCenterY: f32,
  
  // Twist [16-19]
  twistSpeed: f32,
  twistAmount: f32,
  _pad2: f32,
  _pad3: f32,
  
  // Noise [20-23]
  noiseScale: f32,
  noiseStrength: f32,
  noiseSpeed: f32,
  _pad4: f32,
  
  // Ocean [24-27]
  oceanWaveScale: f32,
  oceanWaveHeight: f32,
  oceanWaveSpeed: f32,
  _pad5: f32,
  
  // Displacement [28-31]
  displacementStrength: f32,
  displacementSpeed: f32,
  _pad6: f32,
  _pad7: f32,
}

@group(0) @binding(0) var<uniform> scene : Scene;
@group(1) @binding(0) var<uniform> model : Model;
@group(1) @binding(1) var<uniform> bones : Bones;
@group(1) @binding(2) var<uniform> vertexAnim : VertexAnimParams;

const ANIM_WAVE: u32 = 1u;
const ANIM_WIND: u32 = 2u;
const ANIM_PULSE: u32 = 4u;
const ANIM_TWIST: u32 = 8u;
const ANIM_NOISE: u32 = 16u;
const ANIM_OCEAN: u32 = 32u;

struct SkinResult {
  position : vec4f,
  normal   : vec3f,
};

fn skinVertex(pos: vec4f, nrm: vec3f, joints: vec4<u32>, weights: vec4f) -> SkinResult {
    var skinnedPos = vec4f(0.0);
    var skinnedNorm = vec3f(0.0);
    
    for (var i: u32 = 0u; i < 4u; i = i + 1u) {
        let jointIndex = joints[i];
        let w = weights[i];
        if (w > 0.0) {
          let boneMat = bones.boneMatrices[jointIndex];
          skinnedPos  += (boneMat * pos) * w;
          let boneMat3 = mat3x3f(
            boneMat[0].xyz,
            boneMat[1].xyz,
            boneMat[2].xyz
          );
          skinnedNorm += (boneMat3 * nrm) * w;
        }
    }
    
    return SkinResult(skinnedPos, skinnedNorm);
}

// Hash function for noise
fn hash(p: vec2f) -> f32 {
  var p3 = fract(vec3f(p.x, p.y, p.x) * 0.13);
  p3 += dot(p3, vec3f(p3.y, p3.z, p3.x) + 3.333);
  return fract((p3.x + p3.y) * p3.z);
}

// Noise function
fn noise(p: vec2f) -> f32 {
  let i = floor(p);
  let f = fract(p);
  let u = f * f * (3.0 - 2.0 * f);
  return mix(
    mix(hash(i + vec2f(0.0, 0.0)), hash(i + vec2f(1.0, 0.0)), u.x),
    mix(hash(i + vec2f(0.0, 1.0)), hash(i + vec2f(1.0, 1.0)), u.x),
    u.y
  );
}

// Wave animation
fn applyWave(pos: vec3f) -> vec3f {
  let wave = sin(pos.x * vertexAnim.waveFrequency + vertexAnim.time * vertexAnim.waveSpeed) * 
             cos(pos.z * vertexAnim.waveFrequency + vertexAnim.time * vertexAnim.waveSpeed);
  return vec3f(pos.x, pos.y + wave * vertexAnim.waveAmplitude, pos.z);
}

// Wind animation
fn applyWind(pos: vec3f, normal: vec3f) -> vec3f {
  let heightFactor = max(0.0, pos.y) * vertexAnim.windHeightInfluence;
  
  let windDir = vec2f(
    sin(vertexAnim.time * vertexAnim.windSpeed),
    cos(vertexAnim.time * vertexAnim.windSpeed * 0.7)
  ) * vertexAnim.windStrength;
  
  let turbulence = noise(vec2f(pos.x, pos.z) * 0.5 + vertexAnim.time * 0.3) 
                   * vertexAnim.windTurbulence;
  
  return vec3f(
    pos.x + windDir.x * heightFactor * (1.0 + turbulence),
    pos.y,
    pos.z + windDir.y * heightFactor * (1.0 + turbulence)
  );
}

// Pulse animation
fn applyPulse(pos: vec3f) -> vec3f {
  let pulse = sin(vertexAnim.time * vertexAnim.pulseSpeed) * vertexAnim.pulseAmount;
  let scale = 1.0 + pulse;
  
  let center = vec3f(vertexAnim.pulseCenterX, 0.0, vertexAnim.pulseCenterY);
  return center + (pos - center) * scale;
}

// Twist animation
fn applyTwist(pos: vec3f) -> vec3f {
  let angle = pos.y * vertexAnim.twistAmount * sin(vertexAnim.time * vertexAnim.twistSpeed);
  
  let cosA = cos(angle);
  let sinA = sin(angle);
  
  return vec3f(
    pos.x * cosA - pos.z * sinA,
    pos.y,
    pos.x * sinA + pos.z * cosA
  );
}

// Noise displacement
fn applyNoiseDisplacement(pos: vec3f) -> vec3f {
  let noiseVal = noise(vec2f(pos.x, pos.z) * vertexAnim.noiseScale 
                      + vertexAnim.time * vertexAnim.noiseSpeed);
  let displacement = (noiseVal - 0.5) * vertexAnim.noiseStrength;
  return vec3f(pos.x, pos.y + displacement, pos.z);
}

// Ocean waves
fn applyOcean(pos: vec3f) -> vec3f {
  let t = vertexAnim.time * vertexAnim.oceanWaveSpeed;
  let scale = vertexAnim.oceanWaveScale;
  
  let wave1 = sin(dot(pos.xz, vec2f(1.0, 0.0)) * scale + t) * vertexAnim.oceanWaveHeight;
  let wave2 = sin(dot(pos.xz, vec2f(0.7, 0.7)) * scale * 1.2 + t * 1.3) * vertexAnim.oceanWaveHeight * 0.7;
  let wave3 = sin(dot(pos.xz, vec2f(0.0, 1.0)) * scale * 0.8 + t * 0.9) * vertexAnim.oceanWaveHeight * 0.5;
  
  return vec3f(pos.x, pos.y + wave1 + wave2 + wave3, pos.z);
}

// Combined vertex animation
fn applyVertexAnimation(pos: vec3f, normal: vec3f) -> SkinResult {
  var animatedPos = pos;
  var animatedNorm = normal;
  
  let flags = u32(vertexAnim.flags);
  
  // Apply effects in order
  if ((flags & ANIM_WAVE) != 0u) {
    animatedPos = applyWave(animatedPos);
  }
  
  if ((flags & ANIM_WIND) != 0u) {
    animatedPos = applyWind(animatedPos, animatedNorm);
  }
  
  if ((flags & ANIM_NOISE) != 0u) {
    animatedPos = applyNoiseDisplacement(animatedPos);
  }
  
  if ((flags & ANIM_OCEAN) != 0u) {
    animatedPos = applyOcean(animatedPos);
  }
  
  if ((flags & ANIM_PULSE) != 0u) {
    animatedPos = applyPulse(animatedPos);
  }
  
  if ((flags & ANIM_TWIST) != 0u) {
    animatedPos = applyTwist(animatedPos);
  }
  
  // Apply global intensity
  animatedPos = mix(pos, animatedPos, vertexAnim.globalIntensity);
  
  // For shadows, we can skip expensive normal recalculation
  // Shadows don't need perfect normals
  
  return SkinResult(vec4f(animatedPos, 1.0), animatedNorm);
}

@vertex
fn main(
  @location(0) position: vec3f,
  @location(1) normal: vec3f,
  @location(2) uv: vec2f,
  @location(3) joints: vec4<u32>,
  @location(4) weights: vec4<f32>
) -> @builtin(position) vec4f {
  var pos = vec4(position, 1.0);
  var nrm = normal;
  
  // Apply skinning
  let skinned = skinVertex(pos, nrm, joints, weights);
  var finalPos = skinned.position.xyz;
  
  // Apply vertex animation if any flags are set
  if (u32(vertexAnim.flags) != 0u && vertexAnim.globalIntensity > 0.0) {
    let animated = applyVertexAnimation(finalPos, skinned.normal);
    finalPos = animated.position.xyz;
  }
  
  let worldPos = model.modelMatrix * vec4f(finalPos, 1.0);
  return scene.lightViewProjMatrix * worldPos;
}
`;

},{}],83:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fragmentWaterWGSL = void 0;
let fragmentWaterWGSL = exports.fragmentWaterWGSL = `
/* === Engine uniforms === */

// DINAMIC GLOBALS
const PI: f32 = 3.141592653589793;
override shadowDepthTextureSize: f32 = 1024.0;

// DINAMIC STRUCTS


// PREDEFINED
struct Scene {
    lightViewProjMatrix  : mat4x4f,
    cameraViewProjMatrix : mat4x4f,
    cameraPos            : vec3f,
    padding2             : f32,
    lightPos             : vec3f,
    padding              : f32,
    globalAmbient        : vec3f,
    padding3             : f32,
    time                 : f32,
    deltaTime            : f32,
    padding4             : vec2f,
};

// PREDEFINED
struct SpotLight {
    position      : vec3f,
    _pad1         : f32,
    direction     : vec3f,
    _pad2         : f32,
    innerCutoff   : f32,
    outerCutoff   : f32,
    intensity     : f32,
    _pad3         : f32,
    color         : vec3f,
    _pad4         : f32,
    range         : f32,
    ambientFactor : f32,
    shadowBias    : f32,
    _pad5         : f32,
    lightViewProj : mat4x4<f32>,
};

// PREDEFINED
struct MaterialPBR {
    baseColorFactor : vec4f,
    metallicFactor  : f32,
    roughnessFactor : f32,
    _pad1           : f32,
    _pad2           : f32,
};

// PREDEFINED
struct PBRMaterialData {
    baseColor : vec3f,
    metallic  : f32,
    roughness : f32,
};

// PREDEFINED
const MAX_SPOTLIGHTS = 20u;

// PREDEFINED
@group(0) @binding(0) var<uniform> scene : Scene;
@group(0) @binding(1) var shadowMapArray: texture_depth_2d_array;
@group(0) @binding(2) var shadowSampler: sampler_comparison;
@group(0) @binding(3) var meshTexture: texture_2d<f32>;
@group(0) @binding(4) var meshSampler: sampler;
@group(0) @binding(5) var<uniform> spotlights: array<SpotLight, MAX_SPOTLIGHTS>;
@group(0) @binding(6) var metallicRoughnessTex: texture_2d<f32>;
@group(0) @binding(7) var metallicRoughnessSampler: sampler;
@group(0) @binding(8) var<uniform> material: MaterialPBR;

// ✅ Graph custom uniforms
struct WaterParams {
    deepColor     : vec3f,
    waveSpeed     : f32,
    shallowColor  : vec3f,
    waveScale     : f32,
    waveHeight    : f32,
    fresnelPower  : f32,
    specularPower : f32,
    _pad1         : f32,
};

@group(3) @binding(0) var<uniform> waterParams: WaterParams;

// ✅ Graph custom functions

// Gerstner wave function for realistic water waves
fn gerstnerWave(pos: vec2f, direction: vec2f, steepness: f32, wavelength: f32, time: f32) -> vec3f {
    let k = 2.0 * PI / wavelength;
    let c = sqrt(9.8 / k);
    let d = normalize(direction);
    let f = k * (dot(d, pos) - c * time);
    let a = steepness / k;
    
    return vec3f(
        d.x * a * cos(f),
        a * sin(f),
        d.y * a * cos(f)
    );
}

// Simpler sine wave for smoother animation
fn sineWave(pos: vec2f, direction: vec2f, amplitude: f32, frequency: f32, time: f32) -> vec3f {
    let d = normalize(direction);
    let phase = dot(d, pos) * frequency - time;
    
    return vec3f(
        d.x * amplitude * cos(phase),
        amplitude * sin(phase),
        d.y * amplitude * cos(phase)
    );
}

// Calculate water normal from multiple waves
fn calculateWaterNormal(worldPos: vec3f, time: f32) -> vec3f {
    let pos = worldPos.xz * waterParams.waveScale;
    let t = time * waterParams.waveSpeed;
    
    // Use smoother sine waves instead of Gerstner for better animation
    let wave1 = sineWave(pos, vec2f(1.0, 0.0), 0.3, 2.0, t);
    let wave2 = sineWave(pos, vec2f(0.0, 1.0), 0.25, 1.8, t * 1.13);
    let wave3 = sineWave(pos, vec2f(0.707, 0.707), 0.2, 1.5, t * 0.87);
    let wave4 = sineWave(pos, vec2f(-0.5, 0.866), 0.15, 1.2, t * 1.27);
    
    // Sum waves
    let offset = (wave1 + wave2 + wave3 + wave4) * waterParams.waveHeight;
    
    // Calculate tangent vectors using small step size
    let eps = 0.1;
    let posX = worldPos + vec3f(eps, 0.0, 0.0);
    let posZ = worldPos + vec3f(0.0, 0.0, eps);
    
    let offsetX = (
        sineWave(posX.xz * waterParams.waveScale, vec2f(1.0, 0.0), 0.3, 2.0, t) +
        sineWave(posX.xz * waterParams.waveScale, vec2f(0.0, 1.0), 0.25, 1.8, t * 1.13) +
        sineWave(posX.xz * waterParams.waveScale, vec2f(0.707, 0.707), 0.2, 1.5, t * 0.87) +
        sineWave(posX.xz * waterParams.waveScale, vec2f(-0.5, 0.866), 0.15, 1.2, t * 1.27)
    ) * waterParams.waveHeight;
    
    let offsetZ = (
        sineWave(posZ.xz * waterParams.waveScale, vec2f(1.0, 0.0), 0.3, 2.0, t) +
        sineWave(posZ.xz * waterParams.waveScale, vec2f(0.0, 1.0), 0.25, 1.8, t * 1.13) +
        sineWave(posZ.xz * waterParams.waveScale, vec2f(0.707, 0.707), 0.2, 1.5, t * 0.87) +
        sineWave(posZ.xz * waterParams.waveScale, vec2f(-0.5, 0.866), 0.15, 1.2, t * 1.27)
    ) * waterParams.waveHeight;
    
    let tangentX = normalize(vec3f(eps, offsetX.y - offset.y, 0.0));
    let tangentZ = normalize(vec3f(0.0, offsetZ.y - offset.y, eps));
    
    return normalize(cross(tangentZ, tangentX));
}

// Fresnel effect for water reflections
fn fresnelSchlick(cosTheta: f32, F0: f32) -> f32 {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, waterParams.fresnelPower);
}

// PREDEFINED Fragment input
struct FragmentInput {
    @location(0) shadowPos : vec4f,
    @location(1) fragPos   : vec3f,
    @location(2) fragNorm  : vec3f,
    @location(3) uv        : vec2f,
};

// PREDEFINED PBR helpers
fn getPBRMaterial(uv: vec2f) -> PBRMaterialData {
    let texColor = textureSample(meshTexture, meshSampler, uv);
    let baseColor = texColor.rgb * material.baseColorFactor.rgb;
    let mrTex = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);
    let metallic = mrTex.b * material.metallicFactor;
    let roughness = mrTex.g * material.roughnessFactor;
    return PBRMaterialData(baseColor, metallic, roughness);
}

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
    // Calculate animated water normal
    let waterNormal = calculateWaterNormal(input.fragPos, scene.time);
    
    // View direction
    let viewDir = normalize(scene.cameraPos - input.fragPos);
    
    // Fresnel effect (0 = looking straight down, 1 = grazing angle)
    let fresnel = fresnelSchlick(max(dot(waterNormal, viewDir), 0.0), 0.02);
    
    // Light direction
    let lightDir = normalize(scene.lightPos - input.fragPos);
    
    // Diffuse lighting
    let diff = max(dot(waterNormal, lightDir), 0.0);
    
    // Specular (sun reflection on water)
    let halfDir = normalize(lightDir + viewDir);
    let spec = pow(max(dot(waterNormal, halfDir), 0.0), waterParams.specularPower);
    
    // Mix deep and shallow water colors based on fresnel
    let waterColor = mix(waterParams.deepColor, waterParams.shallowColor, fresnel * 0.5 + 0.5);
    
    // Enhanced lighting for more visible effect
    let ambient = scene.globalAmbient * waterColor * 0.3;
    let diffuse = diff * waterColor * 1.2;
    let specular = spec * vec3f(1.0, 1.0, 1.0) * fresnel * 2.0;
    
    // Enhanced foam on wave peaks
    // let foamAmount = pow(max(waterNormal.y - 0.6, 0.0), 2.0) * 0.8;
    // let foam = vec3f(1.0, 1.0, 1.0) * foamAmount;

    // WITH this — mode flag based on waveSpeed (fast = fire, slow = water):
    let isFireMode = f32(waterParams.waveSpeed > 1.5);

    // Water foam — white peaks
    let foamAmount = pow(max(waterNormal.y - 0.6, 0.0), 2.0) * 0.8 * (1.0 - isFireMode);
    let foam = vec3f(1.0, 1.0, 1.0) * foamAmount;

    // Fire embers — bright yellow-white tips
    let emberAmount = pow(max(waterNormal.y - 0.5, 0.0), 1.5) * 2.0 * isFireMode;
    let ember = vec3f(1.0, 0.95, 0.5) * emberAmount;

    
    // Add some caustics-like effect based on waves
    let caustics = sin(input.fragPos.x * 10.0 + scene.time * 2.0) * 
                   sin(input.fragPos.z * 10.0 + scene.time * 2.0) * 0.15 + 0.15;
    let causticsColor = waterColor * caustics;
    
    // Final color with enhanced effects
    let finalColor = ambient + diffuse + specular + foam +  ember +  causticsColor;
    
    // MUCH more transparent - alpha between 0.2 and 0.5
    let alpha = mix(0.2, 0.5, fresnel);
    
    // Make the color more vibrant so it's visible even when transparent
    let vibrantColor = finalColor * 1.5;
    
    return vec4f(vibrantColor, alpha);
}`;

},{}],84:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MatrixMusicAsset = exports.AudioAssetManager = void 0;
class AudioAssetManager {
  constructor() {
    this.assets = new Map();
    this.loading = new Map();
  }
  load(path, options = {}) {
    if (this.assets.has(path)) {
      return Promise.resolve(this.assets.get(path));
    }
    if (this.loading.has(path)) {
      return this.loading.get(path);
    }
    const asset = new MatrixMusicAsset({
      path,
      ...options
    });
    const promise = asset.init().then(a => {
      this.assets.set(path, a);
      this.loading.delete(path);
      return a;
    });
    this.loading.set(path, promise);
    return promise;
  }
}
exports.AudioAssetManager = AudioAssetManager;
class MatrixMusicAsset {
  constructor({
    path,
    autoplay = true,
    containerId = null
  }) {
    this.path = path;
    this.autoplay = autoplay;
    this.containerId = containerId;
    this.audio = null;
    this.ctx = null;
    this.source = null;
    this.gain = null;
    this.filter = null;
    this.analyser = null;
    this.frequencyData = null;
    this.ready = false;
  }
  async init() {
    this.audio = document.createElement("audio");
    this.audio.id = this.path;
    this.audio.src = `res/audios/${this.path}`;
    this.audio.autoplay = this.autoplay;
    this.audio.playsInline = true;
    this.audio.controls = true;
    (this.containerId ? document.getElementById(this.containerId) : document.body)?.appendChild(this.audio);
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    this.ctx = new AudioCtx();
    if (this.ctx.state === "suspended") {
      await this.ctx.resume();
    }
    this.source = this.ctx.createMediaElementSource(this.audio);
    this.gain = this.ctx.createGain();
    this.filter = this.ctx.createBiquadFilter();
    this.analyser = this.ctx.createAnalyser();
    this.filter.frequency.value = 5000;
    this.analyser.fftSize = 2048;
    this.source.connect(this.gain).connect(this.filter).connect(this.ctx.destination);
    this.source.connect(this.analyser);
    this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);
    try {
      await this.audio.play();
    } catch {}
    this.ready = true;
    return this;
  }
  updateFFT() {
    if (!this.ready) return null;
    this.analyser.getByteFrequencyData(this.frequencyData);
    return this.frequencyData;
  }
}
exports.MatrixMusicAsset = MatrixMusicAsset;

},{}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MatrixSounds = void 0;
class MatrixSounds {
  constructor() {
    this.volume = 0.5;
    this.audios = {};
    this.enabled = true; // 🔇 global flag to mute/allow audio
  }
  muteAll() {
    this.enabled = false;
    Object.values(this.audios).forEach(audio => audio.pause());
  }
  unmuteAll() {
    this.enabled = true;
  }
  createClones(c, name, path) {
    for (let x = 1; x < c; x++) {
      const a = new Audio(path);
      a.id = name + x;
      a.volume = this.volume;
      this.audios[name + x] = a;
      document.body.append(a);
    }
  }
  createAudio(name, path, useClones) {
    const a = new Audio(path);
    a.id = name;
    a.volume = this.volume;
    this.audios[name] = a;
    document.body.append(a);
    if (typeof useClones !== 'undefined') {
      this.createClones(useClones, name, path);
    }
  }
  play(name) {
    if (!this.enabled) return; // 🔇 prevent playing if muted

    const audio = this.audios[name];
    if (!audio) return;
    if (audio.paused) {
      audio.play().catch(e => {
        if (e.name !== 'NotAllowedError') console.warn("sounds error:", e);
      });
    } else {
      this.tryClone(name);
    }
  }
  tryClone(name) {
    if (!this.enabled) return; // 🔇 prevent playing clones

    let cc = 1;
    try {
      while (this.audios[name + cc] && this.audios[name + cc].paused === false) {
        cc++;
      }
      if (this.audios[name + cc]) {
        this.audios[name + cc].play();
      }
    } catch (err) {
      console.warn("Clone play failed:", err);
    }
  }
}
exports.MatrixSounds = MatrixSounds;

},{}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MEEditorClient = void 0;
var _utils = require("../../engine/utils");
class MEEditorClient {
  ws = null;
  constructor(typeOfRun, name) {
    this.ws = new WebSocket("ws://localhost:1243");
    this.ws.onopen = () => {
      if (typeOfRun == 'created from editor') {
        console.log(`%cCreated from editor. Watch <signal> ${name}`, _utils.LOG_FUNNY_ARCADE);
        let o = {
          action: "watch",
          name: name
        };
        o = JSON.stringify(o);
        this.ws.send(o);
        o = {
          action: "list",
          path: name
        };
        o = JSON.stringify(o);
        this.ws.send(o);
      }
      console.log("%c[EDITOR][WS OPEN]", _utils.LOG_FUNNY_ARCADE);
      document.dispatchEvent(new CustomEvent("editorx-ws-ready", {}));
    };
    this.ws.onmessage = event => {
      try {
        const data = JSON.parse(event.data);
        console.log("%c[EDITOR][WS MESSAGE]", _utils.LOG_FUNNY_ARCADE, data);
        if (data && data.ok == true && data.payload && data.payload.redirect == true) {
          setTimeout(() => location.assign(data.name + ".html"), 2000);
        } else if (data.payload && data.payload == "stop-watch done") {
          _utils.mb.show("watch-stoped");
        } else if (data.listAssetsForGraph) {
          // later in graphs ... 
          document.dispatchEvent(new CustomEvent('editorx-update-assets-list', {
            detail: data
          }));
        } else if (data.listAssets) {
          document.dispatchEvent(new CustomEvent('la', {
            detail: data
          }));
        } else if (data.projects) {
          const projects = data.payload.filter(item => item.name !== 'readme.md').map(item => item.name.trim());
          if (projects.length === 0) {
            console.warn('No projects found');
            return;
          }
          const txt = "Project list: \n" + projects.map(p => `- ${p}`).join("\n") + "\n" + "  Choose project name:";
          const projectName = prompt(txt);
          if (projectName) {
            console.log("Project name:", projectName);
            location.assign(projectName + ".html");
          } else {
            console.error('Project loading cancelled');
          }
        } else if (data.details) {
          document.dispatchEvent(new CustomEvent('file-detail-data', {
            detail: data
          }));
        } else if (data.refresh == 'refresh') {
          // setTimeout(() => location.reload(true) , 1500);
          setTimeout(() => document.dispatchEvent(new CustomEvent('updateSceneContainer', {
            detail: {}
          })), 1000);
        } else {
          if (data.methodSaves && data.ok == true) {
            _utils.mb.show("Graph saved ✅");
            // console.log('Graph saved ✅ test ', data.graphName);
            if (typeof data.graphName === "string") document.dispatchEvent(new CustomEvent('get-shader-graphs', {}));
          }
          if (data.methodLoads && data.ok == true && data.shaderGraphs) {
            _utils.mb.show("Graphs list ✅" + data.shaderGraphs);
            document.dispatchEvent(new CustomEvent('on-shader-graphs-list', {
              detail: data.shaderGraphs
            }));
          } else if (data.methodLoads && data.ok == true) {
            _utils.mb.show("Graph loads ✅", data);
            document.dispatchEvent(new CustomEvent('on-graph-load', {
              detail: data.graph
            }));
          } else if (data.aiGenGraph && data.ok == true) {
            _utils.mb.show("AIGraph Generator response graph part ✅", data.aiGenNodes);
            document.dispatchEvent(new CustomEvent('on-ai-graph-response', {
              detail: data.aiGenNodes
            }));
          } else {
            _utils.mb.show("From editorX:" + data.ok);
          }
        }
      } catch (e) {
        console.error("[WS ERROR PARSE]", e);
      }
    };
    this.ws.onerror = err => {
      console.error("%c[WS ERROR]", "color: red", err);
      document.dispatchEvent(new CustomEvent("editor-not-running", {
        detail: {}
      }));
    };
    this.ws.onclose = () => {
      console.log("%c[WS CLOSED]", "color: gray");
    };
    this.attachEvents();
  }
  attachEvents() {
    document.addEventListener('lp', e => {
      console.info('Load project <signal>');
      let o = {
        action: "lp"
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('cnp', e => {
      console.info('Create new project <signal>');
      let o = {
        action: "cnp",
        name: e.detail.name,
        features: e.detail.features
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('stop-watch', e => {
      console.info('stop-watch <signal>');
      let o = {
        action: "stop-watch",
        name: e.detail.name
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('start-watch', e => {
      console.info('start-watch <signal>');
      let o = {
        action: "watch",
        name: e.detail.name
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('nav-folder', e => {
      console.info('nav-folder <signal>');
      let o = {
        action: "nav-folder",
        name: e.detail.name,
        rootFolder: e.detail.rootFolder
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('file-detail', e => {
      console.info('%c[file-detail <signal>]', _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "file-detail",
        name: e.detail.name,
        rootFolder: e.detail.rootFolder
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('web.editor.addCube', e => {
      console.info('%c[web.editor.addCube]', _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "addCube",
        projectName: location.href.split('/public/')[1].split(".")[0],
        options: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('web.editor.addSphere', e => {
      console.info('%c[web.editor.addSphere]', _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "addSphere",
        projectName: location.href.split('/public/')[1].split(".")[0],
        options: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('save-methods', e => {
      console.info('%cSave methods <signal>', _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "save-methods",
        methodsContainer: e.detail.methodsContainer
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('save-graph', e => {
      console.info('%cSave graph <signal>', _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "save-graph",
        graphData: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('save-shader-graph', e => {
      console.info('%cSave shader-graph <signal>', _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "save-shader-graph",
        graphData: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('aiGenGraphCall', e => {
      console.info('%caiGenGraphCall fluxCodexVertex <signal>', _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "aiGenGraphCall",
        prompt: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('load-shader-graph', e => {
      console.info('%cLoad shader-graph <signal>', _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "load-shader-graph",
        name: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('delete-shader-graph', e => {
      console.info('%cDelete shader-graph <signal>', _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "delete-shader-graph",
        name: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('get-shader-graphs', () => {
      console.info('%cget-shader-graphs <signal>', _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "get-shader-graphs"
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('web.editor.addGlb', e => {
      console.log("%c[web.editor.addGlb]: " + e.detail, _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "addGlb",
        projectName: location.href.split('/public/')[1].split(".")[0],
        options: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('web.editor.addObj', e => {
      console.log("%c[web.editor.addObj]: " + e.detail, _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "addObj",
        projectName: location.href.split('/public/')[1].split(".")[0],
        options: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('web.editor.addMp3', e => {
      // console.log("[web.editor.addMp3]: ", e.detail);
      // console.info('addMp3 <signal>');
      // let o = {
      //   action: "addMp3",
      //   projectName: location.href.split('/public/')[1].split(".")[0],
      //   options: e.detail
      // };
      // o = JSON.stringify(o);
      // this.ws.send(o);
    });

    // delete obj
    document.addEventListener('web.editor.delete', e => {
      console.log("%c[web.editor.delete]: " + e.detail, _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "delete-obj",
        projectName: location.href.split('/public/')[1].split(".")[0],
        name: e.detail.prefix
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('web.editor.update.pos', e => {
      console.log("%c[web.editor.update.pos]: " + e.detail, _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "updatePos",
        projectName: location.href.split('/public/')[1].split(".")[0],
        data: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('web.editor.update.rot', e => {
      console.log("%c[web.editor.update.rot]: " + e.detail, _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "updateRot",
        projectName: location.href.split('/public/')[1].split(".")[0],
        data: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('web.editor.update.scale', e => {
      console.log("%c[web.editor.update.scale]: " + e.detail, _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "updateScale",
        projectName: location.href.split('/public/')[1].split(".")[0],
        data: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
    document.addEventListener('web.editor.update.useScale', e => {
      console.log("%c[web.editor.update.useScale]: " + e.detail, _utils.LOG_FUNNY_ARCADE);
      let o = {
        action: "useScale",
        projectName: location.href.split('/public/')[1].split(".")[0],
        data: e.detail
      };
      o = JSON.stringify(o);
      this.ws.send(o);
    });
  }
}
exports.MEEditorClient = MEEditorClient;

},{"../../engine/utils":56}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CurveEditor = exports.CurveData = void 0;
var _utils = require("../../engine/utils");
/**
 * @description
 * Matrix-Engine-Wgpu Curve Editor
 */

class CurveEditor {
  constructor({
    width = 651,
    height = 300,
    samples = 128
  } = {}) {
    this.curveStore = new CurveStore();
    this.width = width;
    this.height = height;
    this.samples = samples;
    this.keys = [{
      time: 0,
      value: 0,
      inTangent: 0,
      outTangent: 0
    }, {
      time: 1,
      value: 0,
      inTangent: 0,
      outTangent: 0
    }];
    this.valueMin = -1;
    this.valueMax = 1;
    this.padLeft = 32;
    this.padBottom = 18;
    this.canvas = document.createElement("canvas");
    this.canvas.width = width;
    this.canvas.height = height;
    this.ctx = this.canvas.getContext("2d");
    this.zeroY = Math.round(this.height * 0.5) + 0.5;
    this.graphHeight = this.height - this.padBottom;
    this.snapEnabled = true;
    this.snapSteps = 20;
    this.snapValueSteps = 20;
    this.name = "Curve";
    this.currentValue = 0;
    // fix
    this.value = 0;
    this.activeKey = null;
    this.dragMode = null;
    this._grabDX = 0;
    this._grabDY = 0;
    this.time = 0;
    this.loop = true;
    this.speed = 1;
    this.isGraphRunning = false;
    this._editorOpen = false;
    this._createPopup();
    this._bindMouse();
    this._buildToolbar();
    this._enableDrag();
    this.length = 1.0;
    this._lastTime = performance.now();
    this._runner = null;
    this.baked = this.bake(samples);
    setTimeout(() => this.draw(), 100);
  }
  _valueToY(v) {
    const n = (v - this.valueMin) / (this.valueMax - this.valueMin);
    return (1 - n) * this.graphHeight;
  }
  _yToValue(y) {
    const n = 1 - y / this.height;
    return this.valueMin + n * (this.valueMax - this.valueMin);
  }
  _snap(value, steps) {
    if (!this.snapEnabled) return value;
    const range = this.valueMax - this.valueMin;
    return Math.round((value - this.valueMin) / range * steps) / steps * range + this.valueMin;
  }

  // VALUE EVALUATION (HERMITE)
  getValue(t) {
    t = Math.max(0, Math.min(1, t));
    for (let i = 0; i < this.keys.length - 1; i++) {
      const k0 = this.keys[i];
      const k1 = this.keys[i + 1];
      if (t >= k0.time && t <= k1.time) {
        const dt = k1.time - k0.time;
        const u = (t - k0.time) / dt;
        const u2 = u * u;
        const u3 = u2 * u;
        const m0 = k0.outTangent * dt;
        const m1 = k1.inTangent * dt;
        return (2 * u3 - 3 * u2 + 1) * k0.value + (u3 - 2 * u2 + u) * m0 + (-2 * u3 + 3 * u2) * k1.value + (u3 - u2) * m1;
      }
    }
    return this.keys.at(-1).value;
  }

  // DRAW
  draw() {
    const padLeft = 32;
    const padBottom = 18;
    const ctx = this.ctx;
    const w = this.width - padLeft;
    const h = this.height - padBottom;
    ctx.save();
    ctx.translate(padLeft, 0);
    ctx.clearRect(-50, -50, w + padLeft + 50, h + padBottom + 50);
    ctx.fillStyle = "#0b0f14";
    ctx.fillRect(0, 0, w, h);

    // grid
    ctx.strokeStyle = "#1c2533";
    for (let i = 0; i <= 10; i++) {
      const x = i / 10 * w;
      const y = i / 10 * h;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }

    // ===== Y AXIS LABELS =====
    ctx.fillStyle = "#9aa7b2";
    ctx.font = "11px monospace";
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    ctx.fillText("+1", -6, this._valueToY(0.9));
    ctx.fillText("0", -6, this._valueToY(0));
    ctx.fillText("-1", -6, this._valueToY(-0.9));
    const zeroY = this._valueToY(0);
    ctx.strokeStyle = "#2e3b4e";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, zeroY);
    ctx.lineTo(w, zeroY);
    ctx.stroke();
    ctx.lineWidth = 1;

    // curve
    ctx.strokeStyle = "#4fc3f7";
    ctx.beginPath();
    for (let i = 0; i <= 100; i++) {
      const t = i / 100;
      // const x = t * w;
      const x = t * w;
      const y = this._valueToY(this.getValue(t));
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();

    // keys + tangents
    this.keys.forEach(k => {
      const x = this._timeToX(k.time);
      const y = this._valueToY(k.value);

      // tangents
      ctx.strokeStyle = "#888";
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + 30, y - k.outTangent * 30);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - 30, y + k.inTangent * 30);
      ctx.stroke();

      // key circle
      ctx.fillStyle = "#ffcc00";
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fill();
    });
    // PLAYHEAD
    const playX = this._timeToX(this.time);
    const playY = this._valueToY(this.getValueNow());
    // vertical line
    ctx.strokeStyle = "#ff5555";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(playX, 0);
    ctx.lineTo(playX, h);
    ctx.stroke();

    // dot
    ctx.fillStyle = "#ff5555";
    ctx.beginPath();
    ctx.arc(playX, playY, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.restore();

    // ===== X AXIS LABELS =====
    ctx.fillStyle = "#ffffffff";
    ctx.font = "13px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    const y = this.height - padBottom + 2;
    ctx.fillText("0s", padLeft, y);
    ctx.fillText((this.length * 0.5).toFixed(2) + "s", padLeft + w * 0.5, y);
    ctx.fillText(this.length.toFixed(2) + "s", padLeft + w, y);
    this._updateToolbar();
  }
  _getMouse(e) {
    const r = this.canvas.getBoundingClientRect();
    return {
      x: e.clientX - r.left - this.padLeft,
      y: e.clientY - r.top
    };
  }
  _bindMouse() {
    const hitKey = (mx, my) => {
      return this.keys.find(k => {
        const x = this._timeToX(k.time);
        const y = this._valueToY(k.value);
        const HIT_RADIUS = 20;
        return Math.hypot(mx - x, my - y) <= HIT_RADIUS;
      });
    };
    const hitPlayhead = (mx, my) => {
      if (this.isGraphRunning) return false;
      const w = this.width - this.padLeft;
      const playX = this._timeToX(this.time);
      const playY = this._valueToY(this.getValueNow());
      return Math.hypot(mx - playX, my - playY) < 8;
    };
    this.canvas.addEventListener("mousedown", e => {
      const {
        x: mx,
        y: my
      } = this._getMouse(e);
      if (hitPlayhead(mx, my)) {
        this.activeKey = 'playhead';
        this.dragMode = 'playhead';
        return;
      }
      const k = hitKey(mx, my);
      if (k) {
        const w = this.width - this.padLeft;
        const kx = k.time * w;
        const ky = this._valueToY(k.value);
        this._grabDX = mx - kx;
        this._grabDY = my - ky;
        this.activeKey = k;
        this.dragMode = e.shiftKey ? "tangent" : "key";
      }
    });
    window.addEventListener("mousemove", e => {
      if (!this.activeKey) return;
      const {
        x: mx,
        y: my
      } = this._getMouse(e);
      if (this.dragMode === 'playhead' && this.activeKey === 'playhead') {
        const w = this.width - this.padLeft;
        let t = Math.max(0, Math.min(1, mx / w));
        t = this._snap(t, this.snapSteps);
        this.time = t;
        this.draw();
        return;
      }
      if (this.dragMode === "key") {
        const w = this.width - this.padLeft;
        // let t = (mx - this._grabDX) / w;
        let t = (mx - this._grabDX) / w;
        t = Math.max(0, Math.min(1 - 1e-6, t));
        let v = this._yToValue(my - this._grabDY);
        v = Math.max(this.valueMin, Math.min(this.valueMax, v));
        v = this._snap(v, this.snapValueSteps);
        t = this._snap(t, this.snapSteps);
        v = this._snap(v, this.snapValueSteps);
        this.activeKey.time = t;
        this.activeKey.value = v;
        this.keys.sort((a, b) => a.time - b.time);
      }
      if (this.dragMode === "tangent") {
        const dx = mx / r.width - this.activeKey.time;
        const dy = 1 - my / r.height - this.activeKey.value;
        this.activeKey.outTangent = dy / dx || 0;
        this.activeKey.inTangent = this.activeKey.outTangent;
      }
      this.draw();
      this._reBake();
    });
    window.addEventListener("mouseup", () => {
      this.activeKey = null;
      this.dragMode = null;
    });
    this.canvas.addEventListener("dblclick", e => {
      const {
        x,
        y
      } = this._getMouse(e);
      const w = this.width - this.padLeft;
      const t = Math.max(0, Math.min(1, x / w));
      const v = this._yToValue(y);
      this.keys.push({
        time: t,
        value: v,
        inTangent: 0,
        outTangent: 0
      });
      this.keys.sort((a, b) => a.time - b.time);
      this._reBake();
      this.draw();
    });

    // delete key
    this.canvas.addEventListener("contextmenu", e => {
      e.preventDefault();
      const {
        x: mx,
        y: my
      } = this._getMouse(e);
      const k = hitKey(mx, my);
      if (k && this.keys.length > 2) {
        this.keys = this.keys.filter(x => x !== k);
        this.draw();
        this._reBake();
      }
    });
  }
  _timeToX(t) {
    const w = this.width - this.padLeft;
    const R = 4;
    let x = t * w;

    // clamp so circle is fully inside canvas
    return Math.min(Math.max(x, R), w - R);
  }

  // BAKING
  bake(samples = this.samples) {
    const data = new Float32Array(samples);
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1);
      data[i] = this.getValue(t);
    }
    return data;
  }
  _reBake() {
    this.baked = this.bake(this.samples);
  }
  exec(delta) {
    if (!this.isGraphRunning) return this.value;
    this.time += delta / this.length * this.speed;
    if (this.loop && this.time > 1) this.time = 0;
    if (!this.loop && this.time > 1) {
      this.time = 1;
      this.stop();
    }
    const idx = Math.floor(this.time * (this.samples - 1));
    this.value = this.baked[idx];
    this.draw();
    return this.value;
  }

  // SYNTETIC FOR NOW 
  play() {
    if (this.isGraphRunning) return;
    this.isGraphRunning = true;
    this._lastTime = performance.now();
    this._runner = setInterval(() => {
      const now = performance.now();
      const delta = (now - this._lastTime) / 1000;
      this._lastTime = now;
      this.exec(delta);
    }, 16); // ~60fps
  }
  stop() {
    this.isGraphRunning = false;
    if (this._runner) {
      clearInterval(this._runner);
      this._runner = null;
    }
    this.draw();
  }
  getValueNow() {
    return this.value;
  }
  _createPopup() {
    this.popup = document.createElement("div");
    this.popup.id = "curve-editor";
    Object.assign(this.popup.style, {
      position: "fixed",
      top: "20%",
      left: "20%",
      transform: "translate(-50%,-50%)",
      background: "#111",
      border: "1px solid #333",
      padding: "5px",
      display: "none",
      zIndex: 999,
      width: '650px',
      height: '409px',
      paddingLeft: '2px',
      paddingRight: '2px'
    });
    this.toolbarTitle = document.createElement("div");
    this.toolbarTitle.style.cssText = `
      display:flex;
      align-items:center;
      gap:10px;
      padding:4px 6px;
      background:#121822;
      border-bottom:1px solid #1c2533;
      font-size:12px;
      margin-bottom: 5px;
    `;
    this.toolbarTitle.innerHTML = `<h3>Curve Editor</h3>`;
    this.popup.appendChild(this.toolbarTitle);
    this.popup.appendChild(this.canvas);
    document.body.appendChild(this.popup);
  }
  toggleEditor() {
    // console.log('_editorOpen')
    this._editorOpen = !this._editorOpen;
    this.popup.style.display = this._editorOpen ? "block" : "none";
    this.draw();
  }
  _buildToolbar() {
    this.root = document.createElement("div");
    this.root.style.cssText = `
    background:#0b0f14;
    border:1px solid #1c2533;
    font-family:monospace;
    color:#cfd8dc;
    width:${this.width}px;
  `;

    // Toolbar
    this.toolbar = document.createElement("div");
    this.toolbar.style.cssText = `
    display:flex;
    align-items:center;
    gap:10px;
    padding:4px 6px;
    background:#121822;
    border-bottom:1px solid #1c2533;
    font-size:12px;
  `;
    this.nameInput = document.createElement("input");
    // console.log(this.name)
    this.nameInput.value = this.name;
    this.nameInput.disabled = true;
    this.nameInput.style.cssText = `
    width:80px;
    background:#0b0f14;
    border:1px solid #1c2533;
    color:#fff;
    padding:2px 4px;
  `;
    this.nameInput.onchange = () => this.name = this.nameInput.value;
    this.playBtn = document.createElement("button");
    this.playBtn.textContent = "▶";
    this.playBtn.style.cssText = `
      background:#1c2533;
      color:#fff;
      border:none;
      padding:2px 8px;
      cursor:pointer;
    `;
    this.playBtn.onclick = () => {
      this.isGraphRunning ? this.stop() : this.play();
    };
    this.lengthInput = document.createElement("input");
    this.lengthInput.type = "number";
    this.lengthInput.value = this.length;
    this.lengthInput.step = "0.1";
    this.lengthInput.style.cssText = `
      width:60px;
      background:#0b0f14;
      border:1px solid #1c2533;
      color:#fff;
      padding:2px 4px;
    `;
    this.lengthInput.onchange = () => {
      this.length = Math.max(0.01, parseFloat(this.lengthInput.value));
    };

    // Time label
    this.timeLabel = document.createElement("span");

    // Value label
    this.valueLabel = document.createElement("span");

    // Running indicator
    this.runLabel = document.createElement("span");

    // Snap toggle
    this.snapBtn = document.createElement("button");
    this.snapBtn.textContent = "Snap";
    this.snapBtn.style.cssText = `
    background:#1c2533;
    color:#fff;
    border:none;
    padding:2px 6px;
    cursor:pointer;
  `;
    this.snapBtn.onclick = () => {
      this.snapEnabled = !this.snapEnabled;
      this.snapBtn.style.opacity = this.snapEnabled ? "1" : "0.4";
    };
    const lenLabel = document.createElement("span");
    lenLabel.textContent = "Len";

    // Reset button
    this.resetBtn = document.createElement("button");
    this.resetBtn.textContent = "Reset";
    this.resetBtn.style.cssText = this.snapBtn.style.cssText;
    this.resetBtn.onclick = () => {
      this.time = 0;
      this.draw();
    };
    this.saveBtn = document.createElement("button");
    this.saveBtn.textContent = "💾 Save";
    this.saveBtn.style.cssText = `
      background:#1c2533;
      color:#fff;
      border:none;
      padding:2px 6px;
      cursor:pointer;
    `;
    this.saveBtn.onclick = () => {
      let curve = this.curveStore.getByName(this.name);
      if (!curve) {
        curve = new CurveData(this.name);
        this.curveStore.curves.push(curve);
      }
      curve.keys = this.keys.map(k => ({
        ...k
      }));
      curve.length = this.length;
      curve.loop = this.loop;
      curve.bake(this.samples);
      this.curveStore.save(curve);
      (0, _utils.byId)('saveMainGraphDOM').click();
      console.log(`%c Curve [${this.name}] saved`, "color:#4caf50;font-weight:bold");
    };
    this.hideBtn = document.createElement("button");
    this.hideBtn.textContent = "Hide";
    this.hideBtn.style.cssText = `
      background:#1c2533;
      color:#fff;
      border:none;
      padding:2px 6px;
      cursor:pointer;
    `;
    this.hideBtn.onclick = () => {
      this.toggleEditor();
      console.log(`%c Curve [${this.name}] saved!`, _utils.LOG_FUNNY_ARCADE);
    };
    this.toolbar.append(this.nameInput, this.playBtn, lenLabel, this.lengthInput, this.timeLabel, this.valueLabel, this.runLabel, this.snapBtn, this.resetBtn, this.saveBtn, this.hideBtn);
    this.root.append(this.toolbar);
    this.popup.appendChild(this.root);
  }
  _updateToolbar = () => {
    this.currentValue = this.getValueNow();
    const timeSec = this.time * this.length;
    this.timeLabel.textContent = `T: ${timeSec.toFixed(2)}s`;
    this.valueLabel.textContent = `V: ${this.currentValue.toFixed(3)}`;
    this.runLabel.textContent = this.isGraphRunning ? "ACTIVE" : "STOPED";
    this.runLabel.style.color = this.isGraphRunning ? "#4caf50" : "#ff9800";
    this.playBtn.textContent = this.isGraphRunning ? "⏸" : "▶";
  };
  _enableDrag() {
    const el = this.popup;
    const handle = this.toolbar;
    const handle2 = this.toolbarTitle;
    let isDown = false;
    let startX = 0;
    let startY = 0;
    let startLeft = 0;
    let startTop = 0;
    handle.style.cursor = "move";
    handle2.style.cursor = "move";
    handle.addEventListener("mousedown", e => {
      isDown = true;
      startX = e.clientX;
      startY = e.clientY;
      const rect = el.getBoundingClientRect();
      startLeft = rect.left;
      startTop = rect.top;
      document.body.style.userSelect = "none";
    });
    handle2.addEventListener("mousedown", e => {
      isDown = true;
      startX = e.clientX;
      startY = e.clientY;
      const rect = el.getBoundingClientRect();
      startLeft = rect.left;
      startTop = rect.top;
      document.body.style.userSelect = "none";
    });
    window.addEventListener("mousemove", e => {
      if (!isDown) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      el.style.left = startLeft + dx + "px";
      el.style.top = startTop + dy + "px";
      el.style.transform = "none";
    });
    window.addEventListener("mouseup", () => {
      isDown = false;
      document.body.style.userSelect = "";
    });
  }
  bindCurve(curve, meta = {}) {
    // console.log("BIND curve", curve, meta);
    this.curve = curve;
    this.keys = curve.keys;
    this.length = curve.length;
    this.loop = curve.loop;
    this.name = meta.idNode;
    this.nameInput.value = this.name;
    this.lengthInput.value = this.length;
    this.idNode = meta.idNode ?? null;
    this.time = 0;
    this._reBake();
    this.draw();
  }
}

/**
 * @description
 * Data class
 **/
exports.CurveEditor = CurveEditor;
class CurveData {
  constructor(name) {
    this.name = name;
    this.keys = [{
      time: 0,
      value: 0,
      inTangent: 0,
      outTangent: 0
    }, {
      time: 1,
      value: 1,
      inTangent: 0,
      outTangent: 0
    }];
    this.length = 1;
    this.loop = true;
    this.samples = 128;
    this.baked = null;
  }
  getValue(t) {
    t = Math.max(0, Math.min(1, t));
    for (let i = 0; i < this.keys.length - 1; i++) {
      const k0 = this.keys[i];
      const k1 = this.keys[i + 1];
      if (t >= k0.time && t <= k1.time) {
        const dt = k1.time - k0.time;
        const u = (t - k0.time) / dt;
        const u2 = u * u;
        const u3 = u2 * u;
        const m0 = k0.outTangent * dt;
        const m1 = k1.inTangent * dt;
        return (2 * u3 - 3 * u2 + 1) * k0.value + (u3 - 2 * u2 + u) * m0 + (-2 * u3 + 3 * u2) * k1.value + (u3 - u2) * m1;
      }
    }
    return this.keys.at(-1).value;
  }

  // bake real values, not normalized 0-1
  bake(samples = this.samples) {
    this.baked = new Float32Array(samples);
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1);
      this.baked[i] = this.getValue(t);
    }
  }
  evaluate(time01) {
    if (!this.baked) {
      console.warn("Curve not baked!");
      return 0;
    }
    let t = time01;
    if (this.loop) t = t % 1;else t = Math.min(1, Math.max(0, t));
    const idx = Math.floor(t * (this.baked.length - 1));
    return this.baked[idx];
  }
}
exports.CurveData = CurveData;
class CurveStore {
  constructor() {
    this.CURVE_STORAGE_KEY = "PROJECT_NAME";
    this.curves = [];
    this.load();
  }
  has(name) {
    return this.curves.some(c => c.name === name);
  }
  getOrCreate(curveArg) {
    let curve = this.curves.find(c => c.name === curveArg.name);
    if (curve) return curve;
    // console.log("PUSH in getOrCreate")
    curve = new CurveData(curveArg.name);
    this.curves.push(curve);
    return curve;
  }
  getByName(name) {
    return this.curves.find(c => c.name === name) || null;
  }
  add(curve) {
    this.curves.push(curve);
    this.save();
  }
  removeByName(name) {
    this.curves = this.curves.filter(c => c.name !== name);
    this.save();
  }
  getAll() {
    return this.curves;
  }

  // SAVE / LOAD
  save() {
    console.log('TEST SAVE', this.curves);
    const data = {
      version: 1,
      curves: this.curves
    };
    localStorage.setItem(this.CURVE_STORAGE_KEY, JSON.stringify(data));
  }

  // saveCurve(curveData) {
  //   const idx = this.curves.findIndex(c => c.name === curveData.name);
  //   if(idx >= 0) {
  //     this.curves[idx] = curveData;
  //   } else {
  //     this.curves.push(curveData);
  //   }
  //   this.save();
  // }

  load() {
    const raw = localStorage.getItem(this.CURVE_STORAGE_KEY);
    if (!raw) return;
    try {
      const data = JSON.parse(raw);
      if (!data.curves) return;
      this.curves = data.curves.map(c => this._fromJSON(c));
    } catch (e) {
      console.warn("CurveStore load failed", e);
      this.curves = [];
    }
  }
  _fromJSON(obj) {
    const c = new CurveData(obj.name);
    c.keys = obj.keys || [];
    c.length = obj.length ?? 1;
    c.loop = !!obj.loop;
    return c;
  }
}

},{"../../engine/utils":56}],88:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Editor = void 0;
var _ToolTip = require("../../engine/plugin/tooltip/ToolTip");
var _utils = require("../../engine/utils");
var _client = require("./client");
var _editor = _interopRequireDefault(require("./editor.provider"));
var _flexCodexShader = require("./flexCodexShader");
var _fluxCodexVertex = _interopRequireDefault(require("./fluxCodexVertex"));
var _hud = _interopRequireDefault(require("./hud"));
var _methodsManager = _interopRequireDefault(require("./methodsManager"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class Editor {
  constructor(core, a, projName) {
    this.core = core;
    this.toolTip = new _ToolTip.METoolTip();
    this.methodsManager = new _methodsManager.default(this.check(a));
    this.editorHud = new _hud.default(core, this.check(a), this.toolTip);
    this.editorProvider = new _editor.default(core, this.check(a));
    if (this.check(a) == 'pre editor') {
      this.client = new _client.MEEditorClient(this.check(a));
    } else if (this.check(a) == 'created from editor') {
      document.addEventListener('editorx-ws-ready', () => {
        (0, _flexCodexShader.openFragmentShaderEditor)().then(e => {
          (0, _utils.byId)('shaderDOM').style.display = 'none';
          app.shaderGraph = e;
        });
      });
      this.client = new _client.MEEditorClient(this.check(a), projName);
      this.createFluxCodexVertexDOM();
      setTimeout(() => {
        console.log("MOMENT BEFORE COSTRUCT MAIN FLUXCODEXVERTEX GRAPH");
        this.fluxCodexVertex = new _fluxCodexVertex.default('board', 'boardWrap', 'log', this.methodsManager, projName, this.toolTip);
        setTimeout(() => {
          this.fluxCodexVertex.updateLinks();
        }, 2500);
      }, 1000);
    }
  }
  check(a) {
    if (typeof a !== 'undefined' && a == "created from editor") {
      return a;
    } else if (typeof a !== 'undefined' && a == "pre editor") {
      return a;
    } else {
      return "infly";
    }
  }
  createFluxCodexVertexDOM() {
    let FCV = document.createElement('div');
    FCV.id = 'app';
    FCV.style.display = 'none';
    FCV.style.opacity = 1;
    FCV.innerHTML = `
    <div id="leftBar">
      <span>Declaration</span>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setProductionMode')">Set ProductionMode</button>
      <span>Events/Func</span>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('event')">Event: onLoad</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('onDraw')">Event: onDraw</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('onKey')">Event: onKey</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('eventCustom')">Custom Event</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('dispatchEvent')">Dispatch Event</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('function')">Function</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('if')">If Branch</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('genrand')">GenRandInt</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('print')">Print</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('timeout')">SetTimeout</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('getArray')">getArray</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('forEach')">forEach</button>
      <span>Scene objects [agnostic]</span>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('getSceneObject')">Get scene object</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('addObj')">Add OBJ</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('getObjectAnimation')">Get Object Animation</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setPosition')">Set position</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('getShaderGraph')">Set Shader Graph</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setMaterial')">Set Material</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setBlend')">Set Blend</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setSpeed')">Set Speed</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('getSpeed')">Get Speed</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setRotation')">Set rotation</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setRotate')">Set Rotate</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setRotateX')">Set RotateX</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setRotateY')">Set RotateY</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setRotateZ')">Set RotateZ</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setTexture')">Set Texture</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('translateByX')">TranslateByX</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('translateByY')">TranslateByY</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('translateByZ')">TranslateByZ</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('onTargetPositionReach')">onTarget PositionReach</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('rayHitEvent')">Ray Hit Event</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setWaterParams')">Set Water Material Params</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setVertexAnim')">Set VertexAnim Intesity</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setVertexWave')">Set Vertex Wave</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setVertexWind')">Set Vertex Wind</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setVertexPulse')">Set Vertex Pulse</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setVertexTwist')">Set Vertex Twist</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setVertexNoise')">Set Vertex Noise</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setVertexOcean')">Set Vertex Ocean</button>
      <span>Dinamics</span>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('dynamicFunction')">Function Dinamic</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('getSubObject')">Get Sub Object</button>
      <span>Data mod</span>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('curveTimeline')">Curve Timeline</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('oscillator')">Oscillator</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('getNumberLiteral')">Get Number Literal</button>
      <span>Networking</span>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('fetch')">Fetch</button>
      <span>Media</span>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('audioMP3')">Add Mp3</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setVideoTexture')">Set Video Tex[Mp4]</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setCanvasInlineTexture')">Set Canvas2d Inline Tex</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('audioReactiveNode')">Audio Reactive Node</button>
      <span>Physics</span>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('generator')">Generator in place</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('generatorWall')">Generate Wall</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('generatorPyramid')">Generate Pyramid</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('setForceOnHit')">Set Force On Hit</button>
      <span>String Operations</span>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('startsWith')">Starts With</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('startsWith')">Starts With</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('endsWith')">Ends With</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('includes')">includes</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('toUpperCase')">toUpperCase</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('toLowerCase')">toLowerCase</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('trim')">Trim</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('length')">Length</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('substring')">Substring</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('startsWith')">Replace</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('startsWith')">Split</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('concat')">Concat</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('isEmpty')">isEmpty</button>

      <span>Math</span>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('add')">Add (+)</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('sub')">Sub (-)</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('mul')">Mul (*)</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('div')">Div (/)</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('sin')">Sin</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('cos')">Cos</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('pi')">Pi</button>
      <span>COMPARISON</span>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('equal')">Equal (==)</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('notequal')">Not Equal (!=)</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('greater')">Greater (>)</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('less')">Less (<)</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('greaterEqual')">Greater/Equal (>=)</button>
      <button class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.addNode('lessEqual')">Less/Equal (<=)</button>
      <hr style="border:none; height:1px; background:rgba(255,255,255,0.03); margin:10px 0;">
      <span>Compile FluxCodexVertex</span>
      <button style="color:#00bcd4;" class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.compileGraph()">Save Graph</button>
      <button style="color:#00bcd4;" class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.clearStorage();">Clear All</button>
      <button style="color:#00bcd4;" class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.runGraph()">Run (F6)</button>
      <hr style="border:none; height:1px; background:rgba(255,255,255,0.03); margin:10px 0;">
      <button style="color: lime;" class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex.exportToJSON()">Export (JSON)</button>
      <button style="color: lime;" class="btn4 btnLeftBox" onclick="app.editor.fluxCodexVertex._importInput.click()">Import (JSON)</button>

      <pre id="log" aria-live="polite"></pre>
    </div>
    <div id="boardWrap">
      <div id="board">
        <svg class="connections"></svg>
      </div>
    </div>
    `;
    document.body.appendChild(FCV);
  }
}
exports.Editor = Editor;

},{"../../engine/plugin/tooltip/ToolTip":51,"../../engine/utils":56,"./client":86,"./editor.provider":89,"./flexCodexShader":90,"./fluxCodexVertex":92,"./hud":94,"./methodsManager":95}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _loaderObj = require("../../engine/loader-obj");
var _webgpuGltf = require("../../engine/loaders/webgpu-gltf");
/**
 * @description
 * For now it is posible for editor to work on fly
 * with no memory/saves.
 */

class EditorProvider {
  constructor(core) {
    this.core = core;
    this.addEditorEvents();
  }
  getNameFromPath(p) {
    return p.split(/[/\\]/).pop().replace(/\.[^/.]+$/, ""); // + (this.core.mainRenderBundle.length);
  }
  addEditorEvents() {
    document.addEventListener('web.editor.input', e => {
      console.log("[EDITOR-input]: ", e.detail);
      // Saves methods
      switch (e.detail.propertyId) {
        case 'position':
          {
            console.log('change signal for pos', e.detail);
            if (e.detail.property == 'x' || e.detail.property == 'y' || e.detail.property == 'z') document.dispatchEvent(new CustomEvent('web.editor.update.pos', {
              detail: e.detail
            }));
            break;
          }
        case 'rotation':
          {
            console.log('[signal][rot]');
            if (e.detail.property == 'x' || e.detail.property == 'y' || e.detail.property == 'z') document.dispatchEvent(new CustomEvent('web.editor.update.rot', {
              detail: e.detail
            }));
            break;
          }
        case 'scale':
          {
            console.log('[signal][scale]');
            if (e.detail.property == '0' || e.detail.property == '1' || e.detail.property == '2') {
              document.dispatchEvent(new CustomEvent('web.editor.update.scale', {
                detail: e.detail
              }));
            }
            break;
          }
        default:
          console.log('changes not saved.');
      }
      // inputFor: "Cube_0" property: "x" propertyId: "position" value: "1"
      // InFly Method
      let sceneObj = this.core.getSceneObjectByName(e.detail.inputFor);
      if (e.detail.property == "no info") {
        // console.warn("What is useScale !!! ", e.detail.value);
        sceneObj[e.detail.propertyId] = e.detail.value;
        if (e.detail.propertyId === "useScale") document.dispatchEvent(new CustomEvent('web.editor.update.useScale', {
          detail: e.detail
        }));
        return;
      }
      if (sceneObj) {
        sceneObj[e.detail.propertyId][e.detail.property] = parseFloat(e.detail.value);
      } else {
        console.warn("EditorProvider input error");
        return;
      }
    });
    document.addEventListener('web.editor.addCube', e => {
      // console.log("[web.editor.addCube]: ", e.detail);
      // THIS MUST BE SAME LIKE SERVER VERSION OF ADD CUBE
      (0, _loaderObj.downloadMeshes)({
        cube: "./res/meshes/blender/cube.obj"
      }, m => {
        const texturesPaths = './res/meshes/blender/cube.png';
        this.core.addMeshObj({
          position: {
            x: 0,
            y: 0,
            z: -20
          },
          rotation: {
            x: 0,
            y: 0,
            z: 0
          },
          rotationSpeed: {
            x: 0,
            y: 0,
            z: 0
          },
          texturesPaths: [texturesPaths],
          // useUVShema4x2: true,
          name: "" + e.detail.index,
          mesh: m.cube,
          raycast: {
            enabled: true,
            radius: 2
          },
          physics: {
            enabled: e.detail.physics,
            geometry: "Cube"
          }
        });
      }, {
        scale: [1, 1, 1]
      });
    });
    document.addEventListener('web.editor.addSphere', e => {
      // console.log("[web.editor.addCube]: ", e.detail);
      (0, _loaderObj.downloadMeshes)({
        mesh: "./res/meshes/shapes/sphere.obj"
      }, m => {
        const texturesPaths = './res/meshes/blender/cube.png';
        this.core.addMeshObj({
          position: {
            x: 0,
            y: 0,
            z: -20
          },
          rotation: {
            x: 0,
            y: 0,
            z: 0
          },
          rotationSpeed: {
            x: 0,
            y: 0,
            z: 0
          },
          texturesPaths: [texturesPaths],
          // useUVShema4x2: true,
          name: e.detail.index,
          mesh: m.mesh,
          raycast: {
            enabled: true,
            radius: 2
          },
          physics: {
            enabled: e.detail.physics,
            geometry: "Sphere"
          }
        });
      }, {
        scale: [1, 1, 1]
      });
    });
    document.addEventListener('web.editor.addGlb', async e => {
      console.log("[web.editor.addGlb]: ", e.detail.path);
      e.detail.path = e.detail.path.replace('\\res', 'res');
      // THIS MUST BE SAME LIKE SERVER VERSION OF ADD GLB
      var glbFile01 = await fetch(e.detail.path).then(res => res.arrayBuffer().then(buf => (0, _webgpuGltf.uploadGLBModel)(buf, this.core.device)));
      this.core.addGlbObj({
        material: {
          type: 'power',
          useTextureFromGlb: true
        },
        scale: [2, 2, 2],
        position: {
          x: 0,
          y: 0,
          z: -20
        },
        name: this.getNameFromPath(e.detail.path),
        texturesPaths: ['./res/meshes/glb/textures/mutant_origin.png']
      }, null, glbFile01);
    });
    document.addEventListener('web.editor.addObj', e => {
      console.log("[web.editor.addObj]: ", e.detail);
      e.detail.path = e.detail.path.replace('\\res', 'res');
      e.detail.path = e.detail.path.replace(/\\/g, '/');
      // THIS MUST BE SAME LIKE SERVER VERSION OF ADD CUBE
      (0, _loaderObj.downloadMeshes)({
        objMesh: `${e.detail.path}`
      }, m => {
        const texturesPaths = './res/meshes/blender/cube.png';
        this.core.addMeshObj({
          position: {
            x: 0,
            y: 0,
            z: -20
          },
          rotation: {
            x: 0,
            y: 0,
            z: 0
          },
          rotationSpeed: {
            x: 0,
            y: 0,
            z: 0
          },
          texturesPaths: [texturesPaths],
          // useUVShema4x2: true,
          name: e.detail.index,
          mesh: m.objMesh,
          raycast: {
            enabled: true,
            radius: 2
          },
          physics: {
            enabled: e.detail.physics,
            geometry: "Cube"
          }
        });
      }, {
        scale: [1, 1, 1]
      });
    });

    // delete
    document.addEventListener('web.editor.delete', e => {
      console.log("[web.editor.delete]: ", e.detail.fullName);
      this.core.removeSceneObjectByName(e.detail.fullName);
    });

    // update procedure
  }
}
exports.default = EditorProvider;

},{"../../engine/loader-obj":44,"../../engine/loaders/webgpu-gltf":47}],90:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ViewDirectionNode = exports.Vec4Node = exports.Vec3Node = exports.Vec2Node = exports.UVNode = exports.TimeNode = exports.TextureSamplerNode = exports.TanNode = exports.SubtractNode = exports.SqrtNode = exports.SplitVec4Node = exports.SmoothstepNode = exports.SinNode = exports.ShaderNode = exports.PowerNode = exports.OneMinusNode = exports.NormalizeNode = exports.NormalOutput = exports.MultiplyVec2Node = exports.MultiplyNode = exports.MultiplyColorNode = exports.MinNode = exports.MaxNode = exports.LightToColorNode = exports.LightShadowNode = exports.LerpNode = exports.LengthNode = exports.InlineFunctionNode = exports.GrayscaleNode = exports.GlobalAmbientNode = exports.FragmentShaderRegistry = exports.FragmentShaderGraph = exports.FragmentPositionNode = exports.FragmentOutputNode = exports.FragmentNormalNode = exports.FracNode = exports.FloorNode = exports.FloatNode = exports.DotProductNode = exports.DivideNode = exports.CrossProductNode = exports.CosNode = exports.ContrastNode = exports.CombineVec4Node = exports.ColorNode = exports.ClampNode = exports.CeilNode = exports.CameraPosNode = exports.AlphaOutput = exports.AddVec2Node = exports.AddNode = exports.AbsNode = void 0;
exports.openFragmentShaderEditor = openFragmentShaderEditor;
var _utils = require("../../engine/utils.js");
var _flexCodexShaderAdapter = require("./flexCodexShaderAdapter.js");
/**
 * @description
 * Flux Codex Vertex use visual scripting model.
 *
 * @filename
 * fluxCodexVertex.js
 *
 * @Licence
 * This Source Code Form is subject to the terms of the
 * Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file,
 * You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Copyright (c) 2025 Nikola Lukić zlatnaspirala@gmail.com
 *
 * @Note
 * License summary for fluxCodexVertex.js (MPL 2.0):
 *
 * ✔ You MAY:
 * - Use this file in commercial and proprietary software
 * - Modify and redistribute this file
 * - Combine it with closed-source code
 * - Sell software that includes this file
 *
 * ✘ You MUST:
 * - Publish the source code of this file if you modify it
 * - Keep this file under MPL 2.0
 * - Provide a link to the MPL 2.0 license
 * - Preserve copyright notices
 *
 * ✔ You do NOT have to:
 * - Open-source your entire project
 * - Publish files that merely import or use this file
 * - Release unrelated source code
 *
 * - MPL applies ONLY to this file
 */

const FragmentShaderRegistry = exports.FragmentShaderRegistry = {};
class FragmentShaderGraph {
  constructor(id) {
    this.id = id;
    this.nodes = [];
    this.connections = [];
    this.spawnX = 80;
    this.spawnY = 80;
    this.spawnStepX = 220;
    this.spawnStepY = 140;
    this.spawnCol = 0;
    this.runtimeList = [];
    this.runtime_memory = {};
    this.onGraphLoadAttached = false;
  }
  addNode(node) {
    if (node.type === "FragmentOutput") {
      const exists = this.nodes.some(n => n.type === "FragmentOutput");
      if (exists) {
        console.warn("FragmentOutput already exists");
        return null;
      }
    }
    this.nodes.push(node);
    return node;
  }
  connect(fromNode, fromPin, toNode, toPin) {
    this.connections = this.connections.filter(c => !(c.toNode === toNode && c.toPin === toPin));
    this.connections.push({
      fromNode,
      fromPin,
      toNode,
      toPin
    });
  }
  getInput(node, pin) {
    return this.connections.find(c => c.toNode === node && c.toPin === pin);
  }
  compile() {
    const wgsl = FragmentCompiler.compile(this);
    FragmentShaderRegistry[this.id] = wgsl;
    return wgsl;
  }
  nextSpawn() {
    const x = this.spawnX + this.spawnCol * this.spawnStepX;
    const y = this.spawnY;
    this.spawnCol++;
    if (this.spawnCol >= 3) {
      this.spawnCol = 0;
      this.spawnY += this.spawnStepY;
    }
    return {
      x,
      y
    };
  }
  makeDraggable(el, node, connectionLayer) {
    let ox = 0,
      oy = 0,
      drag = false;
    el.addEventListener("pointerdown", e => {
      drag = true;
      ox = e.clientX - el.offsetLeft;
      oy = e.clientY - el.offsetTop;
      el.setPointerCapture(e.pointerId);
    });
    el.addEventListener("pointermove", e => {
      if (!drag) return;
      el.style.left = e.clientX - ox + "px";
      el.style.top = e.clientY - oy + "px";
      node.x = e.clientX - ox;
      node.y = e.clientY - oy;
      connectionLayer.redrawAll();
    });
    el.addEventListener("pointerup", () => drag = false);
  }
  clear() {
    this.nodes = [];
    this.connections = [];
    this.spawnX = 80;
    this.spawnY = 80;
    this.spawnCol = 0;
    if (this.connectionLayer) {
      this.connectionLayer.svg.innerHTML = '';
    }
    const container = document.getElementsByClassName("fancy-grid-bg dark");
    if (container) {
      const nodeElements = container[0].querySelectorAll('.nodeShader');
      nodeElements.forEach(el => el.remove());
    }
    this.connectionLayer.redrawAll();
  }
}
exports.FragmentShaderGraph = FragmentShaderGraph;
class CompileContext {
  constructor(shaderGraph) {
    this.shaderGraph = shaderGraph;
    this.cache = new Map();
    this.structs = [];
    this.uniforms = [];
    this.functions = new Map();
    this.locals = [];
    this.mainLines = [];
    this.tmpIndex = 0;
    this.outputs = {
      outColor: null
    };
  }
  temp(type, expr) {
    const name = `t${this.tmpIndex++}`;
    this.locals.push(`let ${name}: ${type} = ${expr};`);
    return name;
  }
  registerFunction(name, code) {
    if (!this.functions.has(name)) {
      this.functions.set(name, code);
    }
  }
  resolve(node, pin) {
    const key = `${node.id}:${pin}`;
    if (this.cache.has(key)) return this.cache.get(key);
    if (!this.resolving) this.resolving = new Set();
    if (this.resolving.has(key)) {
      console.warn("Cyclic dependency detected:", key);
      return node.default?.(pin) ?? "0.0";
    }
    this.resolving.add(key);
    const conn = this.shaderGraph.getInput(node, pin);
    let value;
    if (conn) {
      value = this.resolve(conn.fromNode, conn.fromPin);
      // console.log('value = this.resolve(conn.fromNode, conn.fromPin); ', value)
    } else {
      // ✅ ONLY inputs have defaults
      if (node.inputs && pin in node.inputs) {
        value = node.inputs[pin].default;
      } else {
        // 🔥 OUTPUT PIN → no default
        value = undefined;
      }
    }
    const result = node.build(pin, value, this);
    if (result?.out !== undefined) {
      this.cache.set(key, result.out);
    }
    this.resolving.delete(key);
    return result.out;
  }
}
class FragmentCompiler {
  static compile(shaderGraph) {
    const ctx = new CompileContext(shaderGraph);
    shaderGraph.nodes.forEach(n => {
      if (n.type.endsWith("Output")) {
        ctx.resolve(n, Object.keys(n.inputs)[0]);
      }
    });
    if (!ctx.outputs.outColor) {
      throw new Error("ShaderGraph: No visual output");
    }
    return {
      structs: ctx.structs,
      uniforms: ctx.uniforms,
      functions: [...ctx.functions.values()],
      locals: ctx.locals,
      outputs: ctx.outputs,
      mainLines: ctx.mainLines
    };
  }
}
let NODE_ID = 0;
class ShaderNode {
  constructor(type) {
    this.id = "N" + NODE_ID++;
    this.type = type;
    this.inputs = {};
  }
  default(pin) {
    return this.inputs[pin]?.default ?? "0.0";
  }
  build(_, value, ctx) {
    return {
      out: value,
      type: "f32"
    };
  }
}
exports.ShaderNode = ShaderNode;
class FragmentOutputNode extends ShaderNode {
  constructor() {
    super("FragmentOutput");
    this.inputs = {
      color: {
        default: "vec4f(1.0)"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "color");
    let value;
    if (conn) {
      // Resolve the node connected to this input
      value = ctx.resolve(conn.fromNode, conn.fromPin);
    } else {
      // No connection → use default
      value = this.inputs.color.default;
    }
    ctx.outputs.outColor = value;
    // console.log('From FragmentOutputNode ctx.outputs.outColor', ctx.outputs.outColor);
    return {
      out: ctx.outputs.outColor,
      type: "vec4f"
    };
  }
}
exports.FragmentOutputNode = FragmentOutputNode;
class AlphaOutput extends ShaderNode {
  constructor() {
    super("AlphaOutput");
    this.inputs = {
      alpha: {
        default: "1.0"
      }
    };
  }
  build(_, __, ctx) {
    ctx.outputs.alpha = ctx.resolve(this, "alpha");
    return {
      out: ctx.outputs.alpha
    };
  }
}
exports.AlphaOutput = AlphaOutput;
class NormalOutput extends ShaderNode {
  constructor() {
    super("NormalOutput");
    this.inputs = {
      normal: {
        default: "input.normal"
      }
    };
  }
  build(_, __, ctx) {
    ctx.outputs.normal = ctx.resolve(this, "normal");
    return {
      out: ctx.outputs.normal
    };
  }
}

// STANDARD SOME STUFF ARE PREDEFINED ALREADY IN ADAPTER
exports.NormalOutput = NormalOutput;
class LightShadowNode extends ShaderNode {
  constructor() {
    super("LightShadowNode");
    this.inputs = {
      intensity: {
        default: "1"
      }
    };
  }
  build(_, __, ctx) {
    // Generate the light calculation code as a string
    const lightCalcCode = `
    let norm = normalize(input.fragNorm);
    let viewDir = normalize(scene.cameraPos - input.fragPos);
    let materialData = getPBRMaterial(input.uv);
    var lightContribution = vec3f(0.0);
    for (var i: u32 = 0u; i < MAX_SPOTLIGHTS; i = i + 1u) {
        let sc = spotlights[i].lightViewProj * vec4<f32>(input.fragPos, 1.0);
        let p  = sc.xyz / sc.w;
        let uv = clamp(p.xy * 0.5 + vec2<f32>(0.5), vec2<f32>(0.0), vec2<f32>(1.0));
        let depthRef = p.z * 0.5 + 0.5;
        let lightDir = normalize(spotlights[i].position - input.fragPos);
        let bias = spotlights[i].shadowBias;
        let visibility = sampleShadow(uv, i32(i), depthRef - bias, norm, lightDir);
        let contrib = computeSpotLight(spotlights[i], norm, input.fragPos, viewDir, materialData);
        lightContribution += contrib * visibility;
    }`;
    ctx.locals.push(lightCalcCode);

    // Return the variable name that downstream nodes can use
    return {
      out: "lightContribution",
      type: "vec3f"
    };
  }
}
exports.LightShadowNode = LightShadowNode;
class LightToColorNode extends ShaderNode {
  constructor() {
    super("LightToColor");
    this.inputs = {
      light: {
        default: "vec3f(1.0)"
      }
    };
  }
  build(pin, value, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "light");
    let l;
    if (conn) {
      l = ctx.resolve(conn.fromNode, conn.fromPin);
    } else {
      l = this.inputs.light.default;
    }
    const result = ctx.temp("vec4f", `vec4f(${l}, 1.0)`);
    return {
      out: result,
      type: "vec4f"
    };
  }
}
exports.LightToColorNode = LightToColorNode;
class UVNode extends ShaderNode {
  constructor() {
    super("UV");
  }
  build() {
    return {
      out: "input.uv",
      type: "vec2f"
    };
  }
}
exports.UVNode = UVNode;
class AddVec2Node extends ShaderNode {
  constructor() {
    super("AddVec2");
    this.inputs = {
      a: {
        default: "vec2f(0.0)"
      },
      b: {
        default: "vec2f(0.0)"
      }
    };
  }
  build(_, __, ctx) {
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    const a = connA ? ctx.resolve(connA.fromNode, connA.fromPin) : this.inputs.a.default;
    const b = connB ? ctx.resolve(connB.fromNode, connB.fromPin) : this.inputs.b.default;
    return {
      out: ctx.temp("vec2f", `${a} + ${b}`),
      type: "vec2f"
    };
  }
}
exports.AddVec2Node = AddVec2Node;
class CameraPosNode extends ShaderNode {
  constructor() {
    super("CameraPos");
  }
  build(_, __, ctx) {
    return {
      out: "scene.cameraPos",
      type: "vec3f"
    };
  }
}
exports.CameraPosNode = CameraPosNode;
class MultiplyVec2Node extends ShaderNode {
  constructor() {
    super("MultiplyVec2");
    this.inputs = {
      a: {
        default: "vec2f(1.0)"
      },
      b: {
        default: "1.0"
      } // Can be scalar or vec2
    };
  }
  build(_, __, ctx) {
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    const a = connA ? ctx.resolve(connA.fromNode, connA.fromPin) : this.inputs.a.default;
    const b = connB ? ctx.resolve(connB.fromNode, connB.fromPin) : this.inputs.b.default;
    return {
      out: ctx.temp("vec2f", `${a} * ${b}`),
      type: "vec2f"
    };
  }
}
exports.MultiplyVec2Node = MultiplyVec2Node;
class TimeNode extends ShaderNode {
  constructor() {
    super("Time");
  }
  build(_, __, ctx) {
    return {
      out: "scene.time",
      type: "f32"
    };
  }
}
exports.TimeNode = TimeNode;
class InlineFunctionNode extends ShaderNode {
  constructor(name = "customFn", code = "") {
    super("InlineFunction");
    this.fnName = name;
    this.code = code;
    this.inputs = {
      a: {
        default: "input.uv"
      },
      b: {
        default: "globals.time"
      }
    };
  }
  build(_, __, ctx) {
    ctx.registerFunction(this.fnName, this.code);
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    const a = connA ? ctx.resolve(connA.fromNode, connA.fromPin) : this.inputs.a.default;
    const b = connB ? ctx.resolve(connB.fromNode, connB.fromPin) : this.inputs.b.default;
    return {
      out: ctx.temp("vec4f", `${this.fnName}(${a}, ${b})`),
      type: "vec4f"
    };
  }
}
exports.InlineFunctionNode = InlineFunctionNode;
class TextureSamplerNode extends ShaderNode {
  constructor(name = "tex0") {
    super("TextureSampler");
    this.name = name;
    this.inputs = {
      uv: {
        default: "input.uv"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "uv");
    let uv;
    if (conn) {
      uv = ctx.resolve(conn.fromNode, conn.fromPin);
    } else {
      uv = this.inputs.uv.default;
    }
    return {
      out: ctx.temp("vec4f", `textureSample(meshTexture, meshSampler, ${uv})`),
      type: "vec4f"
    };
  }
}
exports.TextureSamplerNode = TextureSamplerNode;
class MultiplyColorNode extends ShaderNode {
  constructor() {
    super("MultiplyColor");
    this.inputs = {
      a: {
        default: "vec4(1.0)"
      },
      b: {
        default: "vec4(1.0)"
      }
    };
  }
  build(_, __, ctx) {
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    let a, b;
    if (connA) {
      a = ctx.resolve(connA.fromNode, connA.fromPin);
    } else {
      a = this.inputs.a.default;
    }
    if (connB) {
      b = ctx.resolve(connB.fromNode, connB.fromPin);
    } else {
      b = this.inputs.b.default;
    }
    const t = ctx.temp("vec4f", `${a} * ${b}`);
    return {
      out: t,
      type: "vec4f"
    };
  }
}
exports.MultiplyColorNode = MultiplyColorNode;
class ClampNode extends ShaderNode {
  constructor() {
    super("Clamp");
    this.inputs = {
      x: {
        default: "0.0"
      },
      min: {
        default: "0.0"
      },
      max: {
        default: "1.0"
      }
    };
  }
  build(_, __, ctx) {
    const connX = ctx.shaderGraph.getInput(this, "x");
    const connMin = ctx.shaderGraph.getInput(this, "min");
    const connMax = ctx.shaderGraph.getInput(this, "max");
    const x = connX ? ctx.resolve(connX.fromNode, connX.fromPin) : this.inputs.x.default;
    const min = connMin ? ctx.resolve(connMin.fromNode, connMin.fromPin) : this.inputs.min.default;
    const max = connMax ? ctx.resolve(connMax.fromNode, connMax.fromPin) : this.inputs.max.default;
    return {
      out: ctx.temp("f32", `clamp(${x}, ${min}, ${max})`),
      type: "f32"
    };
  }
}
exports.ClampNode = ClampNode;
class GrayscaleNode extends ShaderNode {
  constructor() {
    super("Grayscale");
    this.inputs = {
      color: {
        default: "vec4(1.0)"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "color");
    const c = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.color.default;
    return {
      out: ctx.temp("vec4f", `vec4(vec3(dot(${c}.rgb,vec3(0.299,0.587,0.114))),${c}.a)`),
      type: "vec4f"
    };
  }
}
exports.GrayscaleNode = GrayscaleNode;
class ContrastNode extends ShaderNode {
  constructor() {
    super("Contrast");
    this.inputs = {
      color: {
        default: "vec4(1.0)"
      },
      contrast: {
        default: "1.0"
      }
    };
  }
  build(_, __, ctx) {
    const connColor = ctx.shaderGraph.getInput(this, "color");
    const connContrast = ctx.shaderGraph.getInput(this, "contrast");
    const c = connColor ? ctx.resolve(connColor.fromNode, connColor.fromPin) : this.inputs.color.default;
    const k = connContrast ? ctx.resolve(connContrast.fromNode, connContrast.fromPin) : this.inputs.contrast.default;
    return {
      out: ctx.temp("vec4f", `vec4(((${c}.rgb-0.5)*${k}+0.5),${c}.a)`),
      type: "vec4f"
    };
  }
}

// CONSTANT/LITERAL NODES
exports.ContrastNode = ContrastNode;
class FloatNode extends ShaderNode {
  constructor(value = 1.0) {
    super("Float");
    this.value = value;
  }
  build(_, __, ctx) {
    return {
      out: `${this.value}`,
      type: "f32"
    };
  }
}
exports.FloatNode = FloatNode;
class Vec2Node extends ShaderNode {
  constructor(vx = 0.0, vy = 0.0) {
    super("Vec2");
    this.valueX = vx; // ✅ Store vector X value
    this.valueY = vy; // ✅ Store vector Y value
  }
  build(_, __, ctx) {
    return {
      out: `vec2f(${this.valueX}, ${this.valueY})`,
      // ✅ Use valueX, valueY
      type: "vec2f"
    };
  }
}
exports.Vec2Node = Vec2Node;
class Vec3Node extends ShaderNode {
  constructor(vx = 0.0, vy = 0.0, vz = 0.0) {
    super("Vec3");
    this.valueX = vx;
    this.valueY = vy;
    this.valueZ = vz;
  }
  build(_, __, ctx) {
    return {
      out: `vec3f(${this.valueX}, ${this.valueY}, ${this.valueZ})`,
      type: "vec3f"
    };
  }
}
exports.Vec3Node = Vec3Node;
class Vec4Node extends ShaderNode {
  constructor(vx = 0.0, vy = 0.0, vz = 0.0, vw = 1.0) {
    super("Vec4");
    this.valueX = vx;
    this.valueY = vy;
    this.valueZ = vz;
    this.valueW = vw;
  }
  build(_, __, ctx) {
    return {
      out: `vec4f(${this.valueX}, ${this.valueY}, ${this.valueZ}, ${this.valueW})`,
      type: "vec4f"
    };
  }
}
exports.Vec4Node = Vec4Node;
class ColorNode extends ShaderNode {
  constructor(r = 1.0, g = 1.0, b = 1.0, a = 1.0) {
    super("Color");
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  build(_, __, ctx) {
    return {
      out: `vec4f(${this.r}, ${this.g}, ${this.b}, ${this.a})`,
      type: "vec4f"
    };
  }
}

// MATH NODES
exports.ColorNode = ColorNode;
class AddNode extends ShaderNode {
  constructor() {
    super("Add");
    this.inputs = {
      a: {
        default: "0.0"
      },
      b: {
        default: "0.0"
      }
    };
  }
  build(_, __, ctx) {
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    const a = connA ? ctx.resolve(connA.fromNode, connA.fromPin) : this.inputs.a.default;
    const b = connB ? ctx.resolve(connB.fromNode, connB.fromPin) : this.inputs.b.default;
    return {
      out: ctx.temp("f32", `${a} + ${b}`),
      type: "f32"
    };
  }
}
exports.AddNode = AddNode;
class SubtractNode extends ShaderNode {
  constructor() {
    super("Subtract");
    this.inputs = {
      a: {
        default: "0.0"
      },
      b: {
        default: "0.0"
      }
    };
  }
  build(_, __, ctx) {
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    const a = connA ? ctx.resolve(connA.fromNode, connA.fromPin) : this.inputs.a.default;
    const b = connB ? ctx.resolve(connB.fromNode, connB.fromPin) : this.inputs.b.default;
    return {
      out: ctx.temp("f32", `${a} - ${b}`),
      type: "f32"
    };
  }
}
exports.SubtractNode = SubtractNode;
class MultiplyNode extends ShaderNode {
  constructor() {
    super("Multiply");
    this.inputs = {
      a: {
        default: "1.0"
      },
      b: {
        default: "1.0"
      }
    };
  }
  build(_, __, ctx) {
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    const a = connA ? ctx.resolve(connA.fromNode, connA.fromPin) : this.inputs.a.default;
    const b = connB ? ctx.resolve(connB.fromNode, connB.fromPin) : this.inputs.b.default;
    return {
      out: ctx.temp("f32", `${a} * ${b}`),
      type: "f32"
    };
  }
}
exports.MultiplyNode = MultiplyNode;
class DivideNode extends ShaderNode {
  constructor() {
    super("Divide");
    this.inputs = {
      a: {
        default: "1.0"
      },
      b: {
        default: "1.0"
      }
    };
  }
  build(_, __, ctx) {
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    const a = connA ? ctx.resolve(connA.fromNode, connA.fromPin) : this.inputs.a.default;
    const b = connB ? ctx.resolve(connB.fromNode, connB.fromPin) : this.inputs.b.default;
    return {
      out: ctx.temp("f32", `${a} / ${b}`),
      type: "f32"
    };
  }
}
exports.DivideNode = DivideNode;
class PowerNode extends ShaderNode {
  constructor() {
    super("Power");
    this.inputs = {
      base: {
        default: "1.0"
      },
      exponent: {
        default: "2.0"
      }
    };
  }
  build(_, __, ctx) {
    const connBase = ctx.shaderGraph.getInput(this, "base");
    const connExp = ctx.shaderGraph.getInput(this, "exponent");
    const base = connBase ? ctx.resolve(connBase.fromNode, connBase.fromPin) : this.inputs.base.default;
    const exp = connExp ? ctx.resolve(connExp.fromNode, connExp.fromPin) : this.inputs.exponent.default;
    return {
      out: ctx.temp("f32", `pow(${base}, ${exp})`),
      type: "f32"
    };
  }
}
exports.PowerNode = PowerNode;
class SqrtNode extends ShaderNode {
  constructor() {
    super("Sqrt");
    this.inputs = {
      value: {
        default: "1.0"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "value");
    const val = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.value.default;
    return {
      out: ctx.temp("f32", `sqrt(${val})`),
      type: "f32"
    };
  }
}
exports.SqrtNode = SqrtNode;
class AbsNode extends ShaderNode {
  constructor() {
    super("Abs");
    this.inputs = {
      value: {
        default: "0.0"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "value");
    const val = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.value.default;
    return {
      out: ctx.temp("f32", `abs(${val})`),
      type: "f32"
    };
  }
}
exports.AbsNode = AbsNode;
class MinNode extends ShaderNode {
  constructor() {
    super("Min");
    this.inputs = {
      a: {
        default: "0.0"
      },
      b: {
        default: "0.0"
      }
    };
  }
  build(_, __, ctx) {
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    const a = connA ? ctx.resolve(connA.fromNode, connA.fromPin) : this.inputs.a.default;
    const b = connB ? ctx.resolve(connB.fromNode, connB.fromPin) : this.inputs.b.default;
    return {
      out: ctx.temp("f32", `min(${a}, ${b})`),
      type: "f32"
    };
  }
}
exports.MinNode = MinNode;
class MaxNode extends ShaderNode {
  constructor() {
    super("Max");
    this.inputs = {
      a: {
        default: "0.0"
      },
      b: {
        default: "0.0"
      }
    };
  }
  build(_, __, ctx) {
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    const a = connA ? ctx.resolve(connA.fromNode, connA.fromPin) : this.inputs.a.default;
    const b = connB ? ctx.resolve(connB.fromNode, connB.fromPin) : this.inputs.b.default;
    return {
      out: ctx.temp("f32", `max(${a}, ${b})`),
      type: "f32"
    };
  }
}
exports.MaxNode = MaxNode;
class LerpNode extends ShaderNode {
  constructor() {
    super("Lerp");
    this.inputs = {
      a: {
        default: "0.0"
      },
      b: {
        default: "1.0"
      },
      t: {
        default: "0.5"
      }
    };
  }
  build(_, __, ctx) {
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    const connT = ctx.shaderGraph.getInput(this, "t");
    const a = connA ? ctx.resolve(connA.fromNode, connA.fromPin) : this.inputs.a.default;
    const b = connB ? ctx.resolve(connB.fromNode, connB.fromPin) : this.inputs.b.default;
    const t = connT ? ctx.resolve(connT.fromNode, connT.fromPin) : this.inputs.t.default;
    return {
      out: ctx.temp("f32", `mix(${a}, ${b}, ${t})`),
      type: "f32"
    };
  }
}
exports.LerpNode = LerpNode;
class SinNode extends ShaderNode {
  constructor() {
    super("Sin");
    this.inputs = {
      value: {
        default: "0.0"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "value");
    const val = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.value.default;
    return {
      out: ctx.temp("f32", `sin(${val})`),
      type: "f32"
    };
  }
}
exports.SinNode = SinNode;
class CosNode extends ShaderNode {
  constructor() {
    super("Cos");
    this.inputs = {
      value: {
        default: "0.0"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "value");
    const val = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.value.default;
    return {
      out: ctx.temp("f32", `cos(${val})`),
      type: "f32"
    };
  }
}
exports.CosNode = CosNode;
class TanNode extends ShaderNode {
  constructor() {
    super("Tan");
    this.inputs = {
      value: {
        default: "0.0"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "value");
    const val = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.value.default;
    return {
      out: ctx.temp("f32", `tan(${val})`),
      type: "f32"
    };
  }
}

// VECTOR OPERATIONS
exports.TanNode = TanNode;
class DotProductNode extends ShaderNode {
  constructor() {
    super("DotProduct");
    this.inputs = {
      a: {
        default: "vec3f(0.0)"
      },
      b: {
        default: "vec3f(0.0)"
      }
    };
  }
  build(_, __, ctx) {
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    const a = connA ? ctx.resolve(connA.fromNode, connA.fromPin) : this.inputs.a.default;
    const b = connB ? ctx.resolve(connB.fromNode, connB.fromPin) : this.inputs.b.default;
    return {
      out: ctx.temp("f32", `dot(${a}, ${b})`),
      type: "f32"
    };
  }
}
exports.DotProductNode = DotProductNode;
class CrossProductNode extends ShaderNode {
  constructor() {
    super("CrossProduct");
    this.inputs = {
      a: {
        default: "vec3f(0.0)"
      },
      b: {
        default: "vec3f(0.0)"
      }
    };
  }
  build(_, __, ctx) {
    const connA = ctx.shaderGraph.getInput(this, "a");
    const connB = ctx.shaderGraph.getInput(this, "b");
    const a = connA ? ctx.resolve(connA.fromNode, connA.fromPin) : this.inputs.a.default;
    const b = connB ? ctx.resolve(connB.fromNode, connB.fromPin) : this.inputs.b.default;
    return {
      out: ctx.temp("vec3f", `cross(${a}, ${b})`),
      type: "vec3f"
    };
  }
}
exports.CrossProductNode = CrossProductNode;
class NormalizeNode extends ShaderNode {
  constructor() {
    super("Normalize");
    this.inputs = {
      vector: {
        default: "vec3f(1.0)"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "vector");
    const vec = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.vector.default;
    return {
      out: ctx.temp("vec3f", `normalize(${vec})`),
      type: "vec3f"
    };
  }
}
exports.NormalizeNode = NormalizeNode;
class LengthNode extends ShaderNode {
  constructor() {
    super("Length");
    this.inputs = {
      vector: {
        default: "vec3f(0.0)"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "vector");
    const vec = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.vector.default;
    return {
      out: ctx.temp("f32", `length(${vec})`),
      type: "f32"
    };
  }
}

// CHANNEL/SWIZZLE NODES
exports.LengthNode = LengthNode;
class SplitVec4Node extends ShaderNode {
  constructor() {
    super("SplitVec4");
    this.inputs = {
      vector: {
        default: "vec4f(0.0)"
      }
    };
    // This node has multiple outputs!
  }
  build(pin, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "vector");
    const vec = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.vector.default;

    // Store the temp once
    if (!this._temp) {
      this._temp = ctx.temp("vec4f", vec);
    }

    // Return different components based on which output pin is being resolved
    switch (pin) {
      case "x":
        return {
          out: `${this._temp}.x`,
          type: "f32"
        };
      case "y":
        return {
          out: `${this._temp}.y`,
          type: "f32"
        };
      case "z":
        return {
          out: `${this._temp}.z`,
          type: "f32"
        };
      case "w":
        return {
          out: `${this._temp}.w`,
          type: "f32"
        };
      default:
        return {
          out: this._temp,
          type: "vec4f"
        };
    }
  }
}
exports.SplitVec4Node = SplitVec4Node;
class CombineVec4Node extends ShaderNode {
  constructor() {
    super("CombineVec4");
    this.inputs = {
      x: {
        default: "0.0"
      },
      y: {
        default: "0.0"
      },
      z: {
        default: "0.0"
      },
      w: {
        default: "1.0"
      }
    };
  }
  build(_, __, ctx) {
    const connX = ctx.shaderGraph.getInput(this, "x");
    const connY = ctx.shaderGraph.getInput(this, "y");
    const connZ = ctx.shaderGraph.getInput(this, "z");
    const connW = ctx.shaderGraph.getInput(this, "w");
    const x = connX ? ctx.resolve(connX.fromNode, connX.fromPin) : this.inputs.x.default;
    const y = connY ? ctx.resolve(connY.fromNode, connY.fromPin) : this.inputs.y.default;
    const z = connZ ? ctx.resolve(connZ.fromNode, connZ.fromPin) : this.inputs.z.default;
    const w = connW ? ctx.resolve(connW.fromNode, connW.fromPin) : this.inputs.w.default;
    return {
      out: ctx.temp("vec4f", `vec4f(${x}, ${y}, ${z}, ${w})`),
      type: "vec4f"
    };
  }
}

// UTILITY NODES
exports.CombineVec4Node = CombineVec4Node;
class FracNode extends ShaderNode {
  constructor() {
    super("Frac");
    this.inputs = {
      value: {
        default: "0.0"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "value");
    const val = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.value.default;
    return {
      out: ctx.temp("f32", `fract(${val})`),
      type: "f32"
    };
  }
}
exports.FracNode = FracNode;
class FloorNode extends ShaderNode {
  constructor() {
    super("Floor");
    this.inputs = {
      value: {
        default: "0.0"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "value");
    const val = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.value.default;
    return {
      out: ctx.temp("f32", `floor(${val})`),
      type: "f32"
    };
  }
}
exports.FloorNode = FloorNode;
class CeilNode extends ShaderNode {
  constructor() {
    super("Ceil");
    this.inputs = {
      value: {
        default: "0.0"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "value");
    const val = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.value.default;
    return {
      out: ctx.temp("f32", `ceil(${val})`),
      type: "f32"
    };
  }
}
exports.CeilNode = CeilNode;
class SmoothstepNode extends ShaderNode {
  constructor() {
    super("Smoothstep");
    this.inputs = {
      edge0: {
        default: "0.0"
      },
      edge1: {
        default: "1.0"
      },
      x: {
        default: "0.5"
      }
    };
  }
  build(_, __, ctx) {
    const connEdge0 = ctx.shaderGraph.getInput(this, "edge0");
    const connEdge1 = ctx.shaderGraph.getInput(this, "edge1");
    const connX = ctx.shaderGraph.getInput(this, "x");
    const edge0 = connEdge0 ? ctx.resolve(connEdge0.fromNode, connEdge0.fromPin) : this.inputs.edge0.default;
    const edge1 = connEdge1 ? ctx.resolve(connEdge1.fromNode, connEdge1.fromPin) : this.inputs.edge1.default;
    const x = connX ? ctx.resolve(connX.fromNode, connX.fromPin) : this.inputs.x.default;
    return {
      out: ctx.temp("f32", `smoothstep(${edge0}, ${edge1}, ${x})`),
      type: "f32"
    };
  }
}
exports.SmoothstepNode = SmoothstepNode;
class OneMinusNode extends ShaderNode {
  constructor() {
    super("OneMinus");
    this.inputs = {
      value: {
        default: "0.0"
      }
    };
  }
  build(_, __, ctx) {
    const conn = ctx.shaderGraph.getInput(this, "value");
    const val = conn ? ctx.resolve(conn.fromNode, conn.fromPin) : this.inputs.value.default;
    return {
      out: ctx.temp("f32", `1.0 - ${val}`),
      type: "f32"
    };
  }
}

// INPUT NODES
exports.OneMinusNode = OneMinusNode;
class FragmentPositionNode extends ShaderNode {
  constructor() {
    super("FragmentPosition");
  }
  build(_, __, ctx) {
    return {
      out: "input.fragPos",
      type: "vec3f"
    };
  }
}
exports.FragmentPositionNode = FragmentPositionNode;
class FragmentNormalNode extends ShaderNode {
  constructor() {
    super("FragmentNormal");
  }
  build(_, __, ctx) {
    return {
      out: "input.fragNorm",
      type: "vec3f"
    };
  }
}
exports.FragmentNormalNode = FragmentNormalNode;
class ViewDirectionNode extends ShaderNode {
  constructor() {
    super("ViewDirection");
  }
  build(_, __, ctx) {
    return {
      out: ctx.temp("vec3f", "normalize(scene.cameraPos - input.fragPos)"),
      type: "vec3f"
    };
  }
}
exports.ViewDirectionNode = ViewDirectionNode;
class GlobalAmbientNode extends ShaderNode {
  constructor() {
    super("GlobalAmbient");
  }
  build(_, __, ctx) {
    return {
      out: "scene.globalAmbient",
      type: "vec3f"
    };
  }
}

// export class InlineWGSLNode {
//   constructor(code = "return vec4f(1.0, 0.0, 0.0, 1.0);") {
//     this.id = nodeId++;
//     this.type = "InlineWGSL";
//     this.code = code;
//     this.label = "Inline WGSL";

//     this.inputs = {};
//     this.outputs = {
//       result: {type: "vec4f"}
//     };
//   }

//   build(pin, value, ctx) {
//     if(pin === "result") {
//       const fnName = `inlineWGSL_${this.id}`;

//       const fnCode = `
// fn ${fnName}() -> vec4f {
//   ${this.code}
// }`;

//       ctx.registerFunction(fnName, fnCode);
//       const out = ctx.temp("vec4f", `${fnName}()`);

//       return {out};
//     }
//   }
// }
exports.GlobalAmbientNode = GlobalAmbientNode;
class ConnectionLayer {
  constructor(svg, shaderGraph) {
    this.svg = svg;
    this.shaderGraph = shaderGraph;
    this.temp = null;
    this.from = null;
    document.addEventListener("pointermove", e => this.move(e));
    document.addEventListener("pointerup", e => this.up(e));
  }
  attach(pin) {
    pin.onpointerdown = e => {
      e.stopPropagation();
      if (pin.dataset.type !== "output") return;
      this.from = pin;
      this.temp = this.path();
      this.svg.appendChild(this.temp);
    };
  }
  move(e) {
    if (!this.temp || !this.from) return;
    this.draw(this.temp, this.center(this.from), {
      x: e.clientX,
      y: e.clientY
    });
  }
  up(e) {
    if (!this.temp || !this.from) return;
    const t = document.elementFromPoint(e.clientX, e.clientY);
    if (t?.classList.contains("pinShader") && t.dataset.type === "input") {
      this.finalize(this.from, t);
    }
    this.temp.remove();
    this.temp = this.from = null;
  }
  finalize(outPin, inPin) {
    const fromNode = this.shaderGraph.nodes.find(n => n.id === outPin.dataset.node);
    const toNode = this.shaderGraph.nodes.find(n => n.id === inPin.dataset.node);
    const fromPin = outPin.dataset.pin;
    const toPin = inPin.dataset.pin;
    this.shaderGraph.connect(fromNode, fromPin, toNode, toPin);
    this.redrawAll();
  }
  redrawAll() {
    [...this.svg.children].forEach(p => p.remove()); // remove old paths
    this.shaderGraph.connections.forEach(c => this.redrawConnection(c));
  }
  redrawConnection(conn) {
    const path = this.path();
    path.dataset.from = `${conn.fromNode.id}:${conn.fromPin}`;
    path.dataset.to = `${conn.toNode.id}:${conn.toPin}`;
    this.svg.appendChild(path);
    const a = document.querySelector(`.pinShader.output[data-node="${conn.fromNode.id}"][data-pin="${conn.fromPin}"]`);
    const b = document.querySelector(`.pinShader.input[data-node="${conn.toNode.id}"][data-pin="${conn.toPin}"]`);
    if (a && b) this.draw(path, this.center(a), this.center(b));
  }
  path() {
    const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
    p.setAttribute("stroke", "#6aa9ff");
    p.setAttribute("stroke-width", "2");
    p.setAttribute("fill", "none");
    return p;
  }
  draw(p, a, b) {
    const dx = Math.abs(b.x - a.x) * 0.5;
    p.setAttribute("d", `M${a.x},${a.y} C${a.x + dx},${a.y} ${b.x - dx},${b.y} ${b.x},${b.y}`);
  }
  center(el) {
    const r = el.getBoundingClientRect();
    const svgRect = this.svg.getBoundingClientRect();
    return {
      x: r.left + r.width / 2 - svgRect.left,
      y: r.top + r.height / 2 - svgRect.top
    };
  }
}
async function openFragmentShaderEditor(id = "fragShader") {
  return new Promise((resolve, reject) => {
    const shaderGraph = new FragmentShaderGraph(id);
    const root = document.createElement("div");
    root.id = "shaderDOM";
    root.style.cssText = `
    position:fixed; left: 17.5%; top:4%;
    background:#0b0e14; color:#eee;
    display:flex; font-family:system-ui;
    width:300%;height:90%
  `;
    root.style.display = 'none';
    /* LEFT MENU */
    const menu = document.createElement("div");
    menu.style.cssText = `
    width:200px; border-right:1px solid #222;
    padding:8px; background:#0f1320; height: 77vh; overflow: scroll;
  `;
    const btn = (txt, fn) => {
      const b = document.createElement("button");
      b.textContent = txt;
      b.style.cssText = "width:100%;margin:4px 0;";
      if (txt == "Compile All" || txt == "Compile" || txt == "Save Graph" || txt == "Load Graph") b.style.cssText += "color: orange;";
      if (txt == "Create New") b.style.cssText += "color: lime;";
      if (txt == "Delete") b.style.cssText += "color: red;";
      b.classList.add("btn");
      b.classList.add("btnLeftBox");
      b.onclick = fn;
      menu.appendChild(b);
    };
    /* GRAPH AREA */
    const area = document.createElement("div");
    area.style.cssText = "flex:1;position:relative";
    area.classList.add('fancy-grid-bg');
    area.classList.add('dark');
    let pan = {
      active: false,
      ox: 0,
      oy: 0
    };
    area.addEventListener("pointerdown", e => {
      if (e.target !== area) return;
      pan.active = true;
      pan.ox = e.clientX;
      pan.oy = e.clientY;
      area.setPointerCapture(e.pointerId);
    });
    area.addEventListener("pointermove", e => {
      if (!pan.active) return;
      const dx = e.clientX - pan.ox;
      const dy = e.clientY - pan.oy;
      pan.ox = e.clientX;
      pan.oy = e.clientY;
      shaderGraph.nodes.forEach(n => {
        n.x += dx;
        n.y += dy;
        const el = document.querySelector(`.nodeShader[data-node-id="${n.id}"]`);
        if (el) {
          el.style.left = n.x + "px";
          el.style.top = n.y + "px";
        }
      });
      connectionLayer.redrawAll();
    });
    area.addEventListener("pointerup", e => {
      pan.active = false;
      area.releasePointerCapture(e.pointerId);
    });
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.style.position = "absolute";
    svg.style.left = "0";
    svg.style.top = "0";
    svg.style.width = "100%";
    svg.style.height = "100%";
    svg.style.pointerEvents = "none";
    area.appendChild(svg);
    root.appendChild(menu);
    root.appendChild(area);
    document.body.appendChild(root);
    const style = document.createElement("style");
    style.textContent = `
#shaderDOM { z-index:2 }

.nodeShader {
  position:absolute;
  min-width:140px;
  background:#151a2a;
  border:1px solid #222;
  border-radius:6px;
  padding:0;
  color:#eee;
  cursor:move;
}

.nodeShader.selected {
  border-color: #ff8800;
  box-shadow: 0 0 8px #ff8800;
}

.nodeShader .node-title {
  -webkit-text-stroke-width: 0.2px;
  display: block;
  padding: 6px 8px;
  font-size: 13px;
  line-height: 1.2;
  color: #ffffff;
  background: #1f2937;
  white-space: nowrap;
  position: relative;
  z-index: 10;
  user-select: none;
  border-radius: 6px 6px 0 0;
  border-bottom: 1px solid #333;
}

.node-properties {
  padding: 6px 8px;
  background: #1a1f2e;
  border-bottom: 1px solid #333;
}

.node-properties input,
.node-properties textarea {
  font-family: monospace;
}

.node-properties input:focus,
.node-properties textarea:focus {
  outline: none;
  border-color: #6aa9ff;
}

.nodeShader-body {
  display:flex;
  gap:8px;
  justify-content: space-between;
  padding: 6px 8px;
}

.nodeShader-inputs {
  display:flex;
  flex-direction:column;
}

.pinShader-row {
  position: relative;
  width: 100%;
  height: 18px;
  display: flex;
  align-items: center;
  font-family: monospace;
  font-size: 12px;
  color: #ddd;
}

.pinShader {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: #0f0;
  border: 2px solid #000;
  z-index: 5;
  flex-shrink: 0;
}

.pinShader.input {  margin-left: -6px; background: #ff6a6a; }
.pinShader.output { margin-right: -6px; background: #6aa9ff; }

.pinShader-label {
  margin-left: 6px;
  white-space: nowrap;
  pointer-events: none;
  user-select: none;
  z-index: 6;
}

svg path {
  pointer-events:none;
}
`;
    document.head.appendChild(style);
    const connectionLayer = new ConnectionLayer(svg, shaderGraph);
    function addNode(node, x, y) {
      const test = shaderGraph.addNode(node);
      if (test == null) return;
      if (x == null || y == null) {
        const p = shaderGraph.nextSpawn();
        x = p.x;
        y = p.y;
      }
      node.x = x;
      node.y = y;
      const el = document.createElement("div");
      el.className = "nodeShader";
      el.style.left = x + "px";
      el.style.top = y + "px";
      area.appendChild(el);
      el.tabIndex = 0;
      el.addEventListener("click", e => {
        e.stopPropagation();
        document.querySelectorAll(".nodeShader.selected").forEach(n => n.classList.remove("selected"));
        el.classList.add("selected");
      });
      el.dataset.nodeId = node.id;
      const title = document.createElement("div");
      title.className = "node-title";
      title.textContent = node.type;
      el.appendChild(title);

      // ✅ ADD INPUT FIELDS FOR NODE PROPERTIES
      const propsContainer = document.createElement("div");
      propsContainer.className = "node-properties";
      propsContainer.style.cssText = "padding: 4px 8px; background: #1a1f2e;";

      // Helper to create labeled input
      function addPropertyInput(label, propName, value, type = "number", step = "0.01") {
        const row = document.createElement("div");
        row.style.cssText = "display: flex; align-items: center; gap: 6px; margin: 2px 0;";
        const labelEl = document.createElement("label");
        labelEl.textContent = label + ":";
        labelEl.style.cssText = "font-size: 11px; color: #aaa; min-width: 30px;";
        const input = document.createElement("input");
        input.type = type;
        input.value = value;
        input.step = step;
        input.style.cssText = "flex: 1; background: #0a0d14; border: 1px solid #333; color: #fff; padding: 2px 4px; font-size: 11px; border-radius: 3px;";
        input.addEventListener("input", () => {
          const val = type === "number" ? parseFloat(input.value) : input.value;
          node[propName] = val;
        });
        input.addEventListener("pointerdown", e => e.stopPropagation());
        row.appendChild(labelEl);
        row.appendChild(input);
        propsContainer.appendChild(row);
      }

      // ✅ ADD PROPERTIES BASED ON NODE TYPE
      if (node.type === "Float") {
        addPropertyInput("Value", "value", node.value);
      } else if (node.type === "Vec2") {
        addPropertyInput("X", "valueX", node.valueX || 0);
        addPropertyInput("Y", "valueY", node.valueY || 0);
      } else if (node.type === "Vec3") {
        addPropertyInput("X", "valueX", node.valueX || 0);
        addPropertyInput("Y", "valueY", node.valueY || 0);
        addPropertyInput("Z", "valueZ", node.valueZ || 0);
      } else if (node.type === "Vec4") {
        addPropertyInput("X", "valueX", node.valueX || 0);
        addPropertyInput("Y", "valueY", node.valueY || 0);
        addPropertyInput("Z", "valueZ", node.valueZ || 0);
        addPropertyInput("W", "valueW", node.valueW || 1);
      } else if (node.type === "Color") {
        addPropertyInput("R", "r", node.r);
        addPropertyInput("G", "g", node.g);
        addPropertyInput("B", "b", node.b);
        addPropertyInput("A", "a", node.a);
      } else if (node.type === "AddVec2") {
        // This node has vec2 inputs, but users typically connect nodes
        // If you want to show defaults:
        addPropertyInput("Default A", "defaultA", node.inputs.a.default);
        addPropertyInput("Default B", "defaultB", node.inputs.b.default);
      } else if (node.type === "InlineFunction") {
        addPropertyInput("Name", "fnName", node.fnName, "text");
        const ta = document.createElement("textarea");
        ta.value = node.code;
        ta.style.cssText = "width: 100%; height: 80px; background: #0a0d14; border: 1px solid #333; color: #fff; padding: 4px; font-family: monospace; font-size: 11px; resize: vertical;";
        ta.oninput = () => node.code = ta.value;
        ta.onpointerdown = e => e.stopPropagation();
        propsContainer.appendChild(ta);
      }
      if (propsContainer.children.length > 0) {
        el.appendChild(propsContainer);
      }
      const body = document.createElement("div");
      body.className = "nodeShader-body";
      el.appendChild(body);
      function createPinRow(pinName, type = "input") {
        const row = document.createElement("div");
        row.className = "pinShader-row";
        const pin = document.createElement("div");
        pin.className = "pinShader " + (type === "input" ? "input" : "output");
        pin.dataset.node = node.id;
        pin.dataset.pin = pinName;
        pin.dataset.type = type;
        const label = document.createElement("div");
        label.className = "pinShader-label";
        label.textContent = pinName;
        if (type === "input") row.append(pin, label);else {
          row.style.justifyContent = "flex-end";
          row.append(label, pin);
        }
        return {
          row,
          pin
        };
      }
      const inputsContainer = document.createElement("div");
      inputsContainer.className = "nodeShader-inputs";
      body.appendChild(inputsContainer);
      Object.keys(node.inputs || {}).forEach(pinName => {
        const {
          row,
          pin
        } = createPinRow(pinName, "input");
        inputsContainer.appendChild(row);
      });
      const outputContainer = document.createElement("div");
      outputContainer.style.width = '100%';
      body.appendChild(outputContainer);
      const {
        row: outRow,
        pin: outPin
      } = createPinRow("out", "output");
      outputContainer.appendChild(outRow);
      connectionLayer.attach(outPin);
      shaderGraph.connectionLayer = connectionLayer;
      shaderGraph.makeDraggable(el, node, connectionLayer);
    }
    document.addEventListener("keydown", e => {
      if (e.key === "Delete") {
        const sel = document.querySelector(".nodeShader.selected");
        if (!sel) return;
        const nodeId = sel.dataset.nodeId;
        const node = shaderGraph.nodes.find(n => n.id === nodeId);
        if (!node) return;
        // remove connections involving this node
        shaderGraph.connections = shaderGraph.connections.filter(c => c.fromNode !== node && c.toNode !== node);
        // remove SVG paths
        [...svg.querySelectorAll("path")].forEach(p => {
          if (p.dataset.from?.startsWith(nodeId + ":") || p.dataset.to?.startsWith(nodeId + ":")) {
            p.remove();
          }
        });
        sel.remove();
        shaderGraph.nodes = shaderGraph.nodes.filter(n => n !== node);
        // ?
        shaderGraph.connectionLayer.redrawConnection();
      }
    });
    btn("outColor", () => addNode(new FragmentOutputNode(), 500, 200));
    btn("CameraPos", () => addNode(new CameraPosNode()));
    btn("MultiplyVec2", () => addNode(new MultiplyVec2Node()));
    btn("Time", () => addNode(new TimeNode()));
    btn("AddVec2", () => addNode(new AddVec2Node()));
    btn("GlobalAmbient", () => addNode(new GlobalAmbientNode()));
    btn("TextureSampler", () => addNode(new TextureSamplerNode()));
    btn("MultiplyColor", () => addNode(new MultiplyColorNode()));
    btn("Grayscale", () => addNode(new GrayscaleNode()));
    btn("Contrast", () => addNode(new ContrastNode()));
    // btn("Inline WGSL", () => addNode(new InlineWGSLNode(prompt("WGSL code"))));
    btn("Inline Function", () => addNode(new InlineFunctionNode("customFn", "")));
    // btn("BaseColorOutputNode", () => addNode(new BaseColorOutputNode()));
    // btn("EmissiveOutputNode", () => addNode(new EmissiveOutputNode()));
    btn("LightShadowNode", () => addNode(new LightShadowNode()));
    btn("LightToColorNode", () => addNode(new LightToColorNode()));
    btn("AlphaOutput", () => addNode(new AlphaOutput()));
    btn("NormalOutput", () => addNode(new NormalOutput()));
    // Constants
    btn("Float", () => {
      const val = prompt("Enter float value:", "1.0");
      addNode(new FloatNode(parseFloat(val) || 1.0));
    });
    btn("UV", () => addNode(new UVNode(1, 0)));
    btn("Vec3", () => addNode(new Vec3Node(1, 0, 0)));
    btn("Vec2", () => addNode(new Vec2Node(1, 0)));
    btn("Color", () => addNode(new ColorNode(1, 1, 1, 1)));
    // Math
    btn("Add", () => addNode(new AddNode()));
    btn("Multiply", () => addNode(new MultiplyNode()));
    btn("Power", () => addNode(new PowerNode()));
    btn("Lerp", () => addNode(new LerpNode()));
    // Trig
    btn("Sin", () => addNode(new SinNode()));
    btn("Cos", () => addNode(new CosNode()));
    // Vector
    btn("Normalize", () => addNode(new NormalizeNode()));
    btn("DotProduct", () => addNode(new DotProductNode()));
    btn("Length", () => addNode(new LengthNode()));
    // Utility
    btn("Frac", () => addNode(new FracNode()));
    btn("OneMinus", () => addNode(new OneMinusNode()));
    btn("Smoothstep", () => addNode(new SmoothstepNode()));
    // Inputs
    btn("FragPosition", () => addNode(new FragmentPositionNode()));
    btn("FragNormal", () => addNode(new FragmentNormalNode()));
    btn("ViewDirection", () => addNode(new ViewDirectionNode()));
    // Channel ops
    btn("SplitVec4", () => addNode(new SplitVec4Node()));
    btn("CombineVec4", () => addNode(new CombineVec4Node()));
    btn("Create New", async () => {
      shaderGraph.clear();
      let nameOfGraphMaterital = prompt("You must define a name for shader graph:", "MyShader1");
      if (nameOfGraphMaterital && nameOfGraphMaterital !== "") {
        const exist = await loadGraph(nameOfGraphMaterital, shaderGraph, addNode);
        if (exist === true) {
          console.info("ALREADY EXIST SHADER, please use diff name" + exist);
        } else {
          shaderGraph.id = nameOfGraphMaterital;
          saveGraph(shaderGraph, nameOfGraphMaterital);
        }
      }
    });
    btn("Compile", () => {
      let r = shaderGraph.compile();
      const graphGenShaderWGSL = (0, _flexCodexShaderAdapter.graphAdapter)(r, shaderGraph.nodes);
      // console.log("test compile ", graphGenShaderWGSL);
      shaderGraph.runtime_memory[shaderGraph.id] = graphGenShaderWGSL;
    });
    btn("Compile All", () => {
      for (let x = 0; x < shaderGraph.runtimeList.length; x++) {
        setTimeout(() => {
          (0, _utils.byId)('shader-graphs-list').selectedIndex = x + 1;
          const event = new Event('change', {
            bubbles: true
          });
          (0, _utils.byId)('shader-graphs-list').dispatchEvent(event);
          if (shaderGraph.runtimeList.length == x) {
            console.log('LAST');
          }
        }, 500 * x);
      }
    });
    btn("Save Graph", () => {
      saveGraph(shaderGraph, shaderGraph.id);
    });
    btn("Load Graph", async () => {
      shaderGraph.clear();
      let nameOfGraphMaterital = prompt("Choose Name:", "MyShader1");
      const exist = await loadGraph(nameOfGraphMaterital, shaderGraph, addNode);
      if (exist === false) {
        alert("⚠️Graph no exist!⚠️");
      }
    });
    btn("Delete", () => {
      console.log("[DELETE]", shaderGraph.id);
      document.dispatchEvent(new CustomEvent('delete-shader-graph', {
        detail: shaderGraph.id
      }));
    });
    btn("Import JSON", async e => {
      shaderGraph.clear();
      let nameOfGraphMaterital = prompt("You must define a name for shader graph:", "MyShader1");
      if (nameOfGraphMaterital && nameOfGraphMaterital !== "") {
        const exist = await loadGraph(nameOfGraphMaterital, shaderGraph, addNode);
        if (exist === true) {
          console.info("ALREADY EXIST SHADER, please use diff name" + exist);
        } else {
          shaderGraph.id = nameOfGraphMaterital;
          const input = document.createElement("input");
          input.type = "file";
          input.accept = ".json";
          input.style.display = "none";
          input.onchange = e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
              try {
                let data = JSON.parse(reader.result);
                data.id = shaderGraph.id;
                document.dispatchEvent(new CustomEvent('on-graph-load', {
                  detail: {
                    name: data.id,
                    content: data
                  }
                }));
                // input.remove(); ?
              } catch (err) {
                console.error("Invalid JSON file", err);
              }
            };
            reader.readAsText(file);
          };
          document.body.appendChild(input);
          input.click();
        }
      }
    });
    const titleb = document.createElement("p");
    titleb.style.cssText = "width:100%;margin:4px 0;";
    titleb.classList.add("btn3");
    titleb.classList.add("btnLeftBox");
    titleb.innerHTML = `Current shader:`;
    titleb.style.webkitTextStrokeWidth = 0;
    menu.appendChild(titleb);
    const b = document.createElement("select");
    b.id = "shader-graphs-list";
    b.style.cssText = "width:100%;margin:4px 0;";
    b.classList.add("btn");
    b.classList.add("btnLeftBox");
    b.style.webkitTextStrokeWidth = 0;
    menu.appendChild(b);
    document.addEventListener("on-shader-graphs-list", e => {
      // console.log("on-shader-graphs-list :", e.detail);
      const shaders = e.detail;
      b.innerHTML = "";
      var __ = 0;
      if (!(0, _utils.byId)("shader-graphs-list-dom")) {
        __ = 1;
        const placeholder = document.createElement("option");
        placeholder.id = "shader-graphs-list-dom";
        placeholder.textContent = "Select shader";
        placeholder.value = "";
        placeholder.disabled = true;
        placeholder.selected = true;
        b.appendChild(placeholder);
      }
      shaderGraph.runtimeList = [];
      shaders.forEach((shader, index) => {
        const opt = document.createElement("option");
        opt.value = index;
        opt.textContent = shader.name;
        shaderGraph.runtimeList.push(shader.name);
        let test = JSON.parse(shader.content);
        // console.log("Graph content shader:", test.final);
        shaderGraph.runtime_memory[shader.name] = test.final;
        b.appendChild(opt);
      });
      if (__ == 1) {
        b.onchange = event => {
          shaderGraph.clear();
          const selectedIndex = event.target.value;
          const selectedShader = shaders[selectedIndex];
          console.log("Selected shader:", selectedShader.name);
          // console.log("Graph content:", selectedShader.content);
          // There is a other way - compile and assign - no cache policy
          // const exist = loadGraph(selectedShader.name, shaderGraph, addNode);
          document.dispatchEvent(new CustomEvent('load-shader-graph', {
            detail: selectedShader.name
          }));
          console.log("Lets load selectedShader.name ", selectedShader.name);
        };
      }
      document.dispatchEvent(new CustomEvent("sgraphs-ready", {}));
    });
    document.dispatchEvent(new CustomEvent('get-shader-graphs', {}));
    // Init
    document.addEventListener("sgraphs-ready", async () => {
      if (shaderGraph.runtimeList.length > 0) {
        // load first
        shaderGraph.id = shaderGraph.runtimeList[0];
        const exist = await loadGraph(shaderGraph.id, shaderGraph, addNode);
        if (exist == false) {
          saveGraph(shaderGraph, shaderGraph.id);
          console.log("NEW SHADER:[SAVED]" + exist);
        }
      } else {
        console.log('no saved graphs');
      }
      resolve(shaderGraph);
    });
    // if(shaderGraph.nodes.length == 0) addNode(new FragmentOutputNode(), 500, 200);
  });
}
function serializeGraph(shaderGraph) {
  return JSON.stringify({
    nodes: shaderGraph.nodes.map(n => ({
      id: n.id,
      type: n.type,
      x: n.x ?? 100,
      y: n.y ?? 100,
      fnName: n.fnName,
      code: n.code,
      name: n.name,
      value: n.value,
      r: n.r,
      g: n.g,
      b: n.b,
      a: n.a,
      inputs: Object.fromEntries(Object.entries(n.inputs || {}).map(([k, v]) => [k, {
        default: v.default
      }])),
      valueX: n.valueX,
      valueY: n.valueY,
      valueZ: n.valueZ,
      valueW: n.valueW
    })),
    connections: shaderGraph.connections.map(c => ({
      from: c.fromNode.id,
      fromPin: c.fromPin,
      to: c.toNode.id,
      toPin: c.toPin
    })),
    final: shaderGraph.runtime_memory[shaderGraph.id] ? shaderGraph.runtime_memory[shaderGraph.id] : null
  });
}
function saveGraph(shaderGraph, key = "fragShaderGraph") {
  let content = serializeGraph(shaderGraph);
  localStorage.setItem(key, content);
  console.log('test compile content', shaderGraph.runtime_memory[key]);
  console.log('test compile content', content);
  if (shaderGraph.runtime_memory[key]) {
    // content.runtime_memory = shaderGraph.runtime_memory[key];
  } else {
    console.warn("GraphShader is saved for src but with no compile final data for prod build.");
  }
  document.dispatchEvent(new CustomEvent('save-shader-graph', {
    detail: {
      name: key,
      content: content
    }
  }));
  console.log("%cShader shaderGraph saved", _utils.LOG_FUNNY_ARCADE);
}
async function loadGraph(key, shaderGraph, addNodeUI) {
  // shaderGraph.clear();
  // Editor is not aware where is project file 
  // It is in generated file&folder event projectName is defined
  // Its not good to write import for project file here in middle of engine core...
  if (shaderGraph.onGraphLoadAttached === false) {
    shaderGraph.onGraphLoadAttached = true;
    document.addEventListener('on-graph-load', e => {
      if (e.detail == null) {
        return;
      }
      shaderGraph.nodes.length = 0;
      shaderGraph.connections.length = 0;
      shaderGraph.id = e.detail.name;
      let data;
      if (typeof e.detail.content === 'object') {
        data = e.detail.content;
      } else {
        data = JSON.parse(e.detail.content);
      }
      if (!data) return false;
      const map = {};
      data.nodes.forEach(node => {
        const saveId = node.id;
        const saveX = node.x;
        const saveY = node.y;
        switch (node.type) {
          case "FragmentOutput":
            node = new FragmentOutputNode();
            break;
          case "CameraPos":
            node = new CameraPosNode();
            break;
          case "MultiplyVec2":
            node = new MultiplyVec2Node();
            break;
          case "AddVec2":
            node = new AddVec2Node();
            break;
          case "Time":
            node = new TimeNode();
            break;
          case "InlineFunction":
            node = new InlineFunctionNode(node.fnName, node.code);
            break;
          case "TextureSampler":
            node = new TextureSamplerNode(node.name);
            break;
          case "MultiplyColor":
            node = new MultiplyColorNode();
            break;
          case "Grayscale":
            node = new GrayscaleNode();
            break;
          case "Contrast":
            node = new ContrastNode();
            break;
          case "AlphaOutput":
            node = new AlphaOutput();
            break;
          case "NormalOutput":
            node = new NormalOutput();
            break;
          case "LightShadowNode":
            node = new LightShadowNode();
            break;
          case "LightToColor":
            node = new LightToColorNode();
            break;
          case "UV":
            node = new UVNode();
            break;
          case "Float":
            node = new FloatNode(node.value ?? 1.0);
            break;
          case "Vec2":
            node = new Vec2Node(node.valueX ?? 0, node.valueY ?? 0);
            break;
          case "Vec3":
            node = new Vec3Node(node.valueX ?? 0, node.valueY ?? 0, node.valueZ ?? 0);
            break;
          case "Vec4":
            node = new Vec4Node(node.valueX ?? 0, node.valueY ?? 0, node.valueZ ?? 0, node.valueW ?? 1);
            break;
          case "Color":
            node = new ColorNode(node.r ?? 1, node.g ?? 1, node.b ?? 1, node.a ?? 1);
            break;
          case "Add":
            node = new AddNode();
            break;
          case "Subtract":
            node = new SubtractNode();
            break;
          case "Multiply":
            node = new MultiplyNode();
            break;
          case "Divide":
            node = new DivideNode();
            break;
          case "Power":
            node = new PowerNode();
            break;
          case "Sin":
            node = new SinNode();
            break;
          case "Cos":
            node = new CosNode();
            break;
          case "Normalize":
            node = new NormalizeNode();
            break;
          case "DotProduct":
            node = new DotProductNode();
            break;
          case "Lerp":
            node = new LerpNode();
            break;
          case "Frac":
            node = new FracNode();
            break;
          case "OneMinus":
            node = new OneMinusNode();
            break;
          case "Smoothstep":
            node = new SmoothstepNode();
            break;
          case "FragmentPosition":
            node = new FragmentPositionNode();
            break;
          case "ViewDirection":
            node = new ViewDirectionNode();
            break;
          case "SplitVec4":
            node = new SplitVec4Node();
            break;
          case "CombineVec4":
            node = new CombineVec4Node();
            break;
          case "GlobalAmbient":
            node = new GlobalAmbientNode();
            break;
        }
        node.id = saveId;
        node.x = saveX;
        node.y = saveY;
        // console.log("Loaded:" + node)
        map[node.id] = node;
        addNodeUI(node, node.x, node.y);
      });
      setTimeout(() => data.connections.forEach(c => {
        const fromNode = map[c.from];
        const toNode = map[c.to];
        const fromPin = c.fromPin;
        const toPin = c.toPin;
        if (!fromNode || !toNode) {
          console.warn("Skipping connection due to missing node", c);
          return;
        }
        shaderGraph.connect(fromNode, fromPin, toNode, toPin);
        const path = shaderGraph.connectionLayer.path();
        path.dataset.from = `${fromNode.id}:${fromPin}`;
        path.dataset.to = `${toNode.id}:${toPin}`;
        shaderGraph.connectionLayer.svg.appendChild(path);
        shaderGraph.connectionLayer.redrawAll(path);
      }), 50);

      // compile every loaded
      // let r = shaderGraph.compile();
      // const graphGenShaderWGSL = graphAdapter(r, shaderGraph.nodes);
      // console.log("test compile shaderGraph.final ", shaderGraph.final);
      // shaderGraph.runtime_memory[shaderGraph.id] = graphGenShaderWGSL;
      return true;
    });
  }
  document.dispatchEvent(new CustomEvent('load-shader-graph', {
    detail: key
  }));
}

},{"../../engine/utils.js":56,"./flexCodexShaderAdapter.js":91}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.graphAdapter = graphAdapter;
function graphAdapter(compilerResult, nodes) {
  const {
    structs,
    uniforms,
    functions,
    locals,
    outputs,
    mainLines
  } = compilerResult;

  // console.log("what os node in adapter", nodes);

  const globals = new Set();
  globals.add("const PI: f32 = 3.141592653589793;");
  globals.add("override shadowDepthTextureSize: f32 = 1024.0;");

  // 3️⃣ Prepare final color outputs
  const baseColor = outputs.baseColor || "vec3f(1.0)";
  const alpha = outputs.alpha || "1.0";
  const normal = outputs.normal || "normalize(input.fragNorm)";
  const emissive = outputs.emissive || "vec3f(0.0)";

  /////////////////////////
  // --- Iterate nodes in topological order ---
  for (const node of nodes) {
    if (node.type === "LightShadowNode") {
      functions.push(`
fn computeSpotLight(light: SpotLight, N: vec3f, fragPos: vec3f, V: vec3f, material: PBRMaterialData) -> vec3f {
    let L = normalize(light.position - fragPos);
    let NdotL = max(dot(N, L), 0.0);

    let theta = dot(L, normalize(-light.direction));
    let epsilon = light.innerCutoff - light.outerCutoff;
    var coneAtten = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);

    // coneAtten = 1.0;
    if (coneAtten <= 0.0 || NdotL <= 0.0) {
        return vec3f(0.0);
    }

    let F0 = mix(vec3f(0.04), material.baseColor.rgb, vec3f(material.metallic));
    let H = normalize(L + V);
    let F = F0 + (1.0 - F0) * pow(1.0 - max(dot(H, V), 0.0), 5.0);

    let alpha = material.roughness * material.roughness;
    let NdotH = max(dot(N, H), 0.0);
    let alpha2 = alpha * alpha;
    let denom = (NdotH * NdotH * (alpha2 - 1.0) + 1.0);
    let D = alpha2 / (PI * denom * denom + 1e-5);

    let k = (alpha + 1.0) * (alpha + 1.0) / 8.0;
    let NdotV = max(dot(N, V), 0.0);
    let Gv = NdotV / (NdotV * (1.0 - k) + k);
    let Gl = NdotL / (NdotL * (1.0 - k) + k);
    let G = Gv * Gl;

    let numerator = D * G * F;
    let denominator = 4.0 * NdotV * NdotL + 1e-5;
    let specular = numerator / denominator;

    let kS = F;
    let kD = (vec3f(1.0) - kS) * (1.0 - material.metallic);
    let diffuse = kD * material.baseColor.rgb / PI;

    let radiance = light.color * light.intensity;
    // return (diffuse + specular) * radiance * NdotL * coneAtten;
    return material.baseColor * light.color * light.intensity * NdotL * coneAtten;
}

fn sampleShadow(shadowUV: vec2f, layer: i32, depthRef: f32, normal: vec3f, lightDir: vec3f) -> f32 {
    var visibility: f32 = 0.0;
    let biasConstant: f32 = 0.001;
    let slopeBias = max(0.002 * (1.0 - dot(normal, lightDir)), 0.0);
    let bias = biasConstant + slopeBias;
    let oneOverSize = 1.0 / (shadowDepthTextureSize * 0.5);
    let offsets: array<vec2f, 9> = array<vec2f, 9>(
        vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0),
        vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),
        vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0)
    );
    for(var i: u32 = 0u; i < 9u; i = i + 1u) {
        visibility += textureSampleCompare(
            shadowMapArray, shadowSampler,
            shadowUV + offsets[i] * oneOverSize,
            layer, depthRef - bias
        );
    }
    return visibility / 9.0;
}
`);
      // Inject compute function (inline or multi-line)
      // mainLines.push(`finalColor *= vec4(scene.globalAmbient + lightContribution, 1);`);
    }
  }
  return `
/* === Engine uniforms === */

// DINAMIC GLOBALS
${[...globals].join("\n")}

// DINAMIC STRUCTS
${[...structs].join("\n")}

// PREDEFINED
struct Scene {
    lightViewProjMatrix  : mat4x4f,
    cameraViewProjMatrix : mat4x4f,
    cameraPos            : vec3f,
    padding2             : f32,
    lightPos             : vec3f,
    padding              : f32,
    globalAmbient        : vec3f,
    padding3             : f32,
    time                 : f32,
    deltaTime            : f32,
    padding4             : vec2f,
};

// PREDEFINED
struct SpotLight {
    position      : vec3f,
    _pad1         : f32,
    direction     : vec3f,
    _pad2         : f32,
    innerCutoff   : f32,
    outerCutoff   : f32,
    intensity     : f32,
    _pad3         : f32,
    color         : vec3f,
    _pad4         : f32,
    range         : f32,
    ambientFactor : f32,
    shadowBias    : f32,
    _pad5         : f32,
    lightViewProj : mat4x4<f32>,
};

// PREDEFINED
struct MaterialPBR {
    baseColorFactor : vec4f,
    metallicFactor  : f32,
    roughnessFactor : f32,
    _pad1           : f32,
    _pad2           : f32,
};

// PREDEFINED
struct PBRMaterialData {
    baseColor : vec3f,
    metallic  : f32,
    roughness : f32,
    alpha     : f32
};

// PREDEFINED
const MAX_SPOTLIGHTS = 20u;

// PREDEFINED
@group(0) @binding(0) var<uniform> scene : Scene;
@group(0) @binding(1) var shadowMapArray: texture_depth_2d_array;
@group(0) @binding(2) var shadowSampler: sampler_comparison;
@group(0) @binding(3) var meshTexture: texture_2d<f32>;
@group(0) @binding(4) var meshSampler: sampler;
@group(0) @binding(5) var<uniform> spotlights: array<SpotLight, MAX_SPOTLIGHTS>;
@group(0) @binding(6) var metallicRoughnessTex: texture_2d<f32>;
@group(0) @binding(7) var metallicRoughnessSampler: sampler;
@group(0) @binding(8) var<uniform> material: MaterialPBR;

// ✅ Graph custom uniforms
${[...uniforms].join("\n")}

// ✅ Graph custom functions
${functions.join("\n\n")}

// PREDEFINED Fragment input
struct FragmentInput {
    @location(0) shadowPos : vec4f,
    @location(1) fragPos   : vec3f,
    @location(2) fragNorm  : vec3f,
    @location(3) uv        : vec2f,
};

// PREDEFINED PBR helpers
fn getPBRMaterial(uv: vec2f) -> PBRMaterialData {
    let texColor = textureSample(meshTexture, meshSampler, uv);
    let baseColor = texColor.rgb * material.baseColorFactor.rgb;
    let mrTex = textureSample(metallicRoughnessTex, metallicRoughnessSampler, uv);
    let metallic = mrTex.b * material.metallicFactor;
    let roughness = mrTex.g * material.roughnessFactor;
    
    // ✅ Get alpha from texture and material factor
    // let alpha = texColor.a * material.baseColorFactor.a;
    let alpha = material.baseColorFactor.a;
    
    return PBRMaterialData(baseColor, metallic, roughness, alpha);
}

@fragment
fn main(input: FragmentInput) -> @location(0) vec4f {
  // Locals
  ${locals.join("\n  ")}
  ${mainLines.join("\n  ")}
  return ${outputs.outColor};
}
`;
}

},{}],92:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runtimeCacheObjs = exports.default = void 0;
var _utils = require("../../engine/utils");
var _curveEditor = require("./curve-editor");
var _generateAISchema = require("./generateAISchema.js");
/**
 * @description
 * Flux Codex Vertex use visual scripting model.
 *
 * @filename
 * fluxCodexVertex.js
 *
 * @Licence
 * This Source Code Form is subject to the terms of the
 * Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file,
 * You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Copyright (c) 2025 Nikola Lukić zlatnaspirala@gmail.com
 *
 * @Note
 * License summary for fluxCodexVertex.js (MPL 2.0):
 *
 * ✔ You MAY:
 * - Use this file in commercial and proprietary software
 * - Modify and redistribute this file
 * - Combine it with closed-source code
 * - Sell software that includes this file
 *
 * ✘ You MUST:
 * - Publish the source code of this file if you modify it
 * - Keep this file under MPL 2.0
 * - Provide a link to the MPL 2.0 license
 * - Preserve copyright notices
 *
 * ✔ You do NOT have to:
 * - Open-source your entire project
 * - Publish files that merely import or use this file
 * - Release unrelated source code
 *
 * - MPL applies ONLY to this file
 */

// import {MatrixMusicAsset} from "../../sounds/audioAsset";

// import {graphAdapter} from "./flexCodexShaderAdapter";

// Engine agnostic
let runtimeCacheObjs = exports.runtimeCacheObjs = [];
class FluxCodexVertex {
  constructor(boardId, boardWrapId, logId, methodsManager, projName, toolTip) {
    this.debugMode = true;
    this.toolTip = toolTip;
    this.curveEditor = new _curveEditor.CurveEditor();
    this.SAVE_KEY = "fluxCodexVertex" + projName;
    this.methodsManager = methodsManager;
    this.variables = {
      number: {},
      boolean: {},
      string: {},
      object: {}
    };
    // DOM Elements
    this.board = document.getElementById(boardId);
    this.boardWrap = document.getElementById(boardWrapId);
    this.svg = this.board.querySelector("svg.connections");
    this.logEl = document.getElementById(logId);

    // Data Model
    this.nodes = {};
    this.links = [];
    this.nodeCounter = 1;
    this.linkCounter = 1;
    this._execContext = null;

    // State Management
    this.state = {
      draggingNode: null,
      dragOffset: [0, 0],
      connecting: null,
      selectedNode: null,
      pan: [0, 0],
      panning: false,
      panStart: [0, 0],
      zoom: 1
    };
    this.clearRuntime = () => {
      app.graphUpdate = () => {};
      // stop sepcial onDraw node
      console.info("%cDestroy runtime objects." + Object.values(this.nodes).filter(n => n.title == "On Draw"), _utils.LOG_FUNNY_ARCADE);
      let allOnDraws = Object.values(this.nodes).filter(n => n.title == "On Draw");
      for (var x = 0; x < allOnDraws.length; x++) {
        allOnDraws[x]._listenerAttached = false;
      }
      let getCurrentGIzmoObj = app.mainRenderBundle.filter(o => o.effects.gizmoEffect && o.effects.gizmoEffect.enabled == false);
      if (getCurrentGIzmoObj.length > 0) getCurrentGIzmoObj[0].effects.gizmoEffect.enabled = true;
      // stop vertext anims
      // let allVertexAnims = Object.values(this.nodes).filter((n) =>
      //   n.title == "Set Vertex Wave" || n.title == "Set Vertex Wind" || n.title == "Set Vertex Pulse" ||
      //   n.title == "Set Vertex Twist" || n.title == "Set Vertex Ocean" || n.title == "Set Vertex Noise");
      app.mainRenderBundle.forEach(o => {
        o.vertexAnim.disableAll();
      });
      for (let x = 0; x < runtimeCacheObjs.length; x++) {
        // runtimeCacheObjs[x].destroy(); BUGGY - no sync with render loop logic!
        app.removeSceneObjectByName(runtimeCacheObjs[x].name);
      }
      document.dispatchEvent(new CustomEvent('updateSceneContainer', {
        detail: {}
      }));
      (0, _utils.byId)("graph-status").innerHTML = '⚫';
    };
    this.setZoom = z => {
      this.state.zoom = Math.max(0.2, Math.min(2.5, z));
      this.board.style.transform = `scale(${this.state.zoom})`;
    };
    this.onWheel = e => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      this.setZoom(this.state.zoom + delta);
    };
    this.boardWrap.addEventListener("wheel", this.onWheel.bind(this), {
      passive: false // IMPORTANT
    });

    // Bind event listeners
    this.createVariablesPopup();
    this.createAIToolPopup();
    this._createImportInput();
    this.bindGlobalListeners();
    this._varInputs = {};
    // global events
    document.addEventListener("on-ai-graph-response", e => {
      console.info("%c<AI RESPONSE>", _utils.LOG_FUNNY_ARCADE);
      (0, _utils.byId)("graphGenJSON").value = e.detail;
      (0, _utils.byId)('ai-status').removeAttribute('data-ai-status');
    });
    document.addEventListener("keydown", e => {
      const target = e.composedPath && e.composedPath()[0] || e.target || document.activeElement;
      function isEditableElement(el) {
        if (!el) return false;
        if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement || el instanceof HTMLSelectElement) return true;
        if (el.isContentEditable) return true;
        if (el.getAttribute && el.getAttribute('role') === 'textbox') return true;
        return false;
      }
      if (isEditableElement(target)) return;
      if (e.key == "F6") {
        e.preventDefault();
        this.runGraph();
      } else if (e.key === "Delete") {
        if (this.state.selectedNode) {
          this.deleteNode(this.state.selectedNode);
          this.state.selectedNode = null;
        }
      }
    });
    this.createContextMenu();
    // not in use ? - alternative for refresh getters/ no exec nodes
    document.addEventListener("fluxcodex.input.change", e => {
      console.log('fluxcodex.input.change');
      const {
        nodeId,
        field,
        value
      } = e.detail;
      const node = this.nodes.find(n => n.id === nodeId);
      if (!node) return;
      if (node.type !== "getSubObject") return;
      this.handleGetSubObject(node, value);
      if (field !== "path") return;
    });

    // only node no need to write intro files
    document.addEventListener('web.editor.addMp3', e => {
      console.log("[web.editor.addMp3]: ", e.detail);
      e.detail.path = e.detail.path.replace('\\res', 'res');
      e.detail.path = e.detail.path.replace(/\\/g, '/');
      this.addNode('audioMP3', e.detail);
    });

    // curve editor stuff
    document.addEventListener('show-curve-editor', e => {
      // console.log('show-showCurveEditorBtn editor ', e);
      this.curveEditor.toggleEditor();
    });

    // EXTRA TIME
    setTimeout(() => this.init(), 3300);
  }
  createContextMenu() {
    let CMenu = document.createElement("div");
    CMenu.id = "fc-context-menu";
    CMenu.classList.add("fc-context-menu");
    CMenu.classList.add("hidden");
    const board = document.getElementById("board");
    board.addEventListener("contextmenu", e => {
      e.preventDefault();
      CMenu.innerHTML = this.getFluxCodexMenuHTML();
      const menuRect = CMenu.getBoundingClientRect();
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      let x = e.clientX;
      let y = e.clientY;
      if (x + menuRect.width > vw) {
        x = vw - menuRect.width - 5;
      }
      if (y > vh * 0.5) {
        y = y - menuRect.height;
      }
      if (y < 5) y = 5;
      CMenu.style.left = x + "px";
      CMenu.style.top = y + "px";
      CMenu.classList.remove("hidden");
    });
    document.addEventListener("click", () => {
      CMenu.classList.add("hidden");
    });
    (0, _utils.byId)("app").appendChild(CMenu);
  }
  getFluxCodexMenuHTML() {
    return `
    <h3>Events / Func</h3>
    <button onclick="app.editor.fluxCodexVertex.addNode('event')">Event: onLoad</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('function')">Function</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('if')">If Branch</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('genrand')">GenRandInt</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('print')">Print</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('timeout')">SetTimeout</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('getArray')">getArray</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('forEach')">forEach</button>
    <hr>
    <span>Networking</span>
    <button onclick="app.editor.fluxCodexVertex.addNode('fetch')">Fetch</button>
    <hr>
    <span>Scene</span>
    <button onclick="app.editor.fluxCodexVertex.addNode('getSceneObject')">Get Scene Object</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('getSceneLight')">Get Scene Light</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('getObjectAnimation')">Get Object Animation</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('setPosition')">Set Position</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('setMaterial')">Set Material</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('setWaterParams')">Set Water Material Params</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('translateByX')">Translate by X</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('translateByY')">Translate by Y</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('translateByZ')">Translate by Z</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('setSpeed')">Set Speed</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('getSpeed')">Get Speed</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('setRotation')">Set Rotation</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('setRotate')">Set Rotate</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('setRotateX')">Set RotateX</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('setRotateY')">Set RotateY</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('setRotateZ')">Set RotateZ</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('setTexture')">Set Texture</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('onTargetPositionReach')">onTargetPositionReach</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('dynamicFunction')">Function Dinamic</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('refFunction')">Function by Ref</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('getSubObject')">Get Sub Object</button>
    <hr>
    <span>Comment</span>
    <button onclick="app.editor.fluxCodexVertex.addNode('comment')">Comment</button>
    <hr>
    <span>Math</span>
    <button onclick="app.editor.fluxCodexVertex.addNode('add')">Add (+)</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('sub')">Sub (-)</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('mul')">Mul (*)</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('div')">Div (/)</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('sin')">Sin</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('cos')">Cos</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('pi')">Pi</button>
    <hr>
    <span>Comparison</span>
    <button onclick="app.editor.fluxCodexVertex.addNode('equal')">Equal (==)</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('notequal')">Not Equal (!=)</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('greater')">Greater (>)</button>
    <button onclick="app.editor.fluxCodexVertex.addNode('less')">Less (<)</button>
    <hr>
    <span>Compile</span>
    <button onclick="app.editor.fluxCodexVertex.compileGraph()">Save</button>
    <button onclick="app.editor.fluxCodexVertex.runGraph()">Run (F6)</button>
  `;
  }
  log(...args) {
    this.logEl.textContent = args.join(" ");
  }
  createGetNumberNode(varName) {
    return this.addNode("getNumber", {
      var: varName
    });
  }
  createGetBooleanNode(varName) {
    return this.addNode("getBoolean", {
      var: varName
    });
  }
  createGetStringNode(varName) {
    return this.addNode("getString", {
      var: varName
    });
  }
  createGetObjectNode(varName) {
    return this.addNode("getObject", {
      var: varName
    });
  }
  createSetNumberNode(varName) {
    return this.addNode("setNumber", {
      var: varName
    });
  }
  createSetBooleanNode(varName) {
    return this.addNode("setBoolean", {
      var: varName
    });
  }
  createSetStringNode(varName) {
    return this.addNode("setString", {
      var: varName
    });
  }
  createSetObjectNode(varName) {
    return this.addNode("setObject", {
      var: varName
    });
  }
  evaluateGetterNode(n) {
    const key = n.fields?.find(f => f.key === "var")?.value;
    if (!key) return;
    const type = n.title.replace("Get ", "").toLowerCase();
    const entry = this.variables[type]?.[key];
    n._returnCache = entry ? entry.value : type === "number" ? 0 : type === "boolean" ? false : type === "string" ? "" : type === "object" ? {} : undefined;
  }
  notifyVariableChanged(type, key) {
    for (const id in this.nodes) {
      const n = this.nodes[id];
      // Update getter nodes
      if (n.isGetterNode) {
        const varField = n.fields?.find(f => f.key === "var");
        if (varField?.value === key && n.title.replace("Get ", "").toLowerCase() === type) {
          this.evaluateGetterNode(n);
          if (n.displayEl) {
            const val = n._returnCache;
            if (type === "object") n.displayEl.textContent = JSON.stringify(val, null, 2);else if (type === "number") n.displayEl.textContent = val.toFixed(3);else n.displayEl.textContent = String(val);
          }
        }
      }
      // Update sub-object nodes connected to this getter
      n.inputs?.forEach(pin => {
        const link = this.getConnectedSource(n.id, pin.name);
        if (link?.node?.isGetterNode) {
          const srcNode = link.node;
          const srcPin = link.pin;
          if (srcNode.fields?.find(f => f.key === "var")?.value === key) {
            this._adaptGetSubObjectOnConnect(n, srcNode, srcPin);
          }
        }
      });
    }
    // Update variable input UI if exists
    const input = this._varInputs?.[`${type}.${key}`];
    if (input) {
      const storedValue = this.variables?.[type]?.[key];
      if (type === "object") input.value = JSON.stringify(storedValue ?? {}, null, 2);else input.value = storedValue ?? "";
    }
  }
  createVariablesPopup() {
    if (this._varsPopup) return;
    const popup = document.createElement("div");
    popup.id = "varsPopup";
    this._varsPopup = popup;
    Object.assign(popup.style, {
      display: "none",
      flexDirection: "column",
      position: "absolute",
      top: "10%",
      left: "0",
      width: "60%",
      height: "60%",
      overflow: "scroll",
      background: "linear-gradient(135deg, #1a1a1a 0%, #2b2b2b 100%), /* subtle dark gradient */ repeating-linear-gradient(0deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.05) 1px, transparent 1px, transparent 20px), repeating-linear-gradient(90deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.05) 1px, transparent 1px, transparent 20px)",
      backgroundBlendMode: "overlay",
      backgroundSize: "auto, 20px 20px, 20px 20px",
      border: "1px solid #444",
      borderRadius: "8px",
      padding: "10px",
      zIndex: 99,
      color: "#eee",
      overflowX: "hidden"
    });
    // HEADER
    const title = document.createElement("div");
    title.innerHTML = `Variables`;
    title.style.marginBottom = "8px";
    title.style.fontWeight = "bold";
    popup.appendChild(title);
    const list = document.createElement("div");
    list.id = "varslist";
    popup.appendChild(list);
    // CREATE BUTTONS
    const btns = document.createElement("div");
    btns.style.marginTop = "10px";
    btns.style.display = "flex";
    btns.style.gap = "6px";
    btns.append(this._createVarBtn("Number", "number"), this._createVarBtn("Boolean", "boolean"), this._createVarBtn("String", "string"), this._createVarBtn("Object", "object"));
    popup.appendChild(btns);
    const hideVPopup = document.createElement("button");
    hideVPopup.innerText = `Hide`;
    hideVPopup.classList.add("btn4");
    hideVPopup.style.margin = "8px 8px 8px 8px";
    hideVPopup.style.width = "200px";
    hideVPopup.style.fontWeight = "bold";
    hideVPopup.style.webkitTextStrokeWidth = "0px";
    hideVPopup.addEventListener("click", () => {
      (0, _utils.byId)("varsPopup").style.display = "none";
    });
    popup.appendChild(hideVPopup);
    const saveVPopup = document.createElement("button");
    saveVPopup.innerText = `Save`;
    saveVPopup.classList.add("btn4");
    saveVPopup.style.margin = "8px 8px 8px 8px";
    saveVPopup.style.width = "200px";
    saveVPopup.style.height = "70px";
    saveVPopup.style.fontWeight = "bold";
    saveVPopup.style.webkitTextStrokeWidth = "0px";
    saveVPopup.addEventListener("click", () => {
      this.compileGraph();
    });
    popup.appendChild(saveVPopup);
    document.body.appendChild(popup);
    this.makePopupDraggable(popup);
    this._refreshVarsList(list);
  }
  createAIToolPopup() {
    if (this._aiPopup) return;
    const popup = document.createElement("div");
    popup.id = "aiPopup";
    this._aiPopup = popup;
    Object.assign(popup.style, {
      display: "none",
      flexDirection: "column",
      alignItems: "flex-start",
      position: "absolute",
      top: "10%",
      left: "5%",
      width: "50%",
      height: "70%",
      background: `
    linear-gradient(145deg, #141414 0%, #1e1e1e 60%, #252525 100%),
    repeating-linear-gradient(
      0deg,
      rgba(255,255,255,0.04),
      rgba(255,255,255,0.04) 1px,
      transparent 1px,
      transparent 22px
    ),
    repeating-linear-gradient(
      90deg,
      rgba(255,255,255,0.04),
      rgba(255,255,255,0.04) 1px,
      transparent 1px,
      transparent 22px
    )
  `,
      backgroundBlendMode: "overlay",
      backgroundSize: "auto, 22px 22px, 22px 22px",
      border: "1px solid rgba(255,255,255,0.15)",
      borderRadius: "10px",
      boxShadow: `
    0 20px 40px rgba(0,0,0,0.65),
    inset 0 1px 0 rgba(255,255,255,0.05)
  `,
      padding: "12px 14px",
      zIndex: 99,
      color: "#e6e6e6",
      overflowY: "auto",
      overflowX: "hidden",
      fontFamily: "Orbitron, monospace",
      fontSize: "13px"
    });
    const title = document.createElement("div");
    title.innerHTML = `FluxCodexVertex AI generator [Experimental]`;
    title.style.marginBottom = "18px";
    title.style.fontWeight = "bold";
    title.style.fontSize = "20px";
    popup.appendChild(title);
    const label1 = document.createElement("span");
    label1.innerText = `Select task for ai`;
    popup.appendChild(label1);
    const selectPrompt = document.createElement("select");
    selectPrompt.style.width = '400px';
    const placeholder = document.createElement("option");
    placeholder.textContent = "Select task";
    placeholder.value = "";
    placeholder.disabled = true;
    placeholder.selected = true;
    selectPrompt.appendChild(placeholder);
    _generateAISchema.tasks.forEach((t, i) => {
      const opt = document.createElement("option");
      opt.value = i;
      opt.textContent = t;
      selectPrompt.appendChild(opt);
    });
    popup.appendChild(selectPrompt);
    const label2 = document.createElement("span");
    label2.innerText = `Select provider [Only OLLAMA for now]`;
    popup.appendChild(label2);
    const selectPromptProvider = document.createElement("select");
    selectPromptProvider.style.width = '400px';
    _generateAISchema.providers.forEach((p, i) => {
      const opt = document.createElement("option");
      opt.value = i;
      opt.textContent = p;
      selectPromptProvider.appendChild(opt);
    });
    popup.appendChild(selectPromptProvider);
    const call = document.createElement("button");
    call.id = "ai-status";
    call.innerText = `Generate`;
    call.classList.add("btnLeftBox");
    call.classList.add("btn4");
    call.style.margin = "8px 8px 8px 8px";
    call.style.width = "200px";
    call.style.fontWeight = "bold";
    call.style.webkitTextStrokeWidth = "0px";
    call.addEventListener("click", e => {
      if (selectPrompt.selectedIndex > 0) {
        // use select task...
      }
      if (e.target.getAttribute("data-ai-status") == null) {
        e.target.setAttribute("data-ai-status", "wip");
      } else {
        if (e.target.getAttribute("data-ai-status") == "wip") {
          console.info('gen ai tool call PREVENT ');
          return;
        } else {
          console.info('gen ai tool call !!!!!!!!!!!!!!!! else ');
        }
      }
      console.log(`%cAI TASK:${selectPrompt.selectedOptions[0].innerText}`, _utils.LOG_FUNNY_ARCADE);
      document.dispatchEvent(new CustomEvent('aiGenGraphCall', {
        detail: {
          provider: _generateAISchema.providers[0],
          // hardcode
          task: selectPrompt.selectedOptions[0].innerText
        }
      }));
    });
    popup.appendChild(call);
    this.toolTip.attachTooltip(call, "AI will try to generate graph. It is not guaranteed to work ⚠️");
    const list = document.createElement("textarea");
    list.style.height = '500px';
    list.id = "graphGenJSON";
    list.disabled = true;
    Object.assign(list.style, {
      height: "100%",
      minHeight: "420px",
      resize: "none",
      background: "#0f0f0f",
      color: "#d0f0ff",
      border: "1px solid #333",
      borderRadius: "6px",
      padding: "10px",
      marginBottom: "10px",
      fontFamily: "JetBrains Mono, monospace",
      fontSize: "12px",
      lineHeight: "1.4",
      width: "98%",
      outline: "none",
      boxShadow: "inset 0 0 8px rgba(0,0,0,0.6)"
    });
    popup.appendChild(list);
    this.toolTip.attachTooltip(list, "If the exported graph is not valid, in the last case you can manually try to fix it, but it is best to make a new query ⚠️");
    // popup.appendChild(btns);

    const wrap1 = document.createElement("div");
    wrap1.style.display = 'flex';
    wrap1.style.height = '50px';
    popup.appendChild(wrap1);
    const hideAIGen = document.createElement("button");
    hideAIGen.innerText = `Hide`;
    hideAIGen.classList.add("btn4");
    hideAIGen.classList.add("btnLeftBox");
    hideAIGen.style.margin = "8px 8px 8px 8px";
    hideAIGen.style.width = "100px";
    hideAIGen.style.fontWeight = "bold";
    hideAIGen.style.webkitTextStrokeWidth = "0px";
    hideAIGen.addEventListener("click", () => {
      (0, _utils.byId)("aiPopup").style.display = "none";
    });
    wrap1.appendChild(hideAIGen);
    const copy = document.createElement("button");
    copy.innerText = `Copy`;
    copy.classList.add("btnLeftBox");
    copy.classList.add("btn4");
    copy.style.margin = "8px 8px 8px 8px";
    copy.style.width = "100px";
    copy.style.fontWeight = "bold";
    copy.style.color = "lime";
    copy.style.webkitTextStrokeWidth = "0px";
    copy.addEventListener("click", async () => {
      if (navigator.clipboard) {
        await navigator.clipboard.writeText(list.value);
      } else {
        list.select();
        document.execCommand("copy");
      }
    });
    wrap1.appendChild(copy);
    const exportJSON = document.createElement("button");
    exportJSON.innerText = `Export JSON`;
    exportJSON.classList.add("btnLeftBox");
    exportJSON.classList.add("btn4");
    exportJSON.style.margin = "8px 8px 8px 8px";
    exportJSON.style.width = "100px";
    exportJSON.style.fontWeight = "bold";
    exportJSON.style.color = "lime";
    exportJSON.style.webkitTextStrokeWidth = "0px";
    exportJSON.addEventListener("click", async () => {
      this.exportAIGenJson((0, _utils.byId)("graphGenJSON").value);
    });
    wrap1.appendChild(exportJSON);
    const insertGraph = document.createElement("button");
    insertGraph.innerText = `Insert graph`;
    insertGraph.classList.add("btnLeftBox");
    insertGraph.classList.add("btn4");
    insertGraph.style.margin = "8px 8px 8px 8px";
    insertGraph.style.width = "100px";
    insertGraph.style.fontWeight = "bold";
    insertGraph.style.color = "lime";
    insertGraph.style.webkitTextStrokeWidth = "0px";
    insertGraph.addEventListener("click", async () => {
      console.log("TEST OVERRIDE", list.value);
      let test = JSON.parse(list.value);
      this.mergeGraphBundle(test);
    });
    wrap1.appendChild(insertGraph);
    document.body.appendChild(popup);
    this.makePopupDraggable(popup);
  }
  exportAIGenJson(graphData, fileName = 'ai-gen-fcv-graph.json') {
    try {
      // const jsonString = JSON.stringify(graphData, null, 2);
      const blob = new Blob([graphData], {
        type: 'application/json'
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      console.log("Graph exported successfully.");
    } catch (error) {
      console.error("Failed to export graph:", error);
    }
  }
  _refreshVarsList(container) {
    container.innerHTML = "";
    const colors = {
      number: "#4fc3f7",
      boolean: "#aed581",
      string: "#ffb74d",
      object: "#ce93d8"
    };
    for (const type in this.variables) {
      for (const name in this.variables[type]) {
        const row = document.createElement("div");
        Object.assign(row.style, {
          display: "flex",
          alignItems: "center",
          gap: "6px",
          padding: "4px",
          cursor: "pointer",
          borderBottom: "1px solid #222",
          color: colors[type] || "#fff",
          placeContent: "space-around"
        });
        const label = document.createElement("span");
        label.textContent = `${name} (${type})`;
        label.style.width = "20%";
        let input;
        if (type === "object") {
          input = document.createElement("textarea");
          input.value = JSON.stringify(this.variables[type][name] ?? {}, null, 2);
          input.style.height = "40px";
          input.style.webkitTextStrokeWidth = "0px";
        } else {
          input = document.createElement("input");
          input.value = this.variables[type][name] ?? "";
        }
        input.style.width = "30%";
        this._varInputs[`${type}.${name}`] = input;
        Object.assign(input.style, {
          background: "#000",
          color: "#fff",
          border: "1px solid #333"
        });
        input.oninput = () => {
          if (type === "object") {
            try {
              this.variables.object[name] = JSON.parse(input.value);
            } catch {
              return;
            }
          } else if (type === "number") {
            this.variables.number[name] = parseFloat(input.value);
          } else if (type === "boolean") {
            this.variables.boolean[name] = input.value === "true";
          } else {
            this.variables.string[name] = input.value;
          }
        };
        const btnGet = document.createElement("button");
        btnGet.innerText = "Get";
        btnGet.classList.add("btnGetter");
        btnGet.onclick = () => {
          if (type === "number") this.createGetNumberNode(name);else if (type === "boolean") this.createGetBooleanNode(name);else if (type === "string") this.createGetStringNode(name);else if (type === "object") this.createGetObjectNode(name);
        };
        const btnSet = document.createElement("button");
        btnSet.innerText = "Set";
        btnSet.classList.add("btnGetter");
        btnSet.onclick = () => {
          if (type === "number") this.createSetNumberNode(name);else if (type === "boolean") this.createSetBooleanNode(name);else if (type === "string") this.createSetStringNode(name);else if (type === "object") this.createSetObjectNode(name);
        };
        const btnDel = document.createElement("button");
        btnDel.innerText = "Del";
        btnDel.classList.add("btnGetter");
        btnDel.style.color = "#ff5252";
        btnDel.onclick = () => {
          if (!confirm(`Delete variable "${name}" (${type}) ?`)) return;
          delete this.variables[type][name];
          delete this._varInputs[`${type}.${name}`];
          this._refreshVarsList(container);
        };
        row.append(label, input, btnGet, btnSet, btnDel);
        container.appendChild(row);
      }
    }
  }
  makePopupDraggable(popup, handle = popup) {
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let startLeft = 0;
    let startTop = 0;
    handle.style.cursor = "move";
    handle.addEventListener("mousedown", e => {
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      const rect = popup.getBoundingClientRect();
      startLeft = rect.left;
      startTop = rect.top;
      popup.style.left = startLeft + "px";
      popup.style.top = startTop + "px";
      popup.style.transform = "none";
      document.addEventListener("mousemove", onMove);
      document.addEventListener("mouseup", onUp);
    });
    const onMove = e => {
      if (!isDragging) return;
      popup.style.left = startLeft + (e.clientX - startX) + "px";
      popup.style.top = startTop + (e.clientY - startY) + "px";
    };
    const onUp = () => {
      isDragging = false;
      document.removeEventListener("mousemove", onMove);
      document.removeEventListener("mouseup", onUp);
    };
  }
  _createVarBtn(label, type) {
    const btn = document.createElement("button");
    btn.textContent = label;
    btn.style.flex = "1";
    btn.style.cursor = "pointer";
    btn.classList.add("btn4");
    btn.onclick = () => {
      const name = prompt(`New ${type} variable name`);
      if (!name) return;
      if (!this.variables[type]) this.variables[type] = {};
      if (this.variables[type][name]) {
        alert("Variable exists");
        return;
      }
      // Create variable
      this.variables[type][name] = type === "object" ? {} : type === "number" ? 0 : type === "boolean" ? false : type === "string" ? "" : null;
      this._refreshVarsList(this._varsPopup.children[1]);
      // console.log("[NEW VARIABLE]", type, name, this.variables[type][name]);
    };
    return btn;
  }
  _getPinDot(nodeId, pinName, isOutput) {
    const nodeEl = document.querySelector(`.node[data-id="${nodeId}"]`);
    if (!nodeEl) return null;
    const io = isOutput ? "out" : "in";
    return nodeEl.querySelector(`.pin[data-pin="${pinName}"][data-io="${io}"] .dot`);
  }
  populateVariableSelect(select, type) {
    select.innerHTML = "";
    const vars = this.variables[type];
    if (!vars.length) {
      const opt = document.createElement("option");
      opt.textContent = "(no variables)";
      opt.disabled = true;
      select.appendChild(opt);
      return;
    }
    vars.forEach(v => {
      const opt = document.createElement("option");
      opt.value = v.name;
      opt.textContent = v.name;
      select.appendChild(opt);
    });
  }
  // Dynamic Method Helpers
  getArgNames(fn) {
    const src = fn.toString().trim();
    // Case 1: arrow function with no parentheses:  a => ...
    const arrowNoParen = src.match(/^([a-zA-Z0-9_$]+)\s*=>/);
    if (arrowNoParen) {
      return [arrowNoParen[1].trim()];
    }
    // Case 2: normal (a,b) => ...  OR function(a,b) { ... }
    const argsMatch = src.match(/\(([^)]*)\)/);
    if (argsMatch && argsMatch[1].trim().length > 0) {
      return argsMatch[1].split(",").map(a => a.trim()).filter(a => a.length > 0);
    }
    // Default: no args
    return [];
  }
  hasReturn(fn) {
    const src = fn.toString().trim();
    // Case 1: implicit return in arrow: (a)=>a+2  OR  a=>a*2
    // Detect arrow "=>" followed by an expression, not "{"
    if (/=>\s*[^({]/.test(src)) {
      return true;
    }
    // Case 2: normal "return" inside function body
    if (/return\s+/.test(src)) {
      return true;
    }
    return false;
  }
  adaptNodeToMethod(node, methodItem) {
    const fn = this.methodsManager.compileFunction(methodItem.code);
    // Reset pins except execution pins
    node.inputs = [{
      name: "exec",
      type: "action"
    }];
    node.outputs = [{
      name: "execOut",
      type: "action"
    }];
    // Dynamic input pins
    const args = this.getArgNames(fn);
    args.forEach(arg => node.inputs.push({
      name: arg,
      type: "value"
    }));
    // Dynamic return pin
    if (this.hasReturn(fn)) node.outputs.push({
      name: "return",
      type: "value"
    });

    // test 
    node.outputs.push({
      name: "reference",
      type: "function"
    });
    node.attachedMethod = methodItem.name;
    node.fn = fn;
    this.updateNodeDOM(node.id);
  }
  adaptNodeToMethod2(node, methodItem) {
    const fn = this.methodsManager.compileFunction(methodItem.code);
    const args = this.getArgNames(fn);

    // Preserve action + reference pins
    const preservedInputs = node.inputs.filter(p => p.type === "action" || p.name === "reference");
    const preservedOutputs = node.outputs.filter(p => p.type === "action");
    node.inputs = [...preservedInputs];
    node.outputs = [...preservedOutputs];

    // Add argument pins (reuse if exists)
    args.forEach(arg => {
      if (!node.inputs.some(p => p.name === arg)) {
        node.inputs.push({
          name: arg,
          type: "value"
        });
      }
    });

    // Return value
    if (this.hasReturn(fn)) {
      if (!node.outputs.some(p => p.name === "return")) {
        node.outputs.push({
          name: "return",
          type: "value"
        });
      }
    }
    node.attachedMethod = methodItem.name;
    node.fn = fn;
    this.updateNodeDOM(node.id);
  }
  adaptRefFunctionNode(node, fnRef) {
    const args = this.getArgNames(fnRef);
    const hasReturn = this.hasReturn(fnRef);
    // Preserve exec + reference pins
    const preservedInputs = node.inputs.filter(p => p.type === "action" || p.name === "reference");
    const preservedOutputs = node.outputs.filter(p => p.type === "action");
    node.inputs = [...preservedInputs];
    node.outputs = [...preservedOutputs];
    // 🔹 Real argument pins
    args.forEach(arg => {
      if (!node.inputs.some(p => p.name === arg)) {
        node.inputs.push({
          name: arg,
          type: "value"
        });
      }
    });
    // 🔹 Real return
    if (hasReturn) {
      if (!node.outputs.some(p => p.name === "return")) {
        node.outputs.push({
          name: "return",
          type: "value"
        });
      }
    }
    // Execution logic
    node.fn = (...callArgs) => fnRef(...callArgs);
    this.updateNodeDOM(node.id);
  }
  populateMethodsSelect(selectEl) {
    selectEl.innerHTML = "";
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = "-- Select Method --";
    selectEl.appendChild(placeholder);
    this.methodsManager.methodsContainer.forEach(method => {
      const opt = document.createElement("option");
      opt.value = method.name;
      opt.textContent = method.name;
      selectEl.appendChild(opt);
    });
  }
  _getSceneSelectedName(node) {
    return node.fields?.find(f => f.key === "selectedObject" || f.key === "object")?.value;
  }
  updateNodeDOM(nodeId) {
    const node = this.nodes[nodeId];
    const el = document.querySelector(`.node[data-id="${nodeId}"]`);
    if (!el) return;
    const left = el.querySelector(".pins-left");
    const right = el.querySelector(".pins-right");
    if (!left || !right) return;
    // Clear only **non-exec pins**
    left.innerHTML = "";
    right.innerHTML = "";
    const inputs = node.inputs || [];
    const outputs = node.outputs || [];
    inputs.forEach(pin => left.appendChild(this._pinElement(pin, false, nodeId)));
    outputs.forEach(pin => right.appendChild(this._pinElement(pin, true, nodeId)));
    if (node.title === "Get Scene Object" || node.title === "Get Scene Light" || node.title === "Get Scene Animation") {
      const select = el.querySelector("select.scene-select");
      // console.log('!TEST! ??? BEFORE')
      if (select) {
        console.log('!TEST! ???');
        // const objects = spec.accessObject || [];
        // objects.forEach(obj => {
        //   const opt = document.createElement("option");
        //   opt.value = obj.name;
        //   opt.textContent = obj.name;
        //   select.appendChild(opt);
        // });
        // const selected = this._getSceneSelectedName(node);
        // if(selected) {
        //   select.value = selected;
        // }
      }
    } else if (node.category === "action" && node.title === "Function") {
      let select = el.querySelector("select.method-select");
      if (!select) {
        select = document.createElement("select");
        select.className = "method-select";
        select.style.cssText = "width:100%; margin-top:6px;";
        el.querySelector(".body").appendChild(select);
      }
      this.populateMethodsSelect(select);
      if (node.attachedMethod) select.value = node.attachedMethod;
      select.onchange = e => {
        const selected = this.methodsManager.methodsContainer.find(m => m.name === e.target.value);
        console.log('test reference::::', selected);
        if (selected) this.adaptNodeToMethod(node, selected);
      };
    } else if (node.category === "functions") {
      const dom = document.querySelector(`.node[data-id="${nodeId}"]`);
      this.restoreDynamicFunctionNode(node, dom);
    } else if (node.category === "reffunctions") {
      const dom = document.querySelector(`.node[data-id="${nodeId}"]`);
      this.restoreDynamicFunctionNode(node, dom);
    }
  }
  restoreDynamicFunctionNode(node, dom) {
    // Restore accessObject reference from literal
    if (!node.accessObject && node.accessObjectLiteral) {
      try {
        node.accessObject = eval(node.accessObjectLiteral);
      } catch (e) {
        console.warn("Failed to eval accessObjectLiteral:", node.accessObjectLiteral, e);
        node.accessObject = [];
      }
    }

    // Ensure fields exist
    if (!node.fields) node.fields = [];
    if (!node.fields.find(f => f.key === "selectedObject")) {
      node.fields.push({
        key: "selectedObject",
        value: ""
      });
    }

    // Ensure pins exist
    if (!node.inputs || node.inputs.length === 0) {
      node.inputs = [{
        name: "exec",
        type: "action"
      }];
    }
    if (!node.outputs || node.outputs.length === 0) {
      node.outputs = [{
        name: "execOut",
        type: "action"
      }];
    }

    // Rebuild DOM select for this node
    let select = dom.querySelector("select");
    if (select == null) {
      select = document.createElement("select");
      select.id = node.id;
      select.className = "method-select";
      select.style.cssText = "width:100%; margin-top:6px;";
      dom.appendChild(select);
    }
    if (select && node.accessObject) {
      const numOptions = select.options.length;
      const newLength = Object.keys(node.accessObject).filter(key => typeof node.accessObject[key] === "function");

      // Only repopulate if length differs // +1 for placeholder
      if (numOptions !== newLength.length + 1) {
        select.innerHTML = "";
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "-- Select Function --";
        select.appendChild(placeholder);
        Object.keys(node.accessObject).filter(key => typeof node.accessObject[key] === "function").forEach(fnName => {
          const opt = document.createElement("option");
          opt.value = fnName;
          opt.textContent = fnName;
          select.appendChild(opt);
        });

        // restore previously selected
        const selected = node.fields.find(f => f.key === "selectedObject")?.value;
        if (selected) select.value = selected;
      }

      // Attach onchange
      select.onchange = e => {
        const val = e.target.value;
        node.fields.find(f => f.key === "selectedObject").value = val;
      };
    }
  }

  // NODE/PIN
  startConnect(nodeId, pinName, type, isOut) {
    this.state.connecting = {
      node: nodeId,
      pin: pinName,
      type: type,
      out: isOut
    };
  }
  _applyConnectionRuntime(from, to, type) {
    const toNode = this.nodes[to.node];
    const fromNode = this.nodes[from.node];
    if (!toNode || !fromNode) return;

    // RefFunction special case
    if (toNode.title === "reffunctions" && to.pin === "reference") {
      const fnRef = this.getPinValue(fromNode, from.pin);
      if (typeof fnRef === "function") {
        toNode._fnRef = fnRef;
        this.adaptRefFunctionNode(toNode, fnRef);
      }
    }
    // generic hook
    this.onPinsConnected(fromNode, from.pin, toNode, to.pin);
  }
  restoreConnectionsRuntime() {
    for (const link of this.links) {
      this._applyConnectionRuntime(link.from, link.to, link.type);
    }
  }
  finishConnect(nodeId, pinName, type) {
    if (!this.state.connecting || this.state.connecting.node === nodeId) {
      this.state.connecting = null;
      return;
    }
    const from = this.state.connecting.out ? this.state.connecting : {
      node: nodeId,
      pin: pinName
    };
    const to = this.state.connecting.out ? {
      node: nodeId,
      pin: pinName
    } : this.state.connecting;
    // Prevent duplicate links and type mismatch
    if (from.pin && to.pin && this.isTypeCompatible(this.state.connecting.type, type)) {
      const exists = this.links.find(l => l.from.node === from.node && l.from.pin === from.pin && l.to.node === to.node && l.to.pin === to.pin);
      if (!exists) {
        this.links.push({
          id: "link_" + this.linkCounter++,
          from,
          to,
          type
        });
        this.updateLinks();
        if (type === "value") setTimeout(() => this.updateValueDisplays(), 0);
      }
    }
    this.state.connecting = null;
    let toNode = this.nodes[to.node];
    let fromNode = this.nodes[from.node];
    if (toNode && toNode.title === "reffunctions" && to.pin === "reference") {
      console.log('sss ');
      const fnRef = this.getPinValue(fromNode, from.pin);
      if (typeof fnRef !== "function") return;
      toNode._fnRef = fnRef;
      this.adaptRefFunctionNode(toNode, fnRef);
    }
    // Get Sub Object – adapt pins on connect
    toNode = this.nodes[to.node];
    fromNode = this.nodes[from.node];
    this.onPinsConnected(fromNode, from.pin, toNode, to.pin);
  }
  _adaptGetSubObjectOnConnect(getSubNode, sourceNode) {
    // alert('adapt')
    const obj = sourceNode._returnCache;
    if (!obj || typeof obj !== "object") return;
    const varField = sourceNode.fields?.find(f => f.key === "var");
    const previewField = getSubNode.fields?.find(f => f.key === "objectPreview");
    if (previewField) {
      previewField.value = varField?.value || "[object]";
      if (getSubNode.objectPreviewEl) getSubNode.objectPreviewEl.value = previewField.value;
    }
    const path = getSubNode.fields?.find(f => f.key === "path")?.value;
    const target = this.resolvePath(obj, path);
    this.adaptSubObjectPins(getSubNode, target);
    getSubNode._subCache = {};
    if (target && typeof target === "object") {
      for (const k in target) getSubNode._subCache[k] = target[k];
    }
    getSubNode._needsRebuild = false;
    getSubNode._pinsBuilt = true;
    // console.log("[ADAPT SUB OBJECT]", getSubNode.id, "path:", path, "target:", target);
    this.updateNodeDOM(getSubNode.id);
  }
  onPinsConnected(sourceNode, sourcePin, targetNode) {
    if (targetNode.title === "Get Scene Object" || targetNode.title === "Get Sub Object" || targetNode.title === "Get Scene Light") {
      this._adaptGetSubObjectOnConnect(targetNode, sourceNode, sourcePin);
    }
  }

  // get func for ref pin
  getPinValue(node, pinName) {
    const out = node.outputs?.find(p => p.name === pinName);
    let getName = node.fields.find(item => item.key == "selectedObject").value;
    // little hard code - fix in future
    // By current light rule of given names.
    if (node.title == "Get Scene Object") {
      return app.getSceneObjectByName(getName)[out.name];
    } else if (node.title == "Get Scene Animation") {
      return app.getSceneObjectByName(getName)[out.name];
    } else {
      // light for now
      getName = parseInt(getName.replace("light", ""));
      return node.accessObject[getName][pinName];
    }
  }
  normalizePinType(type) {
    if (!type) return "any";
    if (type === "number") return "value";
    return type;
  }
  updateSceneObjectPins(node, objectName) {
    const obj = (node.accessObject || []).find(o => o.name === objectName);
    if (!obj) return;
    // clear
    node.outputs = [];
    node.exposeProps.forEach(p => {
      const value = this.getByPath(obj, p);
      if (value !== undefined) {
        const type = typeof value === "number" ? "number" : typeof value === "string" ? "string" : "object";
        node.outputs.push({
          name: p,
          type
        });
      }
    });
    this.updateNodeDOM(node.id);
  }
  _pinElement(pinSpec, isOutput, nodeId) {
    const pin = document.createElement("div");
    if (pinSpec.name == "position") {
      pin.className = `pin pin-${pinSpec.name}`;
    } else {
      pin.className = `pin pin-${pinSpec.type}`;
    }
    pin.dataset.pin = pinSpec.name;
    pin.dataset.type = pinSpec.type;
    pin.dataset.io = isOutput ? "out" : "in";
    pin.dataset.node = nodeId;
    // Dot (connect point)
    const dot = document.createElement("div");
    dot.className = "dot";
    pin.appendChild(dot);
    // Pin Label
    const label = document.createElement("span");
    label.className = "pin-label";
    label.textContent = pinSpec.name;
    pin.appendChild(label);
    // Connect events
    pin.addEventListener("mousedown", () => this.startConnect(nodeId, pinSpec.name, pinSpec.type, isOutput));
    pin.addEventListener("mouseup", () => this.finishConnect(nodeId, pinSpec.name, pinSpec.type, isOutput));
    return pin;
  }
  createNodeDOM(spec) {
    const el = document.createElement("div");
    if (spec.title == "Fetch") {
      el.className = "node " + (spec.title.toLowerCase() || "");
    } else if (spec.title == "Play MP3") {
      el.className = "node " + "audios";
    } else if (spec.title == "Curve") {
      el.className = "node " + "curve";
    } else if (spec.title == "Set Shader Graph") {
      el.className = "node " + "shader";
    } else {
      el.className = "node " + (spec.category || "");
    }
    el.style.left = spec.x + "px";
    el.style.top = spec.y + "px";
    el.dataset.id = spec.id;

    // --- Header ---
    const header = document.createElement("div");
    header.className = "header";
    header.textContent = spec.title;
    el.appendChild(header);

    // --- Body ---
    const body = document.createElement("div");
    body.className = "body";

    // --- Pin row ---
    const row = document.createElement("div");
    if (spec.title == "Comment") {
      row.classList.add('pin-row');
      row.classList.add('comment');
    } else {
      row.className = "pin-row";
    }
    const left = document.createElement("div");
    left.className = "pins-left";
    const right = document.createElement("div");
    right.className = "pins-right";

    // Normalize pins before building DOM
    (spec.inputs || []).forEach(pin => {
      pin.type = this.normalizePinType(pin.type);
      left.appendChild(this._pinElement(pin, false, spec.id));
    });
    (spec.outputs || []).forEach(pin => {
      pin.type = this.normalizePinType(pin.type);
      right.appendChild(this._pinElement(pin, true, spec.id));
    });
    row.appendChild(left);
    row.appendChild(right);
    body.appendChild(row);
    if (spec.title == "Curve") {
      const c = new _curveEditor.CurveData(spec.id);
      let curve = this.curveEditor.curveStore.getOrCreate(c);
      spec.curve = curve;
      console.log(`%c Create DOM corotine Node [CURVE] ${spec.curve}`, _utils.LOG_FUNNY_ARCADE);
      this.curveEditor.bindCurve(spec.curve, {
        name: spec.id,
        idNode: spec.id
      });
    }
    if (spec.comment) {
      const textarea = document.createElement("textarea");
      // textarea.style
      textarea.style.webkitBoxShadow = "inset 0px 0px 1px 4px #9E9E9E";
      textarea.style.boxShadow = "inset 0px 0px 22px 1px rgba(118, 118, 118, 1)";
      textarea.style.backgroundColor = "gray";
      textarea.style.color = "black";
      textarea.value = spec.fields.find(f => f.key === "text").value;
      textarea.oninput = () => {
        spec.fields.find(f => f.key === "text").value = textarea.value;
        row.textContent = textarea.value || "Comment";
      };
      body.appendChild(textarea);
    }
    // 🔴 FIELD INPUTS
    if (spec.fields?.length && !spec.comment && spec.title != "GenRandInt") {
      const fieldsWrap = document.createElement("div");
      fieldsWrap.className = "node-fields";
      spec.fields.forEach(field => {
        // skip special cases handled elsewhere
        if (field.key === "var") return;
        const input = this.createFieldInput(spec, field);
        if (field.key === "objectPreview") {
          spec.objectPreviewEl = input;
        }
        fieldsWrap.appendChild(input);
      });
      body.appendChild(fieldsWrap);
    }

    // Value display
    if (spec.fields && spec.title === "GenRandInt") {
      const container = document.createElement("div");
      container.className = "genrand-inputs";
      spec.fields.forEach(f => {
        const input = document.createElement("input");
        input.type = "number";
        input.value = f.value;
        input.style.width = "40px";
        input.style.marginRight = "4px";
        input.addEventListener("input", e => f.value = e.target.value);
        container.appendChild(input);
        const label = document.createElement("span");
        label.textContent = f.key;
        label.className = "field-label";
        container.appendChild(label);
      });
      body.appendChild(container);
    } else if (spec.category === "math" || spec.category === "value" || spec.title === "Print") {
      const display = document.createElement("div");
      display.className = "value-display";
      display.textContent = "?";
      spec.displayEl = display;
      body.appendChild(display);
    }

    // Function Method Selector
    if (spec.title === "Function" && spec.category === "action" && !spec.builtIn && !spec.isVariableNode) {
      const select = document.createElement("select");
      select.id = spec.id;
      select.className = "method-select";
      select.style.cssText = "width:100%; margin-top:6px;";
      body.appendChild(select);
      this.populateMethodsSelect(select);
      if (spec.attachedMethod) {
        select.value = spec.attachedMethod;
      }
      select.addEventListener("change", e => {
        const selected = this.methodsManager.methodsContainer.find(m => m.name === e.target.value);
        if (selected) {
          console.log('test reference', selected);
          this.adaptNodeToMethod(spec, selected);
        }
      });
    }
    // Variable name input (temporary until popup)
    if (spec.fields?.some(f => f.key === "var") && !spec.comment) {
      const input = document.createElement("input");
      input.type = "text";
      input.value = spec.fields.find(f => f.key === "var")?.value ?? "";
      input.readOnly = true;
      input.style.width = "100%";
      input.style.marginTop = "6px";
      input.style.opacity = "0.7";
      input.style.cursor = "default";
      body.appendChild(input);
    }
    if (spec.title === "functions") {
      const select = document.createElement("select");
      select.style.width = "100%";
      select.style.marginTop = "6px";
      if (spec.accessObject === undefined) {
        spec.accessObject = eval(spec.accessObjectLiteral);
      }
      this.populateDynamicFunctionSelect(select, spec);
      select.addEventListener("change", e => {
        const fnName = e.target.value;
        if (fnName) {
          this.adaptDynamicFunction(spec, fnName);
        }
      });
      body.appendChild(select);
    }
    if (spec.title === "Get Scene Object" || spec.title === "Get Scene Animation" || spec.title === "Get Scene Light") {
      const select = document.createElement("select");
      select.id = spec._id ? spec._id : spec.id;
      select.style.width = "100%";
      select.style.marginTop = "6px";

      // Populate scene objects
      if (spec.accessObject === undefined) spec.accessObject = eval(spec.accessObjectLiteral);
      const objects = spec.accessObject || []; // window.app?.mainRenderBundle || [];

      const placeholder = document.createElement("option");
      placeholder.textContent = "-- Select Object --";
      placeholder.value = "";
      select.appendChild(placeholder);
      // console.log('WORKS objects', spec.accessObject.length);
      spec.accessObject.forEach(obj => {
        const opt = document.createElement("option");
        opt.value = obj.name;
        opt.textContent = obj.name;
        select.appendChild(opt);
      });
      if (spec.fields[0].value) select.value = spec.fields[0].value;
      select.addEventListener("change", e => {
        const name = e.target.value;
        spec.fields[0].value = name;
        this.updateSceneObjectPins(spec, name);
      });
      el.appendChild(select);
    } else if (spec.title === "Set Shader Graph") {
      const select = document.createElement("select");
      select.id = spec._id ? spec._id : spec.id;
      select.style.width = "100%";
      select.style.marginTop = "6px";
      // Populate shader objects
      if (spec.accessObject === undefined) spec.accessObject = eval(spec.accessObjectLiteral);
      const placeholder = document.createElement("option");
      placeholder.textContent = "-- Select Shader --";
      placeholder.value = "";
      select.appendChild(placeholder);
      spec.accessObject.runtimeList.forEach(name => {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        select.appendChild(opt);
      });
      select.addEventListener("change", e => {
        const name = e.target.value;
        spec.fields[0].value = name;
        const dom = document.querySelector(`.node[data-id="${spec.id}"]`);
        let fields = dom.querySelectorAll(".node-fields");
        // console.log('WORKS objects', fields);
        fields[0].children[0].value = name;
      });
      el.appendChild(select);
      select.value = spec.fields[0].value;
      setTimeout(() => select.dispatchEvent(new Event('change', {
        bubbles: true
      })), 100);
    }
    el.appendChild(body);
    // --- Dragging ---
    header.addEventListener("mousedown", e => {
      e.preventDefault();
      this.state.draggingNode = el;
      const rect = el.getBoundingClientRect();
      const bx = this.board.getBoundingClientRect();
      this.state.dragOffset = [e.clientX - rect.left + bx.left, e.clientY - rect.top + bx.top];
      document.body.style.cursor = "grabbing";
    });
    // --- Selecting ---
    el.addEventListener("click", e => {
      e.stopPropagation();
      this.selectNode(spec.id);
      this.updateNodeDOM(spec.id);
    });
    el.addEventListener("dblclick", e => {
      e.stopPropagation();
      console.log('DBL ' + spec.id);
      this.onNodeDoubleClick(spec);
    });
    return el;
  }
  selectNode(id) {
    if (this.state.selectedNode) {
      document.querySelector(`.node[data-id="${this.state.selectedNode}"]`)?.classList.remove("selected");
    }
    this.state.selectedNode = id;
    document.querySelector(`.node[data-id="${id}"]`)?.classList.add("selected");
  }
  populateDynamicFunctionSelect(select, spec) {
    select.innerHTML = "";
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = "-- Select Function --";
    select.appendChild(placeholder);
    if (!spec.accessObject || typeof spec.accessObject !== "object") return;
    for (const key in spec.accessObject) {
      if (typeof spec.accessObject[key] === "function") {
        const opt = document.createElement("option");
        opt.value = key;
        opt.textContent = key;
        select.appendChild(opt);
      }
    }
    // console.log(spec.fields.find(item => item.key == "selectedObject").value)
    let current = spec.fields.find(item => item.key == "selectedObject").value;
    for (const opt of select.options) {
      if (opt.text === current) {
        opt.selected = true;
        break;
      }
    }
  }
  isTypeCompatible(fromType, toType) {
    if (fromType === "action" || toType === "action") {
      return fromType === toType;
    }
    if (fromType === toType) return true;
    if (fromType === "any" || toType === "any") return true;
    return false;
  }
  addNode(type, options = {}) {
    const id = "node_" + this.nodeCounter++;
    const x = Math.abs(this.state.pan[0]) + 100 + Math.random() * 200;
    const y = Math.abs(this.state.pan[1]) + 100 + Math.random() * 200;

    // Node factory map
    const nodeFactories = {
      event: (id, x, y) => ({
        id,
        title: "onLoad",
        x,
        y,
        category: "event",
        inputs: [],
        outputs: [{
          name: "exec",
          type: "action"
        }]
      }),
      audioMP3: (id, x, y, options) => ({
        id,
        x,
        y,
        title: "Play MP3",
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "key",
          type: "string",
          default: "audio"
        }, {
          name: "src",
          type: "string",
          default: ""
        }, {
          name: "clones",
          type: "number",
          default: 1
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "created",
          value: false
        }, {
          key: "key",
          value: options?.name
        }, {
          key: "src",
          value: options?.path
        }],
        noselfExec: "true"
      }),
      generator: (id, x, y) => ({
        id,
        x,
        y,
        title: "Generator",
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "material",
          type: "string"
        }, {
          name: "pos",
          type: "object"
        }, {
          name: "rot",
          type: "object"
        }, {
          name: "texturePath",
          type: "string"
        }, {
          name: "name",
          type: "string"
        }, {
          name: "geometry",
          type: "string"
        }, {
          name: "raycast",
          type: "boolean"
        }, {
          name: "scale",
          type: "object"
        }, {
          name: "sum",
          type: "number"
        }, {
          name: "delay",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "material",
          value: "standard"
        }, {
          key: "pos",
          value: '{x:0, y:0, z:-20}'
        }, {
          key: "rot",
          value: '{x:0, y:0, z:0}'
        }, {
          key: "texturePath",
          value: "res/textures/star1.png"
        }, {
          key: "name",
          value: "TEST"
        }, {
          key: "geometry",
          value: "Cube"
        }, {
          key: "raycast",
          value: true
        }, {
          key: "scale",
          value: [1, 1, 1]
        }, {
          key: "sum",
          value: 10
        }, {
          key: "delay",
          value: 500
        }, {
          key: "created",
          value: false
        }],
        noselfExec: "true"
      }),
      generatorWall: (id, x, y) => ({
        id,
        x,
        y,
        title: "Generator Wall",
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "material",
          type: "string"
        }, {
          name: "pos",
          type: "object"
        }, {
          name: "rot",
          type: "object"
        }, {
          name: "texturePath",
          type: "string"
        }, {
          name: "name",
          type: "string"
        }, {
          name: "size",
          type: "string"
        }, {
          name: "raycast",
          type: "boolean"
        }, {
          name: "scale",
          type: "object"
        }, {
          name: "spacing",
          type: "number"
        }, {
          name: "delay",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "material",
          value: "standard"
        }, {
          key: "pos",
          value: '{x:0, y:0, z:-20}'
        }, {
          key: "rot",
          value: '{x:0, y:0, z:0}'
        }, {
          key: "texturePath",
          value: "res/textures/star1.png"
        }, {
          key: "name",
          value: "TEST"
        }, {
          key: "size",
          value: "10x3"
        }, {
          key: "raycast",
          value: true
        }, {
          key: "scale",
          value: [1, 1, 1]
        }, {
          key: "spacing",
          value: 10
        }, {
          key: "delay",
          value: 500
        }, {
          key: "created",
          value: false
        }],
        noselfExec: "true"
      }),
      generatorPyramid: (id, x, y) => ({
        id,
        x,
        y,
        title: "Generator Pyramid",
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "material",
          type: "string"
        }, {
          name: "pos",
          type: "object"
        }, {
          name: "rot",
          type: "object"
        }, {
          name: "texturePath",
          type: "string"
        }, {
          name: "name",
          type: "string"
        }, {
          name: "levels",
          type: "number"
        }, {
          name: "raycast",
          type: "boolean"
        }, {
          name: "scale",
          type: "object"
        }, {
          name: "spacing",
          type: "number"
        }, {
          name: "delay",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }, {
          name: "complete",
          type: "action"
        }, {
          name: "objectNames",
          type: "object"
        }],
        fields: [{
          key: "material",
          value: "standard"
        }, {
          key: "pos",
          value: '{x:0, y:0, z:-20}'
        }, {
          key: "rot",
          value: '{x:0, y:0, z:0}'
        }, {
          key: "texturePath",
          value: "res/textures/star1.png"
        }, {
          key: "name",
          value: "TEST"
        }, {
          key: "levels",
          value: "5"
        }, {
          key: "raycast",
          value: true
        }, {
          key: "scale",
          value: [1, 1, 1]
        }, {
          key: "spacing",
          value: 10
        }, {
          key: "delay",
          value: 500
        }, {
          key: "created",
          value: false
        }],
        noselfExec: "true"
      }),
      addObj: (id, x, y) => ({
        id,
        x,
        y,
        title: "Add OBJ",
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "path",
          type: "string"
        }, {
          name: "material",
          type: "string"
        }, {
          name: "pos",
          type: "object"
        }, {
          name: "rot",
          type: "object"
        }, {
          name: "texturePath",
          type: "string"
        }, {
          name: "name",
          type: "string"
        }, {
          name: "raycast",
          type: "boolean"
        }, {
          name: "scale",
          type: "object"
        }, {
          name: "isPhysicsBody",
          type: "boolean"
        }, {
          name: "isInstancedObj",
          type: "boolean"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }, {
          name: "complete",
          type: "action"
        }, {
          name: "error",
          type: "action"
        }],
        fields: [{
          key: "path",
          value: "res/meshes/blender/cube.obj"
        }, {
          key: "material",
          value: "standard"
        }, {
          key: "pos",
          value: '{x:0, y:0, z:-20}'
        }, {
          key: "rot",
          value: '{x:0, y:0, z:0}'
        }, {
          key: "texturePath",
          value: "res/textures/star1.png"
        }, {
          key: "name",
          value: "TEST"
        }, {
          key: "raycast",
          value: true
        }, {
          key: "scale",
          value: [1, 1, 1]
        }, {
          key: "isPhysicsBody",
          type: false
        }, {
          key: "isInstancedObj",
          type: false
        }, {
          key: "created",
          value: false
        }],
        noselfExec: "true"
      }),
      setForceOnHit: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Force On Hit",
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "objectName",
          type: "string"
        }, {
          name: "rayDirection",
          type: "object"
        }, {
          name: "strength",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [],
        noselfExec: "true"
      }),
      setVideoTexture: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Video Texture",
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "objectName",
          type: "string"
        }, {
          name: "VideoTextureArg",
          type: "object"
        }, {
          name: "muteAudio",
          type: "boolean"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "objectName",
          value: "standard"
        }, {
          key: "VideoTextureArg",
          value: "{type: 'video', src: 'res/videos/tunel.mp4'}"
        }, {
          key: "muteAudio",
          value: true
        }],
        noselfExec: "true"
      }),
      setCanvasInlineTexture: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set CanvasInline",
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "objectName",
          type: "string"
        }, {
          name: "canvaInlineProgram",
          type: "function"
        }, {
          name: "specialCanvas2dArg",
          type: "object"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "objectName",
          value: "standard"
        }, {
          key: "canvaInlineProgram",
          value: "function (ctx, canvas) {}"
        }, {
          key: "specialCanvas2dArg",
          value: "{ hue: 200, glow: 10, text: 'Hello programmer', fontSize: 60, flicker: 0.05, }"
        }],
        noselfExec: "true"
      }),
      audioReactiveNode: (id, x, y) => ({
        id,
        x,
        y,
        title: "Audio Reactive Node",
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "audioSrc",
          type: "string"
        }, {
          name: "loop",
          type: "boolean"
        }, {
          name: "thresholdBeat",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }, {
          name: "low",
          type: "number"
        }, {
          name: "mid",
          type: "number"
        }, {
          name: "high",
          type: "number"
        }, {
          name: "energy",
          type: "number"
        }, {
          name: "beat",
          type: "boolean"
        }],
        fields: [{
          key: "audioSrc",
          value: "audionautix-black-fly.mp3"
        }, {
          key: "loop",
          value: true
        }, {
          key: "thresholdBeat",
          value: 0.7
        }, {
          key: "created",
          value: false
        }],
        noselfExec: "true"
      }),
      oscillator: (id, x, y) => ({
        id,
        x,
        y,
        title: "Oscillator",
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "min",
          type: "number"
        }, {
          name: "max",
          type: "number"
        }, {
          name: "step",
          type: "number"
        }, {
          name: "regime",
          type: "string"
        }, {
          name: "resist",
          type: "number"
        }, {
          name: "resistMode",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }, {
          name: "value",
          type: "number"
        }],
        fields: [{
          key: "min",
          value: 0
        }, {
          key: "max",
          value: 10
        }, {
          key: "step",
          value: 0.2
        }, {
          key: "regime",
          value: 'pingpong'
        }, {
          key: "resist",
          value: 0.02
        }, {
          key: "resistMode",
          value: 'linear'
        }],
        noselfExec: "true"
      }),
      curveTimeline: (id, x, y) => ({
        id,
        x,
        y,
        title: "Curve",
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "name",
          type: "string"
        }, {
          name: "delta",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }, {
          name: "value",
          type: "number"
        }],
        fields: [{
          key: "name",
          value: "Curve1"
        }],
        curve: {},
        noselfExec: "true"
      }),
      eventCustom: (id, x, y) => ({
        id,
        x,
        y,
        title: "Custom Event",
        category: "event",
        fields: [{
          key: "name",
          value: "myEvent"
        }],
        inputs: [],
        outputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "detail",
          type: "object"
        }],
        _listenerAttached: false,
        _returnCache: null,
        noselfExec: 'true'
      }),
      dispatchEvent: (id, x, y) => ({
        id,
        x,
        y,
        title: "Dispatch Event",
        category: "event",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "eventName",
          type: "string",
          default: "myEvent"
        }, {
          name: "detail",
          type: "object",
          default: {}
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        noselfExec: 'true'
      }),
      rayHitEvent: (id, x, y) => ({
        id,
        x,
        y,
        title: "On Ray Hit",
        category: "event",
        inputs: [],
        outputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "hitObjectName",
          type: "string"
        }, {
          name: "screenCoords",
          type: "object"
        }, {
          name: "rayOrigin",
          type: "object"
        }, {
          name: "rayDirection",
          type: "object"
        }, {
          name: "hitObject",
          type: "object"
        }, {
          name: "hitNormal",
          type: "object"
        }, {
          name: "hitDistance",
          type: "object"
        }, {
          name: "eventName",
          type: "object"
        }, {
          name: "button",
          type: "number"
        }, {
          name: "timestamp",
          type: "number"
        }],
        noselfExec: 'true',
        _listenerAttached: false
      }),
      onDraw: (id, x, y) => ({
        id,
        x,
        y,
        title: "On Draw",
        category: "event",
        inputs: [],
        outputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "delta",
          type: "number"
        }, {
          name: "skip",
          type: "number"
        }],
        fields: [{
          key: "skip",
          value: 5
        }],
        noselfExec: 'true',
        _listenerAttached: false
      }),
      onKey: (id, x, y) => ({
        id,
        x,
        y,
        title: "On Key",
        category: "event",
        inputs: [],
        outputs: [{
          name: "keyDown",
          type: "action"
        }, {
          name: "keyUp",
          type: "action"
        }, {
          name: "isHeld",
          type: "boolean"
        }, {
          name: "anyKeyDown",
          type: "action"
        }, {
          name: "keyCode",
          type: "string"
        }, {
          name: "shift",
          type: "action"
        }, {
          name: "ctrl",
          type: "action"
        }, {
          name: "alt",
          type: "action"
        }],
        fields: [{
          key: "key",
          value: "W"
        }],
        noselfExec: 'true',
        _listenerAttached: false
      }),
      function: (id, x, y) => ({
        id,
        title: "Function",
        x,
        y,
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      if: (id, x, y) => ({
        id,
        title: "if",
        x,
        y,
        category: "logic",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "condition",
          type: "boolean"
        }],
        outputs: [{
          name: "true",
          type: "action"
        }, {
          name: "false",
          type: "action"
        }],
        fields: [{
          key: "condition",
          value: true
        }],
        noselfExec: "true"
      }),
      genrand: (id, x, y) => ({
        id,
        title: "GenRandInt",
        x,
        y,
        category: "value",
        inputs: [],
        outputs: [{
          name: "result",
          type: "value"
        }],
        fields: [{
          key: "min",
          value: "0"
        }, {
          key: "max",
          value: "10"
        }]
      }),
      print: (id, x, y) => ({
        id,
        title: "Print",
        x,
        y,
        category: "actionprint",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "value",
          type: "any"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "label",
          value: "Result"
        }],
        builtIn: true,
        noselfExec: 'true'
      }),
      timeout: (id, x, y) => ({
        id,
        title: "SetTimeout",
        x,
        y,
        category: "timer",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "delay",
          type: "value"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "delay",
          value: "1000"
        }],
        builtIn: true
      }),
      // string operation
      startsWith: (id, x, y) => ({
        id,
        title: "Starts With [string]",
        x,
        y,
        category: "stringOperation",
        inputs: [{
          name: "input",
          type: "string"
        }, {
          name: "prefix",
          type: "string"
        }],
        outputs: [{
          name: "return",
          type: "boolean"
        }]
      }),
      endsWith: (id, x, y) => ({
        id,
        title: "Ends With [string]",
        x,
        y,
        category: "stringOperation",
        inputs: [{
          name: "input",
          type: "string"
        }, {
          name: "suffix",
          type: "string"
        }],
        outputs: [{
          name: "return",
          type: "boolean"
        }]
      }),
      includes: (id, x, y) => ({
        id,
        title: "Includes [string]",
        x,
        y,
        category: "stringOperation",
        inputs: [{
          name: "input",
          type: "string"
        }, {
          name: "search",
          type: "string"
        }],
        outputs: [{
          name: "return",
          type: "boolean"
        }]
      }),
      toUpperCase: (id, x, y) => ({
        id,
        title: "To Upper Case [string]",
        x,
        y,
        category: "stringOperation",
        inputs: [{
          name: "input",
          type: "string"
        }],
        outputs: [{
          name: "return",
          type: "string"
        }]
      }),
      toLowerCase: (id, x, y) => ({
        id,
        title: "To Lower Case [string]",
        x,
        y,
        category: "stringOperation",
        inputs: [{
          name: "input",
          type: "string"
        }],
        outputs: [{
          name: "return",
          type: "string"
        }]
      }),
      trim: (id, x, y) => ({
        id,
        title: "Trim [string]",
        x,
        y,
        category: "stringOperation",
        inputs: [{
          name: "input",
          type: "string"
        }],
        outputs: [{
          name: "return",
          type: "string"
        }]
      }),
      length: (id, x, y) => ({
        id,
        title: "String Length",
        x,
        y,
        category: "stringOperation",
        inputs: [{
          name: "input",
          type: "string"
        }],
        outputs: [{
          name: "return",
          type: "number"
        }]
      }),
      substring: (id, x, y) => ({
        id,
        title: "Substring [string]",
        x,
        y,
        category: "stringOperation",
        inputs: [{
          name: "input",
          type: "string"
        }, {
          name: "start",
          type: "number"
        }, {
          name: "end",
          type: "number"
        }],
        outputs: [{
          name: "return",
          type: "string"
        }]
      }),
      replace: (id, x, y) => ({
        id,
        title: "Replace [string]",
        x,
        y,
        category: "stringOperation",
        inputs: [{
          name: "input",
          type: "string"
        }, {
          name: "search",
          type: "string"
        }, {
          name: "replace",
          type: "string"
        }],
        outputs: [{
          name: "return",
          type: "string"
        }]
      }),
      split: (id, x, y) => ({
        id,
        title: "Split [string]",
        x,
        y,
        category: "stringOperation",
        inputs: [{
          name: "input",
          type: "string"
        }, {
          name: "separator",
          type: "string"
        }],
        outputs: [{
          name: "return",
          type: "array"
        }]
      }),
      concat: (id, x, y) => ({
        id,
        title: "Concat [string]",
        x,
        y,
        category: "stringOperation",
        inputs: [{
          name: "a",
          type: "string"
        }, {
          name: "b",
          type: "string"
        }],
        outputs: [{
          name: "return",
          type: "string"
        }]
      }),
      isEmpty: (id, x, y) => ({
        id,
        title: "Is Empty [string]",
        x,
        y,
        category: "stringOperation",
        inputs: [{
          name: "input",
          type: "string"
        }],
        outputs: [{
          name: "return",
          type: "boolean"
        }]
      }),
      // Math
      add: (id, x, y) => ({
        id,
        title: "Add",
        x,
        y,
        category: "math",
        inputs: [{
          name: "a",
          type: "value"
        }, {
          name: "b",
          type: "value"
        }],
        outputs: [{
          name: "result",
          type: "value"
        }]
      }),
      sub: (id, x, y) => ({
        id,
        title: "Sub",
        x,
        y,
        category: "math",
        inputs: [{
          name: "a",
          type: "value"
        }, {
          name: "b",
          type: "value"
        }],
        outputs: [{
          name: "result",
          type: "value"
        }]
      }),
      mul: (id, x, y) => ({
        id,
        title: "Mul",
        x,
        y,
        category: "math",
        inputs: [{
          name: "a",
          type: "value"
        }, {
          name: "b",
          type: "value"
        }],
        outputs: [{
          name: "result",
          type: "value"
        }]
      }),
      div: (id, x, y) => ({
        id,
        title: "Div",
        x,
        y,
        category: "math",
        inputs: [{
          name: "a",
          type: "value"
        }, {
          name: "b",
          type: "value"
        }],
        outputs: [{
          name: "result",
          type: "value"
        }]
      }),
      sin: (id, x, y) => ({
        id,
        title: "Sin",
        x,
        y,
        category: "math",
        inputs: [{
          name: "a",
          type: "value"
        }],
        outputs: [{
          name: "result",
          type: "value"
        }]
      }),
      cos: (id, x, y) => ({
        id,
        title: "Cos",
        x,
        y,
        category: "math",
        inputs: [{
          name: "a",
          type: "value"
        }],
        outputs: [{
          name: "result",
          type: "value"
        }]
      }),
      pi: (id, x, y) => ({
        id,
        title: "Pi",
        x,
        y,
        category: "math",
        inputs: [],
        outputs: [{
          name: "result",
          type: "value"
        }]
      }),
      // comparation nodes
      greater: (id, x, y) => ({
        id,
        title: "A > B",
        x,
        y,
        category: "compare",
        inputs: [{
          name: "A",
          type: "number"
        }, {
          name: "B",
          type: "number"
        }],
        outputs: [{
          name: "result",
          type: "boolean"
        }]
      }),
      less: (id, x, y) => ({
        id,
        title: "A < B",
        x,
        y,
        category: "compare",
        inputs: [{
          name: "A",
          type: "number"
        }, {
          name: "B",
          type: "number"
        }],
        outputs: [{
          name: "result",
          type: "boolean"
        }]
      }),
      equal: (id, x, y) => ({
        id,
        title: "A == B",
        x,
        y,
        category: "compare",
        inputs: [{
          name: "A",
          type: "any"
        }, {
          name: "B",
          type: "any"
        }],
        outputs: [{
          name: "result",
          type: "boolean"
        }]
      }),
      notequal: (id, x, y) => ({
        id,
        title: "A != B",
        x,
        y,
        category: "compare",
        inputs: [{
          name: "A",
          type: "any"
        }, {
          name: "B",
          type: "any"
        }],
        outputs: [{
          name: "result",
          type: "boolean"
        }]
      }),
      greaterEqual: (id, x, y) => ({
        id,
        title: "A >= B",
        x,
        y,
        category: "compare",
        inputs: [{
          name: "A",
          type: "number"
        }, {
          name: "B",
          type: "number"
        }],
        outputs: [{
          name: "result",
          type: "boolean"
        }]
      }),
      lessEqual: (id, x, y) => ({
        id,
        title: "A <= B",
        x,
        y,
        category: "compare",
        inputs: [{
          name: "A",
          type: "number"
        }, {
          name: "B",
          type: "number"
        }],
        outputs: [{
          name: "result",
          type: "boolean"
        }]
      }),
      getNumber: (id, x, y) => ({
        id,
        title: "Get Number",
        x,
        y,
        category: "value",
        outputs: [{
          name: "result",
          type: "number"
        }],
        fields: [{
          key: "var",
          value: ""
        }],
        isGetterNode: true
      }),
      getBoolean: (id, x, y) => ({
        id,
        title: "Get Boolean",
        x,
        y,
        category: "value",
        outputs: [{
          name: "result",
          type: "boolean"
        }],
        fields: [{
          key: "var",
          value: ""
        }],
        isGetterNode: true
      }),
      getString: (id, x, y) => ({
        id,
        title: "Get String",
        x,
        y,
        category: "value",
        outputs: [{
          name: "result",
          type: "string"
        }],
        fields: [{
          key: "var",
          value: ""
        }],
        isGetterNode: true
      }),
      getObject: (id, x, y) => ({
        id,
        title: "Get Object",
        x,
        y,
        category: "value",
        outputs: [{
          name: "result",
          type: "object"
        }],
        fields: [{
          key: "var",
          value: ""
        }],
        isGetterNode: true
      }),
      setObject: (id, x, y) => ({
        id,
        title: "Set Object",
        x,
        y,
        category: "action",
        isVariableNode: true,
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "value",
          type: "object"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "var",
          value: ""
        }, {
          key: "literal",
          value: {}
        }]
      }),
      setNumber: (id, x, y) => ({
        id,
        title: "Set Number",
        x,
        y,
        category: "action",
        isVariableNode: true,
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "value",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "var",
          value: ""
        }, {
          key: "literal",
          value: 0
        }]
      }),
      setBoolean: (id, x, y) => ({
        id,
        title: "Set Boolean",
        x,
        y,
        category: "action",
        isVariableNode: true,
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "value",
          type: "boolean"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "var",
          value: ""
        }, {
          key: "literal",
          value: false
        }]
      }),
      setString: (id, x, y) => ({
        id,
        title: "Set String",
        x,
        y,
        category: "action",
        isVariableNode: true,
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "value",
          type: "string"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "var",
          value: ""
        }, {
          key: "literal",
          value: ""
        }]
      }),
      getNumberLiteral: (id, x, y) => ({
        id,
        title: "getNumberLiteral",
        x,
        y,
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }, {
          name: "value",
          type: "number"
        }],
        fields: [{
          key: "value",
          value: 1
        }],
        noselfExec: "true"
      }),
      comment: (id, x, y) => ({
        id,
        title: "Comment",
        x,
        y,
        category: "meta",
        inputs: [],
        outputs: [],
        comment: true,
        noExec: true,
        fields: [{
          key: "text",
          value: "Add comment"
        }]
      }),
      dynamicFunction: (id, x, y, accessObject) => ({
        id,
        title: "functions",
        x,
        y,
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "selectedObject",
          value: ""
        }],
        accessObject: accessObject ? accessObject : window.app,
        accessObjectLiteral: "window.app"
      }),
      refFunction: (id, x, y) => ({
        id,
        title: "reffunctions",
        x,
        y,
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "reference",
          type: "any"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      getSceneObject: (id, x, y) => ({
        noExec: true,
        id,
        title: "Get Scene Object",
        x,
        y,
        category: "scene",
        inputs: [],
        outputs: [],
        fields: [{
          key: "selectedObject",
          value: ""
        }],
        builtIn: true,
        accessObject: window.app?.mainRenderBundle,
        accessObjectLiteral: "window.app?.mainRenderBundle",
        exposeProps: ["name", "position", "rotation", "scale"]
      }),
      getShaderGraph: (id, x, y) => ({
        noExec: true,
        id,
        title: "Set Shader Graph",
        x,
        y,
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          objectName: "objectName",
          type: "string"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "selectedShader",
          value: ""
        }, {
          key: "objectName",
          value: "FLOOR"
        }],
        builtIn: true,
        accessObject: window.app?.shaderGraph,
        accessObjectLiteral: "window.app?.shaderGraph"
      }),
      getSceneLight: (id, x, y) => ({
        noExec: true,
        id,
        title: "Get Scene Light",
        x,
        y,
        category: "scene",
        inputs: [],
        outputs: [],
        fields: [{
          key: "selectedObject",
          value: ""
        }],
        builtIn: true,
        accessObject: window.app?.lightContainer,
        accessObjectLiteral: "window.app?.lightContainer",
        exposeProps: ["ambientFactor", "setPosX", "setPosY", "setPosZ", "setIntensity", "setInnerCutoff", "setOuterCutoff", "setColor", "setColorR", "setColorB", "setColorG", "setRange", "setAmbientFactor", "setShadowBias"]
      }),
      getObjectAnimation: (id, x, y) => ({
        noExec: true,
        id,
        title: "Get Scene Animation",
        x,
        y,
        category: "scene",
        inputs: [],
        outputs: [],
        fields: [{
          key: "selectedObject",
          value: ""
        }],
        builtIn: true,
        accessObject: window.app?.mainRenderBundle,
        accessObjectLiteral: "window.app?.mainRenderBundle",
        exposeProps: ["name", "glb.glbJsonData.animations", "glb.animationIndex", "playAnimationByName", "playAnimationByIndex"]
      }),
      getPosition: (id, x, y) => ({
        id,
        x,
        y,
        title: "Get Position",
        category: "scene",
        inputs: [{
          name: "position",
          semantic: "position"
        }],
        outputs: [{
          name: "x",
          semantic: "number"
        }, {
          name: "y",
          semantic: "number"
        }, {
          name: "z",
          semantic: "number"
        }],
        noExec: true
      }),
      setPosition: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Position",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "position",
          semantic: "position"
        }, {
          name: "x",
          semantic: "number"
        }, {
          name: "y",
          semantic: "number"
        }, {
          name: "z",
          semantic: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      setSpeed: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Speed",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "position",
          semantic: "position"
        }, {
          name: "thrust",
          semantic: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      setTexture: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Texture",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "texturePath",
          semantic: "texturePath"
        }, {
          name: "sceneObjectName",
          semantic: "string"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      setBlend: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Blend",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "alpha",
          type: "number"
        }, {
          name: "sceneObjectName",
          semantic: "string"
        }],
        fields: [{
          key: "sceneObjectName",
          value: "FLOOR"
        }, {
          key: "alpha",
          value: 0.5
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      setProductionMode: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Production Mode",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "disableLoopWarns",
          type: "boolean"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "disableLoopWarns",
          value: "true"
        }]
      }),
      setMaterial: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Material",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "materialType",
          semantic: "string"
        }, {
          name: "sceneObjectName",
          semantic: "string"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "sceneObjectName",
          value: "FLOOR"
        }, {
          key: "materialType",
          value: "standard",
          placeholder: "standard|power|water"
        }]
      }),
      setWaterParams: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Water Material Params",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "sceneObjectName",
          semantic: "string"
        }, {
          name: "deepColor(vec3f)",
          semantic: "object"
        }, {
          name: "waveSpeed",
          semantic: "number"
        }, {
          name: "shallowColor(vec3f)",
          semantic: "object"
        }, {
          name: "waveScale",
          semantic: "number"
        }, {
          name: "waveHeight",
          semantic: "number"
        }, {
          name: "fresnelPower",
          semantic: "number"
        }, {
          name: "specularPower",
          semantic: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "sceneObjectName",
          value: "FLOOR"
        }, {
          key: "deepColor(vec3f)",
          value: "[0.0, 0.2, 0.4]"
        }, {
          key: "waveSpeed",
          value: "0.5"
        }, {
          key: "shallowColor(vec3f)",
          value: "[0.0, 0.5, 0.7]"
        }, {
          key: "waveScale",
          value: "4.0"
        }, {
          key: "waveHeight",
          value: "0.15"
        }, {
          key: "fresnelPower",
          value: "3.0"
        }, {
          key: "specularPower",
          value: "128"
        }]
      }),
      setVertexWave: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Vertex Wave",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "sceneObjectName",
          semantic: "string"
        }, {
          name: "intensity",
          type: "number"
        }, {
          name: "enableWave",
          type: "boolean"
        }, {
          name: "Wave Speed",
          type: "number"
        }, {
          name: "Wave Amplitude",
          type: "number"
        }, {
          name: "Wave Frequency",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "sceneObjectName",
          value: "FLOOR"
        }, {
          key: "enableWave",
          value: false
        }, {
          key: "Wave Speed",
          value: 3.0
        }, {
          key: "Wave Amplitude",
          value: 0.2
        }, {
          key: "Wave Frequency",
          value: 1.5
        }]
      }),
      setVertexWind: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Vertex Wind",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "sceneObjectName",
          semantic: "string"
        }, {
          name: "enableWind",
          type: "boolean"
        }, {
          name: "Wind Speed",
          type: "number"
        }, {
          name: "Wind Strength",
          type: "number"
        }, {
          name: "Wind HeightInfluence",
          type: "number"
        }, {
          name: "Wind Turbulence",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "sceneObjectName",
          value: "FLOOR"
        }, {
          key: "enableWind",
          value: false
        }, {
          key: "Wind Speed",
          value: 2.0
        }, {
          key: "Wind Strength",
          value: 0.4
        }, {
          key: "Wind HeightInfluence",
          value: 2.0
        }, {
          key: "Wind Turbulence",
          value: 0.4
        }]
      }),
      setVertexPulse: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Vertex Pulse",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "sceneObjectName",
          semantic: "string"
        }, {
          name: "enablePulse",
          type: "boolean"
        }, {
          name: "Pulse speed",
          type: "number"
        }, {
          name: "Pulse amount",
          type: "number"
        }, {
          name: "Pulse centerX",
          type: "number"
        }, {
          name: "Pulse centerY",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "sceneObjectName",
          value: "FLOOR"
        }, {
          key: "enablePulse",
          value: false
        }, {
          key: "Pulse speed",
          value: 1
        }, {
          key: "Pulse amount",
          value: 2
        }, {
          key: "Pulse centerX",
          value: 0
        }, {
          key: "Pulse centerY",
          value: 0
        }]
      }),
      setVertexTwist: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Vertex Twist",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "sceneObjectName",
          semantic: "string"
        }, {
          name: "enableTwist",
          type: "boolean"
        }, {
          name: "Twist speed",
          type: "number"
        }, {
          name: "Twist amount",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "sceneObjectName",
          value: "FLOOR"
        }, {
          key: "enableTwist",
          value: false
        }, {
          key: "Twist speed",
          value: 1
        }, {
          key: "Twist amount",
          value: 1
        }]
      }),
      setVertexNoise: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Vertex Noise",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "sceneObjectName",
          semantic: "string"
        }, {
          name: "enableNoise",
          type: "boolean"
        }, {
          name: "Noise Scale",
          type: "number"
        }, {
          name: "Noise Strength",
          type: "number"
        }, {
          name: "Noise Speed",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "sceneObjectName",
          value: "FLOOR"
        }, {
          key: "enableNoise",
          value: false
        }, {
          key: "Noise Scale",
          value: 0.5
        }, {
          key: "Noise Strength",
          value: 0.02
        }, {
          key: "Noise Speed",
          value: 0.3
        }]
      }),
      setVertexOcean: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Vertex Ocean",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "sceneObjectName",
          semantic: "string"
        }, {
          name: "enableOcean",
          type: "boolean"
        }, {
          name: "Ocean Scale",
          type: "number"
        }, {
          name: "Ocean Height",
          type: "number"
        }, {
          name: "Ocean speed",
          type: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "sceneObjectName",
          value: "FLOOR"
        }, {
          key: "enableOcean",
          value: false
        }, {
          key: "Ocean Scale",
          value: 2.0
        }, {
          key: "Ocean Height",
          value: 0.08
        }, {
          key: "Ocean speed",
          value: 1.5
        }]
      }),
      getSpeed: (id, x, y) => ({
        id,
        x,
        y,
        title: "Get Speed",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "position",
          semantic: "position"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }, {
          name: "thrust",
          semantic: "number"
        }]
      }),
      setRotate: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Rotate",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "rotation",
          semantic: "rotation"
        }, {
          name: "x",
          semantic: "number"
        }, {
          name: "y",
          semantic: "number"
        }, {
          name: "z",
          semantic: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      setRotateX: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set RotateX",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "rotation",
          semantic: "rotation"
        }, {
          name: "x",
          semantic: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      setRotateY: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set RotateY",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "rotation",
          semantic: "rotation"
        }, {
          name: "y",
          semantic: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      setRotateZ: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set RotateZ",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "rotation",
          semantic: "rotation"
        }, {
          name: "z",
          semantic: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      setRotation: (id, x, y) => ({
        id,
        x,
        y,
        title: "Set Rotation",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "rotation",
          semantic: "rotation"
        }, {
          name: "x",
          semantic: "number"
        }, {
          name: "y",
          semantic: "number"
        }, {
          name: "z",
          semantic: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      translateByX: (id, x, y) => ({
        id,
        x,
        y,
        title: "Translate By X",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "position",
          semantic: "position"
        }, {
          name: "x",
          semantic: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        builtIn: true
      }),
      translateByY: (id, x, y) => ({
        id,
        x,
        y,
        title: "Translate By Y",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "position",
          semantic: "position"
        }, {
          name: "y",
          semantic: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      translateByZ: (id, x, y) => ({
        id,
        x,
        y,
        title: "Translate By Z",
        category: "scene",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "position",
          semantic: "position"
        }, {
          name: "z",
          semantic: "number"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }]
      }),
      onTargetPositionReach: (id, x, y) => ({
        id,
        x,
        y,
        title: "On Target Position Reach",
        category: "event",
        noExec: true,
        inputs: [{
          name: "position",
          type: "object"
        }],
        outputs: [{
          name: "exec",
          type: "action"
        }],
        _listenerAttached: false
      }),
      fetch: (id, x, y) => ({
        id,
        title: "Fetch",
        x,
        y,
        category: "action",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "url",
          type: "string"
        }, {
          name: "method",
          type: "string",
          default: "GET"
        }, {
          name: "body",
          type: "object"
        }, {
          name: "headers",
          type: "object"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }, {
          name: "error",
          type: "action"
        }, {
          name: "response",
          type: "object"
        }, {
          name: "status",
          type: "number"
        }]
      }),
      getSubObject: (id, x, y) => ({
        id,
        title: "Get Sub Object",
        x,
        y,
        category: "value",
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "object",
          type: "object"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }],
        fields: [{
          key: "objectPreview",
          value: "",
          readonly: true
        }, {
          key: "path",
          value: "",
          placeholder: "SomeProperty"
        }],
        isDynamicNode: true,
        _needsRebuild: true,
        _pinsBuilt: false
      }),
      forEach: (id, x, y) => ({
        id,
        title: "For Each",
        type: "forEach",
        x,
        y,
        state: {
          item: null,
          index: 0
        },
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "array",
          type: "any"
        } // semantic array pin
        ],
        outputs: [{
          name: "loop",
          type: "action"
        }, {
          name: "completed",
          type: "action"
        }, {
          name: "item",
          type: "any"
        }, {
          name: "index",
          type: "number"
        }]
      }),
      getArray: (id, x, y, initialArray = []) => ({
        id,
        type: "getArray",
        title: "Get Array",
        x,
        y,
        fields: [{
          key: "array",
          value: initialArray.slice()
        }],
        inputs: [{
          name: "exec",
          type: "action"
        }, {
          name: "array",
          type: "any"
        }],
        outputs: [{
          name: "execOut",
          type: "action"
        }, {
          name: "array",
          type: "any"
        }],
        _returnCache: initialArray.slice()
      })
    };

    // Generate node spec
    let spec = null;
    if (type === 'dynamicFunction') {
      // Exception for dynamic access
      let AO = prompt(`
Add global access object and explore all method inside!
(in theory can be any object)
LIST OF INTEREST OBJECT:
 - app            (from main objects yuo can access func like 'activateBloomEffect' of 'activateVolumetricEffect')
 - app.bloomPass  (After activateBloomEffect now you can access bloom params)
 - app.cameras.WASD (Access camera methods)
        `);
      if (AO) {
        console.warn("Adding AO ", eval(AO));
        options.accessObject = eval(AO);
      } else {
        console.warn("Adding global access object failed...");
        options.accessObject = window.app;
        return;
      }
      ;
      if (nodeFactories[type]) spec = nodeFactories[type](id, x, y, options.accessObject);
      spec.accessObjectLiteral = AO;
    } else if (type === 'audioMP3' && options?.path && options?.name) {
      if (nodeFactories[type]) spec = nodeFactories[type](id, x, y, options);
    } else {
      if (nodeFactories[type]) spec = nodeFactories[type](id, x, y);
    }
    if (spec && spec.fields && options) {
      for (const f of spec.fields) {
        if (options[f.key] !== undefined) {
          f.value = options[f.key];
        }
      }
    }

    // TEST
    // const catalog = generateAICatalog(nodeFactories);
    // const systemCatalogText = catalogToText(catalog);
    // console.log(systemCatalogText);
    // localStorage.setItem('systemCatalogText', systemCatalogText);
    // TEST

    if (spec) {
      const dom = this.createNodeDOM(spec);
      this.board.appendChild(dom);
      this.nodes[id] = spec;
      return id;
    }
    return null;
  }
  setVariable(type, key, value) {
    if (!this.variables[type][key]) return;
    this.variables[type][key].value = value;
    this.notifyVariableChanged(type, key);
  }
  updateArrayNode(node, newValue) {
    if (!Array.isArray(newValue)) {
      console.warn("Value must be an array");
      return;
    }
    const field = node.fields.find(f => f.key === "array");
    if (field) {
      field.value = newValue;
      node._returnCache = newValue;
    }
  }
  initEventNodes() {
    for (const nodeId in this.nodes) {
      const n = this.nodes[nodeId];
      if (n.category === "event") {
        // console.log('ACTIVATRE NODE ', n.title)
        this.activateEventNode(nodeId);
      }
    }
  }
  adaptSubObjectPins(node, obj) {
    // 🚫 DO NOTHING if no valid object
    if (!obj || typeof obj !== "object") return;
    node.outputs = node.outputs.filter(p => p.type === "action");
    if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj)) {
        node.outputs.push({
          name: key,
          type: this.detectType(obj[key])
        });
      }
    }
  }
  detectType(val) {
    if (typeof val === "number") return "number";
    if (typeof val === "boolean") return "boolean";
    if (typeof val === "string") return "string";
    if (typeof val === "object") return "object";
    return "any";
  }
  createFieldInput(node, field) {
    const input = document.createElement("input");
    input.type = "text";
    input.value = field.value ?? "";
    input.placeholder = field.placeholder ?? "";
    input.disabled = field.readonly === true;
    if (field.readonly) {
      input.style.opacity = "0.7";
      input.style.cursor = "default";
    }
    const saveInputValue = () => {
      let val;
      if (field.type === "object") {
        try {
          val = JSON.parse(input.value);
        } catch {
          return;
        }
      } else {
        val = input.value;
      }
      field.value = val;

      // existing logic stays
      if (node.isGetterNode && field.key === "var") {
        this.notifyVariableChanged("object", val);
      }

      // ? not tested in last ver
      document.dispatchEvent(new CustomEvent("fluxcodex.field.change", {
        detail: {
          nodeId: node.id,
          nodeType: node.type,
          fieldKey: field.key,
          fieldType: field.type,
          value: field.value
        }
      }));
    };
    input.onkeydown = e => {
      if (e.key === "Enter") {
        e.preventDefault();
        saveInputValue();
      }
    };
    input.onblur = () => saveInputValue();
    if (node.title === "Get Sub Object" && field.key === "path") {
      input.oninput = () => {
        const link = this.getConnectedSource(node.id, "object");
        if (!link?.node?.isGetterNode) {
          if (link.node.title == "Get Sub Object") {
            console.log('special sub sub test ', link.node.title);
            let target = this.resolvePath(link.node._returnCache, link.pin);
            node.outputs = node.outputs.filter(p => p.type === "action"); // clear old object pins
            if (target && typeof target === "object") {
              for (const k in target) {
                node.outputs.push({
                  name: k,
                  type: this.detectType(target[k])
                });
              }
            }
          }
          if (link.node.title == "Get Scene Animation") {
            console.log('special test ', link.node.title);
            const varField = link.node.fields?.find(f => f.key === "selectedObject");
            console.log('special test ', varField);

            // pin: "glb.glbJsonData.animations"

            if (link.pin.indexOf('.') != -1) {
              let target = this.resolvePath(app.getSceneObjectByName(varField.value), link.pin);
              console.log('special test target ', target);
              link.node._subCache = target;
              node.outputs = node.outputs.filter(p => p.type === "action"); // clear old object pins
              if (target && typeof target === "object") {
                for (const k in target) {
                  node.outputs.push({
                    name: k,
                    type: this.detectType(target[k])
                  });
                }
              }
              node._needsRebuild = false;
              node._pinsBuilt = true;
              this.updateNodeDOM(node.id);
            }
            console.log('special test :::: ', link.node.accessObject[varField.value]);
            // this.getValue(link.node.id, "")
          }
          return;
        }
        const varField = link.node.fields?.find(f => f.key === "var");
        const varName = varField?.value;
        const rootObj = this.variables?.object?.[varName];
        const path = input.value;
        const target = this.resolvePath(rootObj, path);
        node._subCache = {};
        node._subCache = target;
        node.outputs = node.outputs.filter(p => p.type === "action"); // clear old object pins
        if (target && typeof target === "object") {
          for (const k in target) {
            node.outputs.push({
              name: k,
              type: this.detectType(target[k])
            });
          }
        }
        node._needsRebuild = false;
        node._pinsBuilt = true;
        this.updateNodeDOM(node.id);
      };
    }
    return input;
  }
  resolvePath(obj, path) {
    if (!obj || !path) return obj;
    const parts = path.split(".").filter(p => p.length);
    let current = obj;
    for (const part of parts) {
      if (current && typeof current === "object" && part in current) {
        current = current[part];
      } else {
        return undefined;
      }
    }
    return current;
  }
  resolveAccessObject(accessObject, objectName) {
    if (!accessObject) return null;
    if (Array.isArray(accessObject)) {
      return accessObject.find(o => o.name === objectName) || null;
    }
    if (typeof accessObject === "object") {
      return accessObject[objectName] || null;
    }
    return null;
  }
  adaptNodeToAccessMethod(node, objectName, methodName) {
    const obj = this.accessObject.find(o => o.name === objectName);
    if (!obj) return;
    const method = obj[methodName];
    if (typeof method !== "function") return;
    const args = this.getArgNames(method);
    node.inputs = [{
      name: "exec",
      type: "action"
    }];
    node.outputs = [{
      name: "execOut",
      type: "action"
    }];
    args.forEach(arg => node.inputs.push({
      name: arg,
      type: "value"
    }));
    if (this.hasReturn(method)) {
      node.outputs.push({
        name: "return",
        type: "value"
      });
    }
    node._access = {
      objectName,
      methodName
    };
    this.updateNodeDOM(node.id);
  }
  activateEventNode(nodeId) {
    const n = this.nodes[nodeId];
    if (n.title === "On Target Position Reach") {
      const pos = this.getValue(nodeId, "position");
      if (!pos) return;
      pos.onTargetPositionReach = () => {
        this.enqueueOutputs(n, "exec");
      };
      n._listenerAttached = true;
    } else if (n.title == "On Ray Hit") {
      // console.log('ON RAY HIT INIT ONLE !!!!!!!!!!!!!!!!!')
      if (n._listenerAttached) return;
      app.reference.addRaycastsListener();
      const handler = e => {
        n._returnCache = e.detail;
        this.enqueueOutputs(n, "exec");
      };
      app.canvas.addEventListener("ray.hit.event", handler);
      n._eventHandler = handler;
      n._listenerAttached = true;
      return;
    } else if (n.title == "On Draw") {
      // console.log('ON DRAW INIT ONLE !!!!!', n.fields.find(f => f.key === "skip")?.value);
      if (n._listenerAttached) return;
      let skip = n.fields.find(f => f.key === "skip")?.value;
      if (typeof n._frameCounter === "undefined") {
        n._frameCounter = 0;
      }
      const graph = this;
      app.graphUpdate = function (delta) {
        n._frameCounter++;
        if (skip > 0 && n._frameCounter < skip) return;
        n._frameCounter = 0;
        // console.info('.....', delta)
        n._returnCache = delta;
        graph.enqueueOutputs(n, "exec");
      };
      n._listenerAttached = true;
      return;
    } else if (n.title == "On Key") {
      if (n._listenerAttached) return;
      const graph = this;
      n._isHeld = false;
      window.addEventListener("keydown", e => {
        n.lastKey = e.key;
        graph.enqueueOutputs(n, "anyKeyDown");
        if (e.ctrlKey == true) graph.enqueueOutputs(n, "ctrl");
        if (e.altKey == true) graph.enqueueOutputs(n, "alt");
        if (e.shiftKey == true) graph.enqueueOutputs(n, "shift");
        const keyValue = n.fields.find(f => f.key === "key")?.value;
        if (!keyValue) return;
        if (e.key.toLowerCase() === keyValue.toLowerCase()) {
          // node._pressed = true;
          n._isHeld = true;
          graph.enqueueOutputs(n, "keyDown");
        }
      });
      window.addEventListener("keyup", e => {
        console.log('ON e.shiftKey !!!!!', e.shiftKey);
        console.log('ON e.altKey !!!!!', e.altKey);
        console.log('ON e.ctrltKey !!!!!', e.ctrlKey);
        const keyValue = n.fields.find(f => f.key === "key")?.value;
        if (!keyValue) return;
        if (e.key.toLowerCase() === keyValue.toLowerCase()) {
          // node._pressed = true;
          n._isHeld = false;
          graph.enqueueOutputs(n, "keyUp");
        }
      });
      window.addEventListener("blur", () => {
        if (n._isHeld) {
          n._isHeld = false;
          graph.enqueueOutputs(n, "keyUp");
        }
      });
      n._listenerAttached = true;
    }
  }
  _executeAttachedMethod(n) {
    if (n.attachedMethod) {
      const method = this.methodsManager.methodsContainer.find(m => m.name === n.attachedMethod);
      if (method) {
        const fn = this.methodsManager.compileFunction(method.code);
        const args = this.getArgNames(fn).map(argName => this.getValue(n.id, argName));
        let result;
        try {
          result = fn(...args);
        } catch (err) {
          console.error("User method error:", err);
        }
        if (this.hasReturn(fn)) n._returnCache = result;
      }
    }
  }
  getValue(nodeId, pinName, visited = new Set()) {
    const node = this.nodes[nodeId];
    if (visited.has(nodeId + ":" + pinName)) {
      return undefined;
    }
    if (!node || visited.has(nodeId)) return undefined;
    visited.add(nodeId);
    if (node.title === "Function" && pinName === "reference") {
      if (typeof node.fn === 'undefined') {
        const selected = this.methodsManager.methodsContainer.find(m => m.name === node.attachedMethod);
        if (selected) {
          node.fn = this.methodsManager.compileFunction(selected.code);
        } else {
          console.warn('Node: Function PinName: reference [reference not found at methodsContainer]');
        }
      }
      return node.fn;
    }
    if (node.title === "On Draw") if (pinName == "delta") return node._returnCache;
    if (node.title === "On Key" && pinName == "isHeld") return node._isHeld;
    if (node.title === "On Key" && pinName == "keyCode") return node.lastKey;
    if (node.title === "Generator Pyramid" && pinName == "objectNames") return node._returnCache;
    if (node.title === "Audio Reactive Node") {
      if (pinName === "low") {
        return node._returnCache[0];
      } else if (pinName === "mid") {
        return node._returnCache[1];
      } else if (pinName === "high") {
        return node._returnCache[2];
      } else if (pinName === "energy") {
        return node._returnCache[3];
      } else if (pinName === "beat") {
        return node._returnCache[4];
      }
    }
    if (node.title === "Oscillator" && pinName == "value") {
      return node._returnCache;
    }
    if (node.title === "On Ray Hit") {
      if (pinName === "hitObjectName") {
        return node._returnCache['hitObject']['name'];
      } else {
        return node._returnCache[pinName];
      }
    }
    if (node.title === "if" && pinName === "condition") {
      let testLink = this.links.find(l => l.to.node === nodeId && l.to.pin === pinName);
      let t;
      try {
        t = this.getValue(testLink.from.node, testLink.from.pin);
      } catch (err) {
        console.log(`IF NODE ${node.id} have no conditional pin connected - default is false... fix this in FluxCodexVertex graph editor.`);
        return false;
      }
      if (typeof t !== 'undefined') {
        return t;
      }
      if (this._execContext !== nodeId) {
        console.warn("[IF] condition read outside exec ignored");
        return node.fields?.find(f => f.key === "condition")?.value;
      }
      // ?
    }
    if (node.title === "Custom Event" && pinName === "detail") {
      console.warn("[Custom Event]  getvalue");
      return node._returnCache;
    }
    if (node.title === "Dispatch Event" && (pinName === 'eventName' || pinName === 'detail')) {
      let testLink = this.links.find(l => l.to.node === nodeId && l.to.pin === pinName);
      return this.getValue(testLink.from.node, testLink.from.pin);
    }
    if (node.isGetterNode) {
      if (node._returnCache === undefined) {
        this.triggerNode(node.id);
      }
      let value = node._returnCache;
      // Optional: parse string to array
      if (typeof value === "string") {
        try {
          if (node.title == "Get String") {
            // value = JSON.parse(value);
          } else {
            value = JSON.parse(value);
          }
        } catch (e) {
          console.warn('[getValue][json parse err]:', e);
        }
      }
      return value;
    }
    const link = this.links.find(l => l.to.node === nodeId && l.to.pin === pinName);
    if (link) return this.getValue(link.from.node, link.from.pin, visited);
    const field = node.fields?.find(f => f.key === pinName);
    if (field) return field.value;
    const inputPin = node.inputs?.find(p => p.name === pinName);
    if (inputPin) return inputPin.default ?? 0;
    if (node.title === "Get Scene Object" || node.title === "Get Scene Animation" || node.title === "Get Scene Light") {
      const objName = this._getSceneSelectedName(node);
      if (!objName) return undefined;
      //repopulate
      const dom = this.board.querySelector(`[data-id="${nodeId}"]`);
      const selects = dom.querySelectorAll("select"); // returns NodeList
      let select = selects[0];
      select.innerHTML = ``;
      if (select) {
        node.accessObject.forEach(obj => {
          const opt = document.createElement("option");
          opt.value = obj.name;
          opt.textContent = obj.name;
          select.appendChild(opt);
        });
      }
      if (node.fields[0].value) select.value = node.fields[0].value;
      const obj = (node.accessObject || []).find(o => o.name === objName);
      if (!obj) return undefined;
      const out = node.outputs.find(o => o.name === pinName);
      if (!out) return undefined;
      if (pinName.indexOf('.') != -1) {
        return this.resolvePath(obj, pinName);
      }
      return obj[pinName];
    } else if (node.title === "Get Position") {
      const pos = this.getValue(nodeId, "position");
      if (!pos) return undefined;
      node._returnCache = {
        x: pos.x,
        y: pos.y,
        z: pos.z
      };
      return node._returnCache[pinName];
    } else if (node.title === "Get Sub Object") {
      let varField = node.outputs?.find(f => f.name === "0");
      let isName = node.outputs?.find(f => f.name === "name");
      // console.log('test1 :::', varField)
      if (varField) if (varField.type == 'object') {
        return node._subCache[parseInt(varField.name)];
      }
      // console.log('test2 :::', isName);
      return node._subCache;
    } else if (node.type === "forEach") {
      if (pinName === "item") return node.state?.item;
      if (pinName === "index") return node.state?.index;
    }

    // console.log("GETVALUE COMPARE!")
    if (["math", "value", "compare", "stringOperation"].includes(node.category)) {
      let result;
      switch (node.title) {
        case "Starts With [string]":
          console.log('test startsWith');
          result = this.getValue(nodeId, "input").startsWith(this.getValue(nodeId, "prefix"));
          break;
        case "Ends With [string]":
          result = this.getValue(nodeId, "input")?.endsWith(this.getValue(nodeId, "suffix"));
          break;
        case "Includes [string]":
          result = this.getValue(nodeId, "input")?.includes(this.getValue(nodeId, "search"));
          break;
        case "Equals [string]":
          result = this.getValue(nodeId, "a") === this.getValue(nodeId, "b");
          break;
        case "Not Equals [string]":
          result = this.getValue(nodeId, "a") !== this.getValue(nodeId, "b");
          break;
        case "To Upper Case [string]":
          result = this.getValue(nodeId, "input")?.toUpperCase();
          break;
        case "To Lower Case [string]":
          result = this.getValue(nodeId, "input")?.toLowerCase();
          break;
        case "Trim [string]":
          result = this.getValue(nodeId, "input")?.trim();
          break;
        case "String Length":
          result = this.getValue(nodeId, "input")?.length ?? 0;
          break;
        case "Substring [string]":
          result = this.getValue(nodeId, "input")?.substring(this.getValue(nodeId, "start"), this.getValue(nodeId, "end"));
          break;
        case "Replace [string]":
          result = this.getValue(nodeId, "input")?.replace(this.getValue(nodeId, "search"), this.getValue(nodeId, "replace"));
          break;
        case "Split [string]":
          result = this.getValue(nodeId, "input")?.split(this.getValue(nodeId, "separator"));
          break;
        case "Concat [string]":
          result = (this.getValue(nodeId, "a") ?? "") + (this.getValue(nodeId, "b") ?? "");
          break;
        case "Is Empty [string]":
          result = !this.getValue(nodeId, "input") || this.getValue(nodeId, "input").length === 0;
          break;
        case "Add":
          result = this.getValue(nodeId, "a") + this.getValue(nodeId, "b");
          break;
        case "Sub":
          result = this.getValue(nodeId, "a") - this.getValue(nodeId, "b");
          break;
        case "Mul":
          result = this.getValue(nodeId, "a") * this.getValue(nodeId, "b");
          break;
        case "Div":
          result = this.getValue(nodeId, "a") / this.getValue(nodeId, "b");
          break;
        case "Sin":
          result = Math.sin(this.getValue(nodeId, "a"));
          break;
        case "Cos":
          result = Math.cos(this.getValue(nodeId, "a"));
          break;
        case "Pi":
          result = Math.PI;
          break;
        case "A > B":
          result = this.getValue(nodeId, "A") > this.getValue(nodeId, "B");
          break;
        case "A < B":
          result = this.getValue(nodeId, "A") < this.getValue(nodeId, "B");
          break;
        case "A == B":
          let varA = this.getValue(nodeId, "A");
          let varB = this.getValue(nodeId, "B");
          if (typeof varA == "object") {
            const r = this.deepEqual(varA, varB);
            result = r;
          } else {
            result = this.getValue(nodeId, "A") != this.getValue(nodeId, "B");
          }
          break;
        case "A != B":
          let varAN = this.getValue(nodeId, "A");
          let varBN = this.getValue(nodeId, "B");
          if (typeof varAN == "object") {
            const r = this.deepEqual(varAN, varBN);
            result = !r;
          } else {
            result = this.getValue(nodeId, "A") != this.getValue(nodeId, "B");
          }
          break;
        case "A >= B":
          result = this.getValue(nodeId, "A") >= this.getValue(nodeId, "B");
          break;
        case "A <= B":
          result = this.getValue(nodeId, "A") <= this.getValue(nodeId, "B");
          break;
        case "GenRandInt":
          const min = +node.fields?.find(f => f.key === "min")?.value || 0;
          const max = +node.fields?.find(f => f.key === "max")?.value || 10;
          result = Math.floor(Math.random() * (max - min + 1)) + min;
          break;
        default:
          result = undefined;
      }
      node._returnCache = result;
      if (node.displayEl) node.displayEl.textContent = typeof result === "number" ? result.toFixed(3) : String(result);
      return result;
    }
    if (node.outputs?.some(o => o.name === pinName)) {
      const dynamicNodes = ["GenRandInt", "RandomFloat"];
      if ((node._returnCache === undefined || dynamicNodes.includes(node.title)) && !node.noselfExec) {
        this._execContext = nodeId;
        this.triggerNode(nodeId);
        this._execContext = null;
      }
      return node._returnCache;
    }
    return undefined;
  }
  updateValueDisplays() {
    for (const id in this.nodes) {
      const node = this.nodes[id];
      if (!node.displayEl) continue;
      if (node.title === "Print") {
        const pin = node.inputs?.[0];
        if (!pin) continue;
        const val = this.getValue(node.id, pin.name);
        if (val === undefined) {
          node.displayEl.textContent = "undefined";
        } else if (typeof val === "object") {
          node.displayEl.textContent = JSON.stringify(val, null, 2);
        } else if (typeof val === "number") {
          node.displayEl.textContent = val.toFixed(3);
        } else {
          node.displayEl.textContent = String(val);
        }
      }
    }
  }
  extractArgs(code) {
    const match = code.match(/function\s+[^(]*\(([^)]*)\)/);
    if (!match) return [];
    return match[1].split(",").map(a => a.trim()).filter(Boolean);
  }
  adaptDynamicFunction(node, fnName) {
    console.log('adaptDynamicFunction(node, fnName) ');
    const fn = node.accessObject?.[fnName];
    if (typeof fn !== "function") return;
    node.inputs = [{
      name: "exec",
      type: "action"
    }];
    node.outputs = [{
      name: "execOut",
      type: "action"
    }];
    // args → inputs read
    const args = this.getArgNames(fn);
    args.forEach(arg => {
      node.inputs.push({
        name: arg,
        type: "any"
      });
    });
    if (this.hasReturn(fn)) {
      node.outputs.push({
        name: "return",
        type: "value"
      });
    }
    node.category = "functions";
    node.fn = fn; // REAL FUNCTION
    node.fnName = fnName;
    node.descFunc = fnName;
    // node.title = fnName;
    this.updateNodeDOM(node.id);
  }
  invalidateVariableGetters(type, varName) {
    for (const id in this.nodes) {
      const n = this.nodes[id];
      if (n.category === "value" && n.fields?.some(f => f.key === "var" && f.value === varName) && n.title === `Get ${type[0].toUpperCase() + type.slice(1)}`) {
        delete n._returnCache;
      }
    }
  }
  deepEqual(a, b) {
    if (a === b) return true;
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) return false;
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) return false;
    for (const key of keysA) {
      if (!keysB.includes(key)) return false;
      if (!this.deepEqual(a[key], b[key])) return false;
    }
    return true;
  }
  triggerNode(nodeId) {
    const n = this.nodes[nodeId];
    if (!n) return;
    this._execContext = nodeId;
    // Highlight node header
    const highlight = document.querySelector(`.node[data-id="${nodeId}"] .header`);
    if (highlight) {
      highlight.style.filter = "brightness(1.5)";
      setTimeout(() => highlight.style.filter = "none", 200);
    }
    if (n.title === "Get Sub Object") {
      const obj = this.getValue(n.id, "object");
      let path = n.fields.find(f => f.key === "path")?.value;
      let target = this.resolvePath(obj, path);
      if (target === undefined) {
        // probably no prefix .value 
        path = path.replace('value.', '');
        target = this.resolvePath(obj, path);
      }
      console.warn('SET CACHE target is ', target);
      // n.outputs = n.outputs.filter(p => p.type === "action");
      n._subCache = target;
      n._returnCache = target;
      n._needsRebuild = false;
      n._pinsBuilt = true;
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.type === "forEach") {
      let arr;
      const link = this.links.find(l => l.to.node === n.id);
      if (link) arr = this.getValue(link.from.node, link.from.pin);
      // Fallback to literal
      if (arr === undefined) {
        const inputPin = n.inputs?.find(p => p.name === "array");
        arr = inputPin?.default;
      }
      if (typeof arr === "string") {
        try {
          arr = JSON.parse(arr);
        } catch (e) {
          console.warn("Failed to parse array string", arr);
          arr = [];
        }
      }
      if (!Array.isArray(arr)) return;
      arr.forEach((item, index) => {
        // update node runtime state!
        n.state = {
          item,
          index
        };
        this.links.filter(l => l.type === "action" && l.from.node === n.id && l.from.pin === "loop").forEach(l => {
          this.triggerNode(l.to.node);
        });
      });
      // completed pin (once)
      this.links.filter(l => l.type === "action" && l.from.node === n.id && l.from.pin === "completed").forEach(l => {
        this.triggerNode(l.to.node);
      });
    } else if (n.title === "Get Array") {
      let arr;
      // Find input link BAd but ok for now
      const link = this.links.find(l => l.to.node === n.id && (l.to.pin === "array" || l.to.pin === "result" || l.to.pin === "value"));
      if (link) {
        const fromNode = this.nodes[link.from.node];
        if (fromNode._returnCache === undefined && fromNode._subCache === undefined) {
          // this.triggerNode(fromNode.id);
        }
        if (fromNode._returnCache) arr = fromNode._returnCache;
        if (fromNode._subCache) arr = fromNode._subCache;
      } else {
        // fallback to default literal
        arr = n.inputs?.find(p => p.name === "array")?.default ?? [];
      }
      // make it fluid 
      n._returnCache = Array.isArray(arr) ? arr : arr ? arr[link.from.pin] : this.getValue(link.from.node, link.from.pin);
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "reffunctions") {
      const fn = n._fnRef;
      if (typeof fn !== "function") {
        console.warn("[reffunctions] No function reference");
        this.enqueueOutputs(n, "execOut");
        return;
      }

      // Collect REAL args (exclude exec + reference)
      const args = n.inputs.filter(p => p.type !== "action" && p.name !== "reference").map(p => this.getValue(n.id, p.name));
      const result = fn(...args);
      if (this.hasReturn(fn)) {
        n._returnCache = result;
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Custom Event") {
      console.log('********************************');
      // if(n._listenerAttached === true) return;

      const eventName = n.fields?.find(f => f.key === "name")?.value;
      if (!eventName) return;
      const handler = e => {
        console.log('**TRUE** HANDLER**');
        n._returnCache = e.detail;
        this.enqueueOutputs(n, "exec");
      };
      console.log('**eventName**', eventName);
      window.removeEventListener(eventName, handler);
      window.addEventListener(eventName, handler);
      n._eventHandler = handler;
      n._listenerAttached = true;
      return;
    } else if (n.title === "Dispatch Event") {
      const name = this.getValue(nodeId, "eventName");
      if (!name) {
        console.warn("[Dispatch] missing eventName");
        this.enqueueOutputs(n, "execOut");
        return;
      }
      const detail = this.getValue(nodeId, "detail");
      console.log('*************window.dispatchEvent****************', name);
      window.dispatchEvent(new CustomEvent(name, {
        detail: detail ?? {}
      }));
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "On Ray Hit") {
      console.log('On Ray Hit =NOTHING NOW', n._listenerAttached);
    }
    if (n.isGetterNode) {
      const varField = n.fields?.find(f => f.key === "var");
      if (varField && varField.value) {
        const type = n.title.replace("Get ", "").toLowerCase();
        const value = this.getVariable(type, varField.value);
        n._returnCache = value;
        // Update visual label if exists
        if (n.displayEl) {
          if (type === "object") {
            n.displayEl.textContent = value !== undefined ? JSON.stringify(value) : "{}";
          } else if (typeof value === "number") {
            n.displayEl.textContent = value.toFixed(3);
          } else {
            n.displayEl.textContent = String(value);
          }
        }
      }
      n.finished = true;
      return;
    }
    if (n.title === "On Target Position Reach") {
      const pos = this.getValue(nodeId, "position");
      console.info("On Target Position Reach ", pos);
      if (!pos) return;
      // Attach listener (engine-agnostic)
      pos.onTargetPositionReach = () => {
        this.triggerNode(n);
        this.enqueueOutputs(n, "exec");
      };
      n._listenerAttached = true;
      return;
    }

    // functionDinamic execution
    if (n.category === "functions") {
      // bloomPass is created in post time - make always update
      n.accessObject = eval(n.accessObjectLiteral);
      if (n.fn === undefined) {
        n.fn = n.accessObject[n.fnName];
      }
      const args = n.inputs.filter(p => p.type !== "action").map(p => this.getValue(n.id, p.name));
      const result = n.fn(...args);
      if (this.hasReturn(n.fn)) {
        n._returnCache = result;
      }
      this.enqueueOutputs(n, "execOut");
      return;
    }
    if (n.category === "event" && typeof n.noselfExec === 'undefined') {
      console.info(`%c<EMPTY EXEC>: ${n.title}`, _utils.LOG_FUNNY_ARCADE);
      this.enqueueOutputs(n, "exec");
      return;
    }
    if (n.category === "event" && typeof n.noselfExec != 'undefined') {
      console.log('<PREVENT SELF EXEC>');
      return;
    }
    if (n.isVariableNode) {
      const type = n.title.replace("Set ", "").toLowerCase();
      const varField = n.fields?.find(f => f.key === "var");
      if (varField && varField.value) {
        let value = this.getValue(nodeId, "value");
        // if 0 probably no pin connection
        if (n.title == "Set Object") {
          if (value == 0) {
            let varliteral = n.fields?.find(f => f.key === "literal");
            // console.log("set object  varliteral.value ", varliteral.value);
            this.variables[type][varField.value] = JSON.parse(varliteral.value);
            // ??
          }
        } else {
          if (value == 0) {
            let varliteral = n.fields?.find(f => f.key === "literal");
            // console.log("set object  varliteral.value ", varliteral.value);
            this.variables[type][varField.value] = JSON.parse(varliteral.value);
            value = JSON.parse(varliteral.value);
          } else {
            console.log("set object ", value);
            this.variables[type][varField.value] = {
              value
            };
          }
        }
        this.notifyVariableChanged(type, varField.value);
        // Update matching getter nodes instantly
        for (const nodeId2 in this.nodes) {
          const node2 = this.nodes[nodeId2];
          if (node2.isGetterNode) {
            const vf2 = node2.fields?.find(f => f.key === "var");
            if (vf2 && vf2.value === varField.value && node2.displayEl) {
              if (type === "object") {
                node2.displayEl.textContent = JSON.stringify(value);
              } else {
                node2.displayEl.textContent = typeof value === "number" ? value.toFixed(3) : String(value);
              }
              node2._returnCache = value;
            }
          }
        }
      }
      n.finished = true;
      this.enqueueOutputs(n, "execOut");
      return;
    }
    if (n.title === "Fetch") {
      const url = this.getValue(nodeId, "url");
      if (!url) {
        console.warn("[Fetch] URL missing");
        this.enqueueOutputs(n, "error");
        return;
      }
      const method = this.getValue(nodeId, "method") || "GET";
      const body = this.getValue(nodeId, "body");
      const headers = this.getValue(nodeId, "headers") || {};
      const options = {
        method,
        headers
      };
      if (body && method !== "GET") {
        options.body = typeof body === "string" ? body : JSON.stringify(body);
        if (!headers["Content-Type"]) {
          headers["Content-Type"] = "application/json";
        }
      }
      fetch(url, options).then(async res => {
        n._returnCache = {
          response: await res.json().catch(() => null),
          status: res.status
        };
        this.enqueueOutputs(n, "execOut");
      }).catch(err => {
        console.error("[Fetch]", err);
        this.enqueueOutputs(n, "error");
      });
      return;
    }

    // Action / Print / Timer Nodes
    if (["action", "actionprint", "timer"].includes(n.category)) {
      // only for custom functions from managerfunction
      if (n.attachedMethod) this._executeAttachedMethod(n);
      if (n.title === "Print") {
        const label = n.fields?.find(f => f.key === "label")?.value || "Print:";
        let val;
        const link = this.getConnectedSource(nodeId, "value");
        if (link) {
          const fromNode = link.node;
          const fromPin = link.pin;
          if (fromNode._subCache && typeof fromNode._subCache === "object" && fromPin in fromNode._subCache) {
            val = fromNode._subCache[fromPin];
          } else {
            val = this.getValue(fromNode.id, fromPin);
          }
        } else {
          val = this.getValue(nodeId, "value");
        }
        if (n.displayEl) {
          if (typeof val === "object") {
            n.displayEl.textContent = JSON.stringify(val);
          } else if (typeof val === "number") {
            n.displayEl.textContent = val.toFixed(3);
          } else {
            n.displayEl.textContent = String(val);
          }
        }
        console.info(`%c[Print] ${label}` + val, _utils.LOG_FUNNY_ARCADE);
      } else if (n.title === "SetTimeout") {
        const delay = +n.fields?.find(f => f.key === "delay")?.value || 1000;
        setTimeout(() => this.enqueueOutputs(n, "execOut"), delay);
        return;
      } else if (n.title === "Play MP3") {
        const key = this.getValue(nodeId, "key");
        const src = this.getValue(nodeId, "src");
        const clones = Number(this.getValue(nodeId, "clones")) || 1;
        if (!key || !src) {
          console.info(`%c[Play MP3] Missing key or src...`, _utils.LOG_FUNNY_ARCADE);
          this.enqueueOutputs(n, "execOut");
          return;
        }
        const createdField = n.fields.find(f => f.key === "created");
        if (!createdField.value) {
          createdField.disabled = true;
          app.matrixSounds.createAudio(key, src, clones);
          createdField.value = true;
        }
        app.matrixSounds.play(key);
        this.enqueueOutputs(n, "execOut");
        return;
      } else if (n.title === "Generator") {
        const texturePath = this.getValue(nodeId, "texturePath");
        const mat = this.getValue(nodeId, "material");
        let pos = this.getValue(nodeId, "pos");
        const geo = this.getValue(nodeId, "geometry");
        let rot = this.getValue(nodeId, "rot");
        let delay = this.getValue(nodeId, "delay");
        let sum = this.getValue(nodeId, "sum");
        let raycast = this.getValue(nodeId, "raycast");
        let scale = this.getValue(nodeId, "scale");
        let name = this.getValue(nodeId, "name");
        // spec adaptation
        if (raycast == "true") {
          raycast = true;
        } else {
          raycast = false;
        }
        if (typeof delay == 'string') delay = parseInt(delay);
        if (typeof pos == 'string') eval("pos = " + pos);
        if (typeof rot == 'string') eval("rot = " + rot);
        if (!texturePath || !pos) {
          console.warn("[Generator] Missing input fields...");
          this.enqueueOutputs(n, "execOut");
          return;
        }
        const createdField = n.fields.find(f => f.key === "created");
        if (createdField.value == "false" || createdField.value == false) {
          console.log('!GEN! ONCE!');
          app.physicsBodiesGenerator(mat, pos, rot, texturePath, name, geo, raycast, scale, sum, delay);
          // createdField.value = true;
        }
        this.enqueueOutputs(n, "execOut");
        return;
      } else if (n.title === "Generator Wall") {
        const texturePath = this.getValue(nodeId, "texturePath");
        const mat = this.getValue(nodeId, "material");
        let pos = this.getValue(nodeId, "pos");
        const size = this.getValue(nodeId, "size");
        let rot = this.getValue(nodeId, "rot");
        let delay = this.getValue(nodeId, "delay");
        let spacing = this.getValue(nodeId, "spacing");
        let raycast = this.getValue(nodeId, "raycast");
        let scale = this.getValue(nodeId, "scale");
        let name = this.getValue(nodeId, "name");
        // spec adaptation
        if (raycast == "true") {
          raycast = true;
        } else {
          raycast = false;
        }
        if (typeof delay == 'string') delay = parseInt(delay);
        if (typeof pos == 'string') eval("pos = " + pos);
        if (typeof rot == 'string') eval("rot = " + rot);
        if (typeof scale == 'string') eval("scale = " + scale);
        if (!texturePath || !pos) {
          console.warn("[Generator] Missing input fields...");
          this.enqueueOutputs(n, "execOut");
          return;
        }
        const createdField = n.fields.find(f => f.key === "created");
        if (createdField.value == "false" || createdField.value == false) {
          app.physicsBodiesGeneratorWall(mat, pos, rot, texturePath, name, size, raycast, scale, spacing, delay);
          // createdField.value = true;
        }
        this.enqueueOutputs(n, "execOut");
        return;
      } else if (n.title === "Add OBJ") {
        const path = this.getValue(nodeId, "path");
        const texturePath = this.getValue(nodeId, "texturePath");
        const mat = this.getValue(nodeId, "material");
        let pos = this.getValue(nodeId, "pos");
        let isPhysicsBody = this.getValue(nodeId, "isPhysicsBody");
        let rot = this.getValue(nodeId, "rot");
        let isInstancedObj = this.getValue(nodeId, "isInstancedObj");
        let raycast = this.getValue(nodeId, "raycast");
        let scale = this.getValue(nodeId, "scale");
        let name = this.getValue(nodeId, "name");
        // spec adaptation - nature of stuff
        if (raycast == "true") {
          raycast = true;
        } else {
          raycast = false;
        }
        if (isInstancedObj == "true") {
          isInstancedObj = true;
        } else {
          isInstancedObj = false;
        }
        if (isPhysicsBody == "true") {
          isPhysicsBody = true;
        } else {
          isPhysicsBody = false;
        }
        if (typeof pos == 'string') eval("pos = " + pos);
        if (typeof rot == 'string') eval("rot = " + rot);
        if (typeof scale == 'string') eval("scale = " + scale);
        if (!texturePath || !path) {
          console.warn("[Generator] Missing input fields...");
          this.enqueueOutputs(n, "execOut");
          return;
        }
        const createdField = n.fields.find(f => f.key === "created");
        if (createdField.value == "false" || createdField.value == false) {
          app.editorAddOBJ(path, mat, pos, rot, texturePath, name, isPhysicsBody, raycast, scale, isInstancedObj).then(object => {
            object._GRAPH_CACHE = true;
            n._returnCache = object;
            this.enqueueOutputs(n, "complete");
          }).catch(err => {
            console.log(`%cADD OBJ ERROR GRAPH!`, _utils.LOG_FUNNY_ARCADE);
            n._returnCache = null;
            this.enqueueOutputs(n, "error");
          });
          // createdField.value = true;
        }
        // sync
        this.enqueueOutputs(n, "execOut");
        return;
      } else if (n.title === "Generator Pyramid") {
        const texturePath = this.getValue(nodeId, "texturePath");
        const mat = this.getValue(nodeId, "material");
        let pos = this.getValue(nodeId, "pos");
        const levels = this.getValue(nodeId, "levels");
        let rot = this.getValue(nodeId, "rot");
        let delay = this.getValue(nodeId, "delay");
        let spacing = this.getValue(nodeId, "spacing");
        let raycast = this.getValue(nodeId, "raycast");
        let scale = this.getValue(nodeId, "scale");
        let name = this.getValue(nodeId, "name");
        // spec adaptation
        if (raycast == "true") {
          raycast = true;
        } else {
          raycast = false;
        }
        if (typeof delay == 'string') delay = parseInt(delay);
        if (typeof pos == 'string') eval("pos = " + pos);
        if (typeof rot == 'string') eval("rot = " + rot);
        if (typeof scale == 'string') eval("scale = " + scale);
        if (!texturePath || !pos) {
          console.warn("[Generator] Missing input fields...");
          this.enqueueOutputs(n, "execOut");
          return;
        }
        const createdField = n.fields.find(f => f.key === "created");
        if (createdField.value == "false" || createdField.value == false) {
          app.physicsBodiesGeneratorDeepPyramid(mat, pos, rot, texturePath, name, levels, raycast, scale, spacing, delay).then(objects => {
            // console.log('!GEN PYRAMID COMPLETE!');
            n._returnCache = objects;
            this.enqueueOutputs(n, "complete");
          });
          // createdField.value = true;
        }
        // sync
        this.enqueueOutputs(n, "execOut");
        return;
      } else if (n.title === "Set Force On Hit") {
        const objectName = this.getValue(nodeId, "objectName");
        const strength = this.getValue(nodeId, "strength");
        const rayDirection = this.getValue(nodeId, "rayDirection");
        if (!objectName || !rayDirection || !strength) {
          console.warn("[Set Force On Hit] Missing input fields...");
          this.enqueueOutputs(n, "execOut");
          return;
        }
        let b = app.matrixAmmo.getBodyByName(objectName);
        const i = new Ammo.btVector3(rayDirection[0] * strength, rayDirection[1] * strength, rayDirection[2] * strength);
        b.applyCentralImpulse(i);
        this.enqueueOutputs(n, "execOut");
        return;
      } else if (n.title === "Set Video Texture") {
        const objectName = this.getValue(nodeId, "objectName");
        let videoTextureArg = this.getValue(nodeId, "VideoTextureArg");
        if (!objectName) {
          console.warn("[Set Video Texture] Missing input fields...");
          this.enqueueOutputs(n, "execOut");
          return;
        }

        // console.warn("[Set Video Texture] arg:", videoTextureArg);
        if (typeof videoTextureArg != 'object') {
          // console.warn("[Set Video Texture] arg is not object!:", videoTextureArg);
          if (typeof videoTextureArg == 'string') {
            eval("videoTextureArg = " + videoTextureArg);
          }
          if (typeof videoTextureArg === "undefined" || videoTextureArg === null) videoTextureArg = {
            type: "video",
            // video , camera  //not tested canvas2d, canvas2dinline
            src: "res/videos/tunel.mp4"
          };
        }
        let o = app.getSceneObjectByName(objectName);
        o.loadVideoTexture(videoTextureArg);
        this.enqueueOutputs(n, "execOut");
        return;
      } else if (n.title === "Set CanvasInline") {
        const objectName = this.getValue(nodeId, "objectName");
        let canvaInlineProgram = this.getValue(nodeId, "canvaInlineProgram");
        let specialCanvas2dArg = this.getValue(nodeId, "specialCanvas2dArg");
        if (!objectName) {
          console.log(`%c Node [Set CanvasInline] probably objectname is missing...`, _utils.LOG_FUNNY_ARCADE);
          this.enqueueOutputs(n, "execOut");
          return;
        }
        // console.warn("[canvaInlineProgram] specialCanvas2dArg arg:", specialCanvas2dArg);
        if (typeof specialCanvas2dArg == 'string') {
          eval("specialCanvas2dArg = " + specialCanvas2dArg);
        }
        if (typeof canvaInlineProgram != 'function') {
          // console.warn("[canvaInlineProgram] arg is not object!:", canvaInlineProgram);
          if (typeof canvaInlineProgram == 'string') {
            canvaInlineProgram = eval("canvaInlineProgram = " + canvaInlineProgram);
          }
          if (typeof canvaInlineProgram === "undefined" || canvaInlineProgram === null) canvaInlineProgram = function (ctx, canvas) {};
        }
        let o = app.getSceneObjectByName(objectName);
        if (typeof o === 'undefined') {
          console.log(`%c Node [Set CanvasInline] probably objectname is wrong...`, _utils.LOG_FUNNY_ARCADE);
          _utils.mb.show("FluxCodexVertex Exec order is breaked on [Set CanvasInline] node id:", n.id);
          return;
        }
        // mb.show("FluxCodexVertex WHAT IS on [Set CanvasInline] node id:", n.id);
        o.loadVideoTexture({
          type: "canvas2d-inline",
          canvaInlineProgram: canvaInlineProgram,
          specialCanvas2dArg: specialCanvas2dArg ? specialCanvas2dArg : undefined
        });
        this.enqueueOutputs(n, "execOut");
        return;
      } else if (n.title === "Curve") {
        const cName = this.getValue(nodeId, "name");
        const cDelta = this.getValue(nodeId, "delta");
        if (!cName) {
          console.log(`%c Node [CURVE] probably name is missing...`, _utils.LOG_FUNNY_ARCADE);
          this.enqueueOutputs(n, "execOut");
          return;
        }
        let curve = this.curveEditor.curveStore.getByName(nodeId);
        if (!curve) {
          console.warn("Curve not found:", cName);
          this.enqueueOutputs(n, "execOut");
          return;
        }
        if (!curve.baked) {
          console.log(`%cNode [CURVE] ${curve} bake.`, _utils.LOG_FUNNY_ARCADE);
          curve.bake();
        }
        n.curve = curve;
        const t01 = cDelta / curve.length;
        // smooth
        // const t01 = curve.loop
        // ? (cDelta / curve.length) % 1
        // : Math.min(1, Math.max(0, cDelta / curve.length));
        let V = n.curve.evaluate(t01);
        n._returnCache = V;
        this.enqueueOutputs(n, "execOut");
        return;
      } else if (n.title === "getNumberLiteral") {
        const literailNum = this.getValue(nodeId, "number");
        n._returnCache = literailNum;
        this.enqueueOutputs(n, "execOut");
        return;
      } else if (n.title === "Audio Reactive Node") {
        const src = this.getValue(nodeId, "audioSrc");
        const loop = this.getValue(nodeId, "loop");
        const thresholdBeat = this.getValue(nodeId, "thresholdBeat");
        const createdField = n.fields.find(f => f.key === "created");
        if (!n._audio && !n._loading) {
          n._loading = true;
          createdField.value = true;
          createdField.disabled = true;
          app.audioManager.load(src).then(asset => {
            asset.audio.loop = loop;
            n._audio = asset;
            n._energyHistory = [];
            n._beatCooldown = 0;
            n._loading = false;
          });
          return;
        }
        if (!n._audio || !n._audio.ready) return;
        const data = n._audio.updateFFT();
        if (!data) return;
        let low = 0,
          mid = 0,
          high = 0;
        for (let i = 0; i < 16; i++) low += data[i];
        for (let i = 16; i < 64; i++) mid += data[i];
        for (let i = 64; i < 128; i++) high += data[i];
        low /= 16;
        mid /= 48;
        high /= 64;
        const energy = (low + mid + high) / 3;
        const hist = n._energyHistory;
        hist.push(low);
        if (hist.length > 30) hist.shift();
        let avg = 0;
        for (let i = 0; i < hist.length; i++) avg += hist[i];
        avg /= hist.length;
        let beat = false;
        if (low > avg * thresholdBeat && n._beatCooldown <= 0) {
          beat = true;
          n._beatCooldown = 10;
        }
        if (n._beatCooldown > 0) n._beatCooldown--;
        n._returnCache = [low, mid, high, energy, beat];
        this.enqueueOutputs(n, "execOut");
        return;
      } else if (n.title === "Oscillator") {
        const min = this.getValue(nodeId, "min");
        const max = this.getValue(nodeId, "max");
        const step = this.getValue(nodeId, "step");
        const regime = this.getValue(nodeId, "regime");
        const resist = this.getValue(nodeId, "resist");
        const resistMode = this.getValue(nodeId, "resistMode");
        if (!n._listenerAttached) {
          n.osc = new _utils.OSCILLATOR(min, max, step, {
            regime: regime,
            resist: resist,
            resistMode: resistMode
          });
          n._listenerAttached = true;
        }
        n._returnCache = n.osc.UPDATE();
      } else if (n.title === "Set Shader Graph") {
        console.warn("[Set Shader Graph] ?????  ??input fields...");
        const objectName = this.getValue(nodeId, "objectName");
        let selectedShader = this.getValue(nodeId, "selectedShader");
        if (!objectName) {
          console.warn("[Set Shader Graph] Missing input fields...");
          this.enqueueOutputs(n, "execOut");
          return;
        }
        let o = app.getSceneObjectByName(objectName);
        // 
        o.changeMaterial("graph", app.shaderGraph.runtime_memory[selectedShader]);
        this.enqueueOutputs(n, "execOut");
        return;
      }
      this.enqueueOutputs(n, "execOut");
      return;
    }
    if (n.category === "logic" && n.title === "if") {
      // console.log('TEST LOGIC ')
      const condition = Boolean(this.getValue(nodeId, "condition"));
      this.enqueueOutputs(n, condition ? "true" : "false");
      this._execContext = null;
      return;
    }
    if (n.title === "Get Speed") {
      const pos = this.getValue(nodeId, "position");
      if (pos?.getSpeed) n._returnCache = pos.getSpeed();
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Water Material Params") {
      let deepColor = this.getValue(nodeId, "deepColor(vec3f)");
      let waveSpeed = this.getValue(nodeId, "waveSpeed");
      let shallowColor = this.getValue(nodeId, "shallowColor(vec3f)");
      let waveScale = this.getValue(nodeId, "waveScale");
      let waveHeight = this.getValue(nodeId, "waveHeight");
      let fresnelPower = this.getValue(nodeId, "fresnelPower");
      let specularPower = this.getValue(nodeId, "specularPower");
      let sceneObjectName = this.getValue(nodeId, "sceneObjectName");
      if (deepColor && sceneObjectName) {
        deepColor = JSON.parse(deepColor);
        shallowColor = JSON.parse(shallowColor);
        let obj = app.getSceneObjectByName(sceneObjectName);
        obj.updateWaterParams(deepColor, shallowColor, waveSpeed, waveScale, waveHeight, fresnelPower, specularPower);
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set VertexAnim Intesity") {
      let sceneObjectName = this.getValue(nodeId, "sceneObjectName");
      let intensity = this.getValue(nodeId, "intensity");
      if (sceneObjectName) {
        let obj = app.getSceneObjectByName(sceneObjectName);
        obj.vertexAnim.setIntensity(intensity);
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Vertex Wave") {
      let sceneObjectName = this.getValue(nodeId, "sceneObjectName");
      let enableWave = this.getValue(nodeId, "enableWave");
      let waveSpeed = this.getValue(nodeId, "Wave Speed");
      let waveAmplitude = this.getValue(nodeId, "Wave Amplitude");
      let waveFrequency = this.getValue(nodeId, "Wave Frequency");
      if (sceneObjectName) {
        if (enableWave == true || enableWave == "true") {
          let obj = app.getSceneObjectByName(sceneObjectName);
          obj.vertexAnim.enableWave();
          obj.vertexAnim.setWaveParams(waveSpeed, waveAmplitude, waveFrequency);
        } else {
          obj.vertexAnim.disableWave();
        }
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Vertex Wind") {
      let sceneObjectName = this.getValue(nodeId, "sceneObjectName");
      let enableWind = this.getValue(nodeId, "enableWind");
      let windSpeed = this.getValue(nodeId, "Wind Speed");
      let windStrength = this.getValue(nodeId, "Wind Strength");
      let windHeightInfluence = this.getValue(nodeId, "Wind HeightInfluence");
      let windTurbulence = this.getValue(nodeId, "Wind Turbulence");
      if (sceneObjectName) {
        let obj = app.getSceneObjectByName(sceneObjectName);
        if (enableWind == true || enableWind == "true") {
          obj.vertexAnim.enableWind();
          obj.vertexAnim.setWindParams(windSpeed, windStrength, windHeightInfluence, windTurbulence);
        } else {
          obj.vertexAnim.disableWind();
        }
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Vertex Pulse") {
      let sceneObjectName = this.getValue(nodeId, "sceneObjectName");
      let enablePulse = this.getValue(nodeId, "enablePulse");
      let pulseSpeed = this.getValue(nodeId, "Pulse speed");
      let pulseAmount = this.getValue(nodeId, "Pulse amount");
      let pulseCenterX = this.getValue(nodeId, "Pulse centerX");
      let pulseCenterY = this.getValue(nodeId, "Pulse centerY");
      if (sceneObjectName) {
        let obj = app.getSceneObjectByName(sceneObjectName);
        if (enablePulse == true || enablePulse == "true") {
          obj.vertexAnim.enablePulse();
          obj.vertexAnim.setPulseParams(pulseSpeed, pulseAmount, pulseCenterX, pulseCenterY);
        } else {
          obj.vertexAnim.disablePulse();
        }
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Vertex Twist") {
      let sceneObjectName = this.getValue(nodeId, "sceneObjectName");
      let enableTwist = this.getValue(nodeId, "enableTwist");
      let twistSpeed = this.getValue(nodeId, "Twist speed");
      let twistAmount = this.getValue(nodeId, "Twist amount");
      // setTwistParams: (speed, amount)");
      if (sceneObjectName) {
        console.log(' TEST VERTEX ANIMATION !Twist ', enableTwist);
        let obj = app.getSceneObjectByName(sceneObjectName);
        if (enableTwist == true || enableTwist == "true") {
          obj.vertexAnim.enableTwist();
          obj.vertexAnim.setTwistParams(twistSpeed, twistAmount);
        }
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Vertex Noise") {
      let sceneObjectName = this.getValue(nodeId, "sceneObjectName");
      let enableNoise = this.getValue(nodeId, "enableNoise");
      let noiseScale = this.getValue(nodeId, "Noise Scale");
      let noiseStrength = this.getValue(nodeId, "Noise Strength");
      let noiseSpeed = this.getValue(nodeId, "Noise Speed");
      // setNoiseParams: (scale, strength, speed)
      if (sceneObjectName) {
        console.log(' TEST VERTEX ANIMATION !enableNoise ', enableNoise);
        let obj = app.getSceneObjectByName(sceneObjectName);
        if (enableNoise == true || enableNoise == "true") {
          obj.vertexAnim.enableNoise();
          obj.vertexAnim.setNoiseParams(noiseScale, noiseStrength, noiseSpeed);
        }
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Vertex Ocean") {
      let sceneObjectName = this.getValue(nodeId, "sceneObjectName");
      let enableOcean = this.getValue(nodeId, "enableOcean");
      let oceanScale = this.getValue(nodeId, "Ocean Scale");
      let oceanHeight = this.getValue(nodeId, "Ocean Height");
      let oceanSpeed = this.getValue(nodeId, "Ocean speed");
      if (sceneObjectName) {
        let obj = app.getSceneObjectByName(sceneObjectName);
        if (enableOcean == true || enableOcean == "true") {
          obj.vertexAnim.enableOcean();
          obj.vertexAnim.setOceanParams(oceanScale, oceanHeight, oceanSpeed);
        } else {
          obj.vertexAnim.disableOcean();
        }
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Material") {
      const materialType = this.getValue(nodeId, "materialType");
      const sceneObjectName = this.getValue(nodeId, "sceneObjectName");
      if (materialType && materialType !== "graph") {
        console.log('sceneObjectName', sceneObjectName);
        let obj = app.getSceneObjectByName(sceneObjectName);
        obj.changeMaterial(materialType);
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Blend") {
      const a = parseFloat(this.getValue(nodeId, "alpha"));
      const sceneObjectName = this.getValue(nodeId, "sceneObjectName");
      if (sceneObjectName) {
        let obj = app.getSceneObjectByName(sceneObjectName);
        obj.setBlend(a);
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Texture") {
      const texpath = this.getValue(nodeId, "texturePath");
      const sceneObjectName = this.getValue(nodeId, "sceneObjectName");
      if (texpath) {
        // console.log('sceneObjectName', sceneObjectName)
        let obj = app.getSceneObjectByName(sceneObjectName);
        obj.loadTex0([texpath]).then(() => {
          setTimeout(() => obj.changeTexture(obj.texture0), 200);
        });
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Speed") {
      const pos = this.getValue(nodeId, "position");
      if (pos?.setSpeed) {
        pos.setSpeed(this.getValue(nodeId, "thrust"));
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Position") {
      const pos = this.getValue(nodeId, "position");
      if (pos?.setPosition) {
        pos.setPosition(this.getValue(nodeId, "x"), this.getValue(nodeId, "y"), this.getValue(nodeId, "z"));
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Rotation") {
      const rot = this.getValue(nodeId, "rotation");
      if (rot?.setRotation) {
        rot.setRotation(this.getValue(nodeId, "x"), this.getValue(nodeId, "y"), this.getValue(nodeId, "z"));
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Rotate") {
      const rot = this.getValue(nodeId, "rotation");
      if (rot?.setRotate) {
        rot.setRotate(this.getValue(nodeId, "x"), this.getValue(nodeId, "y"), this.getValue(nodeId, "z"));
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set RotateX") {
      const rot = this.getValue(nodeId, "rotation");
      if (rot?.setRotateX) {
        rot.setRotateX(this.getValue(nodeId, "x"));
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set RotateY") {
      const rot = this.getValue(nodeId, "rotation");
      if (rot?.setRotateY) {
        rot.setRotateY(this.getValue(nodeId, "y"));
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set RotateZ") {
      const rot = this.getValue(nodeId, "rotation");
      if (rot?.setRotateZ) {
        rot.setRotateZ(this.getValue(nodeId, "z"));
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Translate By X") {
      const pos = this.getValue(nodeId, "position");
      if (pos?.translateByX) {
        pos.translateByX(this.getValue(nodeId, "x"));
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Translate By Y") {
      const pos = this.getValue(nodeId, "position");
      if (pos?.translateByY) {
        pos.translateByX(this.getValue(nodeId, "y"));
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Translate By Z") {
      const pos = this.getValue(nodeId, "position");
      if (pos?.translateByZ) {
        pos.translateByX(this.getValue(nodeId, "z"));
      }
      this.enqueueOutputs(n, "execOut");
      return;
    } else if (n.title === "Set Production Mode") {
      const disableLoopWarns = this.getValue(nodeId, "disableLoopWarns");
      if (disableLoopWarns) {}
      // console.log('set production mode true - must be saved on editorx level.')
      (0, _utils.byId)('hideEditorBtn').click();
      this.enqueueOutputs(n, "execOut");
      return;
    }
    // console.log("BEFORE COMPARE ");
    if (["math", "value", "compare", "stringOperation"].includes(n.category)) {
      let result;
      switch (n.title) {
        case "Starts With [string]":
          // console.log('test startsWith');
          result = this.getValue(nodeId, "input").startsWith(this.getValue(nodeId, "prefix"));
          break;
        case "Add":
          result = this.getValue(nodeId, "a") + this.getValue(nodeId, "b");
          break;
        case "Sub":
          result = this.getValue(nodeId, "a") - this.getValue(nodeId, "b");
          break;
        case "Mul":
          result = this.getValue(nodeId, "a") * this.getValue(nodeId, "b");
          break;
        case "Div":
          result = this.getValue(nodeId, "a") / this.getValue(nodeId, "b");
          break;
        case "Sin":
          result = Math.sin(this.getValue(nodeId, "a"));
          break;
        case "Cos":
          result = Math.cos(this.getValue(nodeId, "a"));
          break;
        case "Pi":
          result = Math.PI;
          break;
        case "A > B":
          result = this.getValue(nodeId, "A") > this.getValue(nodeId, "B");
          break;
        case "A < B":
          result = this.getValue(nodeId, "A") < this.getValue(nodeId, "B");
          break;
        case "A == B":
          let varA = this.getValue(nodeId, "A");
          let varB = this.getValue(nodeId, "B");
          if (typeof varA == "object") {
            const r = this.deepEqual(varA, varB);
            result = r;
          } else {
            result = this.getValue(nodeId, "A") != this.getValue(nodeId, "B");
          }
          break;
        case "A != B":
          let varAN = this.getValue(nodeId, "A");
          let varBN = this.getValue(nodeId, "B");
          if (typeof varAN == "object") {
            const r = this.deepEqual(varAN, varBN);
            result = !r;
          } else {
            result = this.getValue(nodeId, "A") != this.getValue(nodeId, "B");
          }
          break;
        case "A >= B":
          result = this.getValue(nodeId, "A") >= this.getValue(nodeId, "B");
          break;
        case "A <= B":
          result = this.getValue(nodeId, "A") <= this.getValue(nodeId, "B");
          break;
        case "GenRandInt":
          const min = +n.fields?.find(f => f.key === "min")?.value || 0;
          const max = +n.fields?.find(f => f.key === "max")?.value || 10;
          result = Math.floor(Math.random() * (max - min + 1)) + min;
          break;
        default:
          result = undefined;
      }
      n._returnCache = result;
      if (n.displayEl) n.displayEl.textContent = typeof result === "number" ? result.toFixed(3) : String(result);
    }
    this._execContext = null;
  }
  getConnectedSource(nodeId, inputName) {
    const link = this.links.find(l => l.to.node === nodeId && l.to.pin === inputName);
    if (!link) return null;
    return {
      node: this.nodes[link.from.node],
      pin: link.from.pin
    };
  }
  populateAccessMethods(select) {
    select.innerHTML = "";
    this.accessObject.forEach(obj => {
      Object.getOwnPropertyNames(obj.__proto__).filter(k => typeof obj[k] === "function" && k !== "constructor").forEach(fn => {
        const opt = document.createElement("option");
        opt.value = `${obj.name}.${fn}`;
        opt.textContent = `${obj.name}.${fn}`;
        select.appendChild(opt);
      });
    });
    select.onchange = e => {
      const [objName, fnName] = e.target.value.split(".");
      this.adaptNodeToAccessMethod(node, objName, fnName);
    };
  }
  getByPath(obj, path) {
    return path.split(".").reduce((acc, key) => acc?.[key], obj);
  }
  getVariable(type, key) {
    const entry = this.variables[type]?.[key];
    if (entry === undefined) return undefined;
    if (entry && typeof entry === "object" && "value" in entry) {
      return entry.value;
    }
    return entry;
  }
  enqueueOutputs(n, pinName) {
    this.links.filter(l => l.from.node === n.id && l.from.pin === pinName && l.type === "action").forEach(l => setTimeout(() => {
      this.triggerNode(l.to.node);
    }, 2));
  }
  deleteNode(nodeId) {
    const node = this.nodes[nodeId];
    if (!node) return;
    this.links = this.links.filter(link => {
      if (link.from.node === nodeId || link.to.node === nodeId) {
        const dom = document.getElementById(link.id);
        if (dom) dom.remove();
        return false;
      }
      return true;
    });
    const dom = this.board.querySelector(`[data-id="${nodeId}"]`);
    if (dom) dom.remove();
    delete this.nodes[nodeId];
    this.updateLinks();
  }
  bindGlobalListeners() {
    document.addEventListener("mousemove", this.handleMouseMove.bind(this));
    document.addEventListener("mouseup", this.handleMouseUp.bind(this));
    this.boardWrap.addEventListener("mousedown", this.handleBoardWrapMouseDown.bind(this));
    this.boardWrap.addEventListener("mousedown", () => {
      (0, _utils.byId)("app").style.opacity = 1;
    });
    this.board.addEventListener("click", () => {
      (0, _utils.byId)("app").style.opacity = 1;
    });
  }
  handleMouseMove(e) {
    if (this.state.draggingNode) {
      const el = this.state.draggingNode;
      const newX = e.clientX - this.state.dragOffset[0];
      const newY = e.clientY - this.state.dragOffset[1];
      el.style.left = newX + "px";
      el.style.top = newY + "px";
      const id = el.dataset.id;
      if (this.nodes[id]) {
        this.nodes[id].x = newX;
        this.nodes[id].y = newY;
      }
      this.updateLinks();
    } else if (this.state.panning) {
      const dx = e.clientX - this.state.panStart[0],
        dy = e.clientY - this.state.panStart[1];
      this.state.pan[0] += dx;
      this.state.pan[1] += dy;
      this.board.style.transform = `translate(${this.state.pan[0]}px,${this.state.pan[1]}px)`;
      this.state.panStart = [e.clientX, e.clientY];
      this.updateLinks();
    }
  }
  handleMouseUp() {
    // if(this.state.draggingNode) setTimeout(() => this.updateValueDisplays(), 0);
    this.state.draggingNode = null;
    this.state.panning = false;
    document.body.style.cursor = "default";
  }
  handleBoardWrapMouseDown(e) {
    if (!e.target.closest(".node")) {
      this.state.panning = true;
      this.state.panStart = [e.clientX, e.clientY];
      document.body.style.cursor = "grabbing";
      this.selectNode(null);
    }
  }
  updateLinks() {
    while (this.svg.firstChild) this.svg.removeChild(this.svg.firstChild);
    const bRect = this.board.getBoundingClientRect();
    this.links.forEach(l => {
      const fromDot = this._getPinDot(l.from.node, l.from.pin, true);
      const toDot = this._getPinDot(l.to.node, l.to.pin, false);
      if (!fromDot || !toDot) return;
      const fRect = fromDot.getBoundingClientRect(),
        tRect = toDot.getBoundingClientRect();
      const x1 = fRect.left - bRect.left + 6,
        y1 = fRect.top - bRect.top + 6;
      const x2 = tRect.left - bRect.left + 6,
        y2 = tRect.top - bRect.top + 6;
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("class", "link " + (l.type === "value" ? "value" : ""));
      path.setAttribute("d", `M${x1},${y1} C${x1 + 50},${y1} ${x2 - 50},${y2} ${x2},${y2}`);
      this.svg.appendChild(path);
    });
  }
  runGraph() {
    if ((0, _utils.byId)("graph-status").innerHTML == '🔴' || Object.values(this.nodes).length == 0) {
      // Dummy thoughts —> this is wrong.
      // Every data in DOMs is good to use like status flags or any others calls.
      if (_utils.mb) _utils.mb.show('FluxCodexVertex not ready yet...');
      return;
    }
    let getCurrentGIzmoObj = app.mainRenderBundle.filter(o => o.effects.gizmoEffect && o.effects.gizmoEffect.enabled);
    if (getCurrentGIzmoObj.length > 0) getCurrentGIzmoObj[0].effects.gizmoEffect.enabled = false;
    (0, _utils.byId)("app").style.opacity = 0.5;
    this.initEventNodes();
    Object.values(this.nodes).forEach(n => n._returnCache = undefined);
    Object.values(this.nodes).filter(n => n.category === "event" && n.title === "onLoad").forEach(n => this.triggerNode(n.id));
    (0, _utils.byId)("graph-status").innerHTML = '🔴';
  }
  compileGraph() {
    // this is save !!!
    const bundle = {
      nodes: this.nodes,
      links: this.links,
      nodeCounter: this.nodeCounter,
      linkCounter: this.linkCounter,
      pan: this.state.pan,
      variables: this.variables
    };
    function saveReplacer(key, value) {
      if (key === 'fn') return undefined;
      if (key === 'accessObject') return undefined;
      if (key === '_returnCache') return undefined;
      if (key === '_listenerAttached') return false;
      if (key === '_audio') return undefined;
      if (key === '_loading') return false;
      if (key === '_energyHistory') return undefined;
      if (key === '_beatCooldown') return 0;
      return value;
    }
    let d = JSON.stringify(bundle, saveReplacer);
    localStorage.setItem(this.SAVE_KEY, d);
    document.dispatchEvent(new CustomEvent('save-graph', {
      detail: d
    }));
    // this.log("Graph saved to LocalStorage and final script");
  }
  clearStorage() {
    let ask = confirm("⚠️ This will delete all nodes. Are you sure?");
    if (ask) {
      this.clearAllNodes();
      localStorage.removeItem(this.SAVE_KEY);
      this.compileGraph(); // not just save empty
      // location.reload(true);
    }
  }
  clearAllNodes() {
    // Remove node DOMs
    this.board.querySelectorAll(".node").forEach(n => n.remove());
    // Clear data
    this.nodes = [];
    this.nodes.length = 0;
    this.links.length = 0;
    // Clear state
    this.state.selectedNode = null;
    this.state.draggingNode = null;
    this.state.connectingPin = null;
    // Optional: redraw connections
    this.updateLinks();
  }
  _buildSaveBundle() {
    return {
      nodes: this.nodes,
      links: this.links,
      nodeCounter: this.nodeCounter,
      linkCounter: this.linkCounter,
      pan: this.state.pan,
      variables: this.variables,
      version: 1
    };
  }
  _loadFromBundle(data) {
    this.nodes = data.nodes || {};
    this.links = data.links || {};
    this.nodeCounter = data.nodeCounter || 0;
    this.linkCounter = data.linkCounter || 0;
    this.state.pan = data.pan || {
      x: 0,
      y: 0
    };
    this.variables = data.variables || {
      number: {},
      boolean: {},
      string: {}
    };

    // refresh UI
    this._refreshVarsList(this._varsPopup.children[1]);
    this.loadFromImport();
    this.log("Graph imported from JSON");
  }
  exportToJSON() {
    const bundle = this._buildSaveBundle();
    console.log(bundle);
    function saveReplacer(key, value) {
      if (key === 'fn') return undefined;
      if (key === 'accessObject') return undefined;
      if (key === '_returnCache') return undefined;
      if (key === '_listenerAttached') return false;
      return value;
    }
    const json = JSON.stringify(bundle, saveReplacer);
    const blob = new Blob([json], {
      type: "application/json"
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "fluxcodex-graph.json";
    a.click();
    URL.revokeObjectURL(url);
    this.log("Graph exported as JSON");
  }
  _createImportInput() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json";
    input.style.display = "none";
    input.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          this._loadFromBundle(data);
        } catch (err) {
          console.error("Invalid JSON file", err);
        }
      };
      reader.readAsText(file);
    };
    document.body.appendChild(input);
    this._importInput = input;
  }
  init() {
    const saved = localStorage.getItem(this.SAVE_KEY);
    if (saved || app.graph) {
      try {
        let data;
        try {
          if (app.graph) {
            data = app.graph;
          } else {
            console.warn("⚠️ Used cached data for graph, load from localstorage!");
            data = JSON.parse(saved);
          }
          if (data == null) {
            console.warn("⚠️ No file also no cache for graph, Editor faild to load!");
            return;
          }
        } catch (e) {
          console.warn("⚠️ No cache for graph, load from module!");
          data = app.graph;
        }
        if (data.variables) {
          this.variables = data.variables;
          this._refreshVarsList(this._varsPopup.children[1]);
        }
        this.nodes = data.nodes || {};
        this.links = data.links || [];
        this.nodeCounter = data.nodeCounter || 1;
        this.linkCounter = data.linkCounter || 1;
        this.state.pan = data.pan || [0, 0];
        this.board.style.transform = `translate(${this.state.pan[0]}px,${this.state.pan[1]}px)`;
        Object.values(this.nodes).forEach(spec => {
          const domEl = this.createNodeDOM(spec);
          this.board.appendChild(domEl);
          if (spec.category === "value" && spec.title !== "GenRandInt" || spec.category === "math" || spec.title === "Print") {
            spec.displayEl = domEl.querySelector(".value-display");
          }
          this.updateNodeDOM(spec.id);
        });
        this.updateLinks();
        this.restoreConnectionsRuntime();
        this.log("Loaded graph.");
        return;
      } catch (e) {
        console.error("Failed to load graph from storage:", e);
      }
    }
    this.addNode("event");
  }
  loadFromImport() {
    Object.values(this.nodes).forEach(spec => {
      const domEl = this.createNodeDOM(spec);
      this.board.appendChild(domEl);
      if (spec.category === "value" && spec.title !== "GenRandInt" || spec.category === "math" || spec.title === "Print") {
        spec.displayEl = domEl.querySelector(".value-display");
      }
      // Only function nodes get dynamic pins updated
      if (spec.category === "action" && spec.title === "Function") {
        this.updateNodeDOM(spec.id);
      }
    });
    this.updateLinks();
    this.updateValueDisplays();
    this.log("Restored graph.");
    this.compileGraph();
    return;
  }
  onNodeDoubleClick(node) {
    console.log(`%c Node [CURVE  func] ${node.curve}`, _utils.LOG_FUNNY_ARCADE);
    if (node.title !== "Curve") return;
    this.curveEditor.bindCurve(node.curve, {
      name: node.id,
      idNode: node.id
    });
    this.curveEditor.toggleEditor(true);
  }
  mergeGraphBundle(data) {
    if (!data || !data.nodes) return;
    const nodeOffset = this.nodeCounter;
    const linkOffset = this.linkCounter;
    const nodeIdMap = {};

    // 1. Map and Create Nodes
    Object.values(data.nodes).forEach(node => {
      const oldId = node.id;
      // Ensure we create a truly unique ID string
      const newId = "n" + this.nodeCounter++;
      nodeIdMap[oldId] = newId;
      const newNode = {
        ...node,
        id: newId,
        // Offset so they don't overlap existing nodes
        x: (node.x || 0) + 100,
        y: (node.y || 0) + 100
      };
      this.nodes[newId] = newNode;

      // Create DOM element
      const domEl = this.createNodeDOM(newNode);
      this.board.appendChild(domEl);
      if (newNode.category === "value" && newNode.title !== "GenRandInt" || newNode.category === "math" || newNode.title === "Print") {
        newNode.displayEl = domEl.querySelector(".value-display");
      }
    });

    // 2. Map and Create Links
    if (Array.isArray(data.links)) {
      data.links.forEach(link => {
        const newLinkId = "l" + this.linkCounter++;
        const newLink = {
          ...link,
          id: newLinkId,
          from: {
            ...link.from,
            node: nodeIdMap[link.from.node]
          },
          to: {
            ...link.to,
            node: nodeIdMap[link.to.node]
          }
        };

        // Only add link if BOTH nodes were successfully remapped
        if (this.nodes[newLink.from.node] && this.nodes[newLink.to.node]) {
          this.links.push(newLink);
        }
      });
    }

    // 3. Critical UI Refresh Sequence
    // First, update the DOM positions for the new nodes
    Object.keys(nodeIdMap).forEach(oldId => {
      this.updateNodeDOM(nodeIdMap[oldId]);
    });

    // Second, tell the engine to draw the lines
    this.updateLinks();

    // Third, if your engine requires runtime binding (like events/logic)
    if (this.restoreConnectionsRuntime) {
      this.restoreConnectionsRuntime();
    }
    this.log(`Merged ${Object.keys(nodeIdMap).length} nodes with links.`);
    this.compileGraph(); // Save to LocalStorage
  }
}
exports.default = FluxCodexVertex;

},{"../../engine/utils":56,"./curve-editor":87,"./generateAISchema.js":93}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.catalogToText = catalogToText;
exports.generateAICatalog = generateAICatalog;
exports.generateAISchema = generateAISchema;
exports.tasks = exports.providers = void 0;
function generateAISchema(nodeFactories) {
  const schema = {
    nodes: {},
    links: [],
    nodeCounter: 1,
    linkCounter: 1,
    pan: [0, 0],
    variables: {
      number: {},
      boolean: {},
      string: {},
      object: {}
    }
  };
  for (const type in nodeFactories) {
    let spec = null;

    // Simulate your post-factory options handling
    if (type === 'dynamicFunction') {
      spec = {
        ...nodeFactories[type]("node_" + schema.nodeCounter, 0, 0, {
          accessObject: "USER_INPUT"
        })
      };
      if (spec.fields) spec.fields.forEach(f => f.value = f.value ?? "USER_INPUT");
    } else if (type === 'audioMP3') {
      spec = nodeFactories[type]("node_" + schema.nodeCounter, 0, 0, {
        name: "audioName",
        path: "audioPath.mp3"
      });
      if (spec.fields) spec.fields.forEach(f => {
        if (f.key === 'key') f.value = "audioName";
        if (f.key === 'src') f.value = "audioPath.mp3";
      });
    } else {
      spec = nodeFactories[type]("node_" + schema.nodeCounter, 0, 0);
      if (spec.fields) spec.fields.forEach(f => f.value = f.value ?? null);
    }

    // Save-ready format
    schema.nodes["node_" + schema.nodeCounter] = {
      id: "node_" + schema.nodeCounter,
      title: spec.title,
      x: spec.x,
      y: spec.y,
      category: spec.category,
      inputs: spec.inputs ?? [],
      outputs: spec.outputs ?? [],
      fields: spec.fields?.map(f => ({
        key: f.key,
        value: f.value
      })) ?? [],
      builtIn: spec.builtIn ?? false,
      noselfExec: spec.noselfExec ?? false,
      displayEl: {}
    };
    schema.nodeCounter++;
  }
  return schema;
}
function generateAICatalog(factoryNodes) {
  const catalog = {};
  for (const [type, factory] of Object.entries(factoryNodes)) {
    let spec;
    try {
      // Call factory in a SAFE dummy way
      spec = factory("__ai__", 0, 0, {});
    } catch (e) {
      console.warn(`Factory ${type} skipped (needs special args)`);
      continue;
    }
    catalog[type] = {
      title: spec.title,
      category: spec.category,
      inputs: (spec.inputs || []).map(i => ({
        name: i.name,
        type: i.type
      })),
      outputs: (spec.outputs || []).map(o => ({
        name: o.name,
        type: o.type
      })),
      fields: (spec.fields || []).map(f => ({
        key: f.key,
        type: typeof f.value
      })),
      noselfExec: !!spec.noselfExec,
      builtIn: !!spec.builtIn
    };
  }
  return catalog;
}
function catalogToText(catalog) {
  let out = "NODE CATALOG:\n\n";
  for (const [name, n] of Object.entries(catalog)) {
    out += `Node: ${name}\n`;
    out += `Category: ${n.category}\n`;
    if (n.inputs.length) {
      out += "Inputs:\n";
      for (const i of n.inputs) out += `- ${i.name} : ${i.type}\n`;
    }
    if (n.outputs.length) {
      out += "Outputs:\n";
      for (const o of n.outputs) out += `- ${o.name} : ${o.type}\n`;
    }
    if (n.fields.length) {
      out += "Fields:\n";
      for (const f of n.fields) out += `- ${f.key} : ${f.type}\n`;
    }
    if (n.noselfExec) out += "noselfExec: true\n";
    out += "\n";
  }
  return out;
}
let tasks = exports.tasks = ["On load print hello world", "On load create a cube named box1 at position 0 0 0", "Create a the labyrinth using generatorWall", "Set texture for floor object", "Create a cube and enable raycast", "Create 5 cubes in a row with spacing", "Create a pyramid of cubes with 4 levels", "Play mp3 audio on load", "Create audio reactive node from music", "Print beat value when detected", "Rotate box1 slowly on Y axis every frame", "Move box1 forward on Z axis over time", "Oscillate box1 Y position between 0 and 2", "Change box1 rotation using sine wave", "On ray hit print hit object name", "Apply force to hit object in ray direction", "Change texture of object when clicked new texture rust metal", "Generate random number and print it", "Set variable score to 0", "Increase score by 1 on object hit, Print score value", "Dispatch custom event named GAME_START", "After 2 seconds create a new cube", "Animate cube position using curve timeline", "Enable vertex wave animation on floor"];
let providers = exports.providers = ["ollama", "groq"];

},{}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = require("../../engine/utils.js");
var _flexCodexShader = require("./flexCodexShader.js");
/**
 * @Author NIkola Lukic
 * @description
 * Web Editor for matrix-engine-wgpu
 * Using "file protocol" in direct way no virtual/syntetic assets
 */
class EditorHud {
  constructor(core, a, toolTip) {
    this.core = core;
    this.sceneContainer = null;
    this.FS = new _utils.FullscreenManager();
    this.toolTip = toolTip;
    if (a == 'infly') {
      this.createTopMenuInFly();
    } else if (a == "created from editor") {
      this.createTopMenu();
      this.createAssets();
      this.createGizmoIcons();
    } else if (a == "pre editor") {
      this.createTopMenuPre();
    } else {
      throw console.error('Editor err');
    }
    this.createEditorSceneContainer();
    this.createScenePropertyBox();
    this.currentProperties = [];
    document.addEventListener('editor-not-running', () => {
      this.noEditorConn();
    });
    document.addEventListener('file-detail-data', e => {
      console.log(e.detail.details);
      let getPATH = e.detail.details.path.split("public")[1];
      const ext = getPATH.split('.').pop();
      if (ext == 'glb' && confirm("GLB FILE 📦 Do you wanna add it to the scene ?")) {
        // let name = prompt("📦 GLB file : ", getPATH);
        // instanced is standard - top level sceneobj CLASS ...
        let objName = prompt(`Path: ${getPATH} \n 📦 Enter Uniq Name: `);
        if (confirm("⚛ Enable physics (Ammo)?")) {
          // infly
          let o = {
            physics: true,
            path: getPATH,
            index: objName
          };
          document.dispatchEvent(new CustomEvent('web.editor.addGlb', {
            detail: o
          }));
        } else {
          // infly
          let o = {
            physics: false,
            path: getPATH,
            index: objName
          };
          document.dispatchEvent(new CustomEvent('web.editor.addGlb', {
            detail: o
          }));
        }
      } else if (ext == 'obj' && confirm("OBJ FILE 📦 Do you wanna add it to the scene ?")) {
        let objName = prompt("📦 Enter uniq name: ");
        if (confirm("⚛ Enable physics (Ammo)?")) {
          // infly 
          let o = {
            physics: true,
            path: getPATH,
            index: objName
          };
          document.dispatchEvent(new CustomEvent('web.editor.addObj', {
            detail: o
          }));
        } else {
          // infly
          let o = {
            physics: false,
            path: getPATH,
            index: objName
          };
          document.dispatchEvent(new CustomEvent('web.editor.addObj', {
            detail: o
          }));
        }
      } else if (ext == 'mp3' && confirm("MP3 FILE 📦 Do you wanna add it to the scene ?")) {
        let objName = prompt("📦 Enter uniq name: ");
        // infly
        let o = {
          path: getPATH,
          name: objName
        };
        document.dispatchEvent(new CustomEvent('web.editor.addMp3', {
          detail: o
        }));
      } else {
        let s = "";
        for (let key in e.detail.details) {
          if (key == "path") {
            s += key + ":" + e.detail.details[key].split("public")[1] + "\n";
          } else {
            s += key + ":" + e.detail.details[key] + "\n";
          }
        }
        _utils.mb.show(s);
      }
    });
  }
  noEditorConn() {
    this.errorForm = document.createElement("div");
    this.errorForm.id = "errorForm";
    Object.assign(this.errorForm.style, {
      position: "absolute",
      top: "20%",
      left: "25%",
      width: "50%",
      height: "30vh",
      backgroundColor: "rgba(0,0,0,0.85)",
      display: "flex",
      color: "white",
      fontFamily: "'Orbitron', sans-serif",
      zIndex: "15",
      padding: "2px",
      boxSizing: "border-box",
      flexDirection: "column",
      justifyContent: 'center',
      alignItems: 'center'
    });
    this.errorForm.innerHTML = `
       <h1 class='fancy-label' style="font-size: 24px;" >No connection with editor node app.</h1>
       <h3 class='fancy-label'>Run from root [npm run editorx] \n 
          or run from ./src/tools/editor/backend [npm run editorx] \n
          Than refresh page [clear default cache browser with CTRL+F5] </h3>
    `;
    document.body.appendChild(this.errorForm);
  }
  createTopMenu() {
    this.editorMenu = document.createElement("div");
    this.editorMenu.id = "editorMenu";
    Object.assign(this.editorMenu.style, {
      position: "absolute",
      top: "0",
      left: "30%",
      width: "60%",
      height: "50px;",
      backgroundColor: "rgba(0,0,0,0.85)",
      display: "flex",
      alignItems: "start",
      // overflow: "auto",
      color: "white",
      fontFamily: "'Orbitron', sans-serif",
      zIndex: "15",
      padding: "2px",
      boxSizing: "border-box",
      flexDirection: "row"
    });
    this.editorMenu.innerHTML = " PROJECT MENU  ";
    this.editorMenu.innerHTML = `
    <div class="top-item">
      <div class="top-btn">Project ▾</div>
      <div class="dropdown">
      <div id="start-watch" class="drop-item">🛠️ Watch</div>
      <div id="stop-watch" class="drop-item">🛠️ Stop Watch</div>
      <div id="start-refresh" class="drop-item">🛠️ Refresh</div>
      <!--div id="start-prod-build" class="drop-item">🛠️ Build for production</div-->
      </div>
    </div>

    <div class="top-item">
      <div class="top-btn">Insert ▾</div>
      <div class="dropdown">
        <div id="addCube" class="drop-item">🧊Cube</div>
        <div id="addCubePhysics" class="drop-item">🧊Cube with Physics</div>
        <div id="addSphere" class="drop-item">⚪Sphere</div>
        <div id="addSpherePhysics" class="drop-item">⚪Sphere with Physics</div>
        <small>Glb and Obj files add direct from asset (by selecting)</small>
        <!--div class="drop-item">💡 Light</div-->
      </div>
    </div>

    <div class="top-item">
      <div class="top-btn">AI tools ▾</div>
      <div class="dropdown">
        <div id="showAITools" class="drop-item">⚪ AI graph generator</div>
      </div>
    </div>
    
    <div class="top-item">
      <div class="top-btn">Script ▾</div>
      <div class="dropdown">
        <div id="showVisualCodeEditorBtn" class="drop-item btn4">
           <span>Visual Scripting</span>
           <small>⌨️FluxCodexVertex</small>
           <small>⌨️Press F6 for run</small>
        </div>
        <div id="showCodeVARSBtn" class="drop-item btn4">
           <span>Variable editor</span>
           <small>🔧Visual Script tool</small>
        </div>
        <div id="showCodeEditorBtn" class="drop-item btn4">
           <span>Show code editor</span>
           <small>👩‍💻Function raw edit</small>
           <small>Custom Functions</small>
        </div>
        <div id="showCurveEditorBtn" class="drop-item btn4">
           <span>Show curve editor</span>
           <small>📈Timeline curve editor</small>
           <small> </small>
        </div>
        <div id="showShaderEditorBtn" class="drop-item btn4">
           <span>Show shader editor</span>
           <small>Shader editor</small>
           <small> </small>
        </div>
      </div>
    </div>

    <div class="top-item">
      <div class="top-btn">View ▾</div>
      <div class="dropdown">
        <div id="hideEditorBtn" class="drop-item">
           <h4>Hide Editor UI</h4>
           <small>Show editor - press F4 ⌨️</small>
        </div>
        <div id="bg-transparent" class="drop-item">
           <h4>Background transparent</h4>
           <small>Fancy style</small>
        </div>
        <div id="bg-tradicional" class="drop-item">
           <h4>Background tradicional</h4>
           <small>Old school</small>
        </div>
        <div id="fullScreenBtn" class="drop-item">
         <span>FullScreen</span>
         <small>Exit - press F11 ⌨️</small>
        </div>
      </div>
    </div>

    <div class="top-item">
      <div class="top-btn">About ▾</div>
      <div class="dropdown">
        <div id="showAboutEditor" class="drop-item">matrix-engine-wgpu</div>
        <div class="drop-item">Raport issuse on <a href="https://github.com/zlatnaspirala/matrix-engine-wgpu/issues">Github</a></div>
      </div>
    </div>

    <div class="btn2">
      <button class="btn" id="saveMainGraphDOM">SAVE GRAPH</button>
      <button class="btn" id="runMainGraphDOM">RUN [F6]</button>
      <button class="btn" id="stopMainGraphDOM">STOP</button>
      <span id="graph-status">⚫</span>
    </div>
  `;
    document.body.appendChild(this.editorMenu);

    // Mobile friendly toggles
    this.editorMenu.querySelectorAll(".top-btn").forEach(btn => {
      btn.addEventListener("click", e => {
        const menu = e.target.nextElementSibling;

        // close others
        this.editorMenu.querySelectorAll(".dropdown").forEach(d => {
          if (d !== menu) d.style.display = "none";
        });

        // toggle
        menu.style.display = menu.style.display === "block" ? "none" : "block";
      });
    });
    (0, _utils.byId)('saveMainGraphDOM').addEventListener('click', () => {
      app.editor.fluxCodexVertex.compileGraph();
    });
    (0, _utils.byId)('runMainGraphDOM').addEventListener('click', () => {
      app.editor.fluxCodexVertex.runGraph();
    });
    this.toolTip.attachTooltip((0, _utils.byId)('saveMainGraphDOM'), "Any changes in graph must be saved.");
    this.toolTip.attachTooltip((0, _utils.byId)('runMainGraphDOM'), "Run main graph, sometimes engine need refresh.");
    this.toolTip.attachTooltip((0, _utils.byId)('stopMainGraphDOM'), "Stop main graph, clear dynamic created objects.");
    (0, _utils.byId)('stopMainGraphDOM').addEventListener('click', () => {
      // global for now.
      app.editor.fluxCodexVertex.clearRuntime();
    });

    // Close on outside tap
    document.addEventListener("click", e => {
      if (!this.editorMenu.contains(e.target)) {
        this.editorMenu.querySelectorAll(".dropdown").forEach(d => {
          d.style.display = "none";
        });
      }
    });
    (0, _utils.byId)('fullScreenBtn').addEventListener('click', () => {
      this.FS.request();
    });
    this.toolTip.attachTooltip((0, _utils.byId)('fullScreenBtn'), "Just editor gui part for fullscreen - not fullscreen for real program.");
    (0, _utils.byId)('showAITools').addEventListener('click', () => {
      (0, _utils.byId)('aiPopup').style.display = 'flex';
    });
    this.toolTip.attachTooltip((0, _utils.byId)('showAITools'), "Experimental stage, MEWGPU use open source ollama platform. Possible to create less complex - assets data not yet involment...");
    (0, _utils.byId)('hideEditorBtn').addEventListener('click', () => {
      this.editorMenu.style.display = 'none';
      this.assetsBox.style.display = 'none';
      this.sceneProperty.style.display = 'none';
      this.sceneContainer.style.display = 'none';
      (0, _utils.byId)('app').style.display = 'none';
    });
    (0, _utils.byId)('bg-transparent').addEventListener('click', () => {
      (0, _utils.byId)('boardWrap').style.backgroundImage = 'none';
    });
    this.toolTip.attachTooltip((0, _utils.byId)('bg-transparent'), "Make visible both (mix) graphs and render.");
    (0, _utils.byId)('bg-tradicional').addEventListener('click', () => {
      // byId('boardWrap').style.backgroundImage = 'url("res/icons/editor/chatgpt-gen-bg.png")';
      (0, _utils.byId)('boardWrap').style.backgroundImage = '';
    });
    this.toolTip.attachTooltip((0, _utils.byId)('bg-tradicional'), "Make visible graphs layout only.");
    if ((0, _utils.byId)('stop-watch')) (0, _utils.byId)('stop-watch').addEventListener('click', () => {
      document.dispatchEvent(new CustomEvent('stop-watch', {
        detail: {}
      }));
    });
    this.toolTip.attachTooltip((0, _utils.byId)('stop-watch'), "Stops JavaScript compilers. Use this when working with Git, for example, to avoid unnecessary builds.");
    if ((0, _utils.byId)('start-watch')) (0, _utils.byId)('start-watch').addEventListener('click', () => {
      document.dispatchEvent(new CustomEvent('start-watch', {
        detail: {}
      }));
    });
    this.toolTip.attachTooltip((0, _utils.byId)('start-watch'), "Start watch builds for JavaScript compilers.No need at start up - watcher already started on backend of editor.");
    if ((0, _utils.byId)('cnpBtn')) (0, _utils.byId)('cnpBtn').addEventListener('click', () => {
      let name = prompt("📦 Project name :", "MyProject1");
      let features = {
        physics: false,
        networking: false
      };
      if (confirm("⚛ Enable physics (Ammo)?")) {
        features.physics = true;
      }
      if (confirm("🔌 Enable networking (kurento/ov)?")) {
        features.networking = true;
      }
      console.log(features);
      document.dispatchEvent(new CustomEvent('cnp', {
        detail: {
          name: name,
          features: features
        }
      }));
    });
    if ((0, _utils.byId)('cnpBtn')) this.toolTip.attachTooltip((0, _utils.byId)('cnpBtn'), "Create new project. You must input project name.");
    (0, _utils.byId)('start-refresh').onclick = () => {
      location.reload(true);
    };
    if ((0, _utils.byId)('start-refresh')) this.toolTip.attachTooltip((0, _utils.byId)('start-refresh'), "Simple refresh page.");

    // byId('start-prod-build').onclick = () => {
    //   //
    //   console.log('.......start-prod-build.......');
    //   console.log('................................')

    // };

    // OBJECT LEVEL
    if ((0, _utils.byId)('addCube')) (0, _utils.byId)('addCube').addEventListener('click', () => {
      let objName = prompt("📦 Enter uniq name: ");
      let o = {
        physics: false,
        index: objName
      };
      document.dispatchEvent(new CustomEvent('web.editor.addCube', {
        detail: o
      }));
    });
    if ((0, _utils.byId)('addCube')) this.toolTip.attachTooltip((0, _utils.byId)('addCube'), "Create Cube scene object with no physics.If you wanna objects who will be in kinematic also in physics regime (switching) then you need to use CubePhysics.");
    if ((0, _utils.byId)('addSphere')) (0, _utils.byId)('addSphere').addEventListener('click', () => {
      let objName = prompt("📦 Enter uniq name: ");
      let o = {
        physics: false,
        index: objName
      };
      document.dispatchEvent(new CustomEvent('web.editor.addSphere', {
        detail: o
      }));
    });
    if ((0, _utils.byId)('addCubePhysics')) (0, _utils.byId)('addCubePhysics').addEventListener('click', () => {
      let objName = prompt("📦 Enter uniq name: ");
      let o = {
        physics: true,
        index: objName
      };
      document.dispatchEvent(new CustomEvent('web.editor.addCube', {
        detail: o
      }));
    });
    if ((0, _utils.byId)('addSpherePhysics')) (0, _utils.byId)('addSpherePhysics').addEventListener('click', () => {
      let objName = prompt("📦 Enter uniq name: ");
      let o = {
        physics: true,
        index: objName
      };
      document.dispatchEvent(new CustomEvent('web.editor.addSphere', {
        detail: o
      }));
    });

    // // settings
    // setTimeout(() => {
    //   this.core.cameras.WASD.pitch = byId('camera-settings-pitch').value;
    //   this.core.cameras.WASD.yaw = byId('camera-settings-yaw').value;
    // }, 1500);
    //     <!--div id="cameraBox" class="drop-item">
    //    <p>📽️Camera</p>
    //    <div>Pitch: <input id="camera-settings-pitch" step='0.1' type='number' value='0' /></div>
    //    <div>Yaw: <input id="camera-settings-yaw" step='0.1' type='number' value='0' /></div>
    //    <!--div> Position :  </br>
    //     \n 
    //     X: <input id="camera-settings-pos-x" step='0.5' type='number' value='0' /> \n
    //     Y: <input id="camera-settings-pos-y" step='0.5' type='number' value='0' /> \n
    //     Z: <input id="camera-settings-pos-z" step='0.5' type='number' value='0' />
    //    </div-->
    // </div-->
    // byId('camera-settings-pitch').addEventListener('change', (e) => {
    //   console.log('setting camera pitch ', e);
    //   this.core.cameras.WASD.pitch = e.target.value;
    // })
    // byId('camera-settings-yaw').addEventListener('change', (e) => {
    //   console.log('setting camera', e)
    //   this.core.cameras.WASD.yaw = e.target.value;
    // })

    (0, _utils.byId)('showCodeEditorBtn').addEventListener('click', e => {
      document.dispatchEvent(new CustomEvent('show-method-editor', {
        detail: {}
      }));
    });
    (0, _utils.byId)('showCurveEditorBtn').addEventListener('click', e => {
      document.dispatchEvent(new CustomEvent('show-curve-editor', {
        detail: {}
      }));
    });
    (0, _utils.byId)('showShaderEditorBtn').addEventListener('click', e => {
      if ((0, _utils.byId)('app').style.display == 'flex') {
        (0, _utils.byId)('app').style.display = 'none';
      }
      if ((0, _utils.byId)('shaderDOM') === null) {
        (0, _flexCodexShader.openFragmentShaderEditor)().then(e => {
          app.shaderGraph = e;
        });
      } else if ((0, _utils.byId)('shaderDOM').style.display === 'flex') {
        (0, _utils.byId)('shaderDOM').style.display = 'none';
      } else {
        (0, _utils.byId)('shaderDOM').style.display = 'flex';
      }
    });
    (0, _utils.byId)('showVisualCodeEditorBtn').addEventListener('click', e => {
      if ((0, _utils.byId)('shaderDOM') && (0, _utils.byId)('shaderDOM').style.display == 'flex') {
        (0, _utils.byId)('shaderDOM').style.display = 'none';
      }
      if ((0, _utils.byId)('app').style.display == 'flex') {
        (0, _utils.byId)('app').style.display = 'none';
      } else {
        (0, _utils.byId)('app').style.display = 'flex';
        if (this.core.editor.fluxCodexVertex) this.core.editor.fluxCodexVertex.updateLinks();
      }
    });
    (0, _utils.byId)('showCodeVARSBtn').addEventListener('click', e => {
      (0, _utils.byId)('app').style.display = 'flex';
      (0, _utils.byId)('varsPopup').style.display = 'flex';
      this.core.editor.fluxCodexVertex.updateLinks();
      // document.dispatchEvent(new CustomEvent('show-method-editor', {detail: {}}));
    });
    document.addEventListener('updateSceneContainer', e => {
      this.updateSceneContainer();
    });
    this.showAboutModal = () => {
      alert(`
  ✔️ Support for 3D objects and scene transformations
  ✔️ Ammo.js physics integration
  ✔️ Networking with Kurento/OpenVidu/Own middleware Nodejs -> frontend
  ✔️ Event system
  🎯 Save system - direct code line [file-protocol]
  🎯 Adding Visual Scripting System called 
     FlowCodexVertex (deactivete from top menu)(activate on pressing F4 key)
  🎯 Adding Visual Scripting graph for shaders - FlowCodexShader.
     Source code: https://github.com/zlatnaspirala/matrix-engine-wgpu
     More at https://maximumroulette.com
        `);
    };
    (0, _utils.byId)('showAboutEditor').addEventListener('click', this.showAboutModal);
  }
  createGizmoIcons() {
    this.gizmoBox = document.createElement("div");
    this.assetsBox.id = "gizmoBox";
    Object.assign(this.gizmoBox.style, {
      position: "absolute",
      top: "0",
      left: "17.55%",
      width: "190px",
      height: "64px",
      backgroundColor: "transparent",
      display: "flex",
      alignItems: "start",
      color: "white",
      zIndex: "10",
      padding: "2px",
      boxSizing: "border-box",
      flexDirection: "row"
    });
    this.gizmoBox.innerHTML = `
    <div>
    <img id="mode0" data-mode="0" class="gizmo-icon" src="./res/textures/editor/0.png" width="48px" height="48px"/>
    <img id="mode1" data-mode="1" class="gizmo-icon" src="./res/textures/editor/1.png" width="48px" height="48px"/>
    <img id="mode2" data-mode="2" class="gizmo-icon" src="./res/textures/editor/2.png" width="48px" height="48px"/>
    </div>
    `;
    document.body.appendChild(this.gizmoBox);
    if (!document.getElementById('gizmo-style')) {
      const style = document.createElement('style');
      style.id = 'gizmo-style';
      style.innerHTML = `
            .gizmo-icon {
                cursor: pointer;
                transition: all 0.2s ease-in-out;
                border-radius: 4px;
                padding: 4px;
            }
            /* Hover State */
            .gizmo-icon:hover {
                background-color: rgba(255, 255, 255, 0.15);
                transform: scale(1.1);
                filter: brightness(1.2);
            }
            /* Active/Click State */
            .gizmo-icon:active {
                transform: scale(0.95);
                background-color: rgba(255, 255, 255, 0.3);
            }
        `;
      document.head.appendChild(style);
    }
    const setMode = e => {
      let m = parseInt(e.target.getAttribute("data-mode"));
      dispatchEvent(new CustomEvent('editor-set-gizmo-mode', {
        detail: {
          mode: m
        }
      }));
      if (m == 0) {
        (0, _utils.byId)('mode0').style.border = 'gray 1px solid';
        (0, _utils.byId)('mode1').style.border = 'none';
        (0, _utils.byId)('mode2').style.border = 'none';
      } else if (m == 1) {
        (0, _utils.byId)('mode0').style.border = 'none';
        (0, _utils.byId)('mode1').style.border = 'gray 1px solid';
        (0, _utils.byId)('mode2').style.border = 'none';
      } else if (m == 2) {
        (0, _utils.byId)('mode0').style.border = 'none';
        (0, _utils.byId)('mode1').style.border = 'none';
        (0, _utils.byId)('mode2').style.border = 'gray 1px solid';
      }
    };
    ['mode0', 'mode1', 'mode2'].forEach(id => {
      (0, _utils.byId)(id).addEventListener("pointerdown", setMode);
    });
    this.toolTip.attachTooltip((0, _utils.byId)('mode0'), `Set gizmo mode to 'translate'.\n`);
    this.toolTip.attachTooltip((0, _utils.byId)('mode1'), `Set gizmo mode to 'rotate'.\n`);
    this.toolTip.attachTooltip((0, _utils.byId)('mode2'), `Set gizmo mode to 'scale'.\n`);
  }
  createAssets() {
    this.assetsBox = document.createElement("div");
    this.assetsBox.id = "assetsBox";
    Object.assign(this.assetsBox.style, {
      position: "absolute",
      bottom: "0",
      left: "17.55%",
      width: "63%",
      height: "250px",
      backgroundColor: "rgba(0,0,0,0.85)",
      display: "flex",
      alignItems: "start",
      color: "white",
      fontFamily: "'Orbitron', sans-serif",
      zIndex: "15",
      padding: "2px",
      boxSizing: "border-box",
      flexDirection: "column"
    });
    this.assetsBox.innerHTML = "ASSTES";
    this.assetsBox.innerHTML = `
    <div id="folderTitle" >Root</div>
    <div id="folderBack" class="scenePropItem" >...</div>
    <div id='res-folder' class="file-browser">
    </div>`;
    document.body.appendChild(this.assetsBox);
    (0, _utils.byId)('folderBack').addEventListener('click', () => {
      let getCurrent = (0, _utils.byId)('res-folder').getAttribute('data-root-folder');
      const t = getCurrent.substring(0, getCurrent.lastIndexOf("\\"));
      const last = t.substring(t.lastIndexOf("\\") + 1);
      if (last == "public") {
        // console.log(last + "<PREVENTED>");
        return;
      }
      document.dispatchEvent(new CustomEvent("nav-folder", {
        detail: {
          rootFolder: t || "",
          name: ''
        }
      }));
    });
    this.toolTip.attachTooltip((0, _utils.byId)('folderTitle'), `This represent real folders files present intro res folder (what ever is there).\n
    From assets box you can add glb or obj files direct with simple click. Everyting will be saved automatic.\n
    Support for mp3 adding by click also. No support for mp4 - mp4 can be added from 'Set Textures' node.
    `);
    // folderTitle
    document.addEventListener('la', e => {
      console.log(`%c[Editor]Root Resource Folder: ${e.detail.rootFolder}`, _utils.LOG_FUNNY_ARCADE);
      (0, _utils.byId)('res-folder').setAttribute('data-root-folder', e.detail.rootFolder);
      (0, _utils.byId)('res-folder').innerHTML = '';
      e.detail.payload.forEach(i => {
        let item = document.createElement('div');
        item.classList.add('file-item');
        if (i.isDir == true) {
          item.classList.add('folder');
        } else if (i.name.split('.')[1] == 'jpg' || i.name.split('.')[1] == 'png' || i.name.split('.')[1] == 'jpeg') {
          item.classList.add('png');
        } else if (i.name.split('.')[1] == 'mp3') {
          item.classList.add('mp3');
        } else if (i.name.split('.')[1] == 'js') {
          item.classList.add('js');
        } else if (i.name.split('.')[1] == 'ttf' || i.name.split('.')[1] == 'ttf' || i.name.split('.')[1] == 'TTF' || i.name.split('.')[1] == 'otf' || i.name.split('.')[1] == 'woff' || i.name.split('.')[1] == 'woff2') {
          item.classList.add('ttf');
        } else if (i.name.split('.')[1] == 'glb') {
          item.classList.add('glb');
        } else {
          item.classList.add('unknown');
        }
        item.innerHTML = "<p>" + i.name + "</p>";
        (0, _utils.byId)('res-folder').appendChild(item);
        item.addEventListener('click', e => {
          if (i.isDir == true) document.dispatchEvent(new CustomEvent("nav-folder", {
            detail: {
              rootFolder: (0, _utils.byId)('res-folder').getAttribute('data-root-folder') || "",
              name: item.children[0].innerText
            }
          }));
          if (i.isDir == false) document.dispatchEvent(new CustomEvent("file-detail", {
            detail: {
              rootFolder: (0, _utils.byId)('res-folder').getAttribute('data-root-folder') || "",
              name: item.innerText
            }
          }));
        });
      });
      document.querySelectorAll('.file-item').forEach(el => {
        el.addEventListener('click', () => {
          document.querySelectorAll('.file-item').forEach(x => x.classList.remove('selected'));
          el.classList.add('selected');
        });
      });
    });
  }
  createTopMenuPre() {
    this.editorMenu = document.createElement("div");
    this.editorMenu.id = "editorMenu";
    Object.assign(this.editorMenu.style, {
      position: "absolute",
      top: "0",
      left: "20%",
      width: "60%",
      height: "50px;",
      backgroundColor: "rgba(0,0,0,0.85)",
      display: "flex",
      alignItems: "start",
      color: "white",
      fontFamily: "'Orbitron', sans-serif",
      zIndex: "15",
      padding: "2px",
      boxSizing: "border-box",
      flexDirection: "row"
    });
    this.editorMenu.innerHTML = " PROJECT MENU  ";
    this.editorMenu.innerHTML = `
    <div class="top-item">
      <div class="top-btn">Project ▾</div>
      <div class="dropdown">
      <div id="cnpBtn" class="drop-item">📦 Create new project</div>
      <div id="loadProjectBtn" class="drop-item">📂 Load</div>
      </div>
    </div>

    <div class="top-item">
      <div class="top-btn">About ▾</div>
      <div class="dropdown">
        <div id="showAboutEditor" class="drop-item">matrix-engine-wgpu</div>
      </div>
    </div>
  `;
    document.body.appendChild(this.editorMenu);
    // Mobile friendly toggles
    this.editorMenu.querySelectorAll(".top-btn").forEach(btn => {
      btn.addEventListener("click", e => {
        const menu = e.target.nextElementSibling;
        // close others
        this.editorMenu.querySelectorAll(".dropdown").forEach(d => {
          if (d !== menu) d.style.display = "none";
        });
        menu.style.display = menu.style.display === "block" ? "none" : "block";
      });
    });

    // Close on outside tap
    document.addEventListener("click", e => {
      if (!this.editorMenu.contains(e.target)) {
        this.editorMenu.querySelectorAll(".dropdown").forEach(d => {
          d.style.display = "none";
        });
      }
    });
    if ((0, _utils.byId)('loadProjectBtn')) (0, _utils.byId)('loadProjectBtn').addEventListener('click', () => {
      document.dispatchEvent(new CustomEvent('lp', {
        detail: {}
      }));
    });
    if ((0, _utils.byId)('cnpBtn')) (0, _utils.byId)('cnpBtn').addEventListener('click', () => {
      let name = prompt("📦 Project name :", "MyProject1");
      let features = {
        physics: false,
        networking: false
      };
      if (confirm("⚛ Enable physics (Ammo)?")) {
        features.physics = true;
      }
      if (confirm("🔌 Enable networking (kurento/ov)?")) {
        features.networking = true;
      }
      console.log(features);
      document.dispatchEvent(new CustomEvent('cnp', {
        detail: {
          name: name,
          features: features
        }
      }));
    });
    this.showAboutModal = () => {
      alert(`
  ✔️ Support for 3D objects and scene transformations
  ✔️ Ammo.js physics integration
  ✔️ Networking with Kurento/OpenVidu/Own middleware Nodejs -> frontend
  ✔️ Event system
  🎯 Save system - direct code line [file-protocol]
  🎯 Adding Visual Scripting System called 
     FlowCodexVertex (deactivete from top menu)(activate on pressing F4 key)
     Source code: https://github.com/zlatnaspirala/matrix-engine-wgpu
     More at https://maximumroulette.com
        `);
    };
    (0, _utils.byId)('showAboutEditor').addEventListener('click', this.showAboutModal);
  }
  createTopMenuInFly() {
    this.editorMenu = document.createElement("div");
    this.editorMenu.id = "editorMenu";
    Object.assign(this.editorMenu.style, {
      position: "absolute",
      top: "0",
      left: "20%",
      width: "60%",
      height: "50px;",
      backgroundColor: "rgba(0,0,0,0.85)",
      display: "flex",
      alignItems: "start",
      color: "white",
      fontFamily: "'Orbitron', sans-serif",
      zIndex: "15",
      padding: "2px",
      boxSizing: "border-box",
      flexDirection: "row"
    });
    this.editorMenu.innerHTML = " PROJECT MENU ";
    this.editorMenu.innerHTML = `
    <div>INFLY Regime of work no saves. Nice for runtime debugging or get data for map setup.</div>
    <div class="top-item">
      <div class="top-btn">About ▾</div>
      <div class="dropdown">
        <div id="showAboutEditor" class="drop-item">matrix-engine-wgpu</div>
      </div>
    </div>
  `;
    document.body.appendChild(this.editorMenu);
    // Mobile friendly toggles
    this.editorMenu.querySelectorAll(".top-btn").forEach(btn => {
      btn.addEventListener("click", e => {
        const menu = e.target.nextElementSibling;
        // close others
        this.editorMenu.querySelectorAll(".dropdown").forEach(d => {
          if (d !== menu) d.style.display = "none";
        });
        menu.style.display = menu.style.display === "block" ? "none" : "block";
      });
    });

    // Close on outside tap
    document.addEventListener("click", e => {
      if (!this.editorMenu.contains(e.target)) {
        this.editorMenu.querySelectorAll(".dropdown").forEach(d => {
          d.style.display = "none";
        });
      }
    });
    this.showAboutModal = () => {
      alert(`
  ✔️ Support for 3D objects and scene transformations
  ✔️ Ammo.js physics integration
  ✔️ Networking with Kurento/OpenVidu/Own middleware Nodejs -> frontend
  ✔️ Event system
  🎯 Save system - direct code line [file-protocol]
     Adding Visual Scripting System called 
     flowCodexVertex (deactivete from top menu)(activate on pressing F4 key)
     Source code: https://github.com/zlatnaspirala/matrix-engine-wgpu
     More at https://maximumroulette.com
        `);
    };
    (0, _utils.byId)('showAboutEditor').addEventListener('click', this.showAboutModal);
  }
  createEditorSceneContainer() {
    this.sceneContainer = document.createElement("div");
    this.sceneContainer.id = "sceneContainer";
    Object.assign(this.sceneContainer.style, {
      position: "absolute",
      top: "0",
      left: "0",
      width: "17.5%",
      height: "100vh",
      backgroundColor: "rgb(75 75 75 / 85%)",
      display: "flex",
      alignItems: "start",
      overflow: "auto",
      color: "white",
      fontFamily: "'Orbitron', sans-serif",
      zIndex: "15",
      padding: "2px",
      boxSizing: "border-box",
      flexDirection: "column"
    });
    this.scene = document.createElement("div");
    this.scene.id = "scene";
    Object.assign(this.scene.style, {
      width: "100%",
      height: "100%",
      backgroundColor: "rgba(0,0,0,0.85)",
      display: "flex",
      alignItems: "start",
      color: "white",
      fontFamily: "'Orbitron', sans-serif",
      zIndex: "15",
      padding: "2px",
      boxSizing: "border-box",
      flexDirection: "column"
    });
    this.sceneContainerTitle = document.createElement("div");
    this.sceneContainerTitle.style.height = '30px';
    this.sceneContainerTitle.style.width = "-webkit-fill-available";
    this.sceneContainerTitle.style.fontSize = (0, _utils.isMobile)() == true ? "x-larger" : "larger";
    this.sceneContainerTitle.style.padding = '5px';
    this.sceneContainerTitle.innerHTML = 'Scene container';
    this.sceneContainer.appendChild(this.sceneContainerTitle);
    this.sceneContainer.appendChild(this.scene);
    document.body.appendChild(this.sceneContainer);
  }
  updateSceneContainer() {
    this.scene.innerHTML = ``;
    this.core.mainRenderBundle.forEach(sceneObj => {
      let so = document.createElement('div');
      so.style.height = '20px';
      so.classList.add('sceneContainerItem');
      so.innerHTML = sceneObj.name;
      so.addEventListener('click', this.updateSceneObjProperties);
      this.scene.appendChild(so);
    });
  }
  createScenePropertyBox() {
    this.sceneProperty = document.createElement("div");
    this.sceneProperty.id = "sceneProperty";
    this.sceneProperty.classList.add('scenePropItem');
    Object.assign(this.sceneProperty.style, {
      position: "absolute",
      top: "0",
      right: "0",
      width: "20%",
      height: "100vh",
      backgroundColor: "rgb(35 35 35 / 63%)",
      display: "flex",
      alignItems: "start",
      overflow: "auto",
      color: "white",
      fontFamily: "'Orbitron', sans-serif",
      zIndex: "15",
      padding: "2px",
      boxSizing: "border-box",
      flexDirection: "column"
    });
    this.objectProperies = document.createElement("div");
    this.objectProperies.id = "objectProperies";
    Object.assign(this.objectProperies.style, {
      width: "100%",
      height: "auto",
      backgroundColor: "rgba(0,0,0,0.85)",
      display: "flex",
      alignItems: "start",
      color: "white",
      fontFamily: 'monospace',
      zIndex: "15",
      padding: "2px",
      boxSizing: "border-box",
      flexDirection: "column"
    });
    this.objectProperiesTitle = document.createElement("div");
    this.objectProperiesTitle.style.height = '40px';
    this.objectProperiesTitle.style.fontSize = '120%';
    this.objectProperiesTitle.innerHTML = 'Scene object properties';
    this.sceneProperty.appendChild(this.objectProperiesTitle);
    this.sceneProperty.appendChild(this.objectProperies);
    document.body.appendChild(this.sceneProperty);
  }
  updateSceneObjProperties = e => {
    this.currentProperties = [];
    this.objectProperiesTitle.style.fontSize = '120%';
    this.objectProperiesTitle.innerHTML = `Scene object properties`;
    this.objectProperies.innerHTML = ``;
    const currentSO = this.core.getSceneObjectByName(e.target.innerHTML);
    this.objectProperiesTitle.innerHTML = `<span style="color:lime;">Name: ${e.target.innerHTML}</span> 
      <span style="color:yellow;"> [${currentSO.constructor.name}]`;
    const OK = Object.keys(currentSO);
    OK.forEach(prop => {
      // console.log('[key]:', prop);
      if (prop == 'glb' && typeof currentSO[prop] !== 'undefined' && currentSO[prop] != null) {
        this.currentProperties.push(new SceneObjectProperty(this.objectProperies, 'glb', currentSO, this.core));
      } else {
        this.currentProperties.push(new SceneObjectProperty(this.objectProperies, prop, currentSO, this.core));
      }
    });
    // Add editor events system
    this.currentProperties.push(new SceneObjectProperty(this.objectProperies, 'editor-events', currentSO, this.core));
    if (navigator.clipboard) {
      navigator.clipboard.writeText(currentSO.name);
    } else {
      document.execCommand("copy", true, currentSO.name);
    }
  };
  updateSceneObjPropertiesFromGizmo = name => {
    this.currentProperties = [];
    this.objectProperiesTitle.style.fontSize = '120%';
    this.objectProperiesTitle.innerHTML = `Scene object properties`;
    this.objectProperies.innerHTML = ``;
    const currentSO = this.core.getSceneObjectByName(name);
    this.objectProperiesTitle.innerHTML = `<span style="color:lime;">Name: ${name}</span> 
      <span style="color:yellow;"> [${currentSO.constructor.name}]`;
    const OK = Object.keys(currentSO);
    OK.forEach(prop => {
      // console.log('[key]:', prop);
      if (prop == 'glb' && typeof currentSO[prop] !== 'undefined' && currentSO[prop] != null) {
        this.currentProperties.push(new SceneObjectProperty(this.objectProperies, 'glb', currentSO, this.core));
      } else {
        this.currentProperties.push(new SceneObjectProperty(this.objectProperies, prop, currentSO, this.core));
      }
    });
    // Add editor events system
    this.currentProperties.push(new SceneObjectProperty(this.objectProperies, 'editor-events', currentSO, this.core));
  };
}
exports.default = EditorHud;
class SceneObjectProperty {
  constructor(parentDOM, propName, currSceneObj, core) {
    this.core = core;
    this.subObjectsProps = [];
    this.propName = document.createElement("div");
    this.propName.style.width = '100%';
    // console.log("init : " + propName)
    // Register
    if (propName == "device" || propName == "position" || propName == "rotation" || propName == "raycast" || propName == "entityArgPass" || propName == "scale" || propName == "maxInstances" || propName == "texturesPaths" || propName == "glb" || propName == "itIsPhysicsBody" || propName == "useScale") {
      this.propName.style.overflow = 'hidden';
      this.propName.style.height = '20px';
      this.propName.style.borderBottom = 'solid lime 2px';
      this.propName.addEventListener('click', e => {
        if (e.currentTarget.style.height != 'fit-content') {
          this.propName.style.overflow = 'unset';
          e.currentTarget.style.height = 'fit-content';
        } else {
          this.propName.style.overflow = 'hidden';
          e.currentTarget.style.height = '20px';
        }
      });
      if (propName == "itIsPhysicsBody") {
        this.propName.innerHTML = `<div style="text-align:left;" >${propName} <span style="border-radius:7px;background:green;">PhysicsBody</span>
        <span style="border-radius:6px;background:gray;">More info🔽</span></div>`;
      } else if (propName == "position" || propName == "scale" || propName == "rotation" || propName == "glb") {
        this.propName.innerHTML = `<div style="text-align:left;" >${propName} <span style="border-radius:7px;background:purple;">sceneObj</span>
        <span style="border-radius:6px;background:gray;">More info🔽</span></div>`;
      } else if (propName == "entityArgPass") {
        this.propName.innerHTML = `<div style="text-align:left;" >${propName} <span style="border-radius:7px;background:brown;">webGPU props</span>
        <span style="border-radius:6px;background:gray;">More info🔽</span></div>`;
      } else if (propName == "maxInstances") {
        this.propName.innerHTML = `<div style="text-align:left;" >${propName} <span style="border-radius:7px;background:brown;">instanced</span>
        <span style="border-radius:6px;background:gray;"> <input type="number" value="${currSceneObj[propName]}" /> </span></div>`;
      } else if (propName == "useScale") {
        this.propName.innerHTML = `<div style="display:flex;" >useScale  + ${this.readBool(currSceneObj, propName)} </div>`;
      } else if (propName == "texturesPaths") {
        this.propName.innerHTML = `<div style="text-align:left;" >${propName} <span style="border-radius:7px;background:purple;">sceneObj</span>
         <span style="border-radius:6px;background:gray;"> 
           Path: ${currSceneObj[propName]} 
         </span>
           <div style="text-align:center;padding:5px;margin:5px;"> <img src="${currSceneObj[propName]}" width="256px" height="auto" /> </div>
        </div>`;
      } else {
        this.propName.innerHTML = `<div style="text-align:left;" >${propName} <span style="border-radius:7px;background:red;">sys</span> 
        <span style="border-radius:6px;background:gray;">${currSceneObj[propName]}</span></div>`;
      }

      // console.log('[propName] ', propName);
      if (currSceneObj[propName] && typeof currSceneObj[propName].adapterInfo !== 'undefined') {
        this.exploreSubObject(currSceneObj[propName].adapterInfo, 'adapterInfo').forEach(item => {
          if (typeof item === 'string') {
            this.propName.innerHTML += `<div style="text-align:left;"> ${item.split(':'[1])} </div>`;
          } else {
            item.addEventListener('click', event => {
              event.stopPropagation();
            });
            this.propName.appendChild(item);
          }
        });
      } else if (propName == "itIsPhysicsBody") {
        let body = this.core.matrixAmmo.getBodyByName(currSceneObj.name);
        for (let key in body) {
          if (typeof body[key] === 'string') {
            this.propName.innerHTML += `<div style="display:flex;text-align:left;"> 
              <div style="background:black;color:white;width:35%;">${key}</div>
              <div style="background:lime;color:black;width:55%;">${body[key]} </div>`;
          } else {
            let item = document.createElement('div');
            item.style.display = "flex";
            let funcNameDesc = document.createElement('span');
            funcNameDesc.style.background = "blue";
            funcNameDesc.style.width = "55%";
            funcNameDesc.innerHTML = key + ":";
            item.appendChild(funcNameDesc);
            if (typeof body[key] === "function") {
              console.log("function");
              let physicsFuncDesc = document.createElement('select');
              // fill it
              item.appendChild(physicsFuncDesc);
            } else if (typeof body[key] === "object") {
              console.log("OBJECT");
              let objDesc = document.createElement('span');
              objDesc.style.background = "yellow";
              objDesc.style.color = "black";
              objDesc.innerHTML = key;
              item.appendChild(objDesc);
            }
            item.addEventListener('click', event => {
              event.stopPropagation();
            });
            this.propName.style.textAlign = 'left';
            this.propName.appendChild(item);
          }
        }
      } else if (propName == 'position' || propName == 'rotation' || propName == "raycast" || propName == "entityArgPass" || propName == "scale") {
        // console.log('currSceneObj[propName] ', currSceneObj[propName]);
        this.exploreSubObject(currSceneObj[propName], propName, currSceneObj).forEach(item => {
          if (typeof item === 'string') {
            this.propName.innerHTML += `<div style="text-align:left;"> ${item.split(':'[1])} </div>`;
          } else {
            item.addEventListener('click', event => {
              event.stopPropagation();
            });
            this.propName.appendChild(item);
          }
        });
      } else if (propName == 'glb') {
        this.exploreGlb(currSceneObj[propName], propName, currSceneObj).forEach(item => {
          if (typeof item === 'string') {
            this.propName.innerHTML += `<div style="text-align:left;"> ${item.split(':'[1])} </div>`;
          } else {
            item.addEventListener('click', event => {
              event.stopPropagation();
            });
            this.propName.appendChild(item);
          }
        });
      } else if (propName == 'itIsPhysicsBody') {
        this.propName.style.borderBottom = 'solid lime 2px';
        this.propName.innerHTML = `<div style="text-align:left;" >${propName} <span style="border-radius:7px;background:deepskyblue;">boolean</span>
        <span style="border-radius:6px;background:gray;">${currSceneObj[propName]}</span></div>`;
      }
      parentDOM.appendChild(this.propName);
    } else if (propName == "isVideo") {
      this.propName.style.borderBottom = 'solid lime 2px';
      this.propName.innerHTML = `<div style="text-align:left;" >${propName} <span style="border-radius:7px;background:deepskyblue;">boolean</span>
        <span style="border-radius:6px;background:gray;">${currSceneObj[propName]}</span></div>`;
      parentDOM.appendChild(this.propName);
    } else if (propName == 'editor-events') {
      this.addEditorEventsProp(currSceneObj, parentDOM);
      this.addEditorDeleteAction(currSceneObj, parentDOM);
    } else {
      // this.propName.innerHTML = `<div>${propName}</div>`;
      // this.propName.innerHTML += `<div>${currSceneObj[propName]}</div>`;
    }
  }
  readBool(currSceneObj, rootKey) {
    return `
    <input type="checkbox"
      class="inputEditor"
      name="${rootKey}"
      ${currSceneObj[rootKey] == true ? "checked" : ""}
      onchange="
        console.log(this.checked, 'checkbox change fired');
        document.dispatchEvent(
          new CustomEvent('web.editor.input', {
            detail: {
              inputFor: ${currSceneObj ? "'" + currSceneObj.name + "'" : "'no info'"},
              propertyId: ${currSceneObj ? "'" + rootKey + "'" : "'no info'"},
              property: 'no info',
              value: this.checked
            }
          })
        );
      "
    />
  `;
  }
  exploreSubObject(subobj, rootKey, currSceneObj) {
    let a = [];
    let __ = [];
    for (const key in subobj) {
      __.push(key);
    }
    __.forEach((prop, index) => {
      if (index == 0) a.push(`${rootKey}`);
      let d = null;
      d = document.createElement("div");
      d.style.textAlign = "left";
      d.style.display = "flex";
      if (typeof subobj[prop] === 'number') {
        d.innerHTML += `<div style="width:50%;">${prop}</div> 
         <div style="width:48%; background:lime;color:black;" > 

         <input class="inputEditor" name="${prop}" 
          onchange="console.log(this.value, 'change fired'); 
          document.dispatchEvent(new CustomEvent('web.editor.input', {detail: {
           'inputFor': ${currSceneObj ? "'" + currSceneObj.name + "'" : "'no info'"} ,
           'propertyId': ${currSceneObj ? "'" + rootKey + "'" : "'no info'"} ,
           'property': ${currSceneObj ? "'" + prop + "'" : "'no info'"} ,
           'value': ${currSceneObj ? "this.value" : "'no info'"}
          }}))" 
         ${rootKey == "adapterInfo" ? " disabled='true'" : " "} type="number" value="${isNaN(subobj[prop]) ? 0 : subobj[prop]}" /> 
        
         </div>`;
      } else if (Array.isArray(subobj[prop])) {
        d.innerHTML += `<div style="width:50%">${prop}</div> 
         <div style="width:${subobj[prop].length == 0 ? "unset" : "48%"}; background:lime;color:black;border-radius:5px;" > ${subobj[prop].length == 0 ? "[Empty array]" : subobj[prop]} </div>`;
      } else if (subobj[prop] === null) {
        d.innerHTML += `<div style="width:50%;">${prop}</div> 
         <div style="width:unset; background:lime;color:black;padding:1px;border-radius:5px;" >${subobj[prop]}</div>`;
      } else if (subobj[prop] == false) {
        d.innerHTML += `<div style="width:50%;">${prop}</div> 
         <div style="width:unset; background:lime;color:black;padding:1px;border-radius:5px;" >false</div>`;
      } else if (typeof subobj[prop] === 'function') {
        d.innerHTML += `<div style="width:50%;">${prop}</div> 
         <div style="width:48%; background:lime;color:black;padding:1px;border-radius:5px;" >[Available from graph]</div>`;
      } else if (subobj[prop] == "") {
        d.innerHTML += `<div style="width:50%;">${prop}</div> 
         <div style="width:unset; background:lime;color:black;padding:1px;border-radius:5px;" >none</div>`;
      } else {
        d.innerHTML += `<div style="width:50%;">${prop}</div> 
         <div style="width:48%; background:lime;color:black;padding:1px;border-radius:5px;" >${subobj[prop]}</div>`;
      }
      a.push(d);
    });
    // this.subObjectsProps.push(a);
    return a;
  }
  exploreGlb(subobj, rootKey, currSceneObj) {
    let a = [];
    let __ = [];
    for (const key in subobj) {
      __.push(key);
    }
    __.forEach((prop, index) => {
      if (index == 0) a.push(`${rootKey}`);
      let d = null;
      d = document.createElement("div");
      d.style.textAlign = "left";
      d.style.display = "flex";
      d.style.flexWrap = "wrap";
      if (typeof subobj[prop] === 'number') {
        d.innerHTML += `<div style="width:50%;">${prop}</div> 
         <div style="width:48%; background:lime;color:black;" >
           <input
           class="inputEditor" name="${prop}" 
           ${prop === "animationIndex" ? "max='" + subobj['glbJsonData']['animations'].length - 1 + "'" : ""}
             onchange="console.log(this.value, 'change fired'); 
            document.dispatchEvent(new CustomEvent('web.editor.input', {detail: {
             'inputFor': ${currSceneObj ? "'" + currSceneObj.name + "'" : "'no info'"} ,
             'propertyId': ${currSceneObj ? "'" + rootKey + "'" : "'no info'"} ,
             'property': ${currSceneObj ? "'" + prop + "'" : "'no info'"} ,
             'value': ${currSceneObj ? "this.value" : "'no info'"}
            }}))" 
           ${rootKey == "adapterInfo" ? "disabled='true'" : ""}" type="number" value="${subobj[prop]}" /> 
           </div>`;
      } else if (Array.isArray(subobj[prop]) && prop == "nodes") {
        // console.log("init prop: " + rootKey)
        d.innerHTML += `<div style="width:50%">${prop}</div> 
         <div style="width:${subobj[prop].length == 0 ? "unset" : "48%"}; background:lime;color:black;border-radius:5px;" > 
            ${subobj[prop].length == 0 ? "[Empty array]" : subobj[prop].length}
         </div>`;
      } else if (Array.isArray(subobj[prop]) && prop == "skins") {
        // console.log("init prop: " + rootKey)
        d.innerHTML += `<div style="width:50%">${prop}</div> 
         <div style="width:${subobj[prop].length == 0 ? "unset" : "48%"}; background:lime;color:black;border-radius:5px;" > 
            ${subobj[prop].length == 0 ? "[Empty array]" : subobj[prop].map(item => {
          if (item && typeof item === "object" && "name" in item) {
            return item.name + " Joints:" + item.joints.length + "\n inverseBindMatrices:" + item.inverseBindMatrices;
          }
          return String(item);
        }).join(", ")}
         </div>`;
      } else if (prop == "glbJsonData") {
        console.log("init glbJsonData: " + rootKey);
        d.innerHTML += `<div style="width:50%">Animations:</div> 

         <div style="width:${subobj[prop].animations.length == 0 ? "unset" : "48%"}; background:lime;color:black;border-radius:5px;" > 
            ${subobj[prop].animations.length == 0 ? "[Empty array]" : subobj[prop].animations.map(item => {
          if (item && typeof item === "object" && "name" in item) {
            return item.name;
          }
          return String(item);
        }).join(", ")}
         </div>
         \n
         <div style="width:50%">Skinned meshes:</div> 
         <div style="width:${subobj[prop].meshes.length == 0 ? "unset" : "48%"}; background:lime;color:black;border-radius:5px;" > 
            ${subobj[prop].meshes.length == 0 ? "[Empty array]" : subobj[prop].meshes.map(item => {
          if (item && typeof item === "object" && "name" in item) {
            return item.name + " \n Primitives : " + item.primitives.length;
          }
          return String(item);
        }).join(", ")}
         </div>
          \n
         <div style="width:50%">Images:</div> 
         <div style="width:${subobj[prop].images.length == 0 ? "unset" : "48%"}; background:lime;color:black;border-radius:5px;" > 
            ${subobj[prop].images.length == 0 ? "[Empty array]" : subobj[prop].images.map(item => {
          if (item && typeof item === "object" && "name" in item) {
            return "<div>" + item.name + " \n mimeType: " + item.mimeType + "</div>";
          }
          return String(item);
        }).join(", ")}
         </div>

         \n
         <div style="width:50%">Materials:</div> 
         <div style="width:${subobj[prop].materials.length == 0 ? "unset" : "48%"}; background:lime;color:black;border-radius:5px;" > 
            ${subobj[prop].materials.length == 0 ? "[Empty array]" : subobj[prop].materials.map(item => {
          if (item && typeof item === "object" && "name" in item) {
            return "<div>" + item.name + " \n metallicFactor: " + item.pbrMetallicRoughness.metallicFactor + " \n roughnessFactor: " + item.pbrMetallicRoughness.roughnessFactor + "</div>";
          }
          return String(item);
        }).join(", ")}
         </div>
         
         `;
      } else if (subobj[prop] === null) {
        d.innerHTML += `<div style="width:50%;">${prop}</div> 
         <div style="width:unset; background:lime;color:black;padding:1px;border-radius:5px;" >${subobj[prop]}</div>`;
      } else if (subobj[prop] == false) {
        d.innerHTML += `<div style="width:50%;">${prop}</div> 
         <div style="width:unset; background:lime;color:black;padding:1px;border-radius:5px;" >false</div>`;
      } else if (subobj[prop] == "") {
        d.innerHTML += `<div style="width:50%;">${prop}</div> 
         <div style="width:unset; background:lime;color:black;padding:1px;border-radius:5px;" >none</div>`;
      } else {
        d.innerHTML += `<div style="width:50%;">${prop}</div> 
         <div style="width:48%; background:lime;color:black;padding:1px;border-radius:5px;" >${subobj[prop]}</div>`;
      }
      a.push(d);
    });
    // this.subObjectsProps.push(a);
    return a;
  }
  addEditorEventsProp(currSceneObj, parentDOM) {
    this.propName.innerHTML += `<div>HIT</div>`;
    this.propName.innerHTML += `<div style='display:flex;'>
      <div style="align-content: center;">onTargetReached (NoPhysics)</div>
      <div><select id='sceneObjEditorPropEvents' ></select></div>
    </div>`;
    parentDOM.appendChild(this.propName);
    (0, _utils.byId)('sceneObjEditorPropEvents').onchange = e => {
      console.log('Event system selection:', e.target.value);
      if (e.target.value == "none") {
        currSceneObj.position.onTargetPositionReach = () => {};
        console.log('clear event');
        return;
      }
      const method = app.editor.methodsManager.methodsContainer.find(m => m.name === e.target.value);
      let F = app.editor.methodsManager.compileFunction(method.code);
      currSceneObj.position.onTargetPositionReach = F;
      console.log('[position.onTargetPositionReach][attached]', F);
    };
    (0, _utils.byId)('sceneObjEditorPropEvents').innerHTML = "";
    this.core.editor.methodsManager.methodsContainer.forEach((m, index) => {
      if (index == 0) {
        const op = document.createElement("option");
        op.value = 'none';
        op.textContent = `none`;
        (0, _utils.byId)('sceneObjEditorPropEvents').appendChild(op);
      }
      const op = document.createElement("option");
      op.value = m.name;
      op.textContent = `${m.name}  [${m.type}]`;
      (0, _utils.byId)('sceneObjEditorPropEvents').appendChild(op);
    });
  }
  addEditorDeleteAction(currSceneObj, parentDOM) {
    this.propName.innerHTML += `<div style='display:flex;'>
      <div style="align-content: center;color:red;">Delete sceneObject:</div>
      <div><button  data-sceneobject='${currSceneObj.name}' id='delete-${currSceneObj.name}'>DELETE</button></div>
    </div>`;
    (0, _utils.byId)(`delete-${currSceneObj.name}`).addEventListener('click', () => {
      if (this.core.mainRenderBundle.length <= 1) {
        alert("WARN - SCENE IS EMPTY IN EDITOR MODE YOU WILL GOT FREEZE - After adding first obj again you must refresh!");
      }
      // important
      let name = currSceneObj.name;
      let ruleOfNaming = name;
      const underscoreIndex = name.indexOf('_');
      const dashIndex = name.indexOf('-');

      // Rule 1 & 2
      if (underscoreIndex === -1 ||
      // no '_'
      dashIndex !== -1 && dashIndex < underscoreIndex // '-' before '_'
      ) {
        ruleOfNaming = name.split('-')[0];
      }
      alert(ruleOfNaming);
      document.dispatchEvent(new CustomEvent('web.editor.delete', {
        detail: {
          prefix: ruleOfNaming,
          fullName: currSceneObj.name
        }
      }));
    });
  }
}

},{"../../engine/utils.js":56,"./flexCodexShader.js":90}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @description
 * MethodsManager only for web editor jobs.
 * @author Nikola Lukic
 * @email zlatnaspirala@gmail.com
 * @format
 * { name, code, fn, type, intervalId }
 */
class MethodsManager {
  constructor(editorType) {
    this.editorType = editorType;
    this.methodsContainer = [];
    this.createUI();
    this.loadMethods(editorType).then(r => {
      this.methodsContainer = r;
      this.refreshSelect();
      this.select.click();
    });
    document.addEventListener('show-method-editor', () => {
      this.popup.style.display = "block";
      this.wrapper.style.display = "block";
    });
    document.addEventListener('XcompileFunction', e => {
      this.compileFunction(e.detail.code);
    });
  }
  loadMethods = async editorType => {
    return new Promise(async (resolve, reject) => {
      if (editorType == 'created from editor') {
        const page = location.pathname.split("/").pop().replace(".html", "");
        // const file = `../projects/${page}/methods.js`;
        const file = `./${page}_methods.js`;
        let module;
        try {
          module = await import(file);
          if (module) {
            resolve(module.default);
          } else {
            reject([]);
          }
        } catch (err) {
          reject([]);
        }
      } else {
        resolve([]);
      }
    });
  };
  makePopupDraggable() {
    let isDragging = false;
    let offsetX = 0;
    let offsetY = 0;

    // Use the wrapper as the drag handle
    this.wrapper.style.cursor = "move";
    this.wrapper.addEventListener("mousedown", e => {
      isDragging = true;
      const rect = this.popup.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
      this.popup.style.transition = "none"; // remove transition during drag
    });
    document.addEventListener("mousemove", e => {
      if (!isDragging) return;
      this.popup.style.left = e.clientX - offsetX + "px";
      this.popup.style.top = e.clientY - offsetY + "px";
      this.popup.style.transform = "none"; // cancel centering transform
    });
    document.addEventListener("mouseup", () => {
      if (isDragging) isDragging = false;
    });
  }
  createUI() {
    // Wrapper
    this.wrapper = document.createElement("div");
    this.wrapper.style.cssText = `
      padding: 10px; 
      background:#2f2f2f;
      border-radius:8px;
      color:#ddd; 
      font-family: monospace;
    `;
    this.select = document.createElement("select");
    this.select.style.cssText = `
      width:100%;
      padding:5px;
      background:#3a3a3a;
      color:#fff;
      border:1px solid #555;
      margin-bottom:10px;
    `;
    this.select.onchange = () => {
      console.log("CHANGE SCRIPT SELECT");
      const index = this.select.selectedIndex;
      const method = this.methodsContainer[index];
      if (!method) return;

      // Open editor with selected method
      this.openEditor(method);
    };
    this.select.onclick = () => {
      const index = this.select.selectedIndex;
      const method = this.methodsContainer[index];
      if (method) this.openEditor(method);
    };
    this.managerTitle = document.createElement("p");
    this.managerTitle.innerText = "Custom Method Box";
    this.managerTitle.style.cssText = `
      width:100%;
      padding:6px;
      margin-top: -10px;
      color:#fff;
      background: unset;
      font-size: 140%;
      font-family: 'stormfaze';
    `;
    this.wrapper.appendChild(this.managerTitle);

    // BUTTON Add new
    this.btnNew = document.createElement("button");
    this.btnNew.innerText = "New Method";
    this.btnNew.style.cssText = `
      width:30%;
      padding:6px;
      margin-left:10px;
      background:rgb(20 94 171);
      color:#fff;
      border:1px solid #555;
      cursor:pointer;
    `;
    this.btnNew.onclick = () => this.openEditor();
    this.wrapper.appendChild(this.select);

    // Popup Editor
    this.popup = document.createElement("div");
    this.popup.style.cssText = `
      position:fixed;
      top:50%; left:50%;
      transform:translate(-50%,-50%);
      background:#2a2a2a;
      padding:20px;
      border:1px solid #555;
      border-radius:8px;
      display:none;
      width:30%;
      height: 75%;
      z-index:999;
    `;
    this.popup.appendChild(this.wrapper);

    // Add after btnSave or btnExit creation
    this.btnRemove = document.createElement("button");
    this.btnRemove.innerText = "Remove method";
    this.btnRemove.style.cssText = `
        margin-top:10px;
        margin-left:10px;
        padding:6px 14px;
        background:#a33;
        color:#fff;
        border:1px solid #800;
        cursor:pointer;
      `;
    this.btnRemove.onclick = () => this.removeMethod();
    this.textarea = document.createElement("textarea");
    this.textarea.id = "code-editor-textarea";
    this.textarea.style.cssText = `
      width:99%; 
      height:78%; 
      background:#1e1e1e;
      font-size: larger;
      color:#fff; 
      border:1px solid #555;
      box-shadow: inset 0px 0px 10px 0px #3F51B5;
      -webkit-text-stroke-width:0;
    `;
    // -webkit-text-stroke-color: #03A9F4;
    this.popup.appendChild(this.textarea);
    this.btnSave = document.createElement("button");
    this.btnSave.innerText = "Save method";
    this.btnSave.style.cssText = `
      margin-top:10px;
      padding:6px 14px;
      margin-left:10px;
      background:rgb(45 133 0);
      color:#fff;
      border:1px solid #666;
      cursor:pointer;
    `;
    this.btnSave.onclick = () => this.saveMethod();
    this.popup.appendChild(this.btnSave);
    this.popup.appendChild(this.btnRemove);
    this.popup.appendChild(this.btnNew);
    this.btnExit = document.createElement("button");
    this.btnExit.innerText = "Hide";
    this.btnExit.style.cssText = `
      margin-top:10px;
      padding:6px 14px;
      margin-left:10px;
      background:#555;
      color:#fff;
      border:1px solid #666;
      cursor:pointer;
    `;
    this.btnExit.onclick = () => {
      this.popup.style.display = "none";
    };
    this.popup.appendChild(this.btnExit);
    this.makePopupDraggable();
    document.body.appendChild(this.popup);
  }
  openEditor(existing) {
    this.editing = existing || null;
    this.textarea.value = existing ? existing.code : "";
    // this.popup.style.display = "block";
  }
  saveMethod() {
    const code = this.textarea.value.trim();
    if (!code) return;
    const name = this.extractName(code);
    const obj = {
      name,
      code,
      type: this.detectType(code),
      fn: this.compileFunction(code),
      intervalId: null
    };
    if (obj.type === "interval") {
      obj.intervalId = obj.fn(); // start the interval
    }

    // Replace or add
    if (this.editing) {
      const idx = this.methodsContainer.indexOf(this.editing);
      this.methodsContainer[idx] = obj;
    } else {
      this.methodsContainer.push(obj);
    }
    this.refreshSelect();
    this.popup.style.display = "none";
    document.dispatchEvent(new CustomEvent('save-methods', {
      detail: {
        methodsContainer: this.methodsContainer
      }
    }));
  }
  removeMethod() {
    if (!this.editing) return; // nothing selected

    const idx = this.methodsContainer.indexOf(this.editing);
    if (idx === -1) return;

    // If it was an interval, clear it
    if (this.methodsContainer[idx].intervalId) {
      clearInterval(this.methodsContainer[idx].intervalId);
    }

    // Remove from container
    this.methodsContainer.splice(idx, 1);

    // Reset editing
    this.editing = null;

    // Refresh select options
    this.refreshSelect();

    // Optionally clear editor
    this.textarea.value = "";

    // Dispatch update event
    document.dispatchEvent(new CustomEvent('save-methods', {
      detail: {
        methodsContainer: this.methodsContainer
      }
    }));
  }
  refreshSelect() {
    this.select.innerHTML = "";
    this.methodsContainer.forEach(m => {
      const op = document.createElement("option");
      op.textContent = `${m.name}  [${m.type}]`;
      this.select.appendChild(op);
    });
  }
  extractName(code) {
    const match = code.match(/function\s+([a-zA-Z0-9_]+)/);
    return match ? match[1] : "method_" + (this.methodsContainer.length + 1);
  }
  detectType(code) {
    if (code.includes("setInterval")) return "interval";
    if (code.includes("return")) return "return";
    return "void";
  }
  compileFunction(code) {
    try {
      // Wrap the function code into a callable unit
      const fn = new Function(code + "; return " + this.extractName(code) + ";")();
      return fn;
    } catch (e) {
      console.error("Compilation error:", e);
      return () => {};
    }
  }
  destroyIntervals() {
    this.methodsContainer.forEach(m => {
      if (m.intervalId) clearInterval(m.intervalId);
    });
  }
}
exports.default = MethodsManager;

},{}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _wgpuMatrix = require("wgpu-matrix");
var _engine = require("./engine/engine.js");
var _meshObj = _interopRequireDefault(require("./engine/mesh-obj.js"));
var _matrixAmmo = _interopRequireDefault(require("./physics/matrix-ammo.js"));
var _utils = require("./engine/utils.js");
var _lang = require("./multilang/lang.js");
var _sounds = require("./sounds/sounds.js");
var _loaderObj = require("./engine/loader-obj.js");
var _lights = require("./engine/lights.js");
var _bvh = require("./engine/loaders/bvh.js");
var _bvhInstaced = require("./engine/loaders/bvh-instaced.js");
var _editor = require("./tools/editor/editor.js");
var _meshObjInstances = _interopRequireDefault(require("./engine/instanced/mesh-obj-instances.js"));
var _bloom = require("./engine/postprocessing/bloom.js");
var _raycast = require("./engine/raycast.js");
var _generator = require("./engine/generators/generator.js");
var _coreCache = require("./engine/core-cache.js");
var _audioAsset = require("./sounds/audioAsset.js");
var _flexCodexShaderAdapter = require("./tools/editor/flexCodexShaderAdapter.js");
var _volumetric = require("./engine/postprocessing/volumetric.js");
var _flameEmmiter = require("./engine/effects/flame-emmiter.js");
var _energyBar = require("./engine/effects/energy-bar.js");
var _manaBar = require("./engine/effects/mana-bar.js");
var _pointerEffect = require("./engine/effects/pointerEffect.js");
var _flame = require("./engine/effects/flame.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * @description
 * Main engine root class.
 * @author Nikola Lukic 2025
 * @email zlatnaspirala@gmail.com
 * @web https://maximumroulette.com
 * @github zlatnaspirala
 */
class MatrixEngineWGPU {
  // save class reference
  reference = {
    MEMeshObj: _meshObj.default,
    MEMeshObjInstances: _meshObjInstances.default,
    BVHPlayerInstances: _bvhInstaced.BVHPlayerInstances,
    BVHPlayer: _bvh.BVHPlayer,
    downloadMeshes: _loaderObj.downloadMeshes,
    addRaycastsListener: _raycast.addRaycastsListener,
    graphAdapter: _flexCodexShaderAdapter.graphAdapter,
    effectsClassRef: {
      FlameEffect: _flame.FlameEffect,
      FlameEmitter: _flameEmmiter.FlameEmitter,
      PointerEffect: _pointerEffect.PointerEffect,
      HPBarEffect: _energyBar.HPBarEffect,
      MANABarEffect: _manaBar.MANABarEffect
    }
  };
  mainRenderBundle = [];
  lightContainer = [];
  frame = () => {};
  entityHolder = [];
  lastTime = 0;
  entityArgPass = {
    loadOp: 'clear',
    storeOp: 'store',
    depthLoadOp: 'clear',
    depthStoreOp: 'store'
  };
  autoUpdate = [];
  matrixSounds = new _sounds.MatrixSounds();
  audioManager = new _audioAsset.AudioAssetManager();
  constructor(options, callback) {
    if (typeof options == 'undefined' || typeof options == "function") {
      this.options = {
        useSingleRenderPass: true,
        canvasSize: 'fullscreen',
        canvasId: 'canvas1',
        mainCameraParams: {
          type: 'WASD',
          responseCoef: 2000
        },
        clearColor: {
          r: 0.584,
          g: 0,
          b: 0.239,
          a: 1.0
        }
      };
      callback = options;
    }
    if (typeof options.clearColor === 'undefined') {
      options.clearColor = {
        r: 0.584,
        g: 0,
        b: 0.239,
        a: 1.0
      };
    }
    if (typeof options.canvasId === 'undefined') {
      options.canvasId = 'canvas1';
    }
    if (typeof options.mainCameraParams === 'undefined') {
      options.mainCameraParams = {
        type: 'WASD',
        responseCoef: 2000
      };
    }

    // in case of optimisation
    if (typeof options.dontUsePhysics == 'undefined') {
      this.physicsBodiesGenerator = _generator.physicsBodiesGenerator.bind(this);
      this.physicsBodiesGeneratorWall = _generator.physicsBodiesGeneratorWall.bind(this);
      this.physicsBodiesGeneratorPyramid = _generator.physicsBodiesGeneratorPyramid.bind(this);
      this.physicsBodiesGeneratorTower = _generator.physicsBodiesGeneratorTower.bind(this);
      this.physicsBodiesGeneratorDeepPyramid = _generator.physicsBodiesGeneratorDeepPyramid.bind(this);
    }
    this.editorAddOBJ = _generator.addOBJ.bind(this);
    this.logLoopError = true;
    // context select options
    if (typeof options.alphaMode == 'undefined') {
      options.alphaMode = "no";
    } else if (options.alphaMode != 'opaque' && options.alphaMode != 'premultiplied') {
      console.error("[webgpu][alphaMode] Wrong enum Valid:'opaque','premultiplied' !!!");
      return;
    }
    if (typeof options.useContex == 'undefined') {
      options.useContex = "webgpu";
      // this.context = canvas.getContext('webgpu', { alphaMode: 'opaque' });
      // this.context = canvas.getContext('webgpu', { alphaMode: 'premultiplied' });
    }
    if (typeof options.dontUsePhysics == 'undefined') {
      this.matrixAmmo = new _matrixAmmo.default();
    }
    this.editor = undefined;
    if (typeof options.useEditor !== "undefined") {
      if (typeof options.projectType !== "undefined" && options.projectType == "created from editor") {
        this.editor = new _editor.Editor(this, "created from editor", options.projectName);
      } else if (typeof options.projectType !== "undefined" && options.projectType == "pre editor") {
        this.editor = new _editor.Editor(this, options.projectType);
      } else {
        this.editor = new _editor.Editor(this, "infly");
      }
    }
    window.addEventListener('keydown', e => {
      if (e.code == "F4") {
        e.preventDefault();
        _utils.mb.error(`Activated WebEditor view.`);
        app.activateEditor();
        return false;
      }
    });
    this.activateEditor = () => {
      if (this.editor == null || typeof this.editor === 'undefined') {
        if (typeof options.projectType !== "undefined" && options.projectType == "created from editor") {
          this.editor = new _editor.Editor(this, "created from editor");
        } else if (typeof options.projectType !== "undefined" && options.projectType == "pre editor") {
          this.editor = new _editor.Editor(this, options.projectType);
        } else {
          this.editor = new _editor.Editor(this, "infly");
        }
        this.editor.editorHud.updateSceneContainer();
      } else {
        this.editor.editorHud.editorMenu.style.display = 'flex';
        this.editor.editorHud.assetsBox.style.display = 'flex';
        this.editor.editorHud.sceneProperty.style.display = 'flex';
        this.editor.editorHud.sceneContainer.style.display = 'flex';
      }
    };
    this.options = options;
    this.mainCameraParams = options.mainCameraParams;
    const target = this.options.appendTo || document.body;
    var canvas = document.createElement('canvas');
    canvas.id = this.options.canvasId;
    if (this.options.canvasSize == 'fullscreen') {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    } else {
      canvas.width = this.options.canvasSize.w;
      canvas.height = this.options.canvasSize.h;
    }
    target.append(canvas);
    // The camera types
    const initialCameraPosition = _wgpuMatrix.vec3.create(0, 0, 0);
    this.mainCameraParams = {
      type: this.options.mainCameraParams.type,
      responseCoef: this.options.mainCameraParams.responseCoef
    };

    // add defaul generatl config later
    this.cameras = {
      arcball: new _engine.ArcballCamera({
        position: initialCameraPosition
      }),
      WASD: new _engine.WASDCamera({
        position: initialCameraPosition,
        canvas: canvas,
        pitch: 0.18,
        yaw: -0.1
      }),
      RPG: new _engine.RPGCamera({
        position: initialCameraPosition,
        canvas: canvas
      })
    };
    this.label = new _lang.MultiLang();
    if (_utils.urlQuery.lang != null) {
      this.label.loadMultilang(_utils.urlQuery.lang).then(r => {
        this.label.get = r;
      }).catch(r => {
        this.label.get = r;
      });
    } else {
      this.label.loadMultilang().then(r => {
        this.label.get = r;
      }).catch(r => {
        this.label.get = r;
      });
      ;
    }
    this.init({
      canvas,
      callback
    });
  }
  init = async ({
    canvas,
    callback
  }) => {
    this.canvas = canvas;
    this.adapter = await navigator.gpu.requestAdapter();
    this.device = await this.adapter.requestDevice({
      extensions: ["ray_tracing"]
    });
    if (this.options.alphaMode == "no") {
      this.context = canvas.getContext('webgpu');
    } else if (this.options.alphaMode == "opaque") {
      this.context = canvas.getContext('webgpu', {
        alphaMode: 'opaque'
      });
    } else if (this.options.alphaMode == "opaque") {
      this.context = canvas.getContext('webgpu', {
        alphaMode: 'premultiplied'
      });
    }
    const devicePixelRatio = window.devicePixelRatio;
    canvas.width = canvas.clientWidth * devicePixelRatio;
    canvas.height = canvas.clientHeight * devicePixelRatio;
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
    this.context.configure({
      device: this.device,
      format: presentationFormat,
      alphaMode: 'premultiplied'
    });

    // if(this.options.useSingleRenderPass == true) {
    this.frame = this.frameSinglePass;
    this.globalAmbient = _wgpuMatrix.vec3.create(0.5, 0.5, 0.5);
    this.MAX_SPOTLIGHTS = 20;
    this.inputHandler = (0, _engine.createInputHandler)(window, canvas);
    this.createGlobalStuff();
    this.shadersPack = {};

    // if('OffscreenCanvas' in window) {
    //   console.log(`$cOffscreenCanvas is supported`, LOG_FUNNY_ARCADE);
    // } else {
    //   console.log(`%cOffscreenCanvas is NOT supported.`, LOG_FUNNY_ARCADE);
    // }
    console.log("%c ---------------------------------------------------------------------------------------------- ", _utils.LOG_FUNNY);
    console.log("%c 🧬 Matrix-Engine-Wgpu 🧬 ", _utils.LOG_FUNNY_BIG_NEON);
    console.log("%c ---------------------------------------------------------------------------------------------- ", _utils.LOG_FUNNY);
    console.log("%c Version 1.9.0 ", _utils.LOG_FUNNY);
    console.log("%c👽  ", _utils.LOG_FUNNY_EXTRABIG);
    console.log("%cMatrix Engine WGPU - Port is open.\n" + "Creative power loaded with visual scripting.\n" + "Last features : Adding Gizmo , Optimised render in name of performance,\n" + " audioReactiveNode, onDraw , onKey , curve editor.\n" + "No tracking. No hype. Just solutions. 🔥", _utils.LOG_FUNNY_BIG_ARCADE);
    console.log("%cSource code: 👉 GitHub:\nhttps://github.com/zlatnaspirala/matrix-engine-wgpu", _utils.LOG_FUNNY_ARCADE);
    // pseude async
    setTimeout(() => {
      this.run(callback);
    }, 50);
  };
  createGlobalStuff() {
    // OPTIMISATION
    this.textureCache = new _coreCache.TextureCache(this.device);
    this._destroyQueue = new Set();
    this.flushDestroyQueue = () => {
      if (!this._destroyQueue.size) return;
      this._destroyQueue.forEach(name => {
        this.removeSceneObjectByName(name);
      });
      this._destroyQueue.clear();
    };
    this.destroyByPrefix = prefix => {
      const toDestroy = [];
      for (const obj of this.mainRenderBundle) {
        if (obj.name.startsWith(prefix)) {
          toDestroy.push(obj.name);
        }
      }
      toDestroy.forEach(name => this._destroyQueue.add(name));
    };
    this.destroyBySufix = sufix => {
      const toDestroy = [];
      for (const obj of this.mainRenderBundle) {
        if (obj.name.endsWith(sufix)) {
          toDestroy.push(obj.name);
        }
      }
      toDestroy.forEach(name => this._destroyQueue.add(name));
    };

    // Just syntetic to help visual scripting part
    this.bloomPass = {
      enabled: false,
      setIntensity: v => {},
      setKnee: v => {},
      setBlurRadius: v => {},
      setThreshold: v => {}
    };
    this.volumetricPass = {
      enabled: false
    };
    this.bloomOutputTex = this.device.createTexture({
      size: [this.canvas.width, this.canvas.height],
      format: 'rgba16float',
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.sceneTexture = this.device.createTexture({
      label: "final pipeline sceneTexture",
      size: [this.canvas.width, this.canvas.height],
      format: 'rgba16float',
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.sceneTextureView = this.sceneTexture.createView();
    this.presentSampler = this.device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear'
    });
    this.presentPipeline = this.device.createRenderPipeline({
      label: "final pipeline",
      layout: 'auto',
      vertex: {
        module: this.device.createShaderModule({
          code: (0, _bloom.fullscreenQuadWGSL)()
        }),
        entryPoint: 'vert'
      },
      fragment: {
        module: this.device.createShaderModule({
          code: `
        @group(0) @binding(0) var hdrTex : texture_2d<f32>;
        @group(0) @binding(1) var samp : sampler;

        @fragment
        fn main(@builtin(position) pos: vec4<f32>) -> @location(0) vec4<f32> {
          let uv = pos.xy / vec2<f32>(textureDimensions(hdrTex));
          let hdr = textureSample(hdrTex, samp, uv).rgb;

          // simple tonemap
          let ldr = hdr / (hdr + vec3(1.0));

          return vec4<f32>(ldr, 1.0);
        }
      `
        }),
        entryPoint: 'main',
        targets: [{
          format: 'bgra8unorm'
        }] // rgba16float  bgra8unorm
      }
    });
    this.createBloomBindGroup();
    this.spotlightUniformBuffer = this.device.createBuffer({
      label: 'spotlightUniformBufferGLOBAL',
      size: this.MAX_SPOTLIGHTS * 144,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.SHADOW_RES = 1024;
    this.createTexArrayForShadows();
    this.mainDepthTexture = this.device.createTexture({
      size: [this.canvas.width, this.canvas.height],
      format: 'depth24plus',
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.mainDepthView = this.mainDepthTexture.createView();
    this.mainRenderPassDesc = {
      label: 'mainRenderPassDesc',
      colorAttachments: [{
        view: undefined,
        // set each frame
        loadOp: 'clear',
        storeOp: 'store',
        clearValue: [0.02, 0.02, 0.02, 1]
      }],
      depthStencilAttachment: {
        view: this.mainDepthView,
        // fixed
        depthLoadOp: 'clear',
        depthStoreOp: 'store',
        depthClearValue: 1.0
      }
    };

    // pointer effect-not in use
    const depthTexture = this.device.createTexture({
      size: [this.canvas.width, this.canvas.height],
      format: "depth24plus",
      usage: GPUTextureUsage.RENDER_ATTACHMENT
    });
    this.depthTextureViewTrail = depthTexture.createView();
  }
  createTexArrayForShadows() {
    let numberOfLights = this.lightContainer.length;
    if (this.lightContainer.length == 0) {
      setTimeout(() => {
        // console.info('Test light again...')
        this.createMe();
      }, 800);
    }
    this.createMe = () => {
      Math.max(1, this.lightContainer.length);
      if (this.lightContainer.length == 0) {
        setTimeout(() => {
          // console.info('Create now test...')
          this.createMe();
        }, 800);
        return;
      }

      // console.warn('Create this.shadowTextureArray...')
      this.shadowTextureArray = this.device.createTexture({
        label: `shadowTextureArray[GLOBAL] num of light ${numberOfLights}`,
        size: {
          width: 1024,
          height: 1024,
          depthOrArrayLayers: numberOfLights // at least 1
        },
        dimension: '2d',
        format: 'depth32float',
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      this.shadowArrayView = this.shadowTextureArray.createView({
        dimension: '2d-array'
      });
      this.shadowVideoTexture = this.device.createTexture({
        size: [1024, 1024],
        format: "depth32float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      this.shadowVideoView = this.shadowVideoTexture.createView({
        dimension: "2d"
      });
    };
    this.createMe();
  }
  getSceneObjectByName = name => {
    return this.mainRenderBundle.find(sceneObject => sceneObject.name === name);
  };
  getSceneLightByName = name => {
    return this.lightContainer.find(l => l.name === name);
  };
  getNameFromPath(p) {
    return p.split(/[/\\]/).pop().replace(/\.[^/.]+$/, "");
  }
  removeSceneObjectByName = name => {
    const index = this.mainRenderBundle.findIndex(obj => obj.name === name);
    if (index === -1) {
      console.warn("%cScene object not found:" + name, _utils.LOG_FUNNY_ARCADE);
      return false;
    }
    const obj = this.mainRenderBundle[index];
    let testPB = app.matrixAmmo.getBodyByName(obj.name);
    if (testPB !== null) {
      try {
        this.matrixAmmo.dynamicsWorld.removeRigidBody(testPB);
      } catch (e) {
        console.warn("%cPhysics cleanup error:" + e, _utils.LOG_FUNNY_ARCADE);
      }
    }
    this.mainRenderBundle.splice(index, 1);
    return true;
  };
  addLight(o) {
    const camera = this.cameras[this.mainCameraParams.type];
    let newLight = new _lights.SpotLight(camera, this.inputHandler, this.device, this.lightContainer.length);
    this.lightContainer.push(newLight);
    this.createTexArrayForShadows();
    console.log(`%cAdd light: ${newLight}`, _utils.LOG_FUNNY_ARCADE);
  }
  addMeshObj = (o, clearColor = this.options.clearColor) => {
    if (typeof o.name === 'undefined') {
      o.name = (0, _utils.genName)(9);
    }
    if (typeof o.position === 'undefined') {
      o.position = {
        x: 0,
        y: 0,
        z: -4
      };
    }
    if (typeof o.rotation === 'undefined') {
      o.rotation = {
        x: 0,
        y: 0,
        z: 0
      };
    }
    if (typeof o.rotationSpeed === 'undefined') {
      o.rotationSpeed = {
        x: 0,
        y: 0,
        z: 0
      };
    }
    if (typeof o.texturesPaths === 'undefined') {
      o.texturesPaths = ['./res/textures/default.png'];
    }
    if (typeof o.material === 'undefined') {
      o.material = {
        type: 'standard'
      };
    }
    if (typeof o.mainCameraParams === 'undefined') {
      o.mainCameraParams = this.mainCameraParams;
    }
    if (typeof o.scale === 'undefined') {
      o.scale = [1, 1, 1];
    }
    if (typeof o.raycast === 'undefined') {
      o.raycast = {
        enabled: false,
        radius: 2
      };
    }
    if (typeof o.useScale === 'undefined') {
      o.useScale = true;
    }
    if (typeof o.envMapParams === 'undefined') {
      o.envMapParams = null;
    }
    o.entityArgPass = this.entityArgPass;
    o.cameras = this.cameras;
    if (typeof o.physics === 'undefined') {
      o.physics = {
        scale: [1, 1, 1],
        enabled: true,
        geometry: "Sphere",
        // must be fixed<<
        radius: typeof o.scale == Number ? o.scale : o.scale[0],
        name: o.name,
        rotation: o.rotation
      };
    }
    if (typeof o.physics.enabled === 'undefined') {
      o.physics.enabled = true;
    }
    if (typeof o.physics.geometry === 'undefined') {
      o.physics.geometry = "Cube";
    }
    if (typeof o.physics.radius === 'undefined') {
      o.physics.radius = o.scale;
    }
    if (typeof o.physics.mass === 'undefined') {
      o.physics.mass = 1;
    }
    if (typeof o.physics.name === 'undefined') {
      o.physics.name = o.name;
    }
    if (typeof o.physics.scale === 'undefined') {
      o.physics.scale = o.scale;
    }
    if (typeof o.physics.rotation === 'undefined') {
      o.physics.rotation = o.rotation;
    }
    o.physics.position = o.position;
    if (typeof o.objAnim == 'undefined' || typeof o.objAnim == null) {
      o.objAnim = null;
    } else {
      if (typeof o.objAnim.animations !== 'undefined') {
        o.objAnim.play = _loaderObj.play;
      }
      // no need for single test it in future
      o.objAnim.meshList = o.objAnim.meshList;
      if (typeof o.mesh === 'undefined') {
        o.mesh = o.objAnim.meshList[0];
        console.info('objSeq animation is active.');
      }
      // scale for all second option!
      o.objAnim.scaleAll = function (s) {
        for (var k in this.meshList) {
          // console.log('SCALE meshList');
          this.meshList[k].setScale(s);
        }
      };
    }
    o.textureCache = this.textureCache;
    let AM = this.globalAmbient.slice();
    let myMesh1 = new _meshObj.default(this.canvas, this.device, this.context, o, this.inputHandler, AM);
    myMesh1.spotlightUniformBuffer = this.spotlightUniformBuffer;
    myMesh1.clearColor = clearColor;
    if (o.physics.enabled == true) {
      this.matrixAmmo.addPhysics(myMesh1, o.physics);
    }
    this.mainRenderBundle.push(myMesh1);
    if (typeof this.editor !== 'undefined') {
      this.editor.editorHud.updateSceneContainer();
    }
  };
  createBloomBindGroup() {
    this.bloomBindGroup = this.device.createBindGroup({
      layout: this.presentPipeline.getBindGroupLayout(0),
      entries: [{
        binding: 0,
        resource: this.bloomOutputTex
      }, {
        binding: 1,
        resource: this.presentSampler
      }]
    });
    this.noBloomBindGroup = this.device.createBindGroup({
      layout: this.presentPipeline.getBindGroupLayout(0),
      entries: [{
        binding: 0,
        resource: this.sceneTexture.createView()
      }, {
        binding: 1,
        resource: this.presentSampler
      }]
    });
  }
  async run(callback) {
    // await this.device.queue.onSubmittedWorkDone();
    setTimeout(() => {
      requestAnimationFrame(this.frame);
    }, 1000);
    setTimeout(() => {
      callback(this);
    }, 1);
  }
  destroyProgram = () => {
    console.warn('%c[MatrixEngineWGPU] Destroy program', 'color: orange');

    // 1️⃣ Stop render loop
    this.frame = () => {};
    if (this._rafId) {
      cancelAnimationFrame(this._rafId);
      this._rafId = null;
    }

    // 2️⃣ Destroy scene objects
    for (const obj of this.mainRenderBundle) {
      try {
        obj?.destroy?.();
      } catch (e) {
        console.warn('Object destroy error:', obj?.name, e);
      }
    }
    this.mainRenderBundle.length = 0;

    // 3️⃣ Physics
    this.matrixAmmo?.destroy?.();
    this.matrixAmmo = null;

    // 4️⃣ Editor
    this.editor?.destroy?.();
    this.editor = null;

    // 5️⃣ Input
    this.inputHandler?.destroy?.();
    this.inputHandler = null;

    // 6️⃣ GLOBAL GPU RESOURCES
    this.mainDepthTexture?.destroy();
    this.shadowTextureArray?.destroy();
    this.shadowVideoTexture?.destroy();
    this.mainDepthTexture = null;
    this.shadowTextureArray = null;
    this.shadowVideoTexture = null;

    // 7️⃣ Lose WebGPU context
    try {
      this.context?.unconfigure?.();
    } catch {}

    // 8️⃣ Canvas
    this.canvas?.remove();
    this.canvas = null;
    this.device = null;
    this.context = null;
    this.adapter = null;
    console.warn('%c[MatrixEngineWGPU] Destroy complete ✔', 'color: lightgreen');
  };
  updateLights() {
    const floatsPerLight = 36; // not 20 anymore
    const data = new Float32Array(this.MAX_SPOTLIGHTS * floatsPerLight);
    for (let i = 0; i < this.MAX_SPOTLIGHTS; i++) {
      if (i < this.lightContainer.length) {
        const buf = this.lightContainer[i].getLightDataBuffer();
        data.set(buf, i * floatsPerLight);
      } else {
        data.set(new Float32Array(floatsPerLight), i * floatsPerLight);
      }
    }
    this.device.queue.writeBuffer(this.spotlightUniformBuffer, 0, data.buffer);
  }
  frameSinglePass = () => {
    if (typeof this.mainRenderBundle == 'undefined' || this.mainRenderBundle.length == 0) {
      setTimeout(() => {
        requestAnimationFrame(this.frame);
      }, 100);
      return;
    }
    this.autoUpdate.forEach(_ => _.update());
    let now;
    const currentTime = performance.now() / 1000;
    const bufferUpdates = [];
    this.mainRenderBundle.forEach((m, index) => {
      if (m.vertexAnimBuffer && m.vertexAnimParams) {
        m.time = currentTime * m.deltaTimeAdapter;
        m.vertexAnimParams[0] = m.time;
        bufferUpdates.push({
          buffer: m.vertexAnimBuffer,
          data: m.vertexAnimParams
        });
      }
      if (m.isVideo == true) {
        if (!m.externalTexture) {
          m.createBindGroupForRender();
          setTimeout(() => {
            requestAnimationFrame(this.frame);
          }, 300);
          return;
        }
      }
    });
    for (const update of bufferUpdates) {
      this.device.queue.writeBuffer(update.buffer, 0, update.data);
    }
    try {
      let commandEncoder = this.device.createCommandEncoder();
      if (this.matrixAmmo) this.matrixAmmo.updatePhysics();
      this.updateLights();
      this.mainRenderBundle.forEach((mesh, index) => {
        mesh.position.update();
        mesh.updateModelUniformBuffer();
        if (mesh.update) mesh.update(mesh.time);
        if (mesh.updateTime) {
          mesh.updateTime(currentTime);
        }
        this.lightContainer.forEach(light => {
          light.update();
          mesh.getTransformationMatrix(this.mainRenderBundle, light, index);
        });
      });
      for (let i = 0; i < this.lightContainer.length; i++) {
        const light = this.lightContainer[i];
        let ViewPerLightRenderShadowPass = this.shadowTextureArray.createView({
          dimension: '2d',
          baseArrayLayer: i,
          arrayLayerCount: 1,
          // must be > 0
          baseMipLevel: 0,
          mipLevelCount: 1
        });
        const shadowPass = commandEncoder.beginRenderPass({
          label: "shadowPass",
          colorAttachments: [],
          depthStencilAttachment: {
            view: ViewPerLightRenderShadowPass,
            depthLoadOp: 'clear',
            depthStoreOp: 'store',
            depthClearValue: 1.0
          }
        });
        now = performance.now() / 1000;
        for (const [meshIndex, mesh] of this.mainRenderBundle.entries()) {
          if (mesh instanceof _bvhInstaced.BVHPlayerInstances) {
            mesh.updateInstanceData(mesh.getModelMatrix(mesh.position, mesh.useScale));
            shadowPass.setPipeline(light.shadowPipelineInstanced);
          } else {
            shadowPass.setPipeline(light.shadowPipeline);
          }
          if (mesh.videoIsReady == 'NONE') {
            shadowPass.setBindGroup(0, light.getShadowBindGroup(mesh, meshIndex));
            if (mesh instanceof _bvhInstaced.BVHPlayerInstances) {
              shadowPass.setBindGroup(1, mesh.modelBindGroupInstanced);
            } else {
              shadowPass.setBindGroup(1, mesh.modelBindGroup);
            }
            mesh.drawShadows(shadowPass, light);
          }
        }
        shadowPass.end();
      }

      // with no postprocessing
      // const currentTextureView = this.context.getCurrentTexture().createView();
      // this.mainRenderPassDesc.colorAttachments[0].view = currentTextureView;
      this.mainRenderPassDesc.colorAttachments[0].view = this.sceneTextureView;
      let pass = commandEncoder.beginRenderPass(this.mainRenderPassDesc);
      // opaque
      for (const mesh of this.mainRenderBundle) {
        if (mesh.material?.useBlend === true) continue;
        if (mesh.pipeline) {
          pass.setPipeline(mesh.pipeline);
        } else {
          pass.setPipeline(this.mainRenderBundle[0].pipeline);
        }
        if (!mesh.sceneBindGroupForRender || mesh.FINISH_VIDIO_INIT == false && mesh.isVideo == true) {
          for (const m of this.mainRenderBundle) {
            if (m.isVideo == true) {
              // console.log("%c✅shadowVideoView ${this.shadowVideoView}", LOG_FUNNY_ARCADE);
              m.shadowDepthTextureView = this.shadowVideoView;
              m.FINISH_VIDIO_INIT = true;
              m.setupPipeline();
              pass.setPipeline(mesh.pipeline);
            } else {
              m.shadowDepthTextureView = this.shadowArrayView;
              m.setupPipeline();
            }
          }
        }
        mesh.drawElements(pass, this.lightContainer);
      }
      // blend
      for (const mesh of this.mainRenderBundle) {
        if (mesh.material?.useBlend !== true) continue;
        pass.setPipeline(mesh.pipelineTransparent);
        if (!mesh.sceneBindGroupForRender || mesh.FINISH_VIDIO_INIT == false && mesh.isVideo == true) {
          for (const m of this.mainRenderBundle) {
            if (m.isVideo == true) {
              // console.log("%c✅shadowVideoView ${this.shadowVideoView}", LOG_FUNNY_ARCADE);
              m.shadowDepthTextureView = this.shadowVideoView;
              m.FINISH_VIDIO_INIT = true;
              m.setupPipeline();
              pass.setPipeline(mesh.pipelineTransparent);
            } else {
              m.shadowDepthTextureView = this.shadowArrayView;
              m.setupPipeline();
            }
          }
        }
        mesh.drawElements(pass, this.lightContainer);
      }
      pass.end();
      if (this.collisionSystem) this.collisionSystem.update();
      const transPassDesc = {
        colorAttachments: [{
          view: this.sceneTextureView,
          loadOp: 'load',
          storeOp: 'store',
          clearValue: {
            r: 0,
            g: 1,
            b: 0,
            a: 1
          }
        }],
        depthStencilAttachment: {
          view: this.mainDepthView,
          depthLoadOp: 'load',
          depthStoreOp: 'store',
          depthClearValue: 1.0
        }
      };
      const transPass = commandEncoder.beginRenderPass(transPassDesc);
      const viewProjMatrix = _wgpuMatrix.mat4.multiply(this.cameras[this.mainCameraParams.type].projectionMatrix, this.cameras[this.mainCameraParams.type].view, _wgpuMatrix.mat4.identity());
      for (const mesh of this.mainRenderBundle) {
        if (mesh.effects) Object.keys(mesh.effects).forEach(effect_ => {
          const effect = mesh.effects[effect_];
          if (effect == null || effect.enabled == false) return;
          let md = mesh.getModelMatrix(mesh.position, mesh.useScale);
          if (effect.updateInstanceData) effect.updateInstanceData(md);
          effect.render(transPass, mesh, viewProjMatrix);
        });
      }
      transPass.end();
      // volumetric
      if (this.volumetricPass.enabled === true) {
        const cam = this.cameras[this.mainCameraParams.type];
        // If you don't store it yet, compute once per frame:
        const invViewProj = _wgpuMatrix.mat4.invert(_wgpuMatrix.mat4.multiply(cam.projectionMatrix, cam.view, _wgpuMatrix.mat4.identity()));
        // Grab first light for direction + shadow matrix
        const light = this.lightContainer[0];
        this.volumetricPass.render(commandEncoder, this.sceneTextureView,
        // ← your existing scene color
        this.mainDepthView,
        // ← your existing depth
        this.shadowArrayView,
        // ← your existing shadow array
        {
          invViewProjectionMatrix: invViewProj
        }, {
          viewProjectionMatrix: light.viewProjMatrix,
          // Float32Array 16
          direction: light.direction // [x, y, z]
        });
      }
      const canvasView = this.context.getCurrentTexture().createView();
      // Bloom
      if (this.bloomPass.enabled == true) {
        const bloomInput = this.volumetricPass.enabled ? this.volumetricPass.compositeOutputTex.createView() : this.sceneTextureView;
        this.bloomPass.render(commandEncoder, bloomInput, this.bloomOutputTex);
        // ori
        // this.bloomPass.render(commandEncoder, this.sceneTextureView, this.bloomOutputTex);
      }
      pass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: canvasView,
          loadOp: 'clear',
          storeOp: 'store',
          clearValue: {
            r: 0,
            g: 0,
            b: 0,
            a: 1
          }
        }]
      });
      pass.setPipeline(this.presentPipeline);
      pass.setBindGroup(0, this.bloomPass.enabled === true ? this.bloomBindGroup : this.noBloomBindGroup);
      pass.draw(6);
      pass.end();
      this.graphUpdate(now);
      this.device.queue.submit([commandEncoder.finish()]);
      requestAnimationFrame(this.frame);
    } catch (err) {
      if (this.logLoopError) console.log('%cLoop(err):' + err + " info : " + err.stack, _utils.LOG_WARN);
      requestAnimationFrame(this.frame);
    }
  };
  graphUpdate = delta => {};
  addGlbObj = (o, BVHANIM, glbFile, clearColor = this.options.clearColor) => {
    if (typeof o.name === 'undefined') {
      o.name = (0, _utils.genName)(9);
    }
    if (typeof o.position === 'undefined') {
      o.position = {
        x: 0,
        y: 0,
        z: -4
      };
    }
    if (typeof o.rotation === 'undefined') {
      o.rotation = {
        x: 0,
        y: 0,
        z: 0
      };
    }
    if (typeof o.rotationSpeed === 'undefined') {
      o.rotationSpeed = {
        x: 0,
        y: 0,
        z: 0
      };
    }
    if (typeof o.texturesPaths === 'undefined') {
      o.texturesPaths = ['./res/textures/default.png'];
    }
    if (typeof o.material === 'undefined') {
      o.material = {
        type: 'standard'
      };
    }
    if (typeof o.mainCameraParams === 'undefined') {
      o.mainCameraParams = this.mainCameraParams;
    }
    if (typeof o.scale === 'undefined') {
      o.scale = [1, 1, 1];
    }
    if (typeof o.raycast === 'undefined') {
      o.raycast = {
        enabled: false,
        radius: 2
      };
    }
    if (typeof o.pointerEffect === 'undefined') {
      o.pointerEffect = {
        enabled: false
      };
    }
    if (typeof o.useScale === 'undefined') {
      o.useScale = true;
    }
    o.entityArgPass = this.entityArgPass;
    o.cameras = this.cameras;
    if (typeof o.physics === 'undefined') {
      o.physics = {
        scale: [1, 1, 1],
        enabled: true,
        geometry: "Sphere",
        //                   must be fixed<<
        radius: typeof o.scale == Number ? o.scale : o.scale[0],
        name: o.name,
        rotation: o.rotation
      };
    }
    if (typeof o.physics.enabled === 'undefined') {
      o.physics.enabled = true;
    }
    if (typeof o.physics.geometry === 'undefined') {
      o.physics.geometry = "Cube";
    }
    if (typeof o.physics.radius === 'undefined') {
      o.physics.radius = o.scale;
    }
    if (typeof o.physics.mass === 'undefined') {
      o.physics.mass = 1;
    }
    if (typeof o.physics.name === 'undefined') {
      o.physics.name = o.name;
    }
    if (typeof o.physics.scale === 'undefined') {
      o.physics.scale = o.scale;
    }
    if (typeof o.physics.rotation === 'undefined') {
      o.physics.rotation = o.rotation;
    }
    o.physics.position = o.position;
    if (typeof o.objAnim == 'undefined' || typeof o.objAnim == null) {
      o.objAnim = null;
    } else {
      alert('GLB not use objAnim (it is only for obj sequence). GLB use BVH skeletal for animation');
    }
    o.textureCache = this.textureCache;
    let skinnedNodeIndex = 0;
    for (const skinnedNode of glbFile.skinnedMeshNodes) {
      let c = 0;
      for (const primitive of skinnedNode.mesh.primitives) {
        // console.log(`count: ${c} primitive-glb: ${primitive}`);
        // primitive is mesh - probably with own material . material/texture per primitive
        // create scene object for each skinnedNode
        o.name = o.name + "-" + skinnedNode.name + '-' + c;
        const bvhPlayer = new _bvh.BVHPlayer(o, BVHANIM, glbFile, c, skinnedNodeIndex, this.canvas, this.device, this.context, this.inputHandler, this.globalAmbient.slice());
        skinnedNodeIndex++;
        // console.log(`bvhPlayer!!!!!: ${bvhPlayer}`);
        bvhPlayer.spotlightUniformBuffer = this.spotlightUniformBuffer;
        bvhPlayer.clearColor = clearColor;
        // if(o.physics.enabled == true) {
        //   this.matrixAmmo.addPhysics(myMesh1, o.physics)
        // }
        // make it soft
        this.mainRenderBundle.push(bvhPlayer);
        setTimeout(() => {
          document.dispatchEvent(new CustomEvent('updateSceneContainer', {
            detail: {}
          }));
        }, 50);
        c++;
      }
    }
    if (typeof this.editor !== 'undefined') {
      this.editor.editorHud.updateSceneContainer();
    }
  };
  addGlbObjInctance = (o, BVHANIM, glbFile, clearColor = this.options.clearColor) => {
    if (typeof o.name === 'undefined') {
      o.name = (0, _utils.genName)(9);
    }
    if (typeof o.position === 'undefined') {
      o.position = {
        x: 0,
        y: 0,
        z: -4
      };
    }
    if (typeof o.rotation === 'undefined') {
      o.rotation = {
        x: 0,
        y: 0,
        z: 0
      };
    }
    if (typeof o.rotationSpeed === 'undefined') {
      o.rotationSpeed = {
        x: 0,
        y: 0,
        z: 0
      };
    }
    if (typeof o.texturesPaths === 'undefined') {
      o.texturesPaths = ['./res/textures/default.png'];
    }
    if (typeof o.material === 'undefined') {
      o.material = {
        type: 'standard'
      };
    }
    if (typeof o.mainCameraParams === 'undefined') {
      o.mainCameraParams = this.mainCameraParams;
    }
    if (typeof o.scale === 'undefined') {
      o.scale = [1, 1, 1];
    }
    if (typeof o.raycast === 'undefined') {
      o.raycast = {
        enabled: false,
        radius: 2
      };
    }
    if (typeof o.pointerEffect === 'undefined') {
      o.pointerEffect = {
        enabled: false,
        pointer: false,
        ballEffect: false
      };
    }
    if (typeof o.useScale === 'undefined') {
      o.useScale = true;
    }
    if (typeof o.envMapParams === 'undefined') {
      o.envMapParams = null;
    }
    o.textureCache = this.textureCache;
    o.entityArgPass = this.entityArgPass;
    o.cameras = this.cameras;
    if (typeof o.physics === 'undefined') {
      o.physics = {
        scale: o.scale,
        enabled: true,
        geometry: "Sphere",
        //                   must be fixed<<
        radius: typeof o.scale == Number ? o.scale : o.scale[0],
        name: o.name,
        rotation: o.rotation
      };
    }
    if (typeof o.physics.enabled === 'undefined') {
      o.physics.enabled = true;
    }
    if (typeof o.physics.geometry === 'undefined') {
      o.physics.geometry = "Cube";
    }
    if (typeof o.physics.radius === 'undefined') {
      o.physics.radius = o.scale;
    }
    if (typeof o.physics.mass === 'undefined') {
      o.physics.mass = 1;
    }
    if (typeof o.physics.name === 'undefined') {
      o.physics.name = o.name;
    }
    if (typeof o.physics.scale === 'undefined') {
      o.physics.scale = o.scale;
    }
    if (typeof o.physics.rotation === 'undefined') {
      o.physics.rotation = o.rotation;
    }
    o.physics.position = o.position;
    if (typeof o.objAnim == 'undefined' || typeof o.objAnim == null) {
      o.objAnim = null;
    } else {
      console.warn('GLB not use objAnim (it is only for obj sequence). GLB use BVH skeletal for animation');
    }
    let skinnedNodeIndex = 0;
    for (const skinnedNode of glbFile.skinnedMeshNodes) {
      let c = 0;
      for (const primitive of skinnedNode.mesh.primitives) {
        // console.log(`count: ${c} primitive-glb: ${primitive}`);
        // primitive is mesh - probably with own material . material/texture per primitive
        // create scene object for each skinnedNode
        o.name = o.name + "_" + skinnedNode.name;
        // maybe later add logic from constructor
        // always fisrt sub mesh(skinnedmeg-vert group how comes from loaders)
        if (skinnedNodeIndex == 0) {} else {
          o.pointerEffect = {
            enabled: false
          };
        }
        const bvhPlayer = new _bvhInstaced.BVHPlayerInstances(o, BVHANIM, glbFile, c, skinnedNodeIndex, this.canvas, this.device, this.context, this.inputHandler, this.globalAmbient.slice());
        // console.log(`bvhPlayer!!!!!: ${bvhPlayer}`);
        bvhPlayer.spotlightUniformBuffer = this.spotlightUniformBuffer;
        bvhPlayer.clearColor = clearColor;
        // if(o.physics.enabled == true) {
        //   this.matrixAmmo.addPhysics(myMesh1, o.physics)
        // }
        // make it soft
        setTimeout(() => {
          this.mainRenderBundle.push(bvhPlayer);
          setTimeout(() => {
            document.dispatchEvent(new CustomEvent('updateSceneContainer', {
              detail: {}
            }));
          }, 50);
        }, 200);
        c++;
      }
      skinnedNodeIndex++;
    }
    if (typeof this.editor !== 'undefined') {
      this.editor.editorHud.updateSceneContainer();
    }
  };
  activateBloomEffect = () => {
    if (this.bloomPass.enabled != true) {
      this.bloomPass = new _bloom.BloomPass(this.canvas.width, this.canvas.height, this.device, 1.5);
      this.bloomPass.enabled = true;
    }
  };
  activateVolumetricEffect = () => {
    if (this.volumetricPass.enabled != true) {
      this.volumetricPass = new _volumetric.VolumetricPass(this.canvas.width, this.canvas.height, this.device, {
        density: 0.03,
        steps: 32,
        scatterStrength: 1.2,
        heightFalloff: 0.08,
        lightColor: [1.0, 0.88, 0.65] // warm sunlight
      }).init();
      this.volumetricPass.enabled = true;
    }
  };
}
exports.default = MatrixEngineWGPU;

},{"./engine/core-cache.js":25,"./engine/effects/energy-bar.js":27,"./engine/effects/flame-emmiter.js":28,"./engine/effects/flame.js":29,"./engine/effects/mana-bar.js":34,"./engine/effects/pointerEffect.js":35,"./engine/engine.js":37,"./engine/generators/generator.js":38,"./engine/instanced/mesh-obj-instances.js":41,"./engine/lights.js":42,"./engine/loader-obj.js":44,"./engine/loaders/bvh-instaced.js":45,"./engine/loaders/bvh.js":46,"./engine/mesh-obj.js":50,"./engine/postprocessing/bloom.js":52,"./engine/postprocessing/volumetric.js":53,"./engine/raycast.js":55,"./engine/utils.js":56,"./multilang/lang.js":57,"./physics/matrix-ammo.js":58,"./sounds/audioAsset.js":84,"./sounds/sounds.js":85,"./tools/editor/editor.js":88,"./tools/editor/flexCodexShaderAdapter.js":91,"wgpu-matrix":22}]},{},[1]);
